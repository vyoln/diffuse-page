import {
  require_localforage
} from "./chunk-7REVB532.js";
import {
  CID,
  CharSize,
  CryptoSystem,
  EMPTY_CID,
  EccCurve,
  HashAlg,
  KeyUse,
  PRODUCTION,
  RootBranch,
  RsaSize,
  STAGING,
  SymmAlg,
  SymmKeyLength,
  VERSION,
  WASM_WNFS_VERSION,
  apiUrl,
  appData,
  assertBrowser,
  build,
  coerce,
  combine,
  compare,
  concat,
  concat2,
  create,
  decode,
  decodeCID,
  did,
  didToPublicKey,
  did_exports,
  directory,
  encode,
  encodeCID,
  equals,
  exchange,
  file,
  fission_exports,
  fromPosix,
  fromString,
  fromString2,
  hasProp,
  implementation_exports,
  isBlob,
  isBool,
  isCryptoKey,
  isDirectory,
  isExpired,
  isFile,
  isNum,
  isObject,
  isOnRootBranch,
  isPartition,
  isSameKind,
  isSamePartition,
  isSelfSigned,
  isString,
  isValid,
  isValue,
  kind,
  log,
  lookupDnsLink,
  lookupTxtRecord,
  mapObj,
  notNull,
  parent,
  path_exports,
  publicKeyToDid,
  removeKeyFromObj,
  removePartition,
  root,
  rootIssuer,
  terminus,
  toPosix,
  toString as toString2,
  toString2 as toString3,
  toUint8Array,
  ucan_exports,
  unwrap,
  urlEncode,
  withPartition,
  write
} from "./chunk-OG73DF6E.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-5BWDWTGZ.js";

// node_modules/cuint/lib/uint32.js
var require_uint32 = __commonJS({
  "node_modules/cuint/lib/uint32.js"(exports2, module2) {
    (function(root3) {
      var radixPowerCache = {
        36: UINT32(Math.pow(36, 5)),
        16: UINT32(Math.pow(16, 7)),
        10: UINT32(Math.pow(10, 9)),
        2: UINT32(Math.pow(2, 30))
      };
      var radixCache = {
        36: UINT32(36),
        16: UINT32(16),
        10: UINT32(10),
        2: UINT32(2)
      };
      function UINT32(l, h) {
        if (!(this instanceof UINT32))
          return new UINT32(l, h);
        this._low = 0;
        this._high = 0;
        this.remainder = null;
        if (typeof h == "undefined")
          return fromNumber.call(this, l);
        if (typeof l == "string")
          return fromString11.call(this, l, h);
        fromBits.call(this, l, h);
      }
      function fromBits(l, h) {
        this._low = l | 0;
        this._high = h | 0;
        return this;
      }
      UINT32.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromNumber = fromNumber;
      function fromString11(s, radix) {
        var value = parseInt(s, radix || 10);
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromString = fromString11;
      UINT32.prototype.toNumber = function() {
        return this._high * 65536 + this._low;
      };
      UINT32.prototype.toString = function(radix) {
        return this.toNumber().toString(radix || 10);
      };
      UINT32.prototype.add = function(other) {
        var a00 = this._low + other._low;
        var a16 = a00 >>> 16;
        a16 += this._high + other._high;
        this._low = a00 & 65535;
        this._high = a16 & 65535;
        return this;
      };
      UINT32.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT32.prototype.multiply = function(other) {
        var a16 = this._high;
        var a00 = this._low;
        var b16 = other._high;
        var b00 = other._low;
        var c16, c00;
        c00 = a00 * b00;
        c16 = c00 >>> 16;
        c16 += a16 * b00;
        c16 &= 65535;
        c16 += a00 * b16;
        this._low = c00 & 65535;
        this._high = c16 & 65535;
        return this;
      };
      UINT32.prototype.div = function(other) {
        if (other._low == 0 && other._high == 0)
          throw Error("division by zero");
        if (other._high == 0 && other._low == 1) {
          this.remainder = new UINT32(0);
          return this;
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._low = 0;
          this._high = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT32(0);
          this._low = 1;
          this._high = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._low = 0;
        this._high = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 16) {
              this._high |= 1 << i - 16;
            } else {
              this._low |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT32.prototype.negate = function() {
        var v = (~this._low & 65535) + 1;
        this._low = v & 65535;
        this._high = ~this._high + (v >>> 16) & 65535;
        return this;
      };
      UINT32.prototype.equals = UINT32.prototype.eq = function(other) {
        return this._low == other._low && this._high == other._high;
      };
      UINT32.prototype.greaterThan = UINT32.prototype.gt = function(other) {
        if (this._high > other._high)
          return true;
        if (this._high < other._high)
          return false;
        return this._low > other._low;
      };
      UINT32.prototype.lessThan = UINT32.prototype.lt = function(other) {
        if (this._high < other._high)
          return true;
        if (this._high > other._high)
          return false;
        return this._low < other._low;
      };
      UINT32.prototype.or = function(other) {
        this._low |= other._low;
        this._high |= other._high;
        return this;
      };
      UINT32.prototype.and = function(other) {
        this._low &= other._low;
        this._high &= other._high;
        return this;
      };
      UINT32.prototype.not = function() {
        this._low = ~this._low & 65535;
        this._high = ~this._high & 65535;
        return this;
      };
      UINT32.prototype.xor = function(other) {
        this._low ^= other._low;
        this._high ^= other._high;
        return this;
      };
      UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function(n) {
        if (n > 16) {
          this._low = this._high >> n - 16;
          this._high = 0;
        } else if (n == 16) {
          this._low = this._high;
          this._high = 0;
        } else {
          this._low = this._low >> n | this._high << 16 - n & 65535;
          this._high >>= n;
        }
        return this;
      };
      UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function(n, allowOverflow) {
        if (n > 16) {
          this._high = this._low << n - 16;
          this._low = 0;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        } else if (n == 16) {
          this._high = this._low;
          this._low = 0;
        } else {
          this._high = this._high << n | this._low >> 16 - n;
          this._low = this._low << n & 65535;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        }
        return this;
      };
      UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function(n) {
        var v = this._high << 16 | this._low;
        v = v << n | v >>> 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.rotateRight = UINT32.prototype.rotr = function(n) {
        var v = this._high << 16 | this._low;
        v = v >>> n | v << 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.clone = function() {
        return new UINT32(this._low, this._high);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT32;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT32;
      } else {
        root3["UINT32"] = UINT32;
      }
    })(exports2);
  }
});

// node_modules/cuint/lib/uint64.js
var require_uint64 = __commonJS({
  "node_modules/cuint/lib/uint64.js"(exports2, module2) {
    (function(root3) {
      var radixPowerCache = {
        16: UINT64(Math.pow(16, 5)),
        10: UINT64(Math.pow(10, 5)),
        2: UINT64(Math.pow(2, 5))
      };
      var radixCache = {
        16: UINT64(16),
        10: UINT64(10),
        2: UINT64(2)
      };
      function UINT64(a00, a16, a32, a48) {
        if (!(this instanceof UINT64))
          return new UINT64(a00, a16, a32, a48);
        this.remainder = null;
        if (typeof a00 == "string")
          return fromString11.call(this, a00, a16);
        if (typeof a16 == "undefined")
          return fromNumber.call(this, a00);
        fromBits.apply(this, arguments);
      }
      function fromBits(a00, a16, a32, a48) {
        if (typeof a32 == "undefined") {
          this._a00 = a00 & 65535;
          this._a16 = a00 >>> 16;
          this._a32 = a16 & 65535;
          this._a48 = a16 >>> 16;
          return this;
        }
        this._a00 = a00 | 0;
        this._a16 = a16 | 0;
        this._a32 = a32 | 0;
        this._a48 = a48 | 0;
        return this;
      }
      UINT64.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._a00 = value & 65535;
        this._a16 = value >>> 16;
        this._a32 = 0;
        this._a48 = 0;
        return this;
      }
      UINT64.prototype.fromNumber = fromNumber;
      function fromString11(s, radix) {
        radix = radix || 10;
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        var radixUint = radixPowerCache[radix] || new UINT64(Math.pow(radix, 5));
        for (var i = 0, len = s.length; i < len; i += 5) {
          var size = Math.min(5, len - i);
          var value = parseInt(s.slice(i, i + size), radix);
          this.multiply(
            size < 5 ? new UINT64(Math.pow(radix, size)) : radixUint
          ).add(new UINT64(value));
        }
        return this;
      }
      UINT64.prototype.fromString = fromString11;
      UINT64.prototype.toNumber = function() {
        return this._a16 * 65536 + this._a00;
      };
      UINT64.prototype.toString = function(radix) {
        radix = radix || 10;
        var radixUint = radixCache[radix] || new UINT64(radix);
        if (!this.gt(radixUint))
          return this.toNumber().toString(radix);
        var self2 = this.clone();
        var res = new Array(64);
        for (var i = 63; i >= 0; i--) {
          self2.div(radixUint);
          res[i] = self2.remainder.toNumber().toString(radix);
          if (!self2.gt(radixUint))
            break;
        }
        res[i - 1] = self2.toNumber().toString(radix);
        return res.join("");
      };
      UINT64.prototype.add = function(other) {
        var a00 = this._a00 + other._a00;
        var a16 = a00 >>> 16;
        a16 += this._a16 + other._a16;
        var a32 = a16 >>> 16;
        a32 += this._a32 + other._a32;
        var a48 = a32 >>> 16;
        a48 += this._a48 + other._a48;
        this._a00 = a00 & 65535;
        this._a16 = a16 & 65535;
        this._a32 = a32 & 65535;
        this._a48 = a48 & 65535;
        return this;
      };
      UINT64.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT64.prototype.multiply = function(other) {
        var a00 = this._a00;
        var a16 = this._a16;
        var a32 = this._a32;
        var a48 = this._a48;
        var b00 = other._a00;
        var b16 = other._a16;
        var b32 = other._a32;
        var b48 = other._a48;
        var c00 = a00 * b00;
        var c16 = c00 >>> 16;
        c16 += a00 * b16;
        var c32 = c16 >>> 16;
        c16 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c32 += a00 * b32;
        var c48 = c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c48 += a00 * b48;
        c48 &= 65535;
        c48 += a16 * b32;
        c48 &= 65535;
        c48 += a32 * b16;
        c48 &= 65535;
        c48 += a48 * b00;
        this._a00 = c00 & 65535;
        this._a16 = c16 & 65535;
        this._a32 = c32 & 65535;
        this._a48 = c48 & 65535;
        return this;
      };
      UINT64.prototype.div = function(other) {
        if (other._a16 == 0 && other._a32 == 0 && other._a48 == 0) {
          if (other._a00 == 0)
            throw Error("division by zero");
          if (other._a00 == 1) {
            this.remainder = new UINT64(0);
            return this;
          }
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._a00 = 0;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT64(0);
          this._a00 = 1;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 48) {
              this._a48 |= 1 << i - 48;
            } else if (i >= 32) {
              this._a32 |= 1 << i - 32;
            } else if (i >= 16) {
              this._a16 |= 1 << i - 16;
            } else {
              this._a00 |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT64.prototype.negate = function() {
        var v = (~this._a00 & 65535) + 1;
        this._a00 = v & 65535;
        v = (~this._a16 & 65535) + (v >>> 16);
        this._a16 = v & 65535;
        v = (~this._a32 & 65535) + (v >>> 16);
        this._a32 = v & 65535;
        this._a48 = ~this._a48 + (v >>> 16) & 65535;
        return this;
      };
      UINT64.prototype.equals = UINT64.prototype.eq = function(other) {
        return this._a48 == other._a48 && this._a00 == other._a00 && this._a32 == other._a32 && this._a16 == other._a16;
      };
      UINT64.prototype.greaterThan = UINT64.prototype.gt = function(other) {
        if (this._a48 > other._a48)
          return true;
        if (this._a48 < other._a48)
          return false;
        if (this._a32 > other._a32)
          return true;
        if (this._a32 < other._a32)
          return false;
        if (this._a16 > other._a16)
          return true;
        if (this._a16 < other._a16)
          return false;
        return this._a00 > other._a00;
      };
      UINT64.prototype.lessThan = UINT64.prototype.lt = function(other) {
        if (this._a48 < other._a48)
          return true;
        if (this._a48 > other._a48)
          return false;
        if (this._a32 < other._a32)
          return true;
        if (this._a32 > other._a32)
          return false;
        if (this._a16 < other._a16)
          return true;
        if (this._a16 > other._a16)
          return false;
        return this._a00 < other._a00;
      };
      UINT64.prototype.or = function(other) {
        this._a00 |= other._a00;
        this._a16 |= other._a16;
        this._a32 |= other._a32;
        this._a48 |= other._a48;
        return this;
      };
      UINT64.prototype.and = function(other) {
        this._a00 &= other._a00;
        this._a16 &= other._a16;
        this._a32 &= other._a32;
        this._a48 &= other._a48;
        return this;
      };
      UINT64.prototype.xor = function(other) {
        this._a00 ^= other._a00;
        this._a16 ^= other._a16;
        this._a32 ^= other._a32;
        this._a48 ^= other._a48;
        return this;
      };
      UINT64.prototype.not = function() {
        this._a00 = ~this._a00 & 65535;
        this._a16 = ~this._a16 & 65535;
        this._a32 = ~this._a32 & 65535;
        this._a48 = ~this._a48 & 65535;
        return this;
      };
      UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function(n) {
        n %= 64;
        if (n >= 48) {
          this._a00 = this._a48 >> n - 48;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a00 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a16 = this._a48 >> n & 65535;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a00 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a16 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a32 = this._a48 >> n & 65535;
          this._a48 = 0;
        } else {
          this._a00 = (this._a00 >> n | this._a16 << 16 - n) & 65535;
          this._a16 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a32 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a48 = this._a48 >> n & 65535;
        }
        return this;
      };
      UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function(n, allowOverflow) {
        n %= 64;
        if (n >= 48) {
          this._a48 = this._a00 << n - 48;
          this._a32 = 0;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a48 = this._a16 << n | this._a00 >> 16 - n;
          this._a32 = this._a00 << n & 65535;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a48 = this._a32 << n | this._a16 >> 16 - n;
          this._a32 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a16 = this._a00 << n & 65535;
          this._a00 = 0;
        } else {
          this._a48 = this._a48 << n | this._a32 >> 16 - n;
          this._a32 = (this._a32 << n | this._a16 >> 16 - n) & 65535;
          this._a16 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a00 = this._a00 << n & 65535;
        }
        if (!allowOverflow) {
          this._a48 &= 65535;
        }
        return this;
      };
      UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high << n | low >>> 32 - n;
        var _low = low << n | high >>> 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.rotateRight = UINT64.prototype.rotr = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high >>> n | low << 32 - n;
        var _low = low >>> n | high << 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.clone = function() {
        return new UINT64(this._a00, this._a16, this._a32, this._a48);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT64;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT64;
      } else {
        root3["UINT64"] = UINT64;
      }
    })(exports2);
  }
});

// node_modules/cuint/index.js
var require_cuint = __commonJS({
  "node_modules/cuint/index.js"(exports2) {
    exports2.UINT32 = require_uint32();
    exports2.UINT64 = require_uint64();
  }
});

// node_modules/xxhashjs/lib/xxhash.js
var require_xxhash = __commonJS({
  "node_modules/xxhashjs/lib/xxhash.js"(exports2, module2) {
    var UINT32 = require_cuint().UINT32;
    UINT32.prototype.xxh_update = function(low, high) {
      var b00 = PRIME32_2._low;
      var b16 = PRIME32_2._high;
      var c16, c00;
      c00 = low * b00;
      c16 = c00 >>> 16;
      c16 += high * b00;
      c16 &= 65535;
      c16 += low * b16;
      var a00 = this._low + (c00 & 65535);
      var a16 = a00 >>> 16;
      a16 += this._high + (c16 & 65535);
      var v = a16 << 16 | a00 & 65535;
      v = v << 13 | v >>> 19;
      a00 = v & 65535;
      a16 = v >>> 16;
      b00 = PRIME32_1._low;
      b16 = PRIME32_1._high;
      c00 = a00 * b00;
      c16 = c00 >>> 16;
      c16 += a16 * b00;
      c16 &= 65535;
      c16 += a00 * b16;
      this._low = c00 & 65535;
      this._high = c16 & 65535;
    };
    var PRIME32_1 = UINT32("2654435761");
    var PRIME32_2 = UINT32("2246822519");
    var PRIME32_3 = UINT32("3266489917");
    var PRIME32_4 = UINT32("668265263");
    var PRIME32_5 = UINT32("374761393");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH() {
      if (arguments.length == 2)
        return new XXH(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH))
        return new XXH(arguments[0]);
      init2.call(this, arguments[0]);
    }
    function init2(seed) {
      this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed);
      this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2);
      this.v2 = this.seed.clone().add(PRIME32_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME32_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH.prototype.init = init2;
    XXH.prototype.update = function(input) {
      var isString2 = typeof input == "string";
      var isArrayBuffer;
      if (isString2) {
        input = toUTF8Array(input);
        isString2 = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString2) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(16);
        } else {
          this.memory = new Buffer(16);
        }
      }
      if (this.memsize + len < 16) {
        if (isString2) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString2) {
          this.memory += input.slice(0, 16 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 16 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 16 - this.memsize);
        }
        var p32 = 0;
        if (isString2) {
          this.v1.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
        } else {
          this.v1.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
        }
        p += 16 - this.memsize;
        this.memsize = 0;
        if (isString2)
          this.memory = "";
      }
      if (p <= bEnd - 16) {
        var limit = bEnd - 16;
        do {
          if (isString2) {
            this.v1.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v2.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v3.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v4.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
          } else {
            this.v1.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v2.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v3.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v4.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
          }
          p += 4;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString2) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH.prototype.digest = function() {
      var input = this.memory;
      var isString2 = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h32, h;
      var u = new UINT32();
      if (this.total_len >= 16) {
        h32 = this.v1.rotl(1).add(this.v2.rotl(7).add(this.v3.rotl(12).add(this.v4.rotl(18))));
      } else {
        h32 = this.seed.clone().add(PRIME32_5);
      }
      h32.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 4) {
        if (isString2) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2]
          );
        }
        h32.add(u.multiply(PRIME32_3)).rotl(17).multiply(PRIME32_4);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString2 ? input.charCodeAt(p++) : input[p++], 0);
        h32.add(u.multiply(PRIME32_5)).rotl(11).multiply(PRIME32_1);
      }
      h = h32.clone().shiftRight(15);
      h32.xor(h).multiply(PRIME32_2);
      h = h32.clone().shiftRight(13);
      h32.xor(h).multiply(PRIME32_3);
      h = h32.clone().shiftRight(16);
      h32.xor(h);
      this.init(this.seed);
      return h32;
    };
    module2.exports = XXH;
  }
});

// node_modules/xxhashjs/lib/xxhash64.js
var require_xxhash64 = __commonJS({
  "node_modules/xxhashjs/lib/xxhash64.js"(exports2, module2) {
    var UINT64 = require_cuint().UINT64;
    var PRIME64_1 = UINT64("11400714785074694791");
    var PRIME64_2 = UINT64("14029467366897019727");
    var PRIME64_3 = UINT64("1609587929392839161");
    var PRIME64_4 = UINT64("9650029242287828579");
    var PRIME64_5 = UINT64("2870177450012600261");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH64() {
      if (arguments.length == 2)
        return new XXH64(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH64))
        return new XXH64(arguments[0]);
      init2.call(this, arguments[0]);
    }
    function init2(seed) {
      this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed);
      this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2);
      this.v2 = this.seed.clone().add(PRIME64_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME64_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH64.prototype.init = init2;
    XXH64.prototype.update = function(input) {
      var isString2 = typeof input == "string";
      var isArrayBuffer;
      if (isString2) {
        input = toUTF8Array(input);
        isString2 = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString2) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(32);
        } else {
          this.memory = new Buffer(32);
        }
      }
      if (this.memsize + len < 32) {
        if (isString2) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString2) {
          this.memory += input.slice(0, 32 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 32 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 32 - this.memsize);
        }
        var p64 = 0;
        if (isString2) {
          var other;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        } else {
          var other;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        }
        p += 32 - this.memsize;
        this.memsize = 0;
        if (isString2)
          this.memory = "";
      }
      if (p <= bEnd - 32) {
        var limit = bEnd - 32;
        do {
          if (isString2) {
            var other;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          } else {
            var other;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          }
          p += 8;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString2) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH64.prototype.digest = function() {
      var input = this.memory;
      var isString2 = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h64, h;
      var u = new UINT64();
      if (this.total_len >= 32) {
        h64 = this.v1.clone().rotl(1);
        h64.add(this.v2.clone().rotl(7));
        h64.add(this.v3.clone().rotl(12));
        h64.add(this.v4.clone().rotl(18));
        h64.xor(this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
      } else {
        h64 = this.seed.clone().add(PRIME64_5);
      }
      h64.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 8) {
        if (isString2) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
            input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            input[p + 5] << 8 | input[p + 4],
            input[p + 7] << 8 | input[p + 6]
          );
        }
        u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);
        h64.xor(u).rotl(27).multiply(PRIME64_1).add(PRIME64_4);
        p += 8;
      }
      if (p + 4 <= bEnd) {
        if (isString2) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            0,
            0
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            0,
            0
          );
        }
        h64.xor(u.multiply(PRIME64_1)).rotl(23).multiply(PRIME64_2).add(PRIME64_3);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString2 ? input.charCodeAt(p++) : input[p++], 0, 0, 0);
        h64.xor(u.multiply(PRIME64_5)).rotl(11).multiply(PRIME64_1);
      }
      h = h64.clone().shiftRight(33);
      h64.xor(h).multiply(PRIME64_2);
      h = h64.clone().shiftRight(29);
      h64.xor(h).multiply(PRIME64_3);
      h = h64.clone().shiftRight(32);
      h64.xor(h);
      this.init(this.seed);
      return h64;
    };
    module2.exports = XXH64;
  }
});

// node_modules/xxhashjs/lib/index.js
var require_lib = __commonJS({
  "node_modules/xxhashjs/lib/index.js"(exports2, module2) {
    module2.exports = {
      h32: require_xxhash(),
      h64: require_xxhash64()
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup2 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code11.length; i < len; ++i) {
      lookup2[i] = code11[i];
      revLookup[code11.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base644 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length8) {
      if (length8 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length8 + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length8);
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function Buffer2(arg, encodingOrOffset, length8) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from12(arg, encodingOrOffset, length8);
    }
    Buffer2.poolSize = 8192;
    function from12(value, encodingOrOffset, length8) {
      if (typeof value === "string") {
        return fromString11(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length8);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length8);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length8);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length8);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length8) {
      return from12(value, encodingOrOffset, length8);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc2(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc2(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString11(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length8 = byteLength(string2, encoding) | 0;
      let buf2 = createBuffer(length8);
      const actual = buf2.write(string2, encoding);
      if (actual !== length8) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length8 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length8);
      for (let i = 0; i < length8; i += 1) {
        buf2[i] = array[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length8) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length8 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length8 === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length8 === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length8);
      }
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length8) {
      if (length8 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length8 | 0;
    }
    function SlowBuffer(length8) {
      if (+length8 != length8) {
        length8 = 0;
      }
      return Buffer2.alloc(+length8);
    }
    Buffer2.isBuffer = function isBuffer3(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare4(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat5(list, length8) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length8 === void 0) {
        length8 = 0;
        for (i = 0; i < list.length; ++i) {
          length8 += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length8);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf2))
              buf2 = Buffer2.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString11() {
      const length8 = this.length;
      if (length8 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length8);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals16(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read7(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read7(arr, i) === read7(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read7(arr, i + j) !== read7(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string2, offset, length8) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length8) {
        length8 = remaining;
      } else {
        length8 = Number(length8);
        if (length8 > remaining) {
          length8 = remaining;
        }
      }
      const strLen = string2.length;
      if (length8 > strLen / 2) {
        length8 = strLen / 2;
      }
      let i;
      for (i = 0; i < length8; ++i) {
        const parsed = parseInt(string2.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string2, offset, length8) {
      return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length8);
    }
    function asciiWrite(buf2, string2, offset, length8) {
      return blitBuffer(asciiToBytes(string2), buf2, offset, length8);
    }
    function base64Write(buf2, string2, offset, length8) {
      return blitBuffer(base64ToBytes(string2), buf2, offset, length8);
    }
    function ucs2Write(buf2, string2, offset, length8) {
      return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length8);
    }
    Buffer2.prototype.write = function write2(string2, offset, length8, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length8 = this.length;
        offset = 0;
      } else if (length8 === void 0 && typeof offset === "string") {
        encoding = offset;
        length8 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length8)) {
          length8 = length8 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length8;
          length8 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length8 === void 0 || length8 > remaining)
        length8 = remaining;
      if (string2.length > 0 && (length8 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length8);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length8);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length8);
          case "base64":
            return base64Write(this, string2, offset, length8);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length8);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base644.fromByteArray(buf2);
      } else {
        return base644.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes2 = buf2.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes2.length - 1; i += 2) {
        res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length8) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length8)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last = this[offset + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last = this[offset + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last = this[offset + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last = this[offset + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code11 = val.charCodeAt(0);
          if (encoding === "utf8" && code11 < 128 || encoding === "latin1") {
            val = code11;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes2.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes2[i % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name8) {
        if (name8) {
          return `${name8} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name8, actual) {
        return `The "${name8}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf2, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value, name8) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name8, "number", value);
      }
    }
    function boundsError(value, length8, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length8 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length8}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length8 = string2.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i = 0; i < length8; ++i) {
        codePoint = string2.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i + 1 === length8) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base644.toByteArray(base64clean(str));
    }
    function blitBuffer(src7, dst, offset, length8) {
      let i;
      for (i = 0; i < length8; ++i) {
        if (i + offset >= dst.length || i >= src7.length)
          break;
        dst[i + offset] = src7[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet4 = "0123456789abcdef";
      const table2 = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table2[i16 + j] = alphabet4[i] + alphabet4[j];
        }
      }
      return table2;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/fission-bloom-filters/dist/utils.js
var require_utils = __commonJS({
  "node_modules/fission-bloom-filters/dist/utils.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var xxhashjs_1 = __importDefault(require_lib());
    var buffer_1 = require_buffer();
    function allocateArray(size, defaultValue) {
      var array = new Array(size);
      var getDefault = typeof defaultValue === "function" ? defaultValue : function() {
        return defaultValue;
      };
      for (var ind = 0; ind < size; ind++) {
        array[ind] = getDefault();
      }
      return array;
    }
    exports2.allocateArray = allocateArray;
    function hashTwice(value, asInt, seed) {
      if (asInt === void 0) {
        asInt = false;
      }
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      var f = xxhashjs_1.default.h64(value, seed + 1);
      var l = xxhashjs_1.default.h64(value, seed + 2);
      if (asInt) {
        return {
          first: f.toNumber(),
          second: l.toNumber()
        };
      } else {
        var one = f.toString(16);
        if (one.length < 16) {
          one = "0".repeat(16 - one.length) + one;
        }
        var two = l.toString(16);
        if (two.length < 16) {
          two = "0".repeat(16 - two.length) + two;
        }
        return {
          first: Number(one),
          second: Number(two)
        };
      }
    }
    exports2.hashTwice = hashTwice;
    function hashTwiceAsString(value, seed) {
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      var f = xxhashjs_1.default.h64(value, seed + 1);
      var l = xxhashjs_1.default.h64(value, seed + 2);
      var one = f.toString(16);
      if (one.length < 16)
        one = "0".repeat(16 - one.length) + one;
      var two = l.toString(16);
      if (two.length < 16)
        two = "0".repeat(16 - two.length) + two;
      return {
        first: one,
        second: two
      };
    }
    exports2.hashTwiceAsString = hashTwiceAsString;
    function allInOneHashTwice(val, seed) {
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      var one = xxhashjs_1.default.h64(val, seed + 1);
      var two = xxhashjs_1.default.h64(val, seed + 2);
      var stringOne = one.toString(16);
      if (stringOne.length < 16)
        stringOne = "0".repeat(16 - stringOne.length) + stringOne;
      var stringTwo = two.toString(16);
      if (stringTwo.length < 16)
        stringTwo = "0".repeat(16 - stringTwo.length) + stringTwo;
      return {
        int: {
          first: one.toNumber(),
          second: two.toNumber()
        },
        string: {
          first: stringOne,
          second: stringTwo
        }
      };
    }
    exports2.allInOneHashTwice = allInOneHashTwice;
    function doubleHashing(n, hashA, hashB, size) {
      return Math.abs((hashA + n * hashB) % size);
    }
    exports2.doubleHashing = doubleHashing;
    function getDistinctIndices(element, size, number, seed) {
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      function getDistinctIndicesBis(n, elem, size2, count, indexes) {
        if (indexes === void 0) {
          indexes = [];
        }
        if (indexes.length === count) {
          return indexes;
        } else {
          var hashes4 = hashTwice(elem, true, seed + size2 % n);
          var ind = doubleHashing(n, hashes4.first, hashes4.second, size2);
          if (indexes.includes(ind)) {
            return getDistinctIndicesBis(n + 1, elem, size2, count, indexes);
          } else {
            indexes.push(ind);
            return getDistinctIndicesBis(n + 1, elem, size2, count, indexes);
          }
        }
      }
      return getDistinctIndicesBis(1, element, size, number);
    }
    exports2.getDistinctIndices = getDistinctIndices;
    function getIndices(element, size, hashCount, seed) {
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      var arr = [];
      for (var i = 1; i <= hashCount; i++) {
        var hashes4 = hashTwice(element, true, seed + size % i);
        arr.push(doubleHashing(i, hashes4.first, hashes4.second, size));
      }
      if (arr.length !== hashCount)
        throw new Error("report this, please, shouldnt be of different size");
      return arr;
    }
    exports2.getIndices = getIndices;
    function randomInt(min, max, random) {
      if (random === void 0) {
        random = Math.random;
      }
      min = Math.ceil(min);
      max = Math.floor(max);
      var rn = random();
      return Math.floor(rn * (max - min + 1)) + min;
    }
    exports2.randomInt = randomInt;
    function xorBuffer(a, b) {
      var length8 = Math.max(a.length, b.length);
      var buffer2 = buffer_1.Buffer.allocUnsafe(length8).fill(0);
      for (var i = 0; i < length8; ++i) {
        if (i < a.length && i < b.length) {
          buffer2[length8 - i - 1] = a[a.length - i - 1] ^ b[b.length - i - 1];
        } else if (i < a.length && i >= b.length) {
          buffer2[length8 - i - 1] ^= a[a.length - i - 1];
        } else if (i < b.length && i >= a.length) {
          buffer2[length8 - i - 1] ^= b[b.length - i - 1];
        }
      }
      var start = 0;
      var it = buffer2.values();
      var value = it.next();
      while (!value.done && value.value === 0) {
        start++;
        value = it.next();
      }
      var buf2 = buffer2.slice(start);
      return buf2;
    }
    exports2.xorBuffer = xorBuffer;
    function isEmptyBuffer(buffer2) {
      var e_1, _a2;
      if (buffer2 === null || !buffer2)
        return true;
      try {
        for (var buffer_2 = __values(buffer2), buffer_2_1 = buffer_2.next(); !buffer_2_1.done; buffer_2_1 = buffer_2.next()) {
          var value = buffer_2_1.value;
          if (value !== 0) {
            return false;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffer_2_1 && !buffer_2_1.done && (_a2 = buffer_2.return))
            _a2.call(buffer_2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return true;
    }
    exports2.isEmptyBuffer = isEmptyBuffer;
    function hashAsInt(elem, seed, length8) {
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      switch (length8) {
        case 32:
          return xxhashjs_1.default.h32(elem, seed).toNumber();
        case 64:
          return xxhashjs_1.default.h64(elem, seed).toNumber();
        default:
          return xxhashjs_1.default.h64(elem, seed).toNumber();
      }
    }
    exports2.hashAsInt = hashAsInt;
    function hashAsString(elem, seed, base7, length8) {
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      if (base7 === void 0) {
        base7 = 16;
      }
      if (length8 === void 0) {
        length8 = 64;
      }
      var hash3;
      switch (length8) {
        case 32:
          hash3 = xxhashjs_1.default.h32(elem, seed);
          break;
        case 64:
          hash3 = xxhashjs_1.default.h64(elem, seed);
          break;
        default:
          hash3 = xxhashjs_1.default.h64(elem, seed);
          break;
      }
      var result = "";
      if (base7 === 16) {
        result = hash3.toString(base7);
        if (result.length < length8 / 4) {
          result = "0".repeat(length8 / 4 - result.length) + result;
        }
      } else if (base7 === 2) {
        result = hex2bin(hash3.toString(16));
        if (result.length < length8) {
          result = "0".repeat(length8 - result.length) + result;
        }
      }
      return result;
    }
    exports2.hashAsString = hashAsString;
    function hashIntAndString(elem, seed, base7, length8) {
      if (seed === void 0) {
        seed = getDefaultSeed();
      }
      if (base7 === void 0) {
        base7 = 16;
      }
      if (length8 === void 0) {
        length8 = 64;
      }
      var hash3;
      switch (length8) {
        case 32:
          hash3 = xxhashjs_1.default.h32(elem, seed);
          break;
        case 64:
          hash3 = xxhashjs_1.default.h64(elem, seed);
          break;
        default:
          hash3 = xxhashjs_1.default.h64(elem, seed);
          break;
      }
      var result = "";
      if (base7 === 16) {
        result = hash3.toString(base7);
        if (result.length < length8 / 4) {
          result = "0".repeat(length8 / 4 - result.length) + result;
        }
      } else if (base7 === 2) {
        result = hex2bin(hash3.toString(16));
        if (result.length < length8) {
          result = "0".repeat(length8 - result.length) + result;
        }
      }
      return { int: hash3.toNumber(), string: result };
    }
    exports2.hashIntAndString = hashIntAndString;
    function getDefaultSeed() {
      return 78187493520;
    }
    exports2.getDefaultSeed = getDefaultSeed;
    function power2(x) {
      return Math.ceil(Math.pow(2, Math.floor(Math.log(x) / Math.log(2))));
    }
    exports2.power2 = power2;
    function hex2bin(hex) {
      return parseInt(hex, 16).toString(2);
    }
    exports2.hex2bin = hex2bin;
    function uint8ToBits(uint8) {
      return [128, 64, 32, 16, 8, 4, 2, 1].map(function(x) {
        return (x & uint8) > 0 ? 1 : 0;
      });
    }
    exports2.uint8ToBits = uint8ToBits;
    function bitsToUint8(bits) {
      return bits.reduce(function(acc, cur, i) {
        if (cur === 0) {
          return acc;
        } else if (cur === 1) {
          return acc + Math.pow(2, 7 - i);
        } else {
          throw new Error("Not binary");
        }
      }, 0);
    }
    exports2.bitsToUint8 = bitsToUint8;
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports2, module2) {
    (function(global2, module3, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports2, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports2, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports2, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v, w;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init2(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init2(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports2, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init2(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init2(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports2,
      // window object or global
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports2, module2) {
    (function(global2, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports2, module2) {
    (function(global2, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten2(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten2(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten2(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math.random(), pool);
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = seedrandom;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom;
        });
      } else {
        math["seed" + rngname] = seedrandom;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports2,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports2, module2) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module2.exports = sr;
  }
});

// node_modules/fission-bloom-filters/dist/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/fission-bloom-filters/dist/base-filter.js"(exports2) {
    "use strict";
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (Object.hasOwnProperty.call(mod2, k))
            result[k] = mod2[k];
      }
      result["default"] = mod2;
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = __importStar(require_utils());
    var seedrandom_1 = __importDefault(require_seedrandom2());
    var BaseFilter = (
      /** @class */
      function() {
        function BaseFilter2() {
          this._seed = utils.getDefaultSeed();
          this._rng = seedrandom_1.default("" + this._seed);
        }
        Object.defineProperty(BaseFilter2.prototype, "seed", {
          /**
           * Get the seed used in this structure
           */
          get: function() {
            return this._seed;
          },
          /**
           * Set the seed for this structure
           * @param  seed the new seed that will be used in this structure
           */
          set: function(seed) {
            this._seed = seed;
            this._rng = seedrandom_1.default("" + this._seed);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(BaseFilter2.prototype, "random", {
          /**
           * Get a function used to draw random number
           * @return A factory function used to draw random integer
           */
          get: function() {
            return this._rng;
          },
          enumerable: true,
          configurable: true
        });
        BaseFilter2.prototype.saveAsJSON = function() {
          throw new Error("not-implemented");
        };
        BaseFilter2.fromJSON = function(json) {
          throw new Error("not-implemented");
        };
        return BaseFilter2;
      }()
    );
    exports2.default = BaseFilter;
  }
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root3 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
        var exporter = makeExporter(Reflect3);
        if (typeof root3.Reflect === "undefined") {
          root3.Reflect = Reflect3;
        } else {
          exporter = makeExporter(root3.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
          return function(key, value) {
            if (typeof target[key] !== "function") {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
            }
            if (previous)
              previous(key, value);
          };
        }
      })(function(exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map2, key) {
            return hasOwn.call(map2, key);
          } : function(map2, key) {
            return key in map2;
          },
          get: downLevel ? function(map2, key) {
            return hasOwn.call(map2, key) ? map2[key] : void 0;
          } : function(map2, key) {
            return map2[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var Metadata2 = new _WeakMap();
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var metadataMap = GetOrCreateMetadataMap(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(metadataKey))
            return false;
          if (metadataMap.size > 0)
            return true;
          var targetMetadata = Metadata2.get(target);
          targetMetadata.delete(propertyKey);
          if (targetMetadata.size > 0)
            return true;
          Metadata2.delete(target);
          return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = Metadata2.get(O);
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return void 0;
            targetMetadata = new _Map();
            Metadata2.set(O, targetMetadata);
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return void 0;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
          }
          return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent2 = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent2))
            return OrdinaryHasMetadata(MetadataKey, parent2, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent2 = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent2))
            return OrdinaryGetMetadata(MetadataKey, parent2, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return void 0;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            true
          );
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys = OrdinaryOwnMetadataKeys(O, P);
          var parent2 = OrdinaryGetPrototypeOf(O);
          if (parent2 === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent2, P);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set2 = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set2.has(key);
            if (!hasKey) {
              set2.add(key);
              keys.push(key);
            }
          }
          for (var _a2 = 0, parentKeys_1 = parentKeys; _a2 < parentKeys_1.length; _a2++) {
            var key = parentKeys_1[_a2];
            var hasKey = set2.has(key);
            if (!hasKey) {
              set2.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function Type2(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type2(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type2(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function GetMethod(V2, P) {
          var func = V2[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f = iterator["return"];
          if (f)
            f.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            function() {
              function MapIterator2(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index2 = this._index;
                if (index2 >= 0 && index2 < this._keys.length) {
                  var result = this._selector(this._keys[index2], this._values[index2]);
                  if (index2 + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            }()
          );
          return (
            /** @class */
            function() {
              function Map2() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map2.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map2.prototype.has = function(key) {
                return this._find(
                  key,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map2.prototype.get = function(key) {
                var index2 = this._find(
                  key,
                  /*insert*/
                  false
                );
                return index2 >= 0 ? this._values[index2] : void 0;
              };
              Map2.prototype.set = function(key, value) {
                var index2 = this._find(
                  key,
                  /*insert*/
                  true
                );
                this._values[index2] = value;
                return this;
              };
              Map2.prototype.delete = function(key) {
                var index2 = this._find(
                  key,
                  /*insert*/
                  false
                );
                if (index2 >= 0) {
                  var size = this._keys.length;
                  for (var i = index2 + 1; i < size; i++) {
                    this._keys[i - 1] = this._keys[i];
                    this._values[i - 1] = this._values[i];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (key === this._cacheKey) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map2.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map2.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey2);
              };
              Map2.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue2);
              };
              Map2.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map2.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map2.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map2.prototype._find = function(key, insert) {
                if (this._cacheKey !== key) {
                  this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map2;
            }()
          );
          function getKey2(key, _) {
            return key;
          }
          function getValue2(_, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          return (
            /** @class */
            function() {
              function Set2() {
                this._map = new _Map();
              }
              Object.defineProperty(Set2.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set2.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set2.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set2.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set2.prototype.clear = function() {
                this._map.clear();
              };
              Set2.prototype.keys = function() {
                return this._map.keys();
              };
              Set2.prototype.values = function() {
                return this._map.values();
              };
              Set2.prototype.entries = function() {
                return this._map.entries();
              };
              Set2.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set2.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set2;
            }()
          );
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              WeakMap2.prototype.has = function(target) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? HashMap.has(table2, this._key) : false;
              };
              WeakMap2.prototype.get = function(target) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? HashMap.get(table2, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target, value) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table2[this._key] = value;
                return this;
              };
              WeakMap2.prototype.delete = function(target) {
                var table2 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? delete table2[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            }()
          );
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create14) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create14)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer2, size) {
            for (var i = 0; i < size; ++i)
              buffer2[i] = Math.random() * 255 | 0;
            return buffer2;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              if (typeof crypto !== "undefined")
                return crypto.getRandomValues(new Uint8Array(size));
              if (typeof msCrypto !== "undefined")
                return msCrypto.getRandomValues(new Uint8Array(size));
              return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/fission-bloom-filters/dist/exportable.js
var require_exportable = __commonJS({
  "node_modules/fission-bloom-filters/dist/exportable.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports2 && exports2.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    require_Reflect();
    function cloneField(v) {
      if (v === null || v === void 0) {
        return v;
      }
      if (Array.isArray(v)) {
        return v.map(cloneField);
      } else if (typeof v === "object") {
        if ("saveAsJSON" in v) {
          return v.saveAsJSON();
        }
        return Object.assign({}, v);
      }
      return v;
    }
    exports2.cloneField = cloneField;
    function cloneObject(type) {
      var fields = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        fields[_i - 1] = arguments[_i];
      }
      return function(obj) {
        var json = { type };
        fields.forEach(function(field) {
          json[field] = cloneField(obj[field]);
        });
        return json;
      };
    }
    exports2.cloneObject = cloneObject;
    function Exportable(specs) {
      return function(target) {
        target.prototype.saveAsJSON = function() {
          return specs.export(this);
        };
        target.fromJSON = function(json) {
          return specs.import(json);
        };
        return target;
      };
    }
    exports2.Exportable = Exportable;
    var METADATA_CLASSNAME = Symbol("bloom-filters:exportable:class-name");
    var METADATA_FIELDS = Symbol("bloom-filters:exportable:fields");
    var METADATA_PARAMETERS = Symbol("bloom-filters:exportable:constructor-parameters");
    function Field(exporter, importer) {
      if (exporter === void 0) {
        exporter = cloneField;
      }
      if (importer === void 0) {
        importer = function(v) {
          return v;
        };
      }
      return function(target, propertyKey) {
        var fields = [];
        if (Reflect.hasMetadata(METADATA_FIELDS, target)) {
          fields = Reflect.getMetadata(METADATA_FIELDS, target);
        }
        fields.push({
          name: propertyKey,
          exporter,
          importer
        });
        Reflect.defineMetadata(METADATA_FIELDS, fields, target);
      };
    }
    exports2.Field = Field;
    function Parameter(fieldName) {
      return function(target, propertyKey, parameterIndex) {
        var parameters = /* @__PURE__ */ new Map();
        if (Reflect.hasMetadata(METADATA_PARAMETERS, target)) {
          parameters = Reflect.getMetadata(METADATA_PARAMETERS, target);
        }
        parameters.set(fieldName, parameterIndex);
        Reflect.defineMetadata(METADATA_PARAMETERS, parameters, target);
      };
    }
    exports2.Parameter = Parameter;
    function AutoExportable(className, otherFields) {
      if (otherFields === void 0) {
        otherFields = [];
      }
      return function(target) {
        Reflect.defineMetadata(METADATA_CLASSNAME, className, target.prototype);
        if (!Reflect.hasMetadata(METADATA_FIELDS, target.prototype) || otherFields.length === 0) {
          throw new SyntaxError("No exported fields declared when @AutoExportable is called");
        }
        if (!Reflect.hasMetadata(METADATA_PARAMETERS, target)) {
          Reflect.defineMetadata(METADATA_PARAMETERS, /* @__PURE__ */ new Map(), target);
        }
        target.prototype.saveAsJSON = function() {
          var _this = this;
          var json = { "type": Reflect.getMetadata(METADATA_CLASSNAME, target.prototype) };
          var fields = Reflect.getMetadata(METADATA_FIELDS, target.prototype);
          fields.forEach(function(field) {
            json[field.name] = field.exporter(_this[field.name]);
          });
          otherFields.forEach(function(field) {
            json[field] = cloneField(_this[field]);
          });
          return json;
        };
        target.fromJSON = function(json) {
          var className2 = Reflect.getMetadata(METADATA_CLASSNAME, target.prototype);
          var parameters = Reflect.getMetadata(METADATA_PARAMETERS, target);
          var fields = Reflect.getMetadata(METADATA_FIELDS, target.prototype);
          if (json.type !== className2) {
            throw new Error("Cannot create an object " + className2 + ' from a JSON export with type "' + json.type + '"');
          }
          var constructorArgs = [];
          var copyFields = [];
          otherFields.map(function(name8) {
            return { name: name8, importer: function(v) {
              return v;
            } };
          }).concat(fields).forEach(function(field) {
            if (!(field.name in json)) {
              throw new Error('Invalid import: required field "' + field + '" not found in JSON export "' + json + '"');
            }
            if (parameters.has(field.name)) {
              constructorArgs[parameters.get(field.name)] = field.importer(json[field.name]);
            } else {
              copyFields.push({
                name: field.name,
                value: field.importer(json[field.name])
              });
            }
          });
          var obj = new (target.bind.apply(target, __spread([void 0], constructorArgs)))();
          copyFields.forEach(function(arg) {
            obj[arg.name] = arg.value;
          });
          return obj;
        };
      };
    }
    exports2.AutoExportable = AutoExportable;
  }
});

// node_modules/fission-bloom-filters/dist/formulas.js
var require_formulas = __commonJS({
  "node_modules/fission-bloom-filters/dist/formulas.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function optimalFilterSize(length8, errorRate) {
      return Math.ceil(-(length8 * Math.log(errorRate) / Math.pow(Math.log(2), 2)));
    }
    exports2.optimalFilterSize = optimalFilterSize;
    function optimalHashes(size, length8) {
      return Math.ceil(size / length8 * Math.log(2));
    }
    exports2.optimalHashes = optimalHashes;
  }
});

// node_modules/fission-bloom-filters/dist/bloom/bloom-filter.js
var require_bloom_filter = __commonJS({
  "node_modules/fission-bloom-filters/dist/bloom/bloom-filter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var exportable_1 = require_exportable();
    var formulas_1 = require_formulas();
    var utils_1 = require_utils();
    var BloomFilter2 = (
      /** @class */
      function(_super) {
        __extends(BloomFilter3, _super);
        function BloomFilter3(size, nbHashes) {
          var _this = _super.call(this) || this;
          if (nbHashes < 1) {
            throw new Error("A BloomFilter cannot uses less than one hash function, while you tried to use " + nbHashes + ".");
          }
          _this._size = size;
          _this._nbHashes = nbHashes;
          _this._filter = utils_1.allocateArray(_this._size, 0);
          _this._length = 0;
          return _this;
        }
        BloomFilter_1 = BloomFilter3;
        BloomFilter3.create = function(nbItems, errorRate) {
          var size = formulas_1.optimalFilterSize(nbItems, errorRate);
          var hashes4 = formulas_1.optimalHashes(size, nbItems);
          return new BloomFilter_1(size, hashes4);
        };
        BloomFilter3.from = function(items, errorRate) {
          var array = Array.from(items);
          var filter5 = BloomFilter_1.create(array.length, errorRate);
          array.forEach(function(element) {
            return filter5.add(element);
          });
          return filter5;
        };
        BloomFilter3.fromBytes = function(bytes2, nbHashes) {
          var bits = [];
          for (var i = 0; i < bytes2.length; i++) {
            var slice2 = utils_1.uint8ToBits(bytes2[i]);
            bits = bits.concat(slice2);
          }
          var filter5 = new BloomFilter_1(bits.length, nbHashes);
          filter5._filter = bits;
          return filter5;
        };
        Object.defineProperty(BloomFilter3.prototype, "size", {
          /**
           * Get the optimal size of the filter
           * @return The size of the filter
           */
          get: function() {
            return this._size;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(BloomFilter3.prototype, "length", {
          /**
           * Get the number of elements currently in the filter
           * @return The filter length
           */
          get: function() {
            return this._length;
          },
          enumerable: true,
          configurable: true
        });
        BloomFilter3.prototype.add = function(element) {
          var indexes = utils_1.getDistinctIndices(element, this._size, this._nbHashes, this.seed);
          for (var i = 0; i < indexes.length; i++) {
            this._filter[indexes[i]] = 1;
          }
          this._length++;
        };
        BloomFilter3.prototype.has = function(element) {
          var indexes = utils_1.getDistinctIndices(element, this._size, this._nbHashes, this.seed);
          for (var i = 0; i < indexes.length; i++) {
            if (!this._filter[indexes[i]]) {
              return false;
            }
          }
          return true;
        };
        BloomFilter3.prototype.rate = function() {
          return Math.pow(1 - Math.exp(-this._nbHashes * this._length / this._size), this._nbHashes);
        };
        BloomFilter3.prototype.equals = function(other) {
          if (this._size !== other._size || this._nbHashes !== other._nbHashes) {
            return false;
          }
          return this._filter.every(function(value, index2) {
            return other._filter[index2] === value;
          });
        };
        BloomFilter3.prototype.toBytes = function() {
          var arr = new Uint8Array(Math.ceil(this._size / 8));
          for (var i = 0; i < arr.length; i++) {
            var bits = this._filter.slice(i * 8, i * 8 + 8);
            arr[i] = utils_1.bitsToUint8(bits);
          }
          return arr;
        };
        var BloomFilter_1;
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], BloomFilter3.prototype, "_size", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], BloomFilter3.prototype, "_nbHashes", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Array)
        ], BloomFilter3.prototype, "_filter", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], BloomFilter3.prototype, "_length", void 0);
        BloomFilter3 = BloomFilter_1 = __decorate([
          exportable_1.AutoExportable("BloomFilter", ["_seed"]),
          __param(0, exportable_1.Parameter("_size")),
          __param(1, exportable_1.Parameter("_nbHashes")),
          __metadata("design:paramtypes", [Number, Number])
        ], BloomFilter3);
        return BloomFilter3;
      }(base_filter_1.default)
    );
    exports2.default = BloomFilter2;
  }
});

// node_modules/fission-bloom-filters/dist/bloom/counting-bloom-filter.js
var require_counting_bloom_filter = __commonJS({
  "node_modules/fission-bloom-filters/dist/bloom/counting-bloom-filter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var exportable_1 = require_exportable();
    var formulas_1 = require_formulas();
    var utils_1 = require_utils();
    var CountingBloomFilter = (
      /** @class */
      function(_super) {
        __extends(CountingBloomFilter2, _super);
        function CountingBloomFilter2(size, nbHashes) {
          var _this = _super.call(this) || this;
          if (nbHashes < 1) {
            throw new Error("A CountingBloomFilter must used at least one hash function, but you tried to use " + nbHashes + " functions. Consider increasing it.");
          }
          _this._size = size;
          _this._nbHashes = nbHashes;
          _this._filter = utils_1.allocateArray(_this._size, function() {
            return [0, 0];
          });
          _this._length = 0;
          return _this;
        }
        CountingBloomFilter_1 = CountingBloomFilter2;
        CountingBloomFilter2.create = function(capacity, errorRate) {
          var s = formulas_1.optimalFilterSize(capacity, errorRate);
          return new CountingBloomFilter_1(s, formulas_1.optimalHashes(s, capacity));
        };
        CountingBloomFilter2.from = function(items, errorRate) {
          var array = Array.from(items);
          var filter5 = CountingBloomFilter_1.create(array.length, errorRate);
          array.forEach(function(element) {
            return filter5.add(element);
          });
          return filter5;
        };
        Object.defineProperty(CountingBloomFilter2.prototype, "size", {
          /**
           * Get the optimal size of the filter
           */
          get: function() {
            return this._size;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CountingBloomFilter2.prototype, "length", {
          /**
           * Get the number of elements currently in the filter
           */
          get: function() {
            return this._length;
          },
          enumerable: true,
          configurable: true
        });
        CountingBloomFilter2.prototype.add = function(element) {
          var indexes = utils_1.getDistinctIndices(element, this._size, this._nbHashes, this.seed);
          for (var i = 0; i < indexes.length; i++) {
            this._filter[indexes[i]][1] += 1;
            if (this._filter[indexes[i]][1] > 0) {
              this._filter[indexes[i]][0] = 1;
            }
          }
          this._length++;
        };
        CountingBloomFilter2.prototype.remove = function(element) {
          var indexes = utils_1.getDistinctIndices(element, this._size, this._nbHashes, this.seed);
          var success = true;
          for (var i = 0; i < indexes.length; i++) {
            this._filter[indexes[i]][1] -= 1;
            if (this._filter[indexes[i]][1] <= 0) {
              this._filter[indexes[i]][0] = 0;
            }
          }
          this._length--;
          return success;
        };
        CountingBloomFilter2.prototype.has = function(element) {
          var indexes = utils_1.getDistinctIndices(element, this._size, this._nbHashes, this.seed);
          for (var i = 0; i < indexes.length; i++) {
            if (!this._filter[indexes[i]][0]) {
              return false;
            }
          }
          return true;
        };
        CountingBloomFilter2.prototype.rate = function() {
          return Math.pow(1 - Math.exp(-this._nbHashes * this._length / this._size), this._nbHashes);
        };
        CountingBloomFilter2.prototype.equals = function(other) {
          if (this._size !== other._size || this._nbHashes !== other._nbHashes || this._length !== other._length) {
            return false;
          }
          return this._filter.every(function(value, index2) {
            return other._filter[index2][0] === value[0] && other._filter[index2][1] === value[1];
          });
        };
        var CountingBloomFilter_1;
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], CountingBloomFilter2.prototype, "_size", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], CountingBloomFilter2.prototype, "_nbHashes", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Array)
        ], CountingBloomFilter2.prototype, "_filter", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], CountingBloomFilter2.prototype, "_length", void 0);
        CountingBloomFilter2 = CountingBloomFilter_1 = __decorate([
          exportable_1.AutoExportable("CountingBloomFilter", ["_seed"]),
          __param(0, exportable_1.Parameter("_size")),
          __param(1, exportable_1.Parameter("_nbHashes")),
          __metadata("design:paramtypes", [Number, Number])
        ], CountingBloomFilter2);
        return CountingBloomFilter2;
      }(base_filter_1.default)
    );
    exports2.default = CountingBloomFilter;
  }
});

// node_modules/fission-bloom-filters/dist/bloom/partitioned-bloom-filter.js
var require_partitioned_bloom_filter = __commonJS({
  "node_modules/fission-bloom-filters/dist/bloom/partitioned-bloom-filter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var exportable_1 = require_exportable();
    var utils_1 = require_utils();
    function computeOptimalNumberOfhashes(errorRate, loadFactor) {
      return Math.ceil(Math.log(errorRate) / Math.log(loadFactor));
    }
    function computeOptimalNumberOfCells(size, rate, loadFactor) {
      return Math.ceil(size * -Math.log(rate) / (Math.log(loadFactor) * Math.log(1 - loadFactor)));
    }
    function computeNumberOfItems(totalBits, loadFactor, nbHashes) {
      return Math.ceil(totalBits * (Math.log(loadFactor) * Math.log(1 - loadFactor)) / -(nbHashes * Math.log(loadFactor)));
    }
    var PartitionedBloomFilter = (
      /** @class */
      function(_super) {
        __extends(PartitionedBloomFilter2, _super);
        function PartitionedBloomFilter2(size, nbHashes, loadFactor, capacity) {
          var _this = _super.call(this) || this;
          _this._size = size;
          _this._nbHashes = nbHashes;
          _this._loadFactor = loadFactor;
          _this._m = Math.ceil(_this._size / _this._nbHashes);
          _this._filter = utils_1.allocateArray(_this._nbHashes, function() {
            return utils_1.allocateArray(_this._m, 0);
          });
          _this._capacity = capacity !== void 0 ? capacity : computeNumberOfItems(_this._size, loadFactor, nbHashes);
          _this._length = 0;
          return _this;
        }
        PartitionedBloomFilter_1 = PartitionedBloomFilter2;
        PartitionedBloomFilter2.create = function(size, errorRate, loadFactor) {
          if (loadFactor === void 0) {
            loadFactor = 0.5;
          }
          var capacity = computeOptimalNumberOfCells(size, errorRate, loadFactor);
          var nbHashes = computeOptimalNumberOfhashes(errorRate, loadFactor);
          return new PartitionedBloomFilter_1(capacity, nbHashes, loadFactor, size);
        };
        PartitionedBloomFilter2.from = function(items, errorRate, loadFactor) {
          if (loadFactor === void 0) {
            loadFactor = 0.5;
          }
          var array = Array.from(items);
          var filter5 = PartitionedBloomFilter_1.create(array.length, errorRate, loadFactor);
          array.forEach(function(element) {
            return filter5.add(element);
          });
          return filter5;
        };
        Object.defineProperty(PartitionedBloomFilter2.prototype, "capacity", {
          /**
           * Get the filter capacity, i.e. the maximum number of elements it will contains
           */
          get: function() {
            return this._capacity;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(PartitionedBloomFilter2.prototype, "size", {
          /**
           * Get the size of the filter
           */
          get: function() {
            return this._size;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(PartitionedBloomFilter2.prototype, "length", {
          /**
           * Get the number of elements currently in the filter
           */
          get: function() {
            return this._length;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(PartitionedBloomFilter2.prototype, "loadFactor", {
          /**
           * Get the filter's load factor
           */
          get: function() {
            return this._loadFactor;
          },
          enumerable: true,
          configurable: true
        });
        PartitionedBloomFilter2.prototype.add = function(element) {
          var indexes = utils_1.getIndices(element, this._m, this._nbHashes, this.seed);
          for (var i = 0; i < this._nbHashes; i++) {
            this._filter[i][indexes[i]] = 1;
          }
          this._length++;
        };
        PartitionedBloomFilter2.prototype.has = function(element) {
          var indexes = utils_1.getIndices(element, this._m, this._nbHashes, this.seed);
          for (var i = 0; i < this._nbHashes; i++) {
            if (!this._filter[i][indexes[i]]) {
              return false;
            }
          }
          return true;
        };
        PartitionedBloomFilter2.prototype.rate = function() {
          var p = this._currentload();
          return Math.pow(p, this._nbHashes);
        };
        PartitionedBloomFilter2.prototype.equals = function(other) {
          if (this._size !== other._size || this._nbHashes !== other._nbHashes || this._length !== other._length || this._loadFactor !== other._loadFactor) {
            return false;
          }
          return this._filter.every(function(array, outerIndex) {
            return other._filter[outerIndex].every(function(item, innerIndex) {
              return array[innerIndex] === item;
            });
          });
        };
        PartitionedBloomFilter2.prototype._currentload = function() {
          var values = this._filter.map(function(bucket) {
            return bucket.reduce(function(a, b) {
              return a + b;
            }, 0);
          });
          var used = values.reduce(function(a, b) {
            return a + b;
          }, 0);
          return used / this._size;
        };
        var PartitionedBloomFilter_1;
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], PartitionedBloomFilter2.prototype, "_size", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], PartitionedBloomFilter2.prototype, "_nbHashes", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], PartitionedBloomFilter2.prototype, "_loadFactor", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], PartitionedBloomFilter2.prototype, "_m", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Array)
        ], PartitionedBloomFilter2.prototype, "_filter", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], PartitionedBloomFilter2.prototype, "_capacity", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], PartitionedBloomFilter2.prototype, "_length", void 0);
        PartitionedBloomFilter2 = PartitionedBloomFilter_1 = __decorate([
          exportable_1.AutoExportable("PartitionedBloomFilter", ["_seed"]),
          __param(0, exportable_1.Parameter("_size")),
          __param(1, exportable_1.Parameter("_nbHashes")),
          __param(2, exportable_1.Parameter("_loadFactor")),
          __param(3, exportable_1.Parameter("_capacity")),
          __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], PartitionedBloomFilter2);
        return PartitionedBloomFilter2;
      }(base_filter_1.default)
    );
    exports2.default = PartitionedBloomFilter;
  }
});

// node_modules/fission-bloom-filters/dist/sketch/count-min-sketch.js
var require_count_min_sketch = __commonJS({
  "node_modules/fission-bloom-filters/dist/sketch/count-min-sketch.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var exportable_1 = require_exportable();
    var utils_1 = require_utils();
    var CountMinSketch = (
      /** @class */
      function(_super) {
        __extends(CountMinSketch2, _super);
        function CountMinSketch2(columns, rows) {
          var _this = _super.call(this) || this;
          _this._columns = columns;
          _this._rows = rows;
          _this._matrix = utils_1.allocateArray(_this._rows, function() {
            return utils_1.allocateArray(_this._columns, 0);
          });
          _this._allSums = 0;
          return _this;
        }
        CountMinSketch_1 = CountMinSketch2;
        CountMinSketch2.create = function(errorRate, accuracy) {
          if (accuracy === void 0) {
            accuracy = 0.999;
          }
          var columns = Math.ceil(Math.E / errorRate);
          var rows = Math.ceil(Math.log(1 / accuracy));
          return new CountMinSketch_1(columns, rows);
        };
        CountMinSketch2.from = function(items, errorRate, accuracy) {
          var e_1, _a2;
          if (accuracy === void 0) {
            accuracy = 0.999;
          }
          var filter5 = CountMinSketch_1.create(errorRate, accuracy);
          try {
            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
              var item = items_1_1.value;
              filter5.update(item);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
                _a2.call(items_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return filter5;
        };
        Object.defineProperty(CountMinSketch2.prototype, "columns", {
          /**
           * Return the number of columns in the sketch
           */
          get: function() {
            return this._columns;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CountMinSketch2.prototype, "rows", {
          /**
           * Return the number of rows in the sketch
           */
          get: function() {
            return this._rows;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CountMinSketch2.prototype, "sum", {
          /**
           * Get the sum of all counts in the sketch
           */
          get: function() {
            return this._allSums;
          },
          enumerable: true,
          configurable: true
        });
        CountMinSketch2.prototype.update = function(element, count) {
          if (count === void 0) {
            count = 1;
          }
          this._allSums += count;
          var indexes = utils_1.getDistinctIndices(element, this._columns, this._rows, this.seed);
          for (var i = 0; i < this._rows; i++) {
            this._matrix[i][indexes[i]] += count;
          }
        };
        CountMinSketch2.prototype.count = function(element) {
          var min = Infinity;
          var indexes = utils_1.getDistinctIndices(element, this._columns, this._rows, this.seed);
          for (var i = 0; i < this._rows; i++) {
            var v = this._matrix[i][indexes[i]];
            min = Math.min(v, min);
          }
          return min;
        };
        CountMinSketch2.prototype.equals = function(other) {
          if (this._columns !== other._columns || this._rows !== other._rows) {
            return false;
          }
          for (var i = 0; i < this._rows; i++) {
            for (var j = 0; j < this._columns; j++) {
              if (this._matrix[i][j] !== other._matrix[i][j]) {
                return false;
              }
            }
          }
          return true;
        };
        CountMinSketch2.prototype.merge = function(sketch) {
          if (this._columns !== sketch._columns) {
            throw new Error("Cannot merge two sketches with different number of columns");
          }
          if (this._rows !== sketch._rows) {
            throw new Error("Cannot merge two sketches with different number of rows");
          }
          for (var i = 0; i < this._rows; i++) {
            for (var j = 0; j < this._columns; j++) {
              this._matrix[i][j] += sketch._matrix[i][j];
            }
          }
        };
        CountMinSketch2.prototype.clone = function() {
          var sketch = new CountMinSketch_1(this._columns, this._rows);
          sketch.merge(this);
          sketch.seed = this.seed;
          return sketch;
        };
        var CountMinSketch_1;
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], CountMinSketch2.prototype, "_columns", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], CountMinSketch2.prototype, "_rows", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Array)
        ], CountMinSketch2.prototype, "_matrix", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], CountMinSketch2.prototype, "_allSums", void 0);
        CountMinSketch2 = CountMinSketch_1 = __decorate([
          exportable_1.AutoExportable("CountMinSketch", ["_seed"]),
          __param(0, exportable_1.Parameter("_columns")),
          __param(1, exportable_1.Parameter("_rows")),
          __metadata("design:paramtypes", [Number, Number])
        ], CountMinSketch2);
        return CountMinSketch2;
      }(base_filter_1.default)
    );
    exports2.default = CountMinSketch;
  }
});

// node_modules/fission-bloom-filters/dist/sketch/hyperloglog.js
var require_hyperloglog = __commonJS({
  "node_modules/fission-bloom-filters/dist/sketch/hyperloglog.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var exportable_1 = require_exportable();
    var utils_1 = require_utils();
    var TWO_POW_32 = Math.pow(2, 32);
    function computeAlpha(m) {
      switch (m) {
        case 16:
          return 0.673;
        case 32:
          return 0.697;
        case 64:
          return 0.709;
        default:
          return 0.7213 / (1 + 1.079 / m);
      }
    }
    var HyperLogLog = (
      /** @class */
      function(_super) {
        __extends(HyperLogLog2, _super);
        function HyperLogLog2(nbRegisters) {
          var _this = _super.call(this) || this;
          _this._nbRegisters = nbRegisters;
          _this._nbBytesPerHash = Math.round(Math.log2(nbRegisters));
          _this._correctionBias = computeAlpha(nbRegisters);
          _this._registers = utils_1.allocateArray(_this._nbRegisters, 0);
          return _this;
        }
        HyperLogLog_1 = HyperLogLog2;
        Object.defineProperty(HyperLogLog2.prototype, "nbRegisters", {
          /**
           * Get the number of registers used by the HyperLogLog
           */
          get: function() {
            return this._nbRegisters;
          },
          enumerable: true,
          configurable: true
        });
        HyperLogLog2.prototype.update = function(element) {
          var hashedValue = utils_1.hashAsInt(element, this.seed).toString(2);
          var registerIndex = 1 + parseInt(hashedValue.slice(0, this._nbBytesPerHash - 1), 2);
          var secondPart = hashedValue.slice(this._nbBytesPerHash);
          var posLeftMost = 0;
          while (secondPart[posLeftMost] !== "1" && posLeftMost < secondPart.length - 1) {
            posLeftMost++;
          }
          this._registers[registerIndex] = Math.max(this._registers[registerIndex], posLeftMost);
        };
        HyperLogLog2.prototype.count = function(round) {
          if (round === void 0) {
            round = false;
          }
          var harmonicMean = this._registers.reduce(function(acc, value) {
            return acc + Math.pow(2, -value);
          }, 0);
          var estimation = this._correctionBias * Math.pow(this._nbRegisters, 2) / harmonicMean;
          if (estimation > TWO_POW_32 / 30) {
            estimation = -TWO_POW_32 * Math.log(1 - estimation / TWO_POW_32);
          }
          if (round) {
            estimation = Math.round(estimation);
          }
          return estimation;
        };
        HyperLogLog2.prototype.accuracy = function() {
          return 1.04 / Math.sqrt(this._nbRegisters);
        };
        HyperLogLog2.prototype.merge = function(other) {
          if (this.nbRegisters !== other.nbRegisters) {
            throw new Error("Two HyperLogLog must have the same number of registers to be merged. Tried to merge two HyperLogLog with m = " + this.nbRegisters + " and m = " + other.nbRegisters);
          }
          var newSketch = new HyperLogLog_1(this.nbRegisters);
          for (var i = 0; i < this.nbRegisters - 1; i++) {
            newSketch._registers[i] = Math.max(this._registers[i], other._registers[i]);
          }
          return newSketch;
        };
        HyperLogLog2.prototype.equals = function(other) {
          if (this.nbRegisters !== other.nbRegisters) {
            return false;
          }
          for (var i = 0; i < this.nbRegisters - 1; i++) {
            if (this._registers[i] !== other._registers[i]) {
              return false;
            }
          }
          return true;
        };
        var HyperLogLog_1;
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], HyperLogLog2.prototype, "_nbRegisters", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], HyperLogLog2.prototype, "_nbBytesPerHash", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], HyperLogLog2.prototype, "_correctionBias", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Array)
        ], HyperLogLog2.prototype, "_registers", void 0);
        HyperLogLog2 = HyperLogLog_1 = __decorate([
          exportable_1.AutoExportable("HyperLogLog", ["_seed"]),
          __param(0, exportable_1.Parameter("_nbRegisters")),
          __metadata("design:paramtypes", [Number])
        ], HyperLogLog2);
        return HyperLogLog2;
      }(base_filter_1.default)
    );
    exports2.default = HyperLogLog;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root3 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length8 = array == null ? 0 : array.length;
        while (++index2 < length8) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length8 = array == null ? 0 : array.length;
        while (++index2 < length8) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length8 = array == null ? 0 : array.length;
        while (length8--) {
          if (iteratee(array[length8], length8, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length8 = array == null ? 0 : array.length;
        while (++index2 < length8) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length8 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length8) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length8 = array == null ? 0 : array.length;
        return !!length8 && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length8 = array == null ? 0 : array.length;
        while (++index2 < length8) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length8 = array == null ? 0 : array.length, result = Array(length8);
        while (++index2 < length8) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length8 = values.length, offset = array.length;
        while (++index2 < length8) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length8 = array == null ? 0 : array.length;
        if (initAccum && length8) {
          accumulator = array[++index2];
        }
        while (++index2 < length8) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length8 = array == null ? 0 : array.length;
        if (initAccum && length8) {
          accumulator = array[--length8];
        }
        while (length8--) {
          accumulator = iteratee(accumulator, array[length8], length8, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length8 = array == null ? 0 : array.length;
        while (++index2 < length8) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length8 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length8) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length8 = array.length;
        while (++index2 < length8) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length8 = array == null ? 0 : array.length;
        return length8 ? baseSum(array, iteratee) / length8 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length8 = array.length;
        array.sort(comparer);
        while (length8--) {
          array[length8] = array[length8].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length8 = array.length;
        while (++index2 < length8) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache6, key) {
        return cache6.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length8 = strSymbols.length;
        while (++index2 < length8 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length8 = array.length, result = 0;
        while (length8--) {
          if (array[length8] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index2 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length8 = array.length, resIndex = 0, result = [];
        while (++index2 < length8) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length8 = array.length;
        while (++index2 < length8) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function trimmedEndIndex(string2) {
        var index2 = string2.length;
        while (index2-- && reWhitespace.test(string2.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root3 : _.defaults(root3.Object(), context, _.pick(root3, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root3._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root3.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root3.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root3.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length8 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length8, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length8 && takeCount == length8) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length8-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length8 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length8) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length8 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length8) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined2 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length8 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length8) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length8 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length8) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length8 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length8)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length8 = array.length;
          return length8 ? array[baseRandom(0, length8 - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length8 = array.length;
          while (length8--) {
            if (eq(array[length8][0], key)) {
              return length8;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length8 = paths.length, result2 = Array2(length8), skip = object == null;
          while (++index2 < length8) {
            result2[index2] = skip ? undefined2 : get5(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer3(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length8 = props.length;
          if (object == null) {
            return !length8;
          }
          object = Object2(object);
          while (length8--) {
            var key = props[length8], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length8 = array.length, result2 = [], valuesLength = values2.length;
          if (!length8) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length8) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length8 = array.length;
          while (++index2 < length8) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length8 = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length8 ? 0 : length8 + start;
          }
          end = end === undefined2 || end > length8 ? length8 : toInteger(end);
          if (end < 0) {
            end += length8;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length8 = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length8) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index2 = 0, length8 = path.length;
          while (object != null && index2 < length8) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length8 ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length8 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length8 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length8 && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache6 = caches[othIndex];
                  if (!(cache6 ? cacheHas(cache6, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent2(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer3(object)) {
            if (!isBuffer3(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length8 = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length8;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length8) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity8;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get5(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length8 = array.length;
          if (!length8) {
            return;
          }
          n += n < 0 ? length8 : 0;
          return isIndex(n, length8) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity8];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length8 = paths.length, result2 = {};
          while (++index2 < length8) {
            var path = paths[index2], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length8 = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length8) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length8 = array ? indexes.length : 0, lastIndex = length8 - 1;
          while (length8--) {
            var index2 = indexes[length8];
            if (length8 == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length8 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length8);
          while (length8--) {
            result2[fromRight ? length8 : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string2, n) {
          var result2 = "";
          if (!string2 || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string2;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string2 += string2;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity8), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index2 = -1, length8 = path.length, lastIndex = length8 - 1, nested = object;
          while (nested != null && ++index2 < length8) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity8 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity8 : function(func, string2) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index2 = -1, length8 = array.length;
          if (start < 0) {
            start = -start > length8 ? 0 : length8 + start;
          }
          end = end > length8 ? length8 : end;
          if (end < 0) {
            end += length8;
          }
          length8 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length8);
          while (++index2 < length8) {
            result2[index2] = array[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity8, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length8 = array.length, resIndex = 0, result2 = [];
          while (++index2 < length8) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length8 = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length8 >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length8) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent2(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length8 = array.length, index2 = fromRight ? length8 : -1;
          while ((fromRight ? index2-- : ++index2 < length8) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length8) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length8 : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length8 = arrays.length;
          if (length8 < 2) {
            return length8 ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length8);
          while (++index2 < length8) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length8) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length8 = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length8) {
            var value = index2 < valsLength ? values2[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity8;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString11(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length8 = array.length;
          end = end === undefined2 ? length8 : end;
          return !start && end >= length8 ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root3.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length8 = buffer2.length, result2 = allocUnsafe2 ? allocUnsafe2(length8) : new buffer2.constructor(length8);
          buffer2.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView2, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView2.buffer) : dataView2.buffer;
          return new dataView2.constructor(buffer2, dataView2.byteOffset, dataView2.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol3) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol3)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length8 = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length8) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length8 = source.length;
          array || (array = Array2(length8));
          while (++index2 < length8) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length8 = props.length;
          while (++index2 < length8) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length8 = sources.length, customizer = length8 > 1 ? sources[length8 - 1] : undefined2, guard = length8 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length8--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length8 < 3 ? undefined2 : customizer;
              length8 = 1;
            }
            object = Object2(object);
            while (++index2 < length8) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length8 = collection.length, index2 = fromRight ? length8 : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length8) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length8 = props.length;
            while (length8--) {
              var key = props[fromRight ? length8 : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString11(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string2) {
            return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length8 = arguments.length, args = Array2(length8), index2 = length8, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length8 < 3 && args[0] !== placeholder && args[length8 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length8 -= holders.length;
            if (length8 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length8
              );
            }
            var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length8 = funcs.length, index2 = length8, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length8;
            while (++index2 < length8) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length8 ? funcs[index3].apply(this, args) : value;
              while (++index3 < length8) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length8 = arguments.length, args = Array2(length8), index2 = length8;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length8 -= holdersCount;
            if (isCurried && length8 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length8
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length8 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length8 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length8) {
              args.length = ary2;
            }
            if (this && this !== root3 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length8, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length8) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length8 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length8).join("") : result2.slice(0, length8);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString11(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString11(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length8 = partials ? partials.length : 0;
          if (!length8) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length8 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length8, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten2), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length8 = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length8--) {
            var data = array[length8], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length8 = result2.length;
          while (length8--) {
            var key = result2[length8], value = object[key];
            result2[length8] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue2(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol3) {
            return propertyIsEnumerable.call(object, symbol3);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length8 = transforms.length;
          while (++index2 < length8) {
            var data = transforms[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index2 = -1, length8 = path.length, result2 = false;
          while (++index2 < length8) {
            var key = toKey(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length8) {
            return result2;
          }
          length8 = object == null ? 0 : object.length;
          return !!length8 && isLength(length8) && isIndex(key, length8) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length8 = array.length, result2 = new array.constructor(length8);
          if (length8 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length8 = details.length;
          if (!length8) {
            return source;
          }
          var lastIndex = length8 - 1;
          details[lastIndex] = (length8 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length8 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length8) {
          var type = typeof value;
          length8 = length8 == null ? MAX_SAFE_INTEGER : length8;
          return !!length8 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length8);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache6.size === MAX_MEMOIZE_SIZE) {
              cache6.clear();
            }
            return key;
          });
          var cache6 = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length8 = nativeMax(args.length - start, 0), array = Array2(length8);
            while (++index2 < length8) {
              array[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent2(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length8 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length8--) {
            var index2 = indexes[length8];
            array[length8] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root3.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference2, bitmask) {
          var source = reference2 + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index2 = -1, length8 = array.length, lastIndex = length8 - 1;
          size2 = size2 === undefined2 ? length8 : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length8 = array == null ? 0 : array.length;
          if (!length8 || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length8 / size2));
          while (index2 < length8) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length8 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length8) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat5() {
          var length8 = arguments.length;
          if (!length8) {
            return [];
          }
          var args = Array2(length8 - 1), array = arguments[0], index2 = length8;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length8);
        }
        function dropRight(array, n, guard) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length8 - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length8;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length8 + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return -1;
          }
          var index2 = length8 - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length8 + index2, 0) : nativeMin(index2, length8 - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten2(array) {
          var length8 = array == null ? 0 : array.length;
          return length8 ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length8 = array == null ? 0 : array.length;
          return length8 ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length8 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length8) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length8 + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length8 = array == null ? 0 : array.length;
          return length8 ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length8 = array == null ? 0 : array.length;
          return length8 ? array[length8 - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return -1;
          }
          var index2 = length8;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length8 + index2, 0) : nativeMin(index2, length8 - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length8 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length8) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length8 = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length8) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start, end) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length8;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length8 : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length8 = array == null ? 0 : array.length;
          if (length8) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length8 && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length8 = array == null ? 0 : array.length;
          if (length8) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length8 = array == null ? 0 : array.length;
          return length8 ? baseSlice(array, 1, length8) : [];
        }
        function take4(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length8 = array == null ? 0 : array.length;
          if (!length8) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length8 - n;
          return baseSlice(array, n < 0 ? 0 : n, length8);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length8 = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length8 = nativeMax(group.length, length8);
              return true;
            }
          });
          return baseTimes(length8, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor2 = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length8 = arrays.length, iteratee2 = length8 > 1 ? arrays[length8 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length8 = paths.length, start = length8 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length8 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length8 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length8 && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent3 = this;
          while (parent3 instanceof baseLodash) {
            var clone2 = wrapperClone(parent3);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent3 = parent3.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter5(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length8 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length8 + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length8 && collection.indexOf(value, fromIndex) > -1 : !!length8 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length8 = iteratees.length;
          if (length8 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length8 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root3.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache6 = memoized.cache;
            if (cache6.has(key)) {
              return cache6.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache6.set(key, result2) || cache6;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length8 = nativeMin(args.length, funcsLength);
            while (++index2 < length8) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer3 = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString11(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create14(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length8 = sources.length;
          var guard = length8 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length8 = 1;
          }
          while (++index2 < length8) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get5(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity8));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge4 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length8 = paths.length;
          while (length8--) {
            baseUnset(result2, paths[length8]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index2 = -1, length8 = path.length;
          if (!length8) {
            length8 = 1;
            object = undefined2;
          }
          while (++index2 < length8) {
            var value = object == null ? undefined2 : object[toKey(path[index2])];
            if (value === undefined2) {
              index2 = length8;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer3(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string2) {
          return upperFirst(toString11(string2).toLowerCase());
        }
        function deburr(string2) {
          string2 = toString11(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string2, target, position) {
          string2 = toString11(string2);
          target = baseToString(target);
          var length8 = string2.length;
          position = position === undefined2 ? length8 : baseClamp(toInteger(position), 0, length8);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        function escape(string2) {
          string2 = toString11(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        function escapeRegExp(string2) {
          string2 = toString11(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string2, length8, chars) {
          string2 = toString11(string2);
          length8 = toInteger(length8);
          var strLength = length8 ? stringSize(string2) : 0;
          if (!length8 || strLength >= length8) {
            return string2;
          }
          var mid = (length8 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string2, length8, chars) {
          string2 = toString11(string2);
          length8 = toInteger(length8);
          var strLength = length8 ? stringSize(string2) : 0;
          return length8 && strLength < length8 ? string2 + createPadding(length8 - strLength, chars) : string2;
        }
        function padStart(string2, length8, chars) {
          string2 = toString11(string2);
          length8 = toInteger(length8);
          var strLength = length8 ? stringSize(string2) : 0;
          return length8 && strLength < length8 ? createPadding(length8 - strLength, chars) + string2 : string2;
        }
        function parseInt2(string2, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString11(string2).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string2, n, guard) {
          if (guard ? isIterateeCall(string2, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString11(string2), n);
        }
        function replace() {
          var args = arguments, string2 = toString11(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string2, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString11(string2);
          if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString11(string2);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        function template(string2, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string2, options, guard)) {
            options = undefined2;
          }
          string2 = toString11(string2);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString11(value).toLowerCase();
        }
        function toUpper(value) {
          return toString11(value).toUpperCase();
        }
        function trim(string2, chars, guard) {
          string2 = toString11(string2);
          if (string2 && (guard || chars === undefined2)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string2, chars, guard) {
          string2 = toString11(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string2, chars, guard) {
          string2 = toString11(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string2, options) {
          var length8 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length8 = "length" in options ? toInteger(options.length) : length8;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string2 = toString11(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length8 >= strLength) {
            return string2;
          }
          var end = length8 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string2.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString11(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape(string2) {
          string2 = toString11(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string2, pattern, guard) {
          string2 = toString11(string2);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length8 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length8 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length8) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity8(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root3._ === this) {
            root3._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length8 = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length8, iteratee2);
          while (++index2 < n) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString11(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString11(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity8, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity8);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity8, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity8) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat5;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create14;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter5;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge4;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set2;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice2;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take4;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle2;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor2;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get5;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity8;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer3;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString11;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity8);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root3._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root3._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/fission-bloom-filters/dist/sketch/topk.js
var require_topk = __commonJS({
  "node_modules/fission-bloom-filters/dist/sketch/topk.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var count_min_sketch_1 = __importDefault(require_count_min_sketch());
    var exportable_1 = require_exportable();
    var lodash_1 = require_lodash();
    var MinHeap = (
      /** @class */
      function() {
        function MinHeap2() {
          this._content = [];
        }
        Object.defineProperty(MinHeap2.prototype, "length", {
          /**
           * Get the number of items in the heap
           */
          get: function() {
            return this._content.length;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(MinHeap2.prototype, "content", {
          get: function() {
            return this._content;
          },
          set: function(value) {
            this._content = value;
          },
          enumerable: true,
          configurable: true
        });
        MinHeap2.prototype.get = function(index2) {
          return this._content[index2];
        };
        MinHeap2.prototype.add = function(element) {
          var index2 = lodash_1.sortedIndexBy(this._content, element, function(heapElement) {
            return heapElement.frequency;
          });
          this._content.splice(index2, 0, element);
        };
        MinHeap2.prototype.remove = function(index2) {
          this._content.splice(index2, 1);
        };
        MinHeap2.prototype.popMin = function() {
          return this._content.shift();
        };
        MinHeap2.prototype.indexOf = function(value) {
          return this._content.findIndex(function(heapElement) {
            return heapElement.value === value;
          });
        };
        MinHeap2.prototype.clear = function() {
          this._content = [];
        };
        return MinHeap2;
      }()
    );
    var TopK = (
      /** @class */
      function(_super) {
        __extends(TopK2, _super);
        function TopK2(k, errorRate, accuracy) {
          var _this = _super.call(this) || this;
          _this._k = k;
          _this._errorRate = errorRate;
          _this._accuracy = accuracy;
          _this._sketch = count_min_sketch_1.default.create(errorRate, accuracy);
          _this._heap = new MinHeap();
          return _this;
        }
        TopK2.prototype.add = function(element) {
          this._sketch.update(element);
          var frequency = this._sketch.count(element);
          if (this._heap.length < this._k || frequency >= this._heap.get(0).frequency) {
            var index2 = this._heap.indexOf(element);
            if (index2 > -1) {
              this._heap.remove(index2);
            }
            this._heap.add({
              value: element,
              frequency
            });
            if (this._heap.length > this._k) {
              this._heap.popMin();
            }
          }
        };
        TopK2.prototype.clear = function() {
          this._sketch = count_min_sketch_1.default.create(this._errorRate, this._accuracy);
          this._heap.clear();
        };
        TopK2.prototype.values = function() {
          var res = [];
          for (var i = this._heap.length - 1; i >= 0; i--) {
            var elt = this._heap.get(i);
            res.push({
              value: elt.value,
              frequency: elt.frequency,
              rank: this._heap.length - i
            });
          }
          return res;
        };
        TopK2.prototype.iterator = function() {
          var heap2 = this._heap;
          return function() {
            var i, elt;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  i = heap2.length - 1;
                  _a2.label = 1;
                case 1:
                  if (!(i >= 0))
                    return [3, 4];
                  elt = heap2.get(i);
                  return [4, {
                    value: elt.value,
                    frequency: elt.frequency,
                    rank: heap2.length - i
                  }];
                case 2:
                  _a2.sent();
                  _a2.label = 3;
                case 3:
                  i--;
                  return [3, 1];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          }();
        };
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], TopK2.prototype, "_k", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], TopK2.prototype, "_errorRate", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], TopK2.prototype, "_accuracy", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", count_min_sketch_1.default)
        ], TopK2.prototype, "_sketch", void 0);
        __decorate([
          exportable_1.Field(function(heap2) {
            return heap2.content;
          }, function(json) {
            var heap2 = new MinHeap();
            heap2.content = json;
            return heap2;
          }),
          __metadata(
            "design:type",
            MinHeap
            /**
             * Constructor
             * @param k - How many elements to store
             * @param errorRate - The error rate
             * @param accuracy  - The probability of accuracy
             */
          )
        ], TopK2.prototype, "_heap", void 0);
        TopK2 = __decorate([
          exportable_1.AutoExportable("TopK", ["_seed"]),
          __param(0, exportable_1.Parameter("_k")),
          __param(1, exportable_1.Parameter("_errorRate")),
          __param(2, exportable_1.Parameter("_accuracy")),
          __metadata("design:paramtypes", [Number, Number, Number])
        ], TopK2);
        return TopK2;
      }(base_filter_1.default)
    );
    exports2.default = TopK;
  }
});

// node_modules/fission-bloom-filters/dist/sketch/min-hash.js
var require_min_hash = __commonJS({
  "node_modules/fission-bloom-filters/dist/sketch/min-hash.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports2 && exports2.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var exportable_1 = require_exportable();
    var utils_1 = require_utils();
    var lodash_1 = require_lodash();
    var EmptyMinHashError = (
      /** @class */
      function(_super) {
        __extends(EmptyMinHashError2, _super);
        function EmptyMinHashError2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return EmptyMinHashError2;
      }(Error)
    );
    function applyHashFunction(x, fn) {
      return (fn.a * x + fn.b) % fn.c;
    }
    var MinHash = (
      /** @class */
      function(_super) {
        __extends(MinHash2, _super);
        function MinHash2(nbHashes, hashFunctions) {
          var _this = _super.call(this) || this;
          _this._nbHashes = nbHashes;
          _this._hashFunctions = hashFunctions;
          _this._signature = utils_1.allocateArray(_this._nbHashes, Infinity);
          return _this;
        }
        Object.defineProperty(MinHash2.prototype, "nbHashes", {
          /**
           * Get the number of hash functions used by the MinHash
           */
          get: function() {
            return this._nbHashes;
          },
          enumerable: true,
          configurable: true
        });
        MinHash2.prototype.isEmpty = function() {
          return this._signature[0] === Infinity;
        };
        MinHash2.prototype.add = function(value) {
          for (var i = 0; i < this._nbHashes; i++) {
            this._signature[i] = Math.min(this._signature[i], applyHashFunction(value, this._hashFunctions[i]));
          }
        };
        MinHash2.prototype.bulkLoad = function(values) {
          var _this = this;
          var _loop_1 = function(i2) {
            var candidateSignatures = values.map(function(value) {
              return applyHashFunction(value, _this._hashFunctions[i2]);
            });
            this_1._signature[i2] = Math.min.apply(Math, __spread([this_1._signature[i2]], candidateSignatures));
          };
          var this_1 = this;
          for (var i = 0; i < this._nbHashes; i++) {
            _loop_1(i);
          }
        };
        MinHash2.prototype.compareWith = function(other) {
          if (this.isEmpty() || other.isEmpty()) {
            throw new EmptyMinHashError("Cannot compute a Jaccard similairty with a MinHash that contains no values");
          }
          return lodash_1.intersection(this._signature, other._signature).length / this._nbHashes;
        };
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], MinHash2.prototype, "_nbHashes", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Array)
        ], MinHash2.prototype, "_hashFunctions", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Array)
        ], MinHash2.prototype, "_signature", void 0);
        MinHash2 = __decorate([
          exportable_1.AutoExportable("MinHash", ["_seed"]),
          __param(0, exportable_1.Parameter("_nbHashes")),
          __param(1, exportable_1.Parameter("_hashFunctions")),
          __metadata("design:paramtypes", [Number, Array])
        ], MinHash2);
        return MinHash2;
      }(base_filter_1.default)
    );
    exports2.MinHash = MinHash;
  }
});

// node_modules/fission-bloom-filters/dist/sketch/min-hash-factory.js
var require_min_hash_factory = __commonJS({
  "node_modules/fission-bloom-filters/dist/sketch/min-hash-factory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var min_hash_1 = require_min_hash();
    var lodash_1 = require_lodash();
    function isPrime(x) {
      if (x !== 2 && x % 2 === 0) {
        return false;
      }
      for (var i = 2; i < Math.sqrt(x); i++) {
        if (x % i === 0) {
          return false;
        }
      }
      return true;
    }
    function closestPrime(x) {
      var i = 0;
      while (true) {
        if (isPrime(x + i)) {
          return x + i;
        }
        i++;
      }
    }
    var MinHashFactory = (
      /** @class */
      function() {
        function MinHashFactory2(nbHashes, maxValue) {
          this._nbHashes = nbHashes;
          this._maxValue = maxValue;
          this._hashFunctions = [];
          var c = closestPrime(this._maxValue);
          for (var i = 0; i < this._nbHashes; i++) {
            var a = lodash_1.random(0, this._maxValue, false);
            var b = lodash_1.random(0, this._maxValue, false);
            this._hashFunctions.push({ a, b, c });
          }
        }
        MinHashFactory2.prototype.create = function() {
          return new min_hash_1.MinHash(this._nbHashes, this._hashFunctions);
        };
        return MinHashFactory2;
      }()
    );
    exports2.default = MinHashFactory;
  }
});

// node_modules/lodash.eq/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.eq/index.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash.indexof/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.indexof/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length8 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length8) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index2 = fromIndex - 1, length8 = array.length;
      while (++index2 < length8) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length8 = array ? array.length : 0;
      if (!length8) {
        return -1;
      }
      var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index2 < 0) {
        index2 = nativeMax(length8 + index2, 0);
      }
      return baseIndexOf(array, value, index2);
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = indexOf;
  }
});

// node_modules/fission-bloom-filters/dist/cuckoo/bucket.js
var require_bucket = __commonJS({
  "node_modules/fission-bloom-filters/dist/cuckoo/bucket.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (Object.hasOwnProperty.call(mod2, k))
            result[k] = mod2[k];
      }
      result["default"] = mod2;
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lodash_eq_1 = __importDefault(require_lodash2());
    var lodash_indexof_1 = __importDefault(require_lodash3());
    var utils = __importStar(require_utils());
    var exportable_1 = require_exportable();
    var exportable_2 = require_exportable();
    var Bucket = (
      /** @class */
      function() {
        function Bucket2(size) {
          this._elements = utils.allocateArray(size, null);
          this._size = size;
          this._length = 0;
        }
        Bucket_1 = Bucket2;
        Object.defineProperty(Bucket2.prototype, "size", {
          /**
           * Get the maximum number of element in the bucket
           */
          get: function() {
            return this._size;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Bucket2.prototype, "length", {
          /**
           * Get the number of elements currenlty in the bucket
           */
          get: function() {
            return this._length;
          },
          enumerable: true,
          configurable: true
        });
        Bucket2.prototype.isFree = function() {
          return this._length < this._size;
        };
        Bucket2.prototype.nextEmptySlot = function() {
          return lodash_indexof_1.default(this._elements, null);
        };
        Bucket2.prototype.at = function(index2) {
          return this._elements[index2];
        };
        Bucket2.prototype.add = function(element) {
          if (element === null || !this.isFree()) {
            return false;
          }
          this.set(this.nextEmptySlot(), element);
          this._length++;
          return true;
        };
        Bucket2.prototype.remove = function(element) {
          var index2 = lodash_indexof_1.default(this._elements, element);
          if (index2 <= -1) {
            return false;
          }
          this.unset(index2);
          return true;
        };
        Bucket2.prototype.has = function(element) {
          return lodash_indexof_1.default(this._elements, element) > -1;
        };
        Bucket2.prototype.set = function(index2, element) {
          this._elements[index2] = element;
        };
        Bucket2.prototype.unset = function(index2) {
          this._elements[index2] = null;
          this._length--;
        };
        Bucket2.prototype.swapRandom = function(element, random) {
          if (random === void 0) {
            random = Math.random;
          }
          var index2 = utils.randomInt(0, this._length - 1, random);
          var tmp = this._elements[index2];
          this._elements[index2] = element;
          return tmp;
        };
        Bucket2.prototype.swap = function(index2, element) {
          var tmp = this._elements[index2];
          this._elements[index2] = element;
          return tmp;
        };
        Bucket2.prototype.equals = function(bucket) {
          if (this._size !== bucket.size || this._length !== bucket.length)
            return false;
          return this._elements.every(function(elt, index2) {
            return lodash_eq_1.default(bucket.at(index2), elt);
          });
        };
        var Bucket_1;
        Bucket2 = Bucket_1 = __decorate([
          exportable_1.Exportable({
            export: exportable_2.cloneObject("Bucket", "_size", "_elements"),
            import: function(json) {
              if (json.type !== "Bucket" || !("_size" in json), !("_elements" in json)) {
                throw new Error("Cannot create a Bucket from a JSON export which does not represent a bucket");
              }
              var bucket = new Bucket_1(json._size);
              json._elements.forEach(function(elt, i) {
                if (elt !== null) {
                  bucket._elements[i] = elt;
                  bucket._length++;
                }
              });
              return bucket;
            }
          }),
          __metadata("design:paramtypes", [Number])
        ], Bucket2);
        return Bucket2;
      }()
    );
    exports2.default = Bucket;
  }
});

// node_modules/fission-bloom-filters/dist/cuckoo/cuckoo-filter.js
var require_cuckoo_filter = __commonJS({
  "node_modules/fission-bloom-filters/dist/cuckoo/cuckoo-filter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base_filter_1 = __importDefault(require_base_filter());
    var bucket_1 = __importDefault(require_bucket());
    var exportable_1 = require_exportable();
    var utils_1 = require_utils();
    function computeFingerpintLength(size, rate) {
      var f = Math.ceil(Math.log2(1 / rate) + Math.log2(2 * size));
      return Math.ceil(f / 4);
    }
    var CuckooFilter = (
      /** @class */
      function(_super) {
        __extends(CuckooFilter2, _super);
        function CuckooFilter2(size, fLength, bucketSize, maxKicks) {
          if (maxKicks === void 0) {
            maxKicks = 500;
          }
          var _this = _super.call(this) || this;
          _this._filter = utils_1.allocateArray(size, function() {
            return new bucket_1.default(bucketSize);
          });
          _this._size = size;
          _this._bucketSize = bucketSize;
          _this._fingerprintLength = fLength;
          _this._length = 0;
          _this._maxKicks = maxKicks;
          return _this;
        }
        CuckooFilter_1 = CuckooFilter2;
        CuckooFilter2.create = function(size, errorRate, bucketSize, maxKicks) {
          if (bucketSize === void 0) {
            bucketSize = 4;
          }
          if (maxKicks === void 0) {
            maxKicks = 500;
          }
          var fl = computeFingerpintLength(bucketSize, errorRate);
          var capacity = Math.ceil(size / bucketSize / 0.955);
          return new CuckooFilter_1(capacity, fl, bucketSize, maxKicks);
        };
        CuckooFilter2.from = function(items, errorRate, bucketSize, maxKicks) {
          if (bucketSize === void 0) {
            bucketSize = 4;
          }
          if (maxKicks === void 0) {
            maxKicks = 500;
          }
          var array = Array.from(items);
          var filter5 = CuckooFilter_1.create(array.length, errorRate, bucketSize, maxKicks);
          array.forEach(function(item) {
            return filter5.add(item);
          });
          return filter5;
        };
        Object.defineProperty(CuckooFilter2.prototype, "size", {
          /**
           * Get the filter size
           */
          get: function() {
            return this._size;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CuckooFilter2.prototype, "fullSize", {
          /**
           * Get the filter full size, i.e., the total number of cells
           */
          get: function() {
            return this.size * this.bucketSize;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CuckooFilter2.prototype, "length", {
          /**
           * Get the filter length, i.e. the current number of elements in the filter
           */
          get: function() {
            return this._length;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CuckooFilter2.prototype, "fingerprintLength", {
          /**
           * Get the length of the fingerprints in the filter
           */
          get: function() {
            return this._fingerprintLength;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CuckooFilter2.prototype, "bucketSize", {
          /**
           * Get the size of the buckets in the filter
           */
          get: function() {
            return this._bucketSize;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CuckooFilter2.prototype, "maxKicks", {
          /**
           * Get the max number of kicks when resolving collision at insertion
           */
          get: function() {
            return this._maxKicks;
          },
          enumerable: true,
          configurable: true
        });
        CuckooFilter2.prototype.add = function(element, throwError, destructive) {
          if (throwError === void 0) {
            throwError = false;
          }
          if (destructive === void 0) {
            destructive = false;
          }
          var locations = this._locations(element);
          if (this._filter[locations.firstIndex].isFree()) {
            this._filter[locations.firstIndex].add(locations.fingerprint);
          } else if (this._filter[locations.secondIndex].isFree()) {
            this._filter[locations.secondIndex].add(locations.fingerprint);
          } else {
            var index2 = this.random() < 0.5 ? locations.firstIndex : locations.secondIndex;
            var movedElement = locations.fingerprint;
            var logs = [];
            for (var nbTry = 0; nbTry < this._maxKicks; nbTry++) {
              var rndIndex = utils_1.randomInt(0, this._filter[index2].length - 1, this.random);
              var tmp = this._filter[index2].at(rndIndex);
              logs.push([index2, rndIndex, tmp]);
              this._filter[index2].set(rndIndex, movedElement);
              movedElement = tmp;
              var newHash = utils_1.hashAsInt(movedElement, this.seed, 64);
              index2 = Math.abs(index2 ^ Math.abs(newHash)) % this._filter.length;
              if (this._filter[index2].isFree()) {
                this._filter[index2].add(movedElement);
                this._length++;
                return true;
              }
            }
            if (!destructive) {
              for (var i = logs.length - 1; i >= 0; i--) {
                var log11 = logs[i];
                this._filter[log11[0]].set(log11[1], log11[2]);
              }
            }
            if (throwError) {
              throw new Error('The Cuckoo Filter is full, cannot insert element "' + element + '"');
            } else {
              return false;
            }
          }
          this._length++;
          return true;
        };
        CuckooFilter2.prototype.remove = function(element) {
          var locations = this._locations(element);
          if (this._filter[locations.firstIndex].has(locations.fingerprint)) {
            this._filter[locations.firstIndex].remove(locations.fingerprint);
            this._length--;
            return true;
          } else if (this._filter[locations.secondIndex].has(locations.fingerprint)) {
            this._filter[locations.secondIndex].remove(locations.fingerprint);
            this._length--;
            return true;
          }
          return false;
        };
        CuckooFilter2.prototype.has = function(element) {
          var locations = this._locations(element);
          return this._filter[locations.firstIndex].has(locations.fingerprint) || this._filter[locations.secondIndex].has(locations.fingerprint);
        };
        CuckooFilter2.prototype.rate = function() {
          var load2 = this._computeHashTableLoad();
          var c = this._fingerprintLength / load2.load;
          return Math.pow(2, Math.log2(2 * this._bucketSize) - load2.load * c);
        };
        CuckooFilter2.prototype._computeHashTableLoad = function() {
          var max = this._filter.length * this._bucketSize;
          var used = this._filter.reduce(function(acc, val) {
            return acc + val.length;
          }, 0);
          return {
            used,
            free: max - used,
            size: max,
            load: used / max
          };
        };
        CuckooFilter2.prototype._locations = function(element) {
          var hashes4 = utils_1.hashIntAndString(element, this.seed, 16, 64);
          var hash3 = hashes4.int;
          if (this._fingerprintLength > hashes4.string.length) {
            throw new Error("The fingerprint length (" + this._fingerprintLength + ") is higher than the hash length (" + hashes4.string.length + "). Please reduce the fingerprint length or report if it is an unexpected behavior.");
          }
          var fingerprint = hashes4.string.substring(0, this._fingerprintLength);
          var firstIndex = Math.abs(hash3);
          var secondHash = Math.abs(utils_1.hashAsInt(fingerprint, this.seed, 64));
          var secondIndex = Math.abs(firstIndex ^ secondHash);
          var res = {
            fingerprint,
            firstIndex: firstIndex % this._size,
            secondIndex: secondIndex % this._size
          };
          return res;
        };
        CuckooFilter2.prototype.equals = function(filter5) {
          var i = 0;
          var res = true;
          while (res && i < this._filter.length) {
            var bucket = this._filter[i];
            if (!filter5._filter[i].equals(bucket)) {
              res = false;
            }
            i++;
          }
          return res;
        };
        var CuckooFilter_1;
        CuckooFilter2 = CuckooFilter_1 = __decorate([
          exportable_1.Exportable({
            export: exportable_1.cloneObject("CuckooFilter", "_size", "_fingerprintLength", "_length", "_maxKicks", "_filter", "_seed"),
            import: function(json) {
              if (json.type !== "CuckooFilter" || !("_size" in json) || !("_fingerprintLength" in json) || !("_length" in json) || !("_maxKicks" in json) || !("_filter" in json) || !("_seed" in json)) {
                throw new Error("Cannot create a CuckooFilter from a JSON export which does not represent a cuckoo filter");
              }
              var filter5 = new CuckooFilter_1(json._size, json._fingerprintLength, json._bucketSize, json._maxKicks);
              filter5._length = json._length;
              filter5._filter = json._filter.map(function(j) {
                var bucket = new bucket_1.default(j._size);
                j._elements.forEach(function(elt, i) {
                  if (elt !== null) {
                    bucket._elements[i] = elt;
                    bucket._length++;
                  }
                });
                return bucket;
              });
              filter5.seed = json.seed;
              return filter5;
            }
          }),
          __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], CuckooFilter2);
        return CuckooFilter2;
      }(base_filter_1.default)
    );
    exports2.default = CuckooFilter;
  }
});

// node_modules/fission-bloom-filters/dist/iblt/cell.js
var require_cell = __commonJS({
  "node_modules/fission-bloom-filters/dist/iblt/cell.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var utils_1 = require_utils();
    var exportable_1 = require_exportable();
    var base_filter_1 = __importDefault(require_base_filter());
    var inspect3 = Symbol.for("nodejs.util.inspect.custom");
    var Cell = (
      /** @class */
      function(_super) {
        __extends(Cell2, _super);
        function Cell2(idSum, hashSum, count) {
          var _this = _super.call(this) || this;
          _this._idSum = idSum;
          _this._hashSum = hashSum;
          _this._count = count;
          return _this;
        }
        Cell_1 = Cell2;
        Cell2.empty = function() {
          return new Cell_1(buffer_1.Buffer.allocUnsafe(0).fill(0), buffer_1.Buffer.allocUnsafe(0).fill(0), 0);
        };
        Cell2.prototype[inspect3] = function() {
          return "Cell:<" + JSON.stringify(this._idSum.toJSON().data) + ", " + JSON.stringify(this._hashSum.toJSON().data) + ", " + this._count + ">";
        };
        Object.defineProperty(Cell2.prototype, "idSum", {
          /**
           * Get the id sum of the Cell (The XOR of all element inserted in that cell)
           */
          get: function() {
            return this._idSum;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Cell2.prototype, "hashSum", {
          /**
           * Get the hash sum of the Cell (The XOR of all hashed element in that cell)
           */
          get: function() {
            return this._hashSum;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Cell2.prototype, "count", {
          /**
           * Get the number of elements inserted in that cell
           */
          get: function() {
            return this._count;
          },
          enumerable: true,
          configurable: true
        });
        Cell2.prototype.add = function(idSum, hashSum) {
          this._idSum = utils_1.xorBuffer(this._idSum, idSum);
          this._hashSum = utils_1.xorBuffer(this._hashSum, hashSum);
          this._count++;
        };
        Cell2.prototype.xorm = function(cell) {
          return new Cell_1(utils_1.xorBuffer(this._idSum, cell.idSum), utils_1.xorBuffer(this._hashSum, cell.hashSum), this._count - cell.count);
        };
        Cell2.prototype.isEmpty = function() {
          return this._idSum.equals(buffer_1.Buffer.from("")) && this._hashSum.equals(buffer_1.Buffer.from("")) && this._count === 0;
        };
        Cell2.prototype.equals = function(cell) {
          return this._count === cell.count && this._idSum.equals(cell.idSum) && this._hashSum.equals(cell.hashSum);
        };
        Cell2.prototype.isPure = function() {
          if (this.isEmpty() || this._count !== 1 && this._count !== -1) {
            return false;
          }
          var hashes4 = utils_1.hashTwiceAsString(JSON.stringify(this._idSum.toJSON()), this.seed);
          return this._hashSum.equals(buffer_1.Buffer.from(hashes4.first));
        };
        var Cell_1;
        __decorate([
          exportable_1.Field(function(elt) {
            return elt.toString();
          }, buffer_1.Buffer.from),
          __metadata("design:type", Object)
        ], Cell2.prototype, "_idSum", void 0);
        __decorate([
          exportable_1.Field(function(elt) {
            return elt.toString();
          }, buffer_1.Buffer.from),
          __metadata("design:type", Object)
        ], Cell2.prototype, "_hashSum", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], Cell2.prototype, "_count", void 0);
        Cell2 = Cell_1 = __decorate([
          exportable_1.AutoExportable("Cell", ["_seed"]),
          __param(0, exportable_1.Parameter("_idSum")),
          __param(1, exportable_1.Parameter("_hashSum")),
          __param(2, exportable_1.Parameter("_count")),
          __metadata("design:paramtypes", [Object, Object, Number])
        ], Cell2);
        return Cell2;
      }(base_filter_1.default)
    );
    exports2.default = Cell;
  }
});

// node_modules/fission-bloom-filters/dist/iblt/invertible-bloom-lookup-tables.js
var require_invertible_bloom_lookup_tables = __commonJS({
  "node_modules/fission-bloom-filters/dist/iblt/invertible-bloom-lookup-tables.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var base_filter_1 = __importDefault(require_base_filter());
    var cell_1 = __importDefault(require_cell());
    var exportable_1 = require_exportable();
    var utils_1 = require_utils();
    var formulas_1 = require_formulas();
    var InvertibleBloomFilter = (
      /** @class */
      function(_super) {
        __extends(InvertibleBloomFilter2, _super);
        function InvertibleBloomFilter2(size, hashCount) {
          if (hashCount === void 0) {
            hashCount = 3;
          }
          var _this = _super.call(this) || this;
          if (buffer_1.Buffer === void 0) {
            throw new Error('No native Buffer implementation bound in your JavaScript env. If you are in a Web browser, consider importing the polyfill "feross/buffer" (https://github.com/feross/buffer).');
          }
          if (hashCount <= 0) {
            throw new Error("The hashCount must be a non-zero, positive integer");
          }
          _this._size = size;
          _this._hashCount = hashCount;
          _this._elements = utils_1.allocateArray(_this._size, function() {
            return cell_1.default.empty();
          });
          return _this;
        }
        InvertibleBloomFilter_1 = InvertibleBloomFilter2;
        InvertibleBloomFilter2.create = function(nbItems, errorRate) {
          var size = formulas_1.optimalFilterSize(nbItems, errorRate);
          var nbHashes = formulas_1.optimalHashes(size, nbItems);
          return new InvertibleBloomFilter_1(size, nbHashes);
        };
        InvertibleBloomFilter2.from = function(items, errorRate) {
          var array = Array.from(items);
          var filter5 = InvertibleBloomFilter_1.create(array.length, errorRate);
          array.forEach(function(item) {
            return filter5.add(item);
          });
          return filter5;
        };
        Object.defineProperty(InvertibleBloomFilter2.prototype, "hashCount", {
          /**
           * Return the number of hash functions used
           * @return {Number}
           */
          get: function() {
            return this._hashCount;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(InvertibleBloomFilter2.prototype, "size", {
          /**
           * Get the number of cells of the filter
           */
          get: function() {
            return this._size;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(InvertibleBloomFilter2.prototype, "length", {
          /**
           * Get the number of elements added in the filter
           * Complexity in time: O(alpha*d)
           */
          get: function() {
            return this._elements.reduce(function(a, b) {
              return a + b.count;
            }, 0) / this._hashCount;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(InvertibleBloomFilter2.prototype, "elements", {
          /**
           * Return the cells used to store elements in this InvertibleBloomFilter
           */
          get: function() {
            return this._elements;
          },
          enumerable: true,
          configurable: true
        });
        InvertibleBloomFilter2.prototype.add = function(element) {
          var hashes4 = utils_1.allInOneHashTwice(JSON.stringify(element.toJSON()), this.seed);
          var indexes = utils_1.getDistinctIndices(hashes4.string.first, this._size, this._hashCount, this.seed);
          for (var i = 0; i < this._hashCount; ++i) {
            this._elements[indexes[i]].add(element, buffer_1.Buffer.from(hashes4.string.first));
          }
        };
        InvertibleBloomFilter2.prototype.remove = function(element) {
          var hashes4 = utils_1.allInOneHashTwice(JSON.stringify(element.toJSON()), this.seed);
          var indexes = utils_1.getDistinctIndices(hashes4.string.first, this.size, this._hashCount, this.seed);
          for (var i = 0; i < this._hashCount; ++i) {
            this._elements[indexes[i]] = this._elements[indexes[i]].xorm(new cell_1.default(buffer_1.Buffer.from(element), buffer_1.Buffer.from(hashes4.string.first), 1));
          }
          return true;
        };
        InvertibleBloomFilter2.prototype.has = function(element) {
          var hashes4 = utils_1.allInOneHashTwice(JSON.stringify(element.toJSON()), this.seed);
          var indexes = utils_1.getDistinctIndices(hashes4.string.first, this.size, this._hashCount, this.seed);
          for (var i = 0; i < this._hashCount; ++i) {
            if (this._elements[indexes[i]].count === 0) {
              return false;
            } else if (this._elements[indexes[i]].count === 1) {
              if (this._elements[indexes[i]].idSum.equals(element)) {
                return true;
              } else {
                return false;
              }
            }
          }
          return true;
        };
        InvertibleBloomFilter2.prototype.listEntries = function() {
          var that = this;
          var seenBefore = [];
          return function() {
            var _loop_1, index2, state_1;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  _loop_1 = function(index3) {
                    var localCell;
                    return __generator(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          localCell = that._elements[index3];
                          if (!(localCell.count > 0 && seenBefore.findIndex(function(b) {
                            return b.equals(localCell.idSum);
                          }) === -1))
                            return [3, 3];
                          if (!that.has(localCell.idSum))
                            return [3, 2];
                          seenBefore.push(localCell.idSum);
                          return [4, localCell.idSum];
                        case 1:
                          _a3.sent();
                          return [3, 3];
                        case 2:
                          return [2, { value: false }];
                        case 3:
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  };
                  index2 = 0;
                  _a2.label = 1;
                case 1:
                  if (!(index2 < that._elements.length - 1))
                    return [3, 4];
                  return [5, _loop_1(index2)];
                case 2:
                  state_1 = _a2.sent();
                  if (typeof state_1 === "object")
                    return [2, state_1.value];
                  _a2.label = 3;
                case 3:
                  index2++;
                  return [3, 1];
                case 4:
                  return [2, true];
              }
            });
          }();
        };
        InvertibleBloomFilter2.prototype.substract = function(iblt) {
          if (this.size !== iblt.size) {
            throw new Error("The two Invertible Bloom Filters must be of the same size");
          }
          var res = new InvertibleBloomFilter_1(iblt._size, iblt._hashCount);
          res.seed = this.seed;
          for (var i = 0; i < this.size; ++i) {
            res._elements[i] = this._elements[i].xorm(iblt._elements[i]);
          }
          return res;
        };
        InvertibleBloomFilter2.prototype.equals = function(iblt) {
          if (iblt._size !== this._size || iblt._hashCount !== this._hashCount || iblt.seed !== this.seed) {
            return false;
          } else {
            for (var i = 0; i < iblt._elements.length; ++i) {
              if (!iblt._elements[i].equals(this._elements[i])) {
                return false;
              }
            }
            return true;
          }
        };
        InvertibleBloomFilter2.prototype.decode = function(additional, missing) {
          if (additional === void 0) {
            additional = [];
          }
          if (missing === void 0) {
            missing = [];
          }
          var pureList = [];
          var cell = null;
          for (var i = 0; i < this._elements.length; ++i) {
            cell = this._elements[i];
            if (cell.isPure()) {
              pureList.push(i);
            }
          }
          while (pureList.length !== 0) {
            cell = this._elements[pureList.pop()];
            var id = cell.idSum;
            var c = cell.count;
            if (cell.isPure()) {
              if (c === 1) {
                additional.push(id);
              } else if (c === -1) {
                missing.push(id);
              } else {
                throw new Error("Please report, not possible");
              }
              var hashes4 = utils_1.allInOneHashTwice(JSON.stringify(id.toJSON()), this.seed);
              var indexes = utils_1.getDistinctIndices(hashes4.string.first, this._size, this._hashCount, this.seed);
              for (var i = 0; i < indexes.length; ++i) {
                this._elements[indexes[i]] = this._elements[indexes[i]].xorm(new cell_1.default(id, buffer_1.Buffer.from(hashes4.string.first), c));
                if (this._elements[indexes[i]].isPure()) {
                  pureList.push(indexes[i]);
                }
              }
            }
          }
          if (this._elements.findIndex(function(e) {
            return !e.isEmpty();
          }) > -1) {
            return {
              success: false,
              reason: {
                cell,
                iblt: this
              },
              additional,
              missing
            };
          } else {
            return {
              success: true,
              additional,
              missing
            };
          }
        };
        var InvertibleBloomFilter_1;
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], InvertibleBloomFilter2.prototype, "_size", void 0);
        __decorate([
          exportable_1.Field(),
          __metadata("design:type", Number)
        ], InvertibleBloomFilter2.prototype, "_hashCount", void 0);
        __decorate([
          exportable_1.Field(void 0, function(json) {
            return json.map(function(elt) {
              var c = new cell_1.default(buffer_1.Buffer.from(elt._idSum), buffer_1.Buffer.from(elt._hashSum), elt._count);
              c.seed = elt._seed;
              return c;
            });
          }),
          __metadata("design:type", Array)
        ], InvertibleBloomFilter2.prototype, "_elements", void 0);
        InvertibleBloomFilter2 = InvertibleBloomFilter_1 = __decorate([
          exportable_1.AutoExportable("InvertibleBloomFilter", ["_seed"]),
          __param(0, exportable_1.Parameter("_size")),
          __param(1, exportable_1.Parameter("_hashCount")),
          __metadata("design:paramtypes", [Number, Number])
        ], InvertibleBloomFilter2);
        return InvertibleBloomFilter2;
      }(base_filter_1.default)
    );
    exports2.default = InvertibleBloomFilter;
  }
});

// node_modules/fission-bloom-filters/dist/api.js
var require_api = __commonJS({
  "node_modules/fission-bloom-filters/dist/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bloom_filter_1 = require_bloom_filter();
    exports2.BloomFilter = bloom_filter_1.default;
    var counting_bloom_filter_1 = require_counting_bloom_filter();
    exports2.CountingBloomFilter = counting_bloom_filter_1.default;
    var partitioned_bloom_filter_1 = require_partitioned_bloom_filter();
    exports2.PartitionedBloomFilter = partitioned_bloom_filter_1.default;
    var count_min_sketch_1 = require_count_min_sketch();
    exports2.CountMinSketch = count_min_sketch_1.default;
    var hyperloglog_1 = require_hyperloglog();
    exports2.HyperLogLog = hyperloglog_1.default;
    var topk_1 = require_topk();
    exports2.TopK = topk_1.default;
    var min_hash_1 = require_min_hash();
    exports2.MinHash = min_hash_1.MinHash;
    var min_hash_factory_1 = require_min_hash_factory();
    exports2.MinHashFactory = min_hash_factory_1.default;
    var cuckoo_filter_1 = require_cuckoo_filter();
    exports2.CuckooFilter = cuckoo_filter_1.default;
    var invertible_bloom_lookup_tables_1 = require_invertible_bloom_lookup_tables();
    exports2.InvertibleBloomFilter = invertible_bloom_lookup_tables_1.default;
    var cell_1 = require_cell();
    exports2.Cell = cell_1.default;
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl) {
      "use strict";
      var gf = function(init2) {
        var i, r = new Float64Array(16);
        if (init2)
          for (i = 0; i < init2.length; i++)
            r[i] = init2[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes2) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes2 >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes2) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes2)
            want = bytes2;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes2 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (i = 0; i < bytes2; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes2;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto3 && crypto3.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto3.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto3 = require_crypto();
          if (crypto3 && crypto3.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto3.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode26;
    var MSB7 = 128;
    var REST7 = 127;
    var MSBALL7 = ~REST7;
    var INT7 = Math.pow(2, 31);
    function encode26(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode26.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT7) {
        out[offset++] = num & 255 | MSB7;
        num /= 128;
      }
      while (num & MSBALL7) {
        out[offset++] = num & 255 | MSB7;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode26.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read7;
    var MSB7 = 128;
    var REST7 = 127;
    function read7(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read7.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST7) << shift : (b & REST7) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB7);
      read7.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    var N17 = Math.pow(2, 7);
    var N27 = Math.pow(2, 14);
    var N37 = Math.pow(2, 21);
    var N47 = Math.pow(2, 28);
    var N57 = Math.pow(2, 35);
    var N67 = Math.pow(2, 42);
    var N77 = Math.pow(2, 49);
    var N87 = Math.pow(2, 56);
    var N97 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N17 ? 1 : value < N27 ? 2 : value < N37 ? 3 : value < N47 ? 4 : value < N57 ? 5 : value < N67 ? 6 : value < N77 ? 7 : value < N87 ? 8 : value < N97 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code11, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code11 === "object") {
        props = code11;
        code11 = "";
      }
      if (code11) {
        props.code = code11;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name8) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name8 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce8;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace2) {
        let hash3 = 0;
        for (let i = 0; i < namespace2.length; i++) {
          hash3 = (hash3 << 5) - hash3 + namespace2.charCodeAt(i);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace2) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug11(...args) {
          if (!debug11.enabled) {
            return;
          }
          const self2 = debug11;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format6) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format6];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug11.namespace = namespace2;
        debug11.useColors = createDebug.useColors();
        debug11.color = createDebug.selectColor(namespace2);
        debug11.extend = extend;
        debug11.destroy = createDebug.destroy;
        Object.defineProperty(debug11, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace2);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug11);
        }
        return debug11;
      }
      function extend(namespace2, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name8) {
        if (name8[name8.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name8)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name8)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce8(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
      while (index2 < arguments.length)
        params[offset++] = arguments[index2++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base644 = exports2;
    base644.length = function length8(string2) {
      var p = string2.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string2.charAt(p) === "=")
        ++n;
      return Math.ceil(string2.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base644.encode = function encode26(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base644.decode = function decode33(string2, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string2.length; ) {
        var c = string2.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base644.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter3;
    function EventEmitter3() {
      this._listeners = {};
    }
    EventEmitter3.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter3.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter3.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[3];
            buf2[pos + 1] = f8b[2];
            buf2[pos + 2] = f8b[1];
            buf2[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf2, pos) {
            f8b[3] = buf2[pos];
            f8b[2] = buf2[pos + 1];
            f8b[1] = buf2[pos + 2];
            f8b[0] = buf2[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf2, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf2, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign2 << 31 | 2139095040) >>> 0, buf2, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf2, pos) {
            var uint = readUint(buf2, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
            buf2[pos + 4] = f8b[4];
            buf2[pos + 5] = f8b[5];
            buf2[pos + 6] = f8b[6];
            buf2[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[7];
            buf2[pos + 1] = f8b[6];
            buf2[pos + 2] = f8b[5];
            buf2[pos + 3] = f8b[4];
            buf2[pos + 4] = f8b[3];
            buf2[pos + 5] = f8b[2];
            buf2[pos + 6] = f8b[1];
            buf2[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            f8b[4] = buf2[pos + 4];
            f8b[5] = buf2[pos + 5];
            f8b[6] = buf2[pos + 6];
            f8b[7] = buf2[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf2, pos) {
            f8b[7] = buf2[pos];
            f8b[6] = buf2[pos + 1];
            f8b[5] = buf2[pos + 2];
            f8b[4] = buf2[pos + 3];
            f8b[3] = buf2[pos + 4];
            f8b[2] = buf2[pos + 5];
            f8b[1] = buf2[pos + 6];
            f8b[0] = buf2[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0) {
              writeUint(0, buf2, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf2, pos + off0);
              writeUint(2146959360, buf2, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf2, pos + off0);
              writeUint((sign2 << 31 | 2146435072) >>> 0, buf2, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf2, pos + off0);
                writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
            var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
            var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c = 0;
      for (var i = 0; i < string2.length; ++i) {
        c = string2.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string2, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string2.length; ++i) {
        c1 = string2.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc2, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from12(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash3) {
      if (hash3 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
        (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash2() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length8() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash3, unsigned) {
      var bits = util.LongBits.fromHash(hash3);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge4(dst, src7, ifNotSet) {
      for (var keys = Object.keys(src7), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src7[keys[i]];
      return dst;
    }
    util.merge = merge4;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name8) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge4(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get5() {
            return name8;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name8) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name8)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base644 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create14 = function create15() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create14();
    Writer.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i = 0; i < val.length; ++i)
        buf2[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf2 = Writer.alloc(len = base644.length(value));
        base644.decode(value, buf2, 0);
        value = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create14();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf2[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create14 = function create15() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create14();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length8 = this.uint32(), start = this.pos, end = this.pos + length8;
      if (end > this.len)
        throw indexOutOfRange(this, length8);
      this.pos += length8;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip(length8) {
      if (typeof length8 === "number") {
        if (this.pos + length8 > this.len)
          throw indexOutOfRange(this, length8);
        this.pos += length8;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create14();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/fnv1a/index.js
var require_fnv1a = __commonJS({
  "node_modules/fnv1a/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    hash3.BASE = 2166136261;
    function hash3(s, h = hash3.BASE) {
      const l = s.length;
      for (let i = 0; i < l; i++) {
        h ^= s.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0;
    }
    exports2.default = hash3;
    module2.exports = hash3;
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format6;
    module2.exports.parse = parse;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map2 = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse(value);
      }
      if (typeof value === "number") {
        return format6(value, options);
      }
      return null;
    }
    function format6(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map2[unit.toLowerCase()]) {
        if (mag >= map2.pb) {
          unit = "PB";
        } else if (mag >= map2.tb) {
          unit = "TB";
        } else if (mag >= map2.gb) {
          unit = "GB";
        } else if (mag >= map2.mb) {
          unit = "MB";
        } else if (mag >= map2.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map2[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map2[unit] * floatValue);
    }
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name8, value) => Object.defineProperty(object, name8, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol3 of symbols) {
          if (propertyIsEnumerable.call(value, symbol3)) {
            keys.push(symbol3);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config2) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge4(merged[key], source[key], config2));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config2) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
      });
      return result;
    };
    function merge4(merged, source, config2) {
      if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config2);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
    }
    module2.exports = function(...options) {
      const config2 = merge4(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge4(merged, { _: option }, config2);
      }
      return merged._;
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names2 = [], events2, name8;
      if (this._eventsCount === 0)
        return names2;
      for (name8 in events2 = this._events) {
        if (has.call(events2, name8))
          names2.push(prefix ? name8.slice(1) : name8);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events2));
      }
      return names2;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length8 = listeners.length, j;
        for (i = 0; i < length8; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length8 = listeners.length; i < length8; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter3;
    }
  }
});

// node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "node_modules/it-drain/index.js"(exports2, module2) {
    "use strict";
    var drain5 = async (source) => {
      for await (const _ of source) {
      }
    };
    module2.exports = drain5;
  }
});

// node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "node_modules/it-filter/index.js"(exports2, module2) {
    "use strict";
    var filter5 = async function* (source, fn) {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    };
    module2.exports = filter5;
  }
});

// node_modules/it-take/index.js
var require_it_take = __commonJS({
  "node_modules/it-take/index.js"(exports2, module2) {
    "use strict";
    var take4 = async function* (source, limit) {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    };
    module2.exports = take4;
  }
});

// node_modules/it-all/index.js
var require_it_all = __commonJS({
  "node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    var all4 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all4;
  }
});

// node_modules/level-supports/index.js
var require_level_supports = __commonJS({
  "node_modules/level-supports/index.js"(exports2) {
    "use strict";
    exports2.supports = function supports(...manifests) {
      const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
      return Object.assign(manifest, {
        snapshots: manifest.snapshots || false,
        permanence: manifest.permanence || false,
        seek: manifest.seek || false,
        clear: manifest.clear || false,
        getMany: manifest.getMany || false,
        keyIterator: manifest.keyIterator || false,
        valueIterator: manifest.valueIterator || false,
        iteratorNextv: manifest.iteratorNextv || false,
        iteratorAll: manifest.iteratorAll || false,
        status: manifest.status || false,
        createIfMissing: manifest.createIfMissing || false,
        errorIfExists: manifest.errorIfExists || false,
        deferredOpen: manifest.deferredOpen || false,
        promises: manifest.promises || false,
        streams: manifest.streams || false,
        encodings: Object.assign({}, manifest.encodings),
        events: Object.assign({}, manifest.events),
        additionalMethods: Object.assign({}, manifest.additionalMethods)
      });
    };
  }
});

// node_modules/module-error/index.js
var require_module_error = __commonJS({
  "node_modules/module-error/index.js"(exports2, module2) {
    "use strict";
    module2.exports = class ModuleError extends Error {
      /**
       * @param {string} message Error message
       * @param {{ code?: string, cause?: Error, expected?: boolean, transient?: boolean }} [options]
       */
      constructor(message, options) {
        super(message || "");
        if (typeof options === "object" && options !== null) {
          if (options.code)
            this.code = String(options.code);
          if (options.expected)
            this.expected = true;
          if (options.transient)
            this.transient = true;
          if (options.cause)
            this.cause = options.cause;
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
  }
});

// node_modules/level-transcoder/lib/text-endec.js
var require_text_endec = __commonJS({
  "node_modules/level-transcoder/lib/text-endec.js"(exports2, module2) {
    "use strict";
    var lazy = null;
    module2.exports = function() {
      if (lazy === null) {
        lazy = {
          textEncoder: new TextEncoder(),
          textDecoder: new TextDecoder()
        };
      }
      return lazy;
    };
  }
});

// node_modules/level-transcoder/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/level-transcoder/lib/encoding.js"(exports2) {
    "use strict";
    var ModuleError = require_module_error();
    var formats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Encoding = class {
      /**
       * @param {IEncoding<TIn,TFormat,TOut>} options
       */
      constructor(options) {
        this.encode = options.encode || this.encode;
        this.decode = options.decode || this.decode;
        this.name = options.name || this.name;
        this.format = options.format || this.format;
        if (typeof this.encode !== "function") {
          throw new TypeError("The 'encode' property must be a function");
        }
        if (typeof this.decode !== "function") {
          throw new TypeError("The 'decode' property must be a function");
        }
        this.encode = this.encode.bind(this);
        this.decode = this.decode.bind(this);
        if (typeof this.name !== "string" || this.name === "") {
          throw new TypeError("The 'name' property must be a string");
        }
        if (typeof this.format !== "string" || !formats.has(this.format)) {
          throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
        }
        if (options.createViewTranscoder) {
          this.createViewTranscoder = options.createViewTranscoder;
        }
        if (options.createBufferTranscoder) {
          this.createBufferTranscoder = options.createBufferTranscoder;
        }
        if (options.createUTF8Transcoder) {
          this.createUTF8Transcoder = options.createUTF8Transcoder;
        }
      }
      get commonName() {
        return (
          /** @type {string} */
          this.name.split("+")[0]
        );
      }
      /** @return {BufferFormat<TIn,TOut>} */
      createBufferTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      /** @return {ViewFormat<TIn,TOut>} */
      createViewTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      /** @return {UTF8Format<TIn,TOut>} */
      createUTF8Transcoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
    };
    exports2.Encoding = Encoding;
  }
});

// node_modules/level-transcoder/lib/formats.js
var require_formats = __commonJS({
  "node_modules/level-transcoder/lib/formats.js"(exports2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer() || {};
    var { Encoding } = require_encoding();
    var textEndec = require_text_endec();
    var BufferFormat = class extends Encoding {
      /**
       * @param {Omit<IEncoding<TIn, Buffer, TOut>, 'format'>} options
       */
      constructor(options) {
        super({ ...options, format: "buffer" });
      }
      /** @override */
      createViewTranscoder() {
        return new ViewFormat({
          encode: this.encode,
          // Buffer is a view (UInt8Array)
          decode: (data) => this.decode(
            Buffer2.from(data.buffer, data.byteOffset, data.byteLength)
          ),
          name: `${this.name}+view`
        });
      }
      /** @override */
      createBufferTranscoder() {
        return this;
      }
    };
    var ViewFormat = class extends Encoding {
      /**
       * @param {Omit<IEncoding<TIn, Uint8Array, TOut>, 'format'>} options
       */
      constructor(options) {
        super({ ...options, format: "view" });
      }
      /** @override */
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => {
            const view = this.encode(data);
            return Buffer2.from(view.buffer, view.byteOffset, view.byteLength);
          },
          decode: this.decode,
          // Buffer is a view (UInt8Array)
          name: `${this.name}+buffer`
        });
      }
      /** @override */
      createViewTranscoder() {
        return this;
      }
    };
    var UTF8Format = class extends Encoding {
      /**
       * @param {Omit<IEncoding<TIn, string, TOut>, 'format'>} options
       */
      constructor(options) {
        super({ ...options, format: "utf8" });
      }
      /** @override */
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => Buffer2.from(this.encode(data), "utf8"),
          decode: (data) => this.decode(data.toString("utf8")),
          name: `${this.name}+buffer`
        });
      }
      /** @override */
      createViewTranscoder() {
        const { textEncoder: textEncoder7, textDecoder: textDecoder6 } = textEndec();
        return new ViewFormat({
          encode: (data) => textEncoder7.encode(this.encode(data)),
          decode: (data) => this.decode(textDecoder6.decode(data)),
          name: `${this.name}+view`
        });
      }
      /** @override */
      createUTF8Transcoder() {
        return this;
      }
    };
    exports2.BufferFormat = BufferFormat;
    exports2.ViewFormat = ViewFormat;
    exports2.UTF8Format = UTF8Format;
  }
});

// node_modules/level-transcoder/lib/encodings.js
var require_encodings = __commonJS({
  "node_modules/level-transcoder/lib/encodings.js"(exports2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer() || { Buffer: { isBuffer: () => false } };
    var { textEncoder: textEncoder7, textDecoder: textDecoder6 } = require_text_endec()();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var identity8 = (v) => v;
    exports2.utf8 = new UTF8Format({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data.toString("utf8") : ArrayBuffer.isView(data) ? textDecoder6.decode(data) : String(data);
      },
      decode: identity8,
      name: "utf8",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : textEncoder7.encode(data);
          },
          decode: function(data) {
            return textDecoder6.decode(data);
          },
          name: `${this.name}+view`
        });
      },
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
          },
          decode: function(data) {
            return data.toString("utf8");
          },
          name: `${this.name}+buffer`
        });
      }
    });
    exports2.json = new UTF8Format({
      encode: JSON.stringify,
      decode: JSON.parse,
      name: "json"
    });
    exports2.buffer = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
      },
      decode: identity8,
      name: "buffer",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : Buffer2.from(String(data), "utf8");
          },
          decode: function(data) {
            return Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
          },
          name: `${this.name}+view`
        });
      }
    });
    exports2.view = new ViewFormat({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : textEncoder7.encode(data);
      },
      decode: identity8,
      name: "view",
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer2.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer2.from(data.buffer, data.byteOffset, data.byteLength) : Buffer2.from(String(data), "utf8");
          },
          decode: identity8,
          name: `${this.name}+buffer`
        });
      }
    });
    exports2.hex = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : Buffer2.from(String(data), "hex");
      },
      decode: function(buffer2) {
        return buffer2.toString("hex");
      },
      name: "hex"
    });
    exports2.base64 = new BufferFormat({
      encode: function(data) {
        return Buffer2.isBuffer(data) ? data : Buffer2.from(String(data), "base64");
      },
      decode: function(buffer2) {
        return buffer2.toString("base64");
      },
      name: "base64"
    });
  }
});

// node_modules/level-transcoder/index.js
var require_level_transcoder = __commonJS({
  "node_modules/level-transcoder/index.js"(exports2) {
    "use strict";
    var ModuleError = require_module_error();
    var encodings = require_encodings();
    var { Encoding } = require_encoding();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var kFormats = Symbol("formats");
    var kEncodings = Symbol("encodings");
    var validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Transcoder = class {
      /**
       * @param {Array<'buffer'|'view'|'utf8'>} formats
       */
      constructor(formats) {
        if (!Array.isArray(formats)) {
          throw new TypeError("The first argument 'formats' must be an array");
        } else if (!formats.every((f) => validFormats.has(f))) {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
        this[kEncodings] = /* @__PURE__ */ new Map();
        this[kFormats] = new Set(formats);
        for (const k in encodings) {
          try {
            this.encoding(k);
          } catch (err) {
            if (err.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
              throw err;
          }
        }
      }
      /**
       * @returns {Array<Encoding<any,T,any>>}
       */
      encodings() {
        return Array.from(new Set(this[kEncodings].values()));
      }
      /**
       * @param {string|MixedEncoding<any, any, any>} encoding
       * @returns {Encoding<any, T, any>}
       */
      encoding(encoding) {
        let resolved = this[kEncodings].get(encoding);
        if (resolved === void 0) {
          if (typeof encoding === "string" && encoding !== "") {
            resolved = lookup2[encoding];
            if (!resolved) {
              throw new ModuleError(`Encoding '${encoding}' is not found`, {
                code: "LEVEL_ENCODING_NOT_FOUND"
              });
            }
          } else if (typeof encoding !== "object" || encoding === null) {
            throw new TypeError("First argument 'encoding' must be a string or object");
          } else {
            resolved = from12(encoding);
          }
          const { name: name8, format: format6 } = resolved;
          if (!this[kFormats].has(format6)) {
            if (this[kFormats].has("view")) {
              resolved = resolved.createViewTranscoder();
            } else if (this[kFormats].has("buffer")) {
              resolved = resolved.createBufferTranscoder();
            } else if (this[kFormats].has("utf8")) {
              resolved = resolved.createUTF8Transcoder();
            } else {
              throw new ModuleError(`Encoding '${name8}' cannot be transcoded`, {
                code: "LEVEL_ENCODING_NOT_SUPPORTED"
              });
            }
          }
          for (const k of [encoding, name8, resolved.name, resolved.commonName]) {
            this[kEncodings].set(k, resolved);
          }
        }
        return resolved;
      }
    };
    exports2.Transcoder = Transcoder;
    function from12(options) {
      if (options instanceof Encoding) {
        return options;
      }
      const maybeType = "type" in options && typeof options.type === "string" ? options.type : void 0;
      const name8 = options.name || maybeType || `anonymous-${anonymousCount++}`;
      switch (detectFormat(options)) {
        case "view":
          return new ViewFormat({ ...options, name: name8 });
        case "utf8":
          return new UTF8Format({ ...options, name: name8 });
        case "buffer":
          return new BufferFormat({ ...options, name: name8 });
        default: {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
      }
    }
    function detectFormat(options) {
      if ("format" in options && options.format !== void 0) {
        return options.format;
      } else if ("buffer" in options && typeof options.buffer === "boolean") {
        return options.buffer ? "buffer" : "utf8";
      } else if ("code" in options && Number.isInteger(options.code)) {
        return "view";
      } else {
        return "buffer";
      }
    }
    var aliases = {
      binary: encodings.buffer,
      "utf-8": encodings.utf8
    };
    var lookup2 = {
      ...encodings,
      ...aliases
    };
    var anonymousCount = 0;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module2.exports = EventEmitter3;
    module2.exports.once = once;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap4) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap4 ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap4 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name8) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name8, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name8, resolver, { once: true });
        if (name8 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name8, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name8, listener);
        } else {
          emitter.on(name8, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name8, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name8, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/catering/next-tick-browser.js
var require_next_tick_browser = __commonJS({
  "node_modules/catering/next-tick-browser.js"(exports2, module2) {
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});

// node_modules/catering/index.js
var require_catering = __commonJS({
  "node_modules/catering/index.js"(exports2) {
    "use strict";
    var nextTick = require_next_tick_browser();
    exports2.fromCallback = function(callback, symbol3) {
      if (callback === void 0) {
        var promise = new Promise(function(resolve, reject) {
          callback = function(err, res) {
            if (err)
              reject(err);
            else
              resolve(res);
          };
        });
        callback[symbol3 !== void 0 ? symbol3 : "promise"] = promise;
      } else if (typeof callback !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return callback;
    };
    exports2.fromPromise = function(promise, callback) {
      if (callback === void 0)
        return promise;
      promise.then(function(res) {
        nextTick(() => callback(null, res));
      }).catch(function(err) {
        nextTick(() => callback(err));
      });
    };
  }
});

// node_modules/abstract-level/lib/common.js
var require_common2 = __commonJS({
  "node_modules/abstract-level/lib/common.js"(exports2) {
    "use strict";
    exports2.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports2.getOptions = function(options, def) {
      if (typeof options === "object" && options !== null) {
        return options;
      }
      if (def !== void 0) {
        return def;
      }
      return {};
    };
  }
});

// node_modules/abstract-level/abstract-iterator.js
var require_abstract_iterator = __commonJS({
  "node_modules/abstract-level/abstract-iterator.js"(exports2) {
    "use strict";
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getOptions, getCallback } = require_common2();
    var kPromise = Symbol("promise");
    var kCallback = Symbol("callback");
    var kWorking = Symbol("working");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kAutoClose = Symbol("autoClose");
    var kFinishWork = Symbol("finishWork");
    var kReturnMany = Symbol("returnMany");
    var kClosing = Symbol("closing");
    var kHandleClose = Symbol("handleClose");
    var kClosed = Symbol("closed");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var kAbortOnClose = Symbol("abortOnClose");
    var kLegacy = Symbol("legacy");
    var kKeys = Symbol("keys");
    var kValues = Symbol("values");
    var kLimit = Symbol("limit");
    var kCount = Symbol("count");
    var emptyOptions = Object.freeze({});
    var noop = () => {
    };
    var warnedEnd = false;
    var CommonIterator = class {
      constructor(db, options, legacy) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        if (typeof options !== "object" || options === null) {
          throw new TypeError("The second argument must be an options object");
        }
        this[kClosed] = false;
        this[kCloseCallbacks] = [];
        this[kWorking] = false;
        this[kClosing] = false;
        this[kAutoClose] = false;
        this[kCallback] = null;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kHandleClose] = this[kHandleClose].bind(this);
        this[kKeyEncoding] = options[kKeyEncoding];
        this[kValueEncoding] = options[kValueEncoding];
        this[kLegacy] = legacy;
        this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
        this[kCount] = 0;
        this[kAbortOnClose] = !!options.abortOnClose;
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get count() {
        return this[kCount];
      }
      get limit() {
        return this[kLimit];
      }
      next(callback) {
        let promise;
        if (callback === void 0) {
          promise = new Promise((resolve, reject) => {
            callback = (err, key, value) => {
              if (err)
                reject(err);
              else if (!this[kLegacy])
                resolve(key);
              else if (key === void 0 && value === void 0)
                resolve();
              else
                resolve([key, value]);
            };
          });
        } else if (typeof callback !== "function") {
          throw new TypeError("Callback must be a function");
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call next() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleOne], null);
          else
            this._next(this[kHandleOne]);
        }
        return promise;
      }
      _next(callback) {
        this.nextTick(callback);
      }
      nextv(size, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (!Number.isInteger(size)) {
          this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
          return callback[kPromise];
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call nextv() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          if (size < 1)
            size = 1;
          if (this[kLimit] < Infinity)
            size = Math.min(size, this[kLimit] - this[kCount]);
          this[kWorking] = true;
          this[kCallback] = callback;
          if (size <= 0)
            this.nextTick(this[kHandleMany], null, []);
          else
            this._nextv(size, options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _nextv(size, options, callback) {
        const acc = [];
        const onnext = (err, key, value) => {
          if (err) {
            return callback(err);
          } else if (this[kLegacy] ? key === void 0 && value === void 0 : key === void 0) {
            return callback(null, acc);
          }
          acc.push(this[kLegacy] ? [key, value] : key);
          if (acc.length === size) {
            callback(null, acc);
          } else {
            this._next(onnext);
          }
        };
        this._next(onnext);
      }
      all(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call all() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          this[kAutoClose] = true;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleMany], null, []);
          else
            this._all(options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _all(options, callback) {
        let count = this[kCount];
        const acc = [];
        const nextv = () => {
          const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
          if (size <= 0) {
            this.nextTick(callback, null, acc);
          } else {
            this._nextv(size, emptyOptions, onnextv);
          }
        };
        const onnextv = (err, items) => {
          if (err) {
            callback(err);
          } else if (items.length === 0) {
            callback(null, acc);
          } else {
            acc.push.apply(acc, items);
            count += items.length;
            nextv();
          }
        };
        nextv();
      }
      [kFinishWork]() {
        const cb = this[kCallback];
        if (this[kAbortOnClose] && cb === null)
          return noop;
        this[kWorking] = false;
        this[kCallback] = null;
        if (this[kClosing])
          this._close(this[kHandleClose]);
        return cb;
      }
      [kReturnMany](cb, err, items) {
        if (this[kAutoClose]) {
          this.close(cb.bind(null, err, items));
        } else {
          cb(err, items);
        }
      }
      seek(target, options) {
        options = getOptions(options, emptyOptions);
        if (this[kClosing]) {
        } else if (this[kWorking]) {
          throw new ModuleError("Iterator is busy: cannot call seek() until next() has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          });
        } else {
          const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding]);
          const keyFormat = keyEncoding.format;
          if (options.keyEncoding !== keyFormat) {
            options = { ...options, keyEncoding: keyFormat };
          }
          const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
          this._seek(mapped, options);
        }
      }
      _seek(target, options) {
        throw new ModuleError("Iterator does not support seek()", {
          code: "LEVEL_NOT_SUPPORTED"
        });
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kClosed]) {
          this.nextTick(callback);
        } else if (this[kClosing]) {
          this[kCloseCallbacks].push(callback);
        } else {
          this[kClosing] = true;
          this[kCloseCallbacks].push(callback);
          if (!this[kWorking]) {
            this._close(this[kHandleClose]);
          } else if (this[kAbortOnClose]) {
            const cb = this[kFinishWork]();
            cb(new ModuleError("Aborted on iterator close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kHandleClose]() {
        this[kClosed] = true;
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
      async *[Symbol.asyncIterator]() {
        try {
          let item;
          while ((item = await this.next()) !== void 0) {
            yield item;
          }
        } finally {
          if (!this[kClosed])
            await this.close();
        }
      }
    };
    var AbstractIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, true);
        this[kKeys] = options.keys !== false;
        this[kValues] = options.values !== false;
      }
      [kHandleOne](err, key, value) {
        const cb = this[kFinishWork]();
        if (err)
          return cb(err);
        try {
          key = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          value = this[kValues] && value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
        } catch (err2) {
          return cb(new IteratorDecodeError("entry", err2));
        }
        if (!(key === void 0 && value === void 0)) {
          this[kCount]++;
        }
        cb(null, key, value);
      }
      [kHandleMany](err, entries) {
        const cb = this[kFinishWork]();
        if (err)
          return this[kReturnMany](cb, err);
        try {
          for (const entry of entries) {
            const key = entry[0];
            const value = entry[1];
            entry[0] = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
            entry[1] = this[kValues] && value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
          }
        } catch (err2) {
          return this[kReturnMany](cb, new IteratorDecodeError("entries", err2));
        }
        this[kCount] += entries.length;
        this[kReturnMany](cb, null, entries);
      }
      end(callback) {
        if (!warnedEnd && typeof console !== "undefined") {
          warnedEnd = true;
          console.warn(new ModuleError(
            "The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",
            { code: "LEVEL_LEGACY" }
          ));
        }
        return this.close(callback);
      }
    };
    var AbstractKeyIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err, key) {
        const cb = this[kFinishWork]();
        if (err)
          return cb(err);
        try {
          key = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
        } catch (err2) {
          return cb(new IteratorDecodeError("key", err2));
        }
        if (key !== void 0)
          this[kCount]++;
        cb(null, key);
      }
      [kHandleMany](err, keys) {
        const cb = this[kFinishWork]();
        if (err)
          return this[kReturnMany](cb, err);
        try {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            keys[i] = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          }
        } catch (err2) {
          return this[kReturnMany](cb, new IteratorDecodeError("keys", err2));
        }
        this[kCount] += keys.length;
        this[kReturnMany](cb, null, keys);
      }
    };
    var AbstractValueIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err, value) {
        const cb = this[kFinishWork]();
        if (err)
          return cb(err);
        try {
          value = value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
        } catch (err2) {
          return cb(new IteratorDecodeError("value", err2));
        }
        if (value !== void 0)
          this[kCount]++;
        cb(null, value);
      }
      [kHandleMany](err, values) {
        const cb = this[kFinishWork]();
        if (err)
          return this[kReturnMany](cb, err);
        try {
          for (let i = 0; i < values.length; i++) {
            const value = values[i];
            values[i] = value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
          }
        } catch (err2) {
          return this[kReturnMany](cb, new IteratorDecodeError("values", err2));
        }
        this[kCount] += values.length;
        this[kReturnMany](cb, null, values);
      }
    };
    var IteratorDecodeError = class extends ModuleError {
      constructor(subject, cause) {
        super(`Iterator could not decode ${subject}`, {
          code: "LEVEL_DECODE_ERROR",
          cause
        });
      }
    };
    for (const k of ["_ended property", "_nexting property", "_end method"]) {
      Object.defineProperty(AbstractIterator.prototype, k.split(" ")[0], {
        get() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        },
        set() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        }
      });
    }
    AbstractIterator.keyEncoding = kKeyEncoding;
    AbstractIterator.valueEncoding = kValueEncoding;
    exports2.AbstractIterator = AbstractIterator;
    exports2.AbstractKeyIterator = AbstractKeyIterator;
    exports2.AbstractValueIterator = AbstractValueIterator;
  }
});

// node_modules/abstract-level/lib/default-kv-iterator.js
var require_default_kv_iterator = __commonJS({
  "node_modules/abstract-level/lib/default-kv-iterator.js"(exports2) {
    "use strict";
    var { AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kIterator = Symbol("iterator");
    var kCallback = Symbol("callback");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var DefaultKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: true, values: false });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    var DefaultValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: false, values: true });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    for (const Iterator of [DefaultKeyIterator, DefaultValueIterator]) {
      const keys = Iterator === DefaultKeyIterator;
      const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype[kHandleOne] = function(err, key, value) {
        const callback = this[kCallback];
        if (err)
          callback(err);
        else
          callback(null, keys ? key : value);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
      Iterator.prototype[kHandleMany] = function(err, entries) {
        const callback = this[kCallback];
        if (err)
          callback(err);
        else
          callback(null, entries.map(mapEntry));
      };
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports2.DefaultKeyIterator = DefaultKeyIterator;
    exports2.DefaultValueIterator = DefaultValueIterator;
  }
});

// node_modules/abstract-level/lib/deferred-iterator.js
var require_deferred_iterator = __commonJS({
  "node_modules/abstract-level/lib/deferred-iterator.js"(exports2) {
    "use strict";
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var ModuleError = require_module_error();
    var kNut = Symbol("nut");
    var kUndefer = Symbol("undefer");
    var kFactory = Symbol("factory");
    var DeferredIterator = class extends AbstractIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.iterator(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.keys(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.values(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    for (const Iterator of [DeferredIterator, DeferredKeyIterator, DeferredValueIterator]) {
      Iterator.prototype[kUndefer] = function() {
        if (this.db.status === "open") {
          this[kNut] = this[kFactory]();
        }
      };
      Iterator.prototype._next = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].next(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._next(callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        if (this[kNut] !== null) {
          this[kNut].nextv(size, options, callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._nextv(size, options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._all = function(options, callback) {
        if (this[kNut] !== null) {
          this[kNut].all(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._all(options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._seek = function(target, options) {
        if (this[kNut] !== null) {
          this[kNut]._seek(target, options);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._seek(target, options));
        }
      };
      Iterator.prototype._close = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].close(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._close(callback));
        } else {
          this.nextTick(callback);
        }
      };
    }
    exports2.DeferredIterator = DeferredIterator;
    exports2.DeferredKeyIterator = DeferredKeyIterator;
    exports2.DeferredValueIterator = DeferredValueIterator;
  }
});

// node_modules/abstract-level/abstract-chained-batch.js
var require_abstract_chained_batch = __commonJS({
  "node_modules/abstract-level/abstract-chained-batch.js"(exports2) {
    "use strict";
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getCallback, getOptions } = require_common2();
    var kPromise = Symbol("promise");
    var kStatus = Symbol("status");
    var kOperations = Symbol("operations");
    var kFinishClose = Symbol("finishClose");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var AbstractChainedBatch = class {
      constructor(db) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        this[kOperations] = [];
        this[kCloseCallbacks] = [];
        this[kStatus] = "open";
        this[kFinishClose] = this[kFinishClose].bind(this);
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get length() {
        return this[kOperations].length;
      }
      put(key, value, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call put() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err = this.db._checkKey(key) || this.db._checkValue(value);
        if (err)
          throw err;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const valueEncoding = db.valueEncoding(options && options.valueEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };
        if (db !== this.db) {
          options.sublevel = null;
        }
        const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value);
        this._put(mappedKey, mappedValue, options);
        this[kOperations].push({ ...original, type: "put", key, value });
        return this;
      }
      _put(key, value, options) {
      }
      del(key, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call del() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err = this.db._checkKey(key);
        if (err)
          throw err;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat };
        if (db !== this.db) {
          options.sublevel = null;
        }
        this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
        this[kOperations].push({ ...original, type: "del", key });
        return this;
      }
      _del(key, options) {
      }
      clear() {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call clear() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        this._clear();
        this[kOperations] = [];
        return this;
      }
      _clear() {
      }
      write(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options);
        if (this[kStatus] !== "open") {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        } else if (this.length === 0) {
          this.close(callback);
        } else {
          this[kStatus] = "writing";
          this._write(options, (err) => {
            this[kStatus] = "closing";
            this[kCloseCallbacks].push(() => callback(err));
            if (!err)
              this.db.emit("batch", this[kOperations]);
            this._close(this[kFinishClose]);
          });
        }
        return callback[kPromise];
      }
      _write(options, callback) {
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kStatus] === "closing") {
          this[kCloseCallbacks].push(callback);
        } else if (this[kStatus] === "closed") {
          this.nextTick(callback);
        } else {
          this[kCloseCallbacks].push(callback);
          if (this[kStatus] !== "writing") {
            this[kStatus] = "closing";
            this._close(this[kFinishClose]);
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kFinishClose]() {
        this[kStatus] = "closed";
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
    };
    exports2.AbstractChainedBatch = AbstractChainedBatch;
  }
});

// node_modules/abstract-level/lib/default-chained-batch.js
var require_default_chained_batch = __commonJS({
  "node_modules/abstract-level/lib/default-chained-batch.js"(exports2) {
    "use strict";
    var { AbstractChainedBatch } = require_abstract_chained_batch();
    var ModuleError = require_module_error();
    var kEncoded = Symbol("encoded");
    var DefaultChainedBatch = class extends AbstractChainedBatch {
      constructor(db) {
        super(db);
        this[kEncoded] = [];
      }
      _put(key, value, options) {
        this[kEncoded].push({ ...options, type: "put", key, value });
      }
      _del(key, options) {
        this[kEncoded].push({ ...options, type: "del", key });
      }
      _clear() {
        this[kEncoded] = [];
      }
      // Assumes this[kEncoded] cannot change after write()
      _write(options, callback) {
        if (this.db.status === "opening") {
          this.db.defer(() => this._write(options, callback));
        } else if (this.db.status === "open") {
          if (this[kEncoded].length === 0)
            this.nextTick(callback);
          else
            this.db._batch(this[kEncoded], options, callback);
        } else {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        }
      }
    };
    exports2.DefaultChainedBatch = DefaultChainedBatch;
  }
});

// node_modules/abstract-level/lib/range-options.js
var require_range_options = __commonJS({
  "node_modules/abstract-level/lib/range-options.js"(exports2, module2) {
    "use strict";
    var ModuleError = require_module_error();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var rangeOptions = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
    module2.exports = function(options, keyEncoding) {
      const result = {};
      for (const k in options) {
        if (!hasOwnProperty.call(options, k))
          continue;
        if (k === "keyEncoding" || k === "valueEncoding")
          continue;
        if (k === "start" || k === "end") {
          throw new ModuleError(`The legacy range option '${k}' has been removed`, {
            code: "LEVEL_LEGACY"
          });
        } else if (k === "encoding") {
          throw new ModuleError("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
            code: "LEVEL_LEGACY"
          });
        }
        if (rangeOptions.has(k)) {
          result[k] = keyEncoding.encode(options[k]);
        } else {
          result[k] = options[k];
        }
      }
      result.reverse = !!result.reverse;
      result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
      return result;
    };
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/abstract-level/lib/next-tick-browser.js
var require_next_tick_browser2 = __commonJS({
  "node_modules/abstract-level/lib/next-tick-browser.js"(exports2, module2) {
    "use strict";
    var queueMicrotask2 = require_queue_microtask();
    module2.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});

// node_modules/abstract-level/lib/abstract-sublevel-iterator.js
var require_abstract_sublevel_iterator = __commonJS({
  "node_modules/abstract-level/lib/abstract-sublevel-iterator.js"(exports2) {
    "use strict";
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kUnfix = Symbol("unfix");
    var kIterator = Symbol("iterator");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kCallback = Symbol("callback");
    var AbstractSublevelIterator = class extends AbstractIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err, key, value) {
        const callback = this[kCallback];
        if (err)
          return callback(err);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err, key, value);
      }
      [kHandleMany](err, entries) {
        const callback = this[kCallback];
        if (err)
          return callback(err);
        for (const entry of entries) {
          const key = entry[0];
          if (key !== void 0)
            entry[0] = this[kUnfix](key);
        }
        callback(err, entries);
      }
    };
    var AbstractSublevelKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err, key) {
        const callback = this[kCallback];
        if (err)
          return callback(err);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err, key);
      }
      [kHandleMany](err, keys) {
        const callback = this[kCallback];
        if (err)
          return callback(err);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== void 0)
            keys[i] = this[kUnfix](key);
        }
        callback(err, keys);
      }
    };
    var AbstractSublevelValueIterator = class extends AbstractValueIterator {
      constructor(db, options, iterator) {
        super(db, options);
        this[kIterator] = iterator;
      }
    };
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
    }
    for (const Iterator of [AbstractSublevelValueIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kIterator].next(callback);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kIterator].nextv(size, options, callback);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kIterator].all(options, callback);
      };
    }
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports2.AbstractSublevelIterator = AbstractSublevelIterator;
    exports2.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
    exports2.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
  }
});

// node_modules/abstract-level/lib/abstract-sublevel.js
var require_abstract_sublevel = __commonJS({
  "node_modules/abstract-level/lib/abstract-sublevel.js"(exports2, module2) {
    "use strict";
    var ModuleError = require_module_error();
    var { Buffer: Buffer2 } = require_buffer() || {};
    var {
      AbstractSublevelIterator,
      AbstractSublevelKeyIterator,
      AbstractSublevelValueIterator
    } = require_abstract_sublevel_iterator();
    var kPrefix = Symbol("prefix");
    var kUpperBound = Symbol("upperBound");
    var kPrefixRange = Symbol("prefixRange");
    var kParent = Symbol("parent");
    var kUnfix = Symbol("unfix");
    var textEncoder7 = new TextEncoder();
    var defaults = { separator: "!" };
    module2.exports = function({ AbstractLevel }) {
      class AbstractSublevel extends AbstractLevel {
        static defaults(options) {
          if (typeof options === "string") {
            throw new ModuleError("The subleveldown string shorthand for { separator } has been removed", {
              code: "LEVEL_LEGACY"
            });
          } else if (options && options.open) {
            throw new ModuleError("The subleveldown open option has been removed", {
              code: "LEVEL_LEGACY"
            });
          }
          if (options == null) {
            return defaults;
          } else if (!options.separator) {
            return { ...options, separator: "!" };
          } else {
            return options;
          }
        }
        // TODO: add autoClose option, which if true, does parent.attachResource(this)
        constructor(db, name8, options) {
          const { separator, manifest, ...forward } = AbstractSublevel.defaults(options);
          name8 = trim(name8, separator);
          const reserved = separator.charCodeAt(0) + 1;
          const parent2 = db[kParent] || db;
          if (!textEncoder7.encode(name8).every((x) => x > reserved && x < 127)) {
            throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {
              code: "LEVEL_INVALID_PREFIX"
            });
          }
          super(mergeManifests(parent2, manifest), forward);
          const prefix = (db.prefix || "") + separator + name8 + separator;
          const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
          this[kParent] = parent2;
          this[kPrefix] = new MultiFormat(prefix);
          this[kUpperBound] = new MultiFormat(upperBound);
          this[kUnfix] = new Unfixer();
          this.nextTick = parent2.nextTick;
        }
        prefixKey(key, keyFormat) {
          if (keyFormat === "utf8") {
            return this[kPrefix].utf8 + key;
          } else if (key.byteLength === 0) {
            return this[kPrefix][keyFormat];
          } else if (keyFormat === "view") {
            const view = this[kPrefix].view;
            const result = new Uint8Array(view.byteLength + key.byteLength);
            result.set(view, 0);
            result.set(key, view.byteLength);
            return result;
          } else {
            const buffer2 = this[kPrefix].buffer;
            return Buffer2.concat([buffer2, key], buffer2.byteLength + key.byteLength);
          }
        }
        // Not exposed for now.
        [kPrefixRange](range, keyFormat) {
          if (range.gte !== void 0) {
            range.gte = this.prefixKey(range.gte, keyFormat);
          } else if (range.gt !== void 0) {
            range.gt = this.prefixKey(range.gt, keyFormat);
          } else {
            range.gte = this[kPrefix][keyFormat];
          }
          if (range.lte !== void 0) {
            range.lte = this.prefixKey(range.lte, keyFormat);
          } else if (range.lt !== void 0) {
            range.lt = this.prefixKey(range.lt, keyFormat);
          } else {
            range.lte = this[kUpperBound][keyFormat];
          }
        }
        get prefix() {
          return this[kPrefix].utf8;
        }
        get db() {
          return this[kParent];
        }
        _open(options, callback) {
          this[kParent].open({ passive: true }, callback);
        }
        _put(key, value, options, callback) {
          this[kParent].put(key, value, options, callback);
        }
        _get(key, options, callback) {
          this[kParent].get(key, options, callback);
        }
        _getMany(keys, options, callback) {
          this[kParent].getMany(keys, options, callback);
        }
        _del(key, options, callback) {
          this[kParent].del(key, options, callback);
        }
        _batch(operations, options, callback) {
          this[kParent].batch(operations, options, callback);
        }
        _clear(options, callback) {
          this[kPrefixRange](options, options.keyEncoding);
          this[kParent].clear(options, callback);
        }
        _iterator(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].iterator(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelIterator(this, options, iterator, unfix);
        }
        _keys(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].keys(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelKeyIterator(this, options, iterator, unfix);
        }
        _values(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].values(options);
          return new AbstractSublevelValueIterator(this, options, iterator);
        }
      }
      return { AbstractSublevel };
    };
    var mergeManifests = function(parent2, manifest) {
      return {
        // Inherit manifest of parent db
        ...parent2.supports,
        // Disable unsupported features
        createIfMissing: false,
        errorIfExists: false,
        // Unset additional events because we're not forwarding them
        events: {},
        // Unset additional methods (like approximateSize) which we can't support here unless
        // the AbstractSublevel class is overridden by an implementation of `abstract-level`.
        additionalMethods: {},
        // Inherit manifest of custom AbstractSublevel subclass. Such a class is not
        // allowed to override encodings.
        ...manifest,
        encodings: {
          utf8: supportsEncoding(parent2, "utf8"),
          buffer: supportsEncoding(parent2, "buffer"),
          view: supportsEncoding(parent2, "view")
        }
      };
    };
    var supportsEncoding = function(parent2, encoding) {
      return parent2.supports.encodings[encoding] ? parent2.keyEncoding(encoding).name === encoding : false;
    };
    var MultiFormat = class {
      constructor(key) {
        this.utf8 = key;
        this.view = textEncoder7.encode(key);
        this.buffer = Buffer2 ? Buffer2.from(this.view.buffer, 0, this.view.byteLength) : {};
      }
    };
    var Unfixer = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      get(prefixLength, keyFormat) {
        let unfix = this.cache.get(keyFormat);
        if (unfix === void 0) {
          if (keyFormat === "view") {
            unfix = function(prefixLength2, key) {
              return key.subarray(prefixLength2);
            }.bind(null, prefixLength);
          } else {
            unfix = function(prefixLength2, key) {
              return key.slice(prefixLength2);
            }.bind(null, prefixLength);
          }
          this.cache.set(keyFormat, unfix);
        }
        return unfix;
      }
    };
    var trim = function(str, char) {
      let start = 0;
      let end = str.length;
      while (start < end && str[start] === char)
        start++;
      while (end > start && str[end - 1] === char)
        end--;
      return str.slice(start, end);
    };
  }
});

// node_modules/abstract-level/abstract-level.js
var require_abstract_level = __commonJS({
  "node_modules/abstract-level/abstract-level.js"(exports2) {
    "use strict";
    var { supports } = require_level_supports();
    var { Transcoder } = require_level_transcoder();
    var { EventEmitter: EventEmitter3 } = require_events();
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { AbstractIterator } = require_abstract_iterator();
    var { DefaultKeyIterator, DefaultValueIterator } = require_default_kv_iterator();
    var { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require_deferred_iterator();
    var { DefaultChainedBatch } = require_default_chained_batch();
    var { getCallback, getOptions } = require_common2();
    var rangeOptions = require_range_options();
    var kPromise = Symbol("promise");
    var kLanded = Symbol("landed");
    var kResources = Symbol("resources");
    var kCloseResources = Symbol("closeResources");
    var kOperations = Symbol("operations");
    var kUndefer = Symbol("undefer");
    var kDeferOpen = Symbol("deferOpen");
    var kOptions = Symbol("options");
    var kStatus = Symbol("status");
    var kDefaultOptions = Symbol("defaultOptions");
    var kTranscoder = Symbol("transcoder");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var noop = () => {
    };
    var AbstractLevel = class extends EventEmitter3 {
      constructor(manifest, options) {
        super();
        if (typeof manifest !== "object" || manifest === null) {
          throw new TypeError("The first argument 'manifest' must be an object");
        }
        options = getOptions(options);
        const { keyEncoding, valueEncoding, passive, ...forward } = options;
        this[kResources] = /* @__PURE__ */ new Set();
        this[kOperations] = [];
        this[kDeferOpen] = true;
        this[kOptions] = forward;
        this[kStatus] = "opening";
        this.supports = supports(manifest, {
          status: true,
          promises: true,
          clear: true,
          getMany: true,
          deferredOpen: true,
          // TODO (next major): add seek
          snapshots: manifest.snapshots !== false,
          permanence: manifest.permanence !== false,
          // TODO: remove from level-supports because it's always supported
          keyIterator: true,
          valueIterator: true,
          iteratorNextv: true,
          iteratorAll: true,
          encodings: manifest.encodings || {},
          events: Object.assign({}, manifest.events, {
            opening: true,
            open: true,
            closing: true,
            closed: true,
            put: true,
            del: true,
            batch: true,
            clear: true
          })
        });
        this[kTranscoder] = new Transcoder(formats(this));
        this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || "utf8");
        this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || "utf8");
        for (const encoding of this[kTranscoder].encodings()) {
          if (!this.supports.encodings[encoding.commonName]) {
            this.supports.encodings[encoding.commonName] = true;
          }
        }
        this[kDefaultOptions] = {
          empty: Object.freeze({}),
          entry: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName,
            valueEncoding: this[kValueEncoding].commonName
          }),
          key: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName
          })
        };
        this.nextTick(() => {
          if (this[kDeferOpen]) {
            this.open({ passive: false }, noop);
          }
        });
      }
      get status() {
        return this[kStatus];
      }
      keyEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);
      }
      valueEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);
      }
      open(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = { ...this[kOptions], ...getOptions(options) };
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        const maybeOpened = (err) => {
          if (this[kStatus] === "closing" || this[kStatus] === "opening") {
            this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened);
          } else if (this[kStatus] !== "open") {
            callback(new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN",
              cause: err
            }));
          } else {
            callback();
          }
        };
        if (options.passive) {
          if (this[kStatus] === "opening") {
            this.once(kLanded, maybeOpened);
          } else {
            this.nextTick(maybeOpened);
          }
        } else if (this[kStatus] === "closed" || this[kDeferOpen]) {
          this[kDeferOpen] = false;
          this[kStatus] = "opening";
          this.emit("opening");
          this._open(options, (err) => {
            if (err) {
              this[kStatus] = "closed";
              this[kCloseResources](() => {
                this.emit(kLanded);
                maybeOpened(err);
              });
              this[kUndefer]();
              return;
            }
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            if (this[kStatus] === "open")
              this.emit("open");
            if (this[kStatus] === "open")
              this.emit("ready");
            maybeOpened();
          });
        } else if (this[kStatus] === "open") {
          this.nextTick(maybeOpened);
        } else {
          this.once(kLanded, () => this.open(options, callback));
        }
        return callback[kPromise];
      }
      _open(options, callback) {
        this.nextTick(callback);
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        const maybeClosed = (err) => {
          if (this[kStatus] === "opening" || this[kStatus] === "closing") {
            this.once(kLanded, err ? maybeClosed(err) : maybeClosed);
          } else if (this[kStatus] !== "closed") {
            callback(new ModuleError("Database is not closed", {
              code: "LEVEL_DATABASE_NOT_CLOSED",
              cause: err
            }));
          } else {
            callback();
          }
        };
        if (this[kStatus] === "open") {
          this[kStatus] = "closing";
          this.emit("closing");
          const cancel = (err) => {
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            maybeClosed(err);
          };
          this[kCloseResources](() => {
            this._close((err) => {
              if (err)
                return cancel(err);
              this[kStatus] = "closed";
              this[kUndefer]();
              this.emit(kLanded);
              if (this[kStatus] === "closed")
                this.emit("closed");
              maybeClosed();
            });
          });
        } else if (this[kStatus] === "closed") {
          this.nextTick(maybeClosed);
        } else {
          this.once(kLanded, () => this.close(callback));
        }
        return callback[kPromise];
      }
      [kCloseResources](callback) {
        if (this[kResources].size === 0) {
          return this.nextTick(callback);
        }
        let pending = this[kResources].size;
        let sync = true;
        const next = () => {
          if (--pending === 0) {
            if (sync)
              this.nextTick(callback);
            else
              callback();
          }
        };
        for (const resource of this[kResources]) {
          resource.close(next);
        }
        sync = false;
        this[kResources].clear();
      }
      _close(callback) {
        this.nextTick(callback);
      }
      get(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.get(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err = this._checkKey(key);
        if (err) {
          this.nextTick(callback, err);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err2, value) => {
          if (err2) {
            if (err2.code === "LEVEL_NOT_FOUND" || err2.notFound || /NotFound/i.test(err2)) {
              if (!err2.code)
                err2.code = "LEVEL_NOT_FOUND";
              if (!err2.notFound)
                err2.notFound = true;
              if (!err2.status)
                err2.status = 404;
            }
            return callback(err2);
          }
          try {
            value = valueEncoding.decode(value);
          } catch (err3) {
            return callback(new ModuleError("Could not decode value", {
              code: "LEVEL_DECODE_ERROR",
              cause: err3
            }));
          }
          callback(null, value);
        });
        return callback[kPromise];
      }
      _get(key, options, callback) {
        this.nextTick(callback, new Error("NotFound"));
      }
      getMany(keys, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.getMany(keys, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(keys)) {
          this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
          return callback[kPromise];
        }
        if (keys.length === 0) {
          this.nextTick(callback, null, []);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKeys = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const err = this._checkKey(key);
          if (err) {
            this.nextTick(callback, err);
            return callback[kPromise];
          }
          mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat);
        }
        this._getMany(mappedKeys, options, (err, values) => {
          if (err)
            return callback(err);
          try {
            for (let i = 0; i < values.length; i++) {
              if (values[i] !== void 0) {
                values[i] = valueEncoding.decode(values[i]);
              }
            }
          } catch (err2) {
            return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {
              code: "LEVEL_DECODE_ERROR",
              cause: err2
            }));
          }
          callback(null, values);
        });
        return callback[kPromise];
      }
      _getMany(keys, options, callback) {
        this.nextTick(callback, null, new Array(keys.length).fill(void 0));
      }
      put(key, value, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.put(key, value, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err = this._checkKey(key) || this._checkValue(value);
        if (err) {
          this.nextTick(callback, err);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value);
        this._put(mappedKey, mappedValue, options, (err2) => {
          if (err2)
            return callback(err2);
          this.emit("put", key, value);
          callback();
        });
        return callback[kPromise];
      }
      _put(key, value, options, callback) {
        this.nextTick(callback);
      }
      del(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].key);
        if (this[kStatus] === "opening") {
          this.defer(() => this.del(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err = this._checkKey(key);
        if (err) {
          this.nextTick(callback, err);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const keyFormat = keyEncoding.format;
        if (options.keyEncoding !== keyFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat });
        }
        this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err2) => {
          if (err2)
            return callback(err2);
          this.emit("del", key);
          callback();
        });
        return callback[kPromise];
      }
      _del(key, options, callback) {
        this.nextTick(callback);
      }
      batch(operations, options, callback) {
        if (!arguments.length) {
          if (this[kStatus] === "opening")
            return new DefaultChainedBatch(this);
          if (this[kStatus] !== "open") {
            throw new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN"
            });
          }
          return this._chainedBatch();
        }
        if (typeof operations === "function")
          callback = operations;
        else
          callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.batch(operations, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(operations)) {
          this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
          return callback[kPromise];
        }
        if (operations.length === 0) {
          this.nextTick(callback);
          return callback[kPromise];
        }
        const mapped = new Array(operations.length);
        const { keyEncoding: ke, valueEncoding: ve, ...forward } = options;
        for (let i = 0; i < operations.length; i++) {
          if (typeof operations[i] !== "object" || operations[i] === null) {
            this.nextTick(callback, new TypeError("A batch operation must be an object"));
            return callback[kPromise];
          }
          const op = Object.assign({}, operations[i]);
          if (op.type !== "put" && op.type !== "del") {
            this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
            return callback[kPromise];
          }
          const err = this._checkKey(op.key);
          if (err) {
            this.nextTick(callback, err);
            return callback[kPromise];
          }
          const db = op.sublevel != null ? op.sublevel : this;
          const keyEncoding = db.keyEncoding(op.keyEncoding || ke);
          const keyFormat = keyEncoding.format;
          op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
          op.keyEncoding = keyFormat;
          if (op.type === "put") {
            const valueErr = this._checkValue(op.value);
            if (valueErr) {
              this.nextTick(callback, valueErr);
              return callback[kPromise];
            }
            const valueEncoding = db.valueEncoding(op.valueEncoding || ve);
            op.value = valueEncoding.encode(op.value);
            op.valueEncoding = valueEncoding.format;
          }
          if (db !== this) {
            op.sublevel = null;
          }
          mapped[i] = op;
        }
        this._batch(mapped, forward, (err) => {
          if (err)
            return callback(err);
          this.emit("batch", operations);
          callback();
        });
        return callback[kPromise];
      }
      _batch(operations, options, callback) {
        this.nextTick(callback);
      }
      sublevel(name8, options) {
        return this._sublevel(name8, AbstractSublevel.defaults(options));
      }
      _sublevel(name8, options) {
        return new AbstractSublevel(this, name8, options);
      }
      prefixKey(key, keyFormat) {
        return key;
      }
      clear(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.clear(options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const original = options;
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keyEncoding = keyEncoding.format;
        if (options.limit === 0) {
          this.nextTick(callback);
        } else {
          this._clear(options, (err) => {
            if (err)
              return callback(err);
            this.emit("clear", original);
            callback();
          });
        }
        return callback[kPromise];
      }
      _clear(options, callback) {
        this.nextTick(callback);
      }
      iterator(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keys = options.keys !== false;
        options.values = options.values !== false;
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._iterator(options);
      }
      _iterator(options) {
        return new AbstractIterator(this, options);
      }
      keys(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredKeyIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._keys(options);
      }
      _keys(options) {
        return new DefaultKeyIterator(this, options);
      }
      values(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredValueIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._values(options);
      }
      _values(options) {
        return new DefaultValueIterator(this, options);
      }
      defer(fn) {
        if (typeof fn !== "function") {
          throw new TypeError("The first argument must be a function");
        }
        this[kOperations].push(fn);
      }
      [kUndefer]() {
        if (this[kOperations].length === 0) {
          return;
        }
        const operations = this[kOperations];
        this[kOperations] = [];
        for (const op of operations) {
          op();
        }
      }
      // TODO: docs and types
      attachResource(resource) {
        if (typeof resource !== "object" || resource === null || typeof resource.close !== "function") {
          throw new TypeError("The first argument must be a resource object");
        }
        this[kResources].add(resource);
      }
      // TODO: docs and types
      detachResource(resource) {
        this[kResources].delete(resource);
      }
      _chainedBatch() {
        return new DefaultChainedBatch(this);
      }
      _checkKey(key) {
        if (key === null || key === void 0) {
          return new ModuleError("Key cannot be null or undefined", {
            code: "LEVEL_INVALID_KEY"
          });
        }
      }
      _checkValue(value) {
        if (value === null || value === void 0) {
          return new ModuleError("Value cannot be null or undefined", {
            code: "LEVEL_INVALID_VALUE"
          });
        }
      }
    };
    AbstractLevel.prototype.nextTick = require_next_tick_browser2();
    var { AbstractSublevel } = require_abstract_sublevel()({ AbstractLevel });
    exports2.AbstractLevel = AbstractLevel;
    exports2.AbstractSublevel = AbstractSublevel;
    var maybeError = function(db, callback) {
      if (db[kStatus] !== "open") {
        db.nextTick(callback, new ModuleError("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN"
        }));
        return true;
      }
      return false;
    };
    var formats = function(db) {
      return Object.keys(db.supports.encodings).filter((k) => !!db.supports.encodings[k]);
    };
  }
});

// node_modules/abstract-level/index.js
var require_abstract_level2 = __commonJS({
  "node_modules/abstract-level/index.js"(exports2) {
    "use strict";
    exports2.AbstractLevel = require_abstract_level().AbstractLevel;
    exports2.AbstractSublevel = require_abstract_level().AbstractSublevel;
    exports2.AbstractIterator = require_abstract_iterator().AbstractIterator;
    exports2.AbstractKeyIterator = require_abstract_iterator().AbstractKeyIterator;
    exports2.AbstractValueIterator = require_abstract_iterator().AbstractValueIterator;
    exports2.AbstractChainedBatch = require_abstract_chained_batch().AbstractChainedBatch;
  }
});

// node_modules/run-parallel-limit/index.js
var require_run_parallel_limit = __commonJS({
  "node_modules/run-parallel-limit/index.js"(exports2, module2) {
    module2.exports = runParallelLimit;
    var queueMicrotask2 = require_queue_microtask();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number")
        throw new Error("second argument must be a Number");
      let results, len, pending, keys, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = len = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (err)
          isErrored = true;
        if (--pending === 0 || err) {
          done(err);
        } else if (!isErrored && next < len) {
          let key;
          if (keys) {
            key = keys[next];
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.some(function(key, i) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      } else {
        tasks.some(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});

// node_modules/browser-level/util/key-range.js
var require_key_range = __commonJS({
  "node_modules/browser-level/util/key-range.js"(exports2, module2) {
    "use strict";
    module2.exports = function createKeyRange(options) {
      const lower = options.gte !== void 0 ? options.gte : options.gt !== void 0 ? options.gt : void 0;
      const upper = options.lte !== void 0 ? options.lte : options.lt !== void 0 ? options.lt : void 0;
      const lowerExclusive = options.gte === void 0;
      const upperExclusive = options.lte === void 0;
      if (lower !== void 0 && upper !== void 0) {
        return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
      } else if (lower !== void 0) {
        return IDBKeyRange.lowerBound(lower, lowerExclusive);
      } else if (upper !== void 0) {
        return IDBKeyRange.upperBound(upper, upperExclusive);
      } else {
        return null;
      }
    };
  }
});

// node_modules/browser-level/util/deserialize.js
var require_deserialize = __commonJS({
  "node_modules/browser-level/util/deserialize.js"(exports2, module2) {
    "use strict";
    var textEncoder7 = new TextEncoder();
    module2.exports = function(data) {
      if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
      } else {
        return textEncoder7.encode(data);
      }
    };
  }
});

// node_modules/browser-level/iterator.js
var require_iterator = __commonJS({
  "node_modules/browser-level/iterator.js"(exports2) {
    "use strict";
    var { AbstractIterator } = require_abstract_level2();
    var createKeyRange = require_key_range();
    var deserialize = require_deserialize();
    var kCache = Symbol("cache");
    var kFinished = Symbol("finished");
    var kOptions = Symbol("options");
    var kCurrentOptions = Symbol("currentOptions");
    var kPosition = Symbol("position");
    var kLocation = Symbol("location");
    var kFirst = Symbol("first");
    var emptyOptions = {};
    var Iterator = class extends AbstractIterator {
      constructor(db, location, options) {
        super(db, options);
        this[kCache] = [];
        this[kFinished] = this.limit === 0;
        this[kOptions] = options;
        this[kCurrentOptions] = { ...options };
        this[kPosition] = void 0;
        this[kLocation] = location;
        this[kFirst] = true;
      }
      // Note: if called by _all() then size can be Infinity. This is an internal
      // detail; by design AbstractIterator.nextv() does not support Infinity.
      _nextv(size, options, callback) {
        this[kFirst] = false;
        if (this[kFinished]) {
          return this.nextTick(callback, null, []);
        } else if (this[kCache].length > 0) {
          size = Math.min(size, this[kCache].length);
          return this.nextTick(callback, null, this[kCache].splice(0, size));
        }
        if (this[kPosition] !== void 0) {
          if (this[kOptions].reverse) {
            this[kCurrentOptions].lt = this[kPosition];
            this[kCurrentOptions].lte = void 0;
          } else {
            this[kCurrentOptions].gt = this[kPosition];
            this[kCurrentOptions].gte = void 0;
          }
        }
        let keyRange;
        try {
          keyRange = createKeyRange(this[kCurrentOptions]);
        } catch (_) {
          this[kFinished] = true;
          return this.nextTick(callback, null, []);
        }
        const transaction = this.db.db.transaction([this[kLocation]], "readonly");
        const store2 = transaction.objectStore(this[kLocation]);
        const entries = [];
        if (!this[kOptions].reverse) {
          let keys;
          let values;
          const complete = () => {
            if (keys === void 0 || values === void 0)
              return;
            const length8 = Math.max(keys.length, values.length);
            if (length8 === 0 || size === Infinity) {
              this[kFinished] = true;
            } else {
              this[kPosition] = keys[length8 - 1];
            }
            entries.length = length8;
            for (let i = 0; i < length8; i++) {
              const key = keys[i];
              const value = values[i];
              entries[i] = [
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value !== void 0 ? deserialize(value) : void 0
              ];
            }
            maybeCommit(transaction);
          };
          if (this[kOptions].keys || size < Infinity) {
            store2.getAllKeys(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              keys = ev.target.result;
              complete();
            };
          } else {
            keys = [];
            this.nextTick(complete);
          }
          if (this[kOptions].values) {
            store2.getAll(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              values = ev.target.result;
              complete();
            };
          } else {
            values = [];
            this.nextTick(complete);
          }
        } else {
          const method = !this[kOptions].values && store2.openKeyCursor ? "openKeyCursor" : "openCursor";
          store2[method](keyRange, "prev").onsuccess = (ev) => {
            const cursor = ev.target.result;
            if (cursor) {
              const { key, value } = cursor;
              this[kPosition] = key;
              entries.push([
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value !== void 0 ? deserialize(value) : void 0
              ]);
              if (entries.length < size) {
                cursor.continue();
              } else {
                maybeCommit(transaction);
              }
            } else {
              this[kFinished] = true;
            }
          };
        }
        transaction.onabort = () => {
          callback(transaction.error || new Error("aborted by user"));
          callback = null;
        };
        transaction.oncomplete = () => {
          callback(null, entries);
          callback = null;
        };
      }
      _next(callback) {
        if (this[kCache].length > 0) {
          const [key, value] = this[kCache].shift();
          this.nextTick(callback, null, key, value);
        } else if (this[kFinished]) {
          this.nextTick(callback);
        } else {
          let size = Math.min(100, this.limit - this.count);
          if (this[kFirst]) {
            this[kFirst] = false;
            size = 1;
          }
          this._nextv(size, emptyOptions, (err, entries) => {
            if (err)
              return callback(err);
            this[kCache] = entries;
            this._next(callback);
          });
        }
      }
      _all(options, callback) {
        this[kFirst] = false;
        const cache6 = this[kCache].splice(0, this[kCache].length);
        const size = this.limit - this.count - cache6.length;
        if (size <= 0) {
          return this.nextTick(callback, null, cache6);
        }
        this._nextv(size, emptyOptions, (err, entries) => {
          if (err)
            return callback(err);
          if (cache6.length > 0)
            entries = cache6.concat(entries);
          callback(null, entries);
        });
      }
      _seek(target, options) {
        this[kFirst] = true;
        this[kCache] = [];
        this[kFinished] = false;
        this[kPosition] = void 0;
        this[kCurrentOptions] = { ...this[kOptions] };
        let keyRange;
        try {
          keyRange = createKeyRange(this[kOptions]);
        } catch (_) {
          this[kFinished] = true;
          return;
        }
        if (keyRange !== null && !keyRange.includes(target)) {
          this[kFinished] = true;
        } else if (this[kOptions].reverse) {
          this[kCurrentOptions].lte = target;
        } else {
          this[kCurrentOptions].gte = target;
        }
      }
    };
    exports2.Iterator = Iterator;
    function maybeCommit(transaction) {
      if (typeof transaction.commit === "function") {
        transaction.commit();
      }
    }
  }
});

// node_modules/browser-level/util/clear.js
var require_clear = __commonJS({
  "node_modules/browser-level/util/clear.js"(exports2, module2) {
    "use strict";
    module2.exports = function clear4(db, location, keyRange, options, callback) {
      if (options.limit === 0)
        return db.nextTick(callback);
      const transaction = db.db.transaction([location], "readwrite");
      const store2 = transaction.objectStore(location);
      let count = 0;
      transaction.oncomplete = function() {
        callback();
      };
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      const method = store2.openKeyCursor ? "openKeyCursor" : "openCursor";
      const direction = options.reverse ? "prev" : "next";
      store2[method](keyRange, direction).onsuccess = function(ev) {
        const cursor = ev.target.result;
        if (cursor) {
          store2.delete(cursor.key).onsuccess = function() {
            if (options.limit <= 0 || ++count < options.limit) {
              cursor.continue();
            }
          };
        }
      };
    };
  }
});

// node_modules/browser-level/index.js
var require_browser_level = __commonJS({
  "node_modules/browser-level/index.js"(exports2) {
    "use strict";
    var { AbstractLevel } = require_abstract_level2();
    var ModuleError = require_module_error();
    var parallel = require_run_parallel_limit();
    var { fromCallback } = require_catering();
    var { Iterator } = require_iterator();
    var deserialize = require_deserialize();
    var clear4 = require_clear();
    var createKeyRange = require_key_range();
    var DEFAULT_PREFIX = "level-js-";
    var kIDB = Symbol("idb");
    var kNamePrefix = Symbol("namePrefix");
    var kLocation = Symbol("location");
    var kVersion = Symbol("version");
    var kStore = Symbol("store");
    var kOnComplete = Symbol("onComplete");
    var kPromise = Symbol("promise");
    var BrowserLevel = class extends AbstractLevel {
      constructor(location, options, _) {
        if (typeof options === "function" || typeof _ === "function") {
          throw new ModuleError("The levelup-style callback argument has been removed", {
            code: "LEVEL_LEGACY"
          });
        }
        const { prefix, version: version3, ...forward } = options || {};
        super({
          encodings: { view: true },
          snapshots: false,
          createIfMissing: false,
          errorIfExists: false,
          seek: true
        }, forward);
        if (typeof location !== "string") {
          throw new Error("constructor requires a location string argument");
        }
        this[kLocation] = location;
        this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
        this[kVersion] = parseInt(version3 || 1, 10);
        this[kIDB] = null;
      }
      get location() {
        return this[kLocation];
      }
      get namePrefix() {
        return this[kNamePrefix];
      }
      get version() {
        return this[kVersion];
      }
      // Exposed for backwards compat and unit tests
      get db() {
        return this[kIDB];
      }
      get type() {
        return "browser-level";
      }
      _open(options, callback) {
        const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
        req.onerror = function() {
          callback(req.error || new Error("unknown error"));
        };
        req.onsuccess = () => {
          this[kIDB] = req.result;
          callback();
        };
        req.onupgradeneeded = (ev) => {
          const db = ev.target.result;
          if (!db.objectStoreNames.contains(this[kLocation])) {
            db.createObjectStore(this[kLocation]);
          }
        };
      }
      [kStore](mode) {
        const transaction = this[kIDB].transaction([this[kLocation]], mode);
        return transaction.objectStore(this[kLocation]);
      }
      [kOnComplete](request2, callback) {
        const transaction = request2.transaction;
        transaction.onabort = function() {
          callback(transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback(null, request2.result);
        };
      }
      _get(key, options, callback) {
        const store2 = this[kStore]("readonly");
        let req;
        try {
          req = store2.get(key);
        } catch (err) {
          return this.nextTick(callback, err);
        }
        this[kOnComplete](req, function(err, value) {
          if (err)
            return callback(err);
          if (value === void 0) {
            return callback(new ModuleError("Entry not found", {
              code: "LEVEL_NOT_FOUND"
            }));
          }
          callback(null, deserialize(value));
        });
      }
      _getMany(keys, options, callback) {
        const store2 = this[kStore]("readonly");
        const tasks = keys.map((key) => (next) => {
          let request2;
          try {
            request2 = store2.get(key);
          } catch (err) {
            return next(err);
          }
          request2.onsuccess = () => {
            const value = request2.result;
            next(null, value === void 0 ? value : deserialize(value));
          };
          request2.onerror = (ev) => {
            ev.stopPropagation();
            next(request2.error);
          };
        });
        parallel(tasks, 16, callback);
      }
      _del(key, options, callback) {
        const store2 = this[kStore]("readwrite");
        let req;
        try {
          req = store2.delete(key);
        } catch (err) {
          return this.nextTick(callback, err);
        }
        this[kOnComplete](req, callback);
      }
      _put(key, value, options, callback) {
        const store2 = this[kStore]("readwrite");
        let req;
        try {
          req = store2.put(value, key);
        } catch (err) {
          return this.nextTick(callback, err);
        }
        this[kOnComplete](req, callback);
      }
      // TODO: implement key and value iterators
      _iterator(options) {
        return new Iterator(this, this[kLocation], options);
      }
      _batch(operations, options, callback) {
        const store2 = this[kStore]("readwrite");
        const transaction = store2.transaction;
        let index2 = 0;
        let error;
        transaction.onabort = function() {
          callback(error || transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback();
        };
        function loop() {
          const op = operations[index2++];
          const key = op.key;
          let req;
          try {
            req = op.type === "del" ? store2.delete(key) : store2.put(op.value, key);
          } catch (err) {
            error = err;
            transaction.abort();
            return;
          }
          if (index2 < operations.length) {
            req.onsuccess = loop;
          } else if (typeof transaction.commit === "function") {
            transaction.commit();
          }
        }
        loop();
      }
      _clear(options, callback) {
        let keyRange;
        let req;
        try {
          keyRange = createKeyRange(options);
        } catch (e) {
          return this.nextTick(callback);
        }
        if (options.limit >= 0) {
          return clear4(this, this[kLocation], keyRange, options, callback);
        }
        try {
          const store2 = this[kStore]("readwrite");
          req = keyRange ? store2.delete(keyRange) : store2.clear();
        } catch (err) {
          return this.nextTick(callback, err);
        }
        this[kOnComplete](req, callback);
      }
      _close(callback) {
        this[kIDB].close();
        this.nextTick(callback);
      }
    };
    BrowserLevel.destroy = function(location, prefix, callback) {
      if (typeof prefix === "function") {
        callback = prefix;
        prefix = DEFAULT_PREFIX;
      }
      callback = fromCallback(callback, kPromise);
      const request2 = indexedDB.deleteDatabase(prefix + location);
      request2.onsuccess = function() {
        callback();
      };
      request2.onerror = function(err) {
        callback(err);
      };
      return callback[kPromise];
    };
    exports2.BrowserLevel = BrowserLevel;
  }
});

// node_modules/level/browser.js
var require_browser2 = __commonJS({
  "node_modules/level/browser.js"(exports2) {
    exports2.Level = require_browser_level().BrowserLevel;
  }
});

// node_modules/@oddjs/odd/lib/index.js
var import_localforage3 = __toESM(require_localforage(), 1);

// node_modules/@oddjs/odd/lib/common/identifiers.js
async function bareNameFilter({ crypto: crypto3, accountDID, path }) {
  return `wnfs:${accountDID}:bareNameFilter:${await pathHash(crypto3, path)}`;
}
async function readKey({ crypto: crypto3, accountDID, path }) {
  return `wnfs:${accountDID}:readKey:${await pathHash(crypto3, path)}`;
}
async function pathHash(crypto3, path) {
  return toString3(await crypto3.hash.sha256(fromString2("/" + unwrap(path).join("/"), "utf8")), "base64pad");
}

// node_modules/@oddjs/odd/lib/permissions.js
var ROOT_FILESYSTEM_PERMISSIONS = {
  fs: {
    private: [root()],
    public: [root()]
  }
};
function appId(app) {
  return `${app.creator}/${app.name}`;
}
function permissionPaths(permissions) {
  let list = [];
  if (permissions.app)
    list.push(appData(permissions.app));
  if (permissions.fs?.private)
    list = list.concat(permissions.fs?.private.map((p) => withPartition("private", p)));
  if (permissions.fs?.public)
    list = list.concat(permissions.fs?.public.map((p) => withPartition("public", p)));
  return list;
}

// node_modules/@oddjs/odd/lib/repository.js
var Repository = class {
  constructor({ storage: storage2, storageName }) {
    this.memoryCache = [];
    this.dictionary = {};
    this.storage = storage2;
    this.storageName = storageName;
  }
  static async create(options) {
    const repo = new this.prototype.constructor(options);
    repo.memoryCache = await repo.getAll();
    repo.dictionary = repo.toDictionary(repo.memoryCache);
    return repo;
  }
  async add(itemOrItems) {
    const items = Array.isArray(itemOrItems) ? itemOrItems : [itemOrItems];
    this.memoryCache = [...this.memoryCache, ...items];
    this.dictionary = this.toDictionary(this.memoryCache);
    await this.storage.setItem(
      this.storageName,
      // TODO: JSON.stringify(this.memoryCache.map(this.toJSON))
      this.memoryCache.map(this.toJSON).join("|||")
    );
  }
  clear() {
    this.memoryCache = [];
    this.dictionary = {};
    return this.storage.removeItem(this.storageName);
  }
  find(predicate) {
    return this.memoryCache.find(predicate) || null;
  }
  getByIndex(idx) {
    return this.memoryCache[idx];
  }
  async getAll() {
    const storage2 = await this.storage.getItem(this.storageName);
    const storedItems = isString(storage2) ? storage2.split("|||").map(this.fromJSON) : [];
    return storedItems;
  }
  indexOf(item) {
    return this.memoryCache.indexOf(item);
  }
  length() {
    return this.memoryCache.length;
  }
  // ENCODING
  fromJSON(a) {
    return JSON.parse(a);
  }
  toJSON(a) {
    return JSON.stringify(a);
  }
  // DICTIONARY
  getByKey(key) {
    return this.dictionary[key];
  }
  toDictionary(items) {
    return items.reduce((acc, value, idx) => ({ ...acc, [idx.toString()]: value }), {});
  }
};

// node_modules/@oddjs/odd/lib/repositories/ucans.js
function create2({ storage: storage2 }) {
  return Repo.create({
    storage: storage2,
    storageName: storage2.KEYS.UCANS
  });
}
var Repo = class extends Repository {
  constructor(options) {
    super(options);
  }
  // ENCODING
  fromJSON(a) {
    return decode(a);
  }
  toJSON(a) {
    return encode(a);
  }
  // `${resourceKey}:${resourceValue}`
  toDictionary(items) {
    return items.reduce((acc, ucan) => ({ ...acc, [resourceLabel(ucan.payload.rsc)]: ucan }), {});
  }
  // LOOKUPS
  /**
   * Look up a UCAN with a file system path.
   */
  async lookupFilesystemUcan(path) {
    const god = this.getByKey("*");
    if (god)
      return god;
    const all4 = path === "*";
    const isDirectory2 = all4 ? false : isDirectory(path);
    const pathParts = all4 ? ["*"] : unwrap(path);
    const prefix = filesystemPrefix();
    return pathParts.reduce((acc, part, idx) => {
      if (acc)
        return acc;
      const isLastPart = idx === 0;
      const partsSlice = pathParts.slice(0, pathParts.length - idx);
      const partialPath = toPosix(isLastPart && !isDirectory2 ? file(...partsSlice) : directory(...partsSlice));
      return this.getByKey(`${prefix}${partialPath}`) || null;
    }, null);
  }
  /**
   * Look up a UCAN for a platform app.
   */
  async lookupAppUcan(domain) {
    return this.getByKey("*") || this.getByKey("app:*") || this.getByKey(`app:${domain}`);
  }
};
var WNFS_PREFIX = "wnfs";
function filesystemPrefix(username) {
  return WNFS_PREFIX + ":";
}
function resourceLabel(rsc) {
  if (typeof rsc !== "object") {
    return rsc;
  }
  const resource = Array.from(Object.entries(rsc))[0];
  return resource[0] + ":" + (resource[0] === WNFS_PREFIX ? resource[1].replace(/^\/+/, "") : resource[1]);
}

// node_modules/@oddjs/odd/lib/capabilities.js
var SESSION_TYPE = "capabilities";
async function collect({ capabilities: capabilities2, crypto: crypto3, reference: reference2, storage: storage2 }) {
  if (capabilities2.ucans.length === 0)
    throw new Error("Expected at least one UCAN");
  await collectPermissions({ reference: reference2, ucans: capabilities2.ucans });
  const accountDID = await reference2.didRoot.lookup(capabilities2.username);
  await capabilities2.fileSystemSecrets.reduce(async (acc, fsSecret) => {
    await acc;
    await collectSecret({
      accountDID,
      crypto: crypto3,
      storage: storage2,
      bareNameFilter: fsSecret.bareNameFilter,
      readKey: fsSecret.readKey,
      path: fsSecret.path
    });
  }, Promise.resolve());
}
async function collectSecret({ accountDID, bareNameFilter: bareNameFilter2, crypto: crypto3, path, readKey: readKey2, storage: storage2 }) {
  const readKeyId = await readKey({ accountDID, crypto: crypto3, path });
  const bareNameFilterId = await bareNameFilter({ accountDID, crypto: crypto3, path });
  await crypto3.keystore.importSymmKey(readKey2, readKeyId);
  await storage2.setItem(bareNameFilterId, bareNameFilter2);
}
async function collectPermissions({ reference: reference2, ucans }) {
  await reference2.repositories.ucans.add(ucans);
}
function validatePermissions(repo, { app, fs, raw }) {
  let ucan;
  const prefix = filesystemPrefix();
  const rootUcan = repo.getByKey("*");
  if (rootUcan && !isExpired(rootUcan) && !isSelfSigned(rootUcan))
    return rootUcan;
  if (app) {
    const k = prefix + toPosix(appData(app));
    const u = repo.getByKey(k);
    if (!u || isExpired(u))
      return null;
    ucan = u;
  }
  if (fs?.private) {
    const priv = fs.private.every((path) => {
      const pathWithPrefix = `${prefix}private/` + toPosix(path);
      const u = repo.getByKey(pathWithPrefix);
      ucan = u;
      return u && !isExpired(u);
    });
    if (!priv)
      return null;
  }
  if (fs?.public) {
    const publ = fs.public.every((path) => {
      const pathWithPrefix = `${prefix}public/` + toPosix(path);
      const u = repo.getByKey(pathWithPrefix);
      ucan = u;
      return u && !isExpired(u);
    });
    if (!publ)
      return null;
  }
  if (raw) {
    const hasRaw = raw.every((r) => {
      const label = resourceLabel(r.rsc);
      const u = repo.getByKey(label);
      ucan = u;
      return u && !isExpired(u);
    });
    if (!hasRaw)
      return null;
  }
  return ucan || null;
}
async function validateSecrets(crypto3, accountDID, permissions) {
  return permissionPaths(permissions).reduce((acc, path) => acc.then(async (bool) => {
    if (bool === false)
      return bool;
    if (isPartition(RootBranch.Public, path))
      return bool;
    const keyName = await readKey({ accountDID, crypto: crypto3, path });
    return crypto3.keystore.keyExists(keyName);
  }), Promise.resolve(true));
}

// node_modules/@oddjs/odd/lib/common/event-emitter.js
var EventEmitter = class {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
    this.on = this.addListener;
    this.off = this.removeListener;
  }
  addListener(eventName, listener) {
    const eventSet = this.events.get(eventName);
    if (eventSet === void 0) {
      this.events.set(eventName, /* @__PURE__ */ new Set([listener]));
    } else {
      eventSet.add(listener);
    }
  }
  removeListener(eventName, listener) {
    const eventSet = this.events.get(eventName);
    if (eventSet === void 0)
      return;
    eventSet.delete(listener);
    if (eventSet.size === 0) {
      this.events.delete(eventName);
    }
  }
  emit(eventName, event) {
    this.events.get(eventName)?.forEach((listener) => {
      listener.apply(this, [event]);
    });
  }
};

// node_modules/@oddjs/odd/lib/events.js
function createEmitter() {
  return new EventEmitter();
}
function listenTo(emitter) {
  return {
    addListener: emitter.addListener.bind(emitter),
    removeListener: emitter.removeListener.bind(emitter),
    on: emitter.on.bind(emitter),
    off: emitter.off.bind(emitter)
  };
}
function merge(a, b) {
  const merged = createEmitter();
  const aEmit = a.emit;
  const bEmit = b.emit;
  a.emit = (eventName, event) => {
    aEmit.call(a, eventName, event);
    merged.emit(eventName, event);
  };
  b.emit = (eventName, event) => {
    bEmit.call(b, eventName, event);
    merged.emit(eventName, event);
  };
  return merged;
}

// node_modules/@oddjs/odd/lib/extension/index.js
async function create3(config2) {
  let connection = { extensionId: null, connected: false };
  let listeners;
  return {
    connect: async (extensionId) => {
      connection = await connect(extensionId, config2);
      if (!listeners)
        listeners = listen(connection, config2);
    },
    disconnect: async (extensionId) => {
      connection = await disconnect(extensionId, config2);
      stopListening(config2, listeners);
    }
  };
}
async function connect(extensionId, config2) {
  const state = await getState(config2);
  globalThis.postMessage({
    id: extensionId,
    type: "connect",
    timestamp: Date.now(),
    state
  });
  return { extensionId, connected: true };
}
async function disconnect(extensionId, config2) {
  const state = await getState(config2);
  globalThis.postMessage({
    id: extensionId,
    type: "disconnect",
    timestamp: Date.now(),
    state
  });
  return { extensionId, connected: false };
}
function listen(connection, config2) {
  async function handleLocalChange(params) {
    const { root: root3, path } = params;
    const state = await getState(config2);
    globalThis.postMessage({
      id: connection.extensionId,
      type: "fileSystem",
      timestamp: Date.now(),
      state,
      detail: {
        type: "local-change",
        root: root3.toString(),
        path
      }
    });
  }
  async function handlePublish(params) {
    const { root: root3 } = params;
    const state = await getState(config2);
    globalThis.postMessage({
      id: connection.extensionId,
      type: "fileSystem",
      timestamp: Date.now(),
      state,
      detail: {
        type: "publish",
        root: root3.toString()
      }
    });
  }
  async function handleSessionCreate(params) {
    const { session: session3 } = params;
    config2 = { ...config2, session: session3 };
    const state = await getState(config2);
    globalThis.postMessage({
      id: connection.extensionId,
      type: "session",
      timestamp: Date.now(),
      state,
      detail: {
        type: "create",
        username: session3.username
      }
    });
  }
  async function handleSessionDestroy(params) {
    const { username } = params;
    config2 = { ...config2, session: null };
    const state = await getState(config2);
    globalThis.postMessage({
      id: connection.extensionId,
      type: "session",
      timestamp: Date.now(),
      state,
      detail: {
        type: "destroy",
        username
      }
    });
  }
  config2.eventEmitters.fileSystem.on("fileSystem:local-change", handleLocalChange);
  config2.eventEmitters.fileSystem.on("fileSystem:publish", handlePublish);
  config2.eventEmitters.session.on("session:create", handleSessionCreate);
  config2.eventEmitters.session.on("session:destroy", handleSessionDestroy);
  return { handleLocalChange, handlePublish, handleSessionCreate, handleSessionDestroy };
}
function stopListening(config2, listeners) {
  if (listeners) {
    config2.eventEmitters.fileSystem.removeListener("fileSystem:local-change", listeners.handleLocalChange);
    config2.eventEmitters.fileSystem.removeListener("fileSystem:publish", listeners.handlePublish);
    config2.eventEmitters.session.removeListener("session:create", listeners.handleSessionCreate);
    config2.eventEmitters.session.removeListener("session:destroy", listeners.handleSessionDestroy);
  }
}
async function getState(config2) {
  const { capabilities: capabilities2, dependencies, namespace: namespace2, session: session3 } = config2;
  const agentDID = await write(dependencies.crypto);
  let accountDID = null;
  let username = null;
  let dataRootCID = null;
  if (session3 && session3.username) {
    username = session3.username;
    accountDID = await dependencies.reference.didRoot.lookup(username);
    dataRootCID = await dependencies.reference.dataRoot.lookup(username);
  }
  return {
    app: {
      namespace: namespace2,
      ...capabilities2 ? { capabilities: capabilities2 } : {}
    },
    fileSystem: {
      dataRootCID: dataRootCID?.toString() ?? null
    },
    user: {
      username,
      accountDID,
      agentDID
    },
    odd: {
      version: VERSION
    }
  };
}

// node_modules/@ipld/dag-cbor/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  code: () => code,
  decode: () => decode7,
  encode: () => encode5,
  name: () => name
});

// node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// node_modules/cborg/esm/lib/token.js
var Type = class {
  constructor(major, name8, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name8;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString4 = useBuffer ? (bytes2, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice(bytes2, start, end);
} : (bytes2, start, end) => {
  return end - start > 64 ? textDecoder.decode(bytes2.subarray(start, end)) : utf8Slice(bytes2, start, end);
};
var fromString3 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder.encode(string2) : utf8ToBytes(string2);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes2, start, end) => {
  if (isBuffer2(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end));
  }
  return bytes2.slice(start, end);
} : (bytes2, start, end) => {
  return bytes2.slice(start, end);
};
var concat3 = useBuffer ? (chunks, length8) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length8));
} : (chunks, length8) => {
  const out = new Uint8Array(length8);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare2(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length8 = string2.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i = 0; i < length8; ++i) {
    codePoint = string2.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i + 1 === length8) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat3(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length8) {
  assertEnoughData(data, pos, prefix + length8);
  const buf2 = slice(data, pos + prefix, pos + prefix + length8);
  return new Token(Type.bytes, buf2, prefix + length8);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString3(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes2 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}

// node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length8, options) {
  const totLength = prefix + length8;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString4(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length8) {
  return new Token(Type.array, length8, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length8) {
  return new Token(Type.map, length8, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  constructor(obj, parent2) {
    this.obj = obj;
    this.parent = parent2;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length8 = isMap ? obj.size : keys.length;
    if (!length8) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length8),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length8),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode2(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// node_modules/cborg/esm/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode2(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// node_modules/multiformats/vendor/varint.js
var encode_1 = encode3;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
var decode3 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode3,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/multiformats/src/varint.js
var decode4 = (data, offset = 0) => {
  const code11 = varint_default.decode(data, offset);
  return [code11, varint_default.decode.bytes];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var equals2 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString4 = (str) => new TextEncoder().encode(str);
var toString5 = (b) => new TextDecoder().decode(b);

// node_modules/multiformats/src/hashes/digest.js
var create4 = (code11, digest5) => {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength(code11);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo(code11, bytes2, 0);
  encodeTo(size, bytes2, sizeOffset);
  bytes2.set(digest5, digestOffset);
  return new Digest(code11, size, digest5, bytes2);
};
var decode5 = (multihash) => {
  const bytes2 = coerce2(multihash);
  const [code11, sizeOffset] = decode4(bytes2);
  const [size, digestOffset] = decode4(bytes2.subarray(sizeOffset));
  const digest5 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code11, size, digest5, bytes2);
};
var equals3 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals2(a.bytes, data.bytes);
  }
};
var Digest = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code11, size, digest5, bytes2) {
    this.code = code11;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes2;
  }
};

// node_modules/multiformats/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});

// node_modules/multiformats/vendor/base-x.js
function base(ALPHABET, name8) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode26(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length8 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length8) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      pbegin++;
    }
    var it2 = size - length8;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length8 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length8) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length8;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode33(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name8} character`);
  }
  return {
    encode: encode26,
    decodeUnsafe,
    decode: decode33
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/multiformats/src/bases/base.js
var Encoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name8, prefix, baseEncode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseEncode, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name8, prefix, baseEncode);
    this.decoder = new Decoder(name8, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name8, prefix, encode: encode26, decode: decode33 }) => new Codec(name8, prefix, encode26, decode33);
var baseX = ({ prefix, name: name8, alphabet: alphabet4 }) => {
  const { encode: encode26, decode: decode33 } = base_x_default(alphabet4, name8);
  return from({
    prefix,
    name: name8,
    encode: encode26,
    /**
     * @param {string} text
     */
    decode: (text) => coerce2(decode33(text))
  });
};
var decode6 = (string2, alphabet4, bitsPerChar, name8) => {
  const codes2 = {};
  for (let i = 0; i < alphabet4.length; ++i) {
    codes2[alphabet4[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name8} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode4 = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name8, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from({
    prefix,
    name: name8,
    encode(input) {
      return encode4(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode6(input, alphabet4, bitsPerChar, name8);
    }
  });
};

// node_modules/multiformats/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/src/cid.js
var format = (link, base7) => {
  const { bytes: bytes2, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV0(
        bytes2,
        baseCache(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base7 || base58btc.encoder
      );
    default:
      return toStringV1(
        bytes2,
        baseCache(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base7 || base32.encoder
      );
  }
};
var cache = /* @__PURE__ */ new WeakMap();
var baseCache = (cid) => {
  const baseCache6 = cache.get(cid);
  if (baseCache6 == null) {
    const baseCache7 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache7);
    return baseCache7;
  }
  return baseCache6;
};
var CID2 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version3, code11, multihash, bytes2) {
    this.code = code11;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code11, multihash } = this;
        if (code11 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code11, digest: digest5 } = this.multihash;
        const multihash = create4(code11, digest5);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals3(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base7) {
    return format(this, base7);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code11, multihash, bytes: bytes2 } = value;
      return new _CID(
        version3,
        code11,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes2 || encodeCID2(version3, code11, multihash.bytes)
      );
    } else if (value[cidSymbol] === true) {
      const { version: version3, multihash, code: code11 } = value;
      const digest5 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode5(multihash)
      );
      return _CID.create(version3, code11, digest5);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version3, code11, digest5) {
    if (typeof code11 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code11 !== DAG_PB_CODE) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`
          );
        } else {
          return new _CID(version3, code11, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID2(version3, code11, digest5.bytes);
        return new _CID(version3, code11, digest5, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code11, digest5) {
    return _CID.create(1, code11, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest5 = new Digest(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest5
    ) : _CID.createV1(specs.codec, digest5);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length8] = decode4(initialBytes.subarray(offset));
      offset += length8;
      return i;
    };
    let version3 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE
    );
    if (
      /** @type {number} */
      version3 === 18
    ) {
      version3 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base7) {
    const [prefix, bytes2] = parseCIDtoBytes(source, base7);
    const cid = _CID.decode(bytes2);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base7) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base7 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base7 || base58btc;
      return [
        /** @type {Prefix} */
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base7 || base32;
      return [
        /** @type {Prefix} */
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base7 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base7.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
  }
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2).slice(1);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID2 = (version3, code11, multihash) => {
  const codeOffset = encodingLength(version3);
  const hashOffset = codeOffset + encodingLength(code11);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version3, bytes2, 0);
  encodeTo(code11, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");

// node_modules/@ipld/dag-cbor/src/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID2.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID2.decode(bytes2.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name = "dag-cbor";
var code = 113;
var encode5 = (node) => encode2(node, encodeOptions);
var decode7 = (data) => decode2(data, decodeOptions);

// node_modules/@oddjs/odd/lib/fs/protocol/basic.js
var basic_exports = {};
__export(basic_exports, {
  DEFAULT_AES_ALG: () => DEFAULT_AES_ALG,
  getEncryptedFile: () => getEncryptedFile,
  getFile: () => getFile,
  getFileSystemLinks: () => getFileSystemLinks,
  getSimpleLinks: () => getSimpleLinks,
  putEncryptedFile: () => putEncryptedFile,
  putFile: () => putFile,
  putLinks: () => putLinks
});

// node_modules/@ipld/dag-pb/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  code: () => code2,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode8,
  encode: () => encode6,
  name: () => name2,
  prepare: () => prepare,
  validate: () => validate
});

// node_modules/@ipld/dag-pb/src/pb-decode.js
var textDecoder2 = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes2.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes2, index2) {
  let wire;
  [wire, index2] = decodeVarint(bytes2, index2);
  return [wire & 7, wire >> 3, index2];
}
function decodeLink(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index2 = 0;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index2] = decodeBytes(bytes2, index2);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      link.Name = textDecoder2.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index2] = decodeVarint(bytes2, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index2 = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index2] = decodeBytes(bytes2, index2);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}

// node_modules/@ipld/dag-pb/src/pb-encode.js
var textEncoder2 = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes2, i, link.Tsize) - 1;
    bytes2[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder2.encode(link.Name);
    i -= nameBytes.length;
    bytes2.set(nameBytes, i);
    i = encodeVarint(bytes2, i, nameBytes.length) - 1;
    bytes2[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes2.set(link.Hash, i);
    i = encodeVarint(bytes2, i, link.Hash.length) - 1;
    bytes2[i] = 10;
  }
  return bytes2.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes2 = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes2.set(node.Data, i);
    i = encodeVarint(bytes2, i, node.Data.length) - 1;
    bytes2[i] = 10;
  }
  if (node.Links) {
    for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
      const size2 = encodeLink(node.Links[index2], bytes2.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes2, i, size2) - 1;
      bytes2[i] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder2.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base7 = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base7;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// node_modules/@ipld/dag-pb/src/util.js
var pbNodeProperties = ["Data", "Links"];
var pbLinkProperties = ["Hash", "Name", "Tsize"];
var textEncoder3 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder3.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder3.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID2.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID2.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID2.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID2.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder3.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links2 = []) {
  return prepare({ Data: data, Links: links2 });
}
function createLink(name8, size, cid) {
  return asLink({ Hash: cid, Name: name8, Tsize: size });
}

// node_modules/@ipld/dag-pb/src/index.js
var name2 = "dag-pb";
var code2 = 112;
function encode6(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode8(bytes2) {
  const pbn = decodeNode(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID2.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// node_modules/@oddjs/odd/node_modules/multiformats/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code3,
  decode: () => decode9,
  encode: () => encode7,
  name: () => name3
});
var name3 = "raw";
var code3 = 85;
var encode7 = (node) => coerce(node);
var decode9 = (data) => coerce(data);

// node_modules/@oddjs/odd/lib/dag/codecs.js
var BY_NAME = {
  [name2]: src_exports3,
  [name]: src_exports2,
  [name3]: raw_exports
};
var BY_CODE = {
  [code2]: src_exports3,
  [code]: src_exports2,
  [code3]: raw_exports
};
function getByCode(code11) {
  const codec = BY_CODE[code11];
  if (!codec)
    throw new Error(`No codec was registered for the code: ${numberHex(code11)}. Is it part of the multicodec table (https://github.com/multiformats/multicodec/blob/master/table.csv)?`);
  return codec;
}
function getByName(name8) {
  const codec = BY_NAME[name8];
  if (!codec)
    throw new Error(`No codec was registered for the name: ${name8}`);
  return codec;
}
function getByIdentifier(id) {
  if (typeof id === "string")
    return getByName(id);
  return getByCode(id);
}
function expect(codecId, cid) {
  const codec = getByIdentifier(codecId);
  if (cid.code !== codec.code) {
    const cidCodec = getByCode(cid.code);
    throw new Error(`Expected a ${codec.name} CID, found a ${cidCodec.name} CID instead.`);
  }
}
function isIdentifier(codeOrName) {
  return typeof codeOrName === "string" ? !!BY_NAME[codeOrName] : !!BY_CODE[codeOrName];
}
function numberHex(num) {
  const codeUint8Array = new Uint8Array(4);
  const numberByteView = new DataView(codeUint8Array.buffer);
  numberByteView.setUint32(0, num);
  const hex = toString3(codeUint8Array, "hex");
  const trimmed = hex.replace(/^(00)*/, "");
  return `0x${trimmed}`;
}

// node_modules/@oddjs/odd/lib/dag/index.js
var PB_IPLD_DATA = new Uint8Array([8, 1]);
async function getPB(depot2, cid) {
  expect(code2, cid);
  return decode8(await depot2.getBlock(cid));
}
function putPB(depot2, links2) {
  const node = createNode(PB_IPLD_DATA, links2);
  return depot2.putBlock(encode6(node), code2);
}

// node_modules/@oddjs/odd/lib/fs/types/check.js
var isFile2 = (obj) => {
  return isObject(obj) && obj.content !== void 0;
};
var isTree = (obj) => {
  return isObject(obj) && obj.ls !== void 0;
};
var isBaseLink = (obj) => {
  return isObject(obj) && isString(obj.name) && isNum(obj.size) && isBool(obj.isFile);
};
var isSimpleLink = (obj) => {
  return isObject(obj) && isString(obj.name) && isNum(obj.size) && isCID(obj.cid);
};
var isSoftLink = (obj) => {
  return isObject(obj) && isString(obj.name) && isString(obj.ipns);
};
var isSoftLinkDictionary = (obj) => {
  if (isObject(obj)) {
    const values = Object.values(obj);
    return values.length > 0 && values.every(isSoftLink);
  }
  return false;
};
var isSoftLinkList = (obj) => {
  return Array.isArray(obj) && obj.every(isSoftLink);
};
var isHardLink = (obj) => {
  return isBaseLink(obj) && isCID(obj.cid);
};
var isLinks = (obj) => {
  return isObject(obj) && Object.values(obj).every((a) => isHardLink(a) || isSoftLink(a));
};
var isUnixMeta = (obj) => {
  return isObject(obj) && isNum(obj.mtime) && isNum(obj.ctime) && isNum(obj.mode) && isString(obj._type);
};
var isMetadata = (obj) => {
  return isObject(obj) && isUnixMeta(obj.unixMeta) && isBool(obj.isFile) && isSemVer(obj.version);
};
var isSkeleton = (obj) => {
  return isObject(obj) && Object.values(obj).every(isSkeletonInfo);
};
var isSkeletonInfo = (val) => {
  const isNode = isObject(val) && isCID(val.cid) && isCID(val.userland) && isCID(val.metadata) && isSkeleton(val.subSkeleton);
  return isNode || isSoftLink(val);
};
var isTreeHeader = (obj) => {
  return isObject(obj) && isSkeleton(obj.skeleton) && isMetadata(obj.metadata) && obj.metadata.isFile === false;
};
var isTreeInfo = (obj) => {
  return isTreeHeader(obj) && isCID(obj.userland);
};
var isFileHeader = (obj) => {
  return isObject(obj) && isMetadata(obj.metadata) && obj.metadata.isFile === true;
};
var isFileInfo = (obj) => {
  return isFileHeader(obj) && isCID(obj.userland);
};
var isCID = (obj) => {
  const cid = CID.asCID(obj);
  return !!cid || isString(obj) || obj && "code" in obj && "version" in obj && ("multihash" in obj || "hash" in obj);
};
var isSemVer = (obj) => {
  if (!isObject(obj))
    return false;
  const { major, minor, patch } = obj;
  return isNum(major) && isNum(minor) && isNum(patch);
};

// node_modules/@oddjs/odd/lib/fs/link.js
var arrToMap = (arr) => {
  return arr.reduce((acc, cur) => {
    acc[cur.name] = cur;
    return acc;
  }, {});
};
var fromDAGLink = (link) => {
  const name8 = link.Name || "";
  const cid = link.Hash;
  const size = link.Tsize || 0;
  return { name: name8, cid, size };
};
var make = (name8, cid, isFile3, size) => {
  return {
    name: name8,
    cid: encodeCID(cid),
    size,
    isFile: isFile3
  };
};
var toDAGLink = (link) => {
  const { name: name8, cid, size } = link;
  return createLink(name8, size, decodeCID(cid));
};

// node_modules/@oddjs/odd/lib/fs/protocol/basic.js
var DEFAULT_AES_ALG = SymmAlg.AES_CTR;
var getFile = async (depot2, cid) => {
  return depot2.getUnixFile(cid);
};
var getEncryptedFile = async (depot2, crypto3, cid, key) => {
  const buf2 = await getFile(depot2, cid);
  let withAlgorithm;
  try {
    withAlgorithm = decode7(buf2);
  } catch {
    return buf2;
  }
  if (!hasProp(withAlgorithm, "alg") || !hasProp(withAlgorithm, "cip") || !isSymmAlg(withAlgorithm.alg) || !ArrayBuffer.isView(withAlgorithm.cip)) {
    throw new Error(`Unexpected private block. Expected "alg" and "cip" field.`);
  }
  const alg = withAlgorithm.alg;
  const cip = new Uint8Array(withAlgorithm.cip.buffer);
  const toDecode = await crypto3.aes.decrypt(cip, key, alg);
  const decoded = decode7(toDecode);
  if (decoded instanceof Uint8Array)
    return decoded;
  if (typeof decoded === "string")
    return fromString2(decoded, "utf8");
  return fromString2(JSON.stringify(decoded), "utf8");
};
var putFile = async (depot2, content) => {
  return depot2.putChunked(content);
};
var putEncryptedFile = async (depot2, crypto3, content, key) => {
  const normalized = isBlob(content) ? await toUint8Array(content) : content;
  const encoded = encode5(normalized);
  const alg = SymmAlg.AES_GCM;
  const cip = await crypto3.aes.encrypt(encoded, key, alg);
  const toAdd = encode5({ alg, cip });
  return putFile(depot2, toAdd);
};
var getSimpleLinks = async (depot2, cid) => {
  const dagNode = await getPB(depot2, cid);
  return arrToMap(dagNode.Links.map(fromDAGLink));
};
var getFileSystemLinks = async (depot2, cid) => {
  const topNode = await getPB(depot2, cid);
  const links2 = await Promise.all(topNode.Links.map(async (l) => {
    const innerNode = await getPB(depot2, l.Hash);
    const innerLinks = arrToMap(innerNode.Links.map(fromDAGLink));
    const isSoftLink2 = !!innerLinks["softLink"];
    if (isSoftLink2) {
      const a = await depot2.getUnixFile(decodeCID(innerLinks["softLink"].cid));
      const b = new TextDecoder().decode(a);
      return JSON.parse(b);
    }
    const f = await decode7(await getFile(depot2, decodeCID(innerLinks["metadata"].cid)));
    return {
      ...fromDAGLink(l),
      isFile: hasProp(f, "isFile") ? f.isFile : false
    };
  }));
  return arrToMap(links2);
};
var putLinks = async (depot2, links2) => {
  const dagLinks = Object.values(links2).reduce(async (acc, l) => {
    const arr = await acc;
    if (isSoftLink(l)) {
      const softLink = await depot2.putChunked(fromString2(JSON.stringify(l), "utf8"));
      const dagNodeCID = await putPB(depot2, [
        createLink("softLink", softLink.size, softLink.cid)
      ]);
      const dagNodeSize = await depot2.size(dagNodeCID);
      return [...arr, createLink(l.name, dagNodeSize, dagNodeCID)];
    } else if (hasProp(l, "Hash") && l.Hash) {
      return [...arr, l];
    } else if (isSimpleLink(l)) {
      return [...arr, toDAGLink(l)];
    } else {
      return arr;
    }
  }, Promise.resolve([]));
  const cid = await putPB(depot2, await dagLinks);
  return {
    cid,
    isFile: false,
    size: await depot2.size(cid)
  };
};
function isSymmAlg(alg) {
  return isString(alg) && Object.values(SymmAlg).includes(alg);
}

// node_modules/@oddjs/odd/lib/fs/protocol/public/index.js
var public_exports = {};
__export(public_exports, {
  checkValue: () => checkValue,
  get: () => get,
  getAndCheckValue: () => getAndCheckValue,
  getValue: () => getValue,
  getValueFromLinks: () => getValueFromLinks,
  putFile: () => putFile2,
  putTree: () => putTree
});
var putTree = async (depot2, links2, skeletonVal, metadataVal, previousCID) => {
  const userlandInfo = await putLinks(depot2, links2);
  const userland = make("userland", userlandInfo.cid, true, userlandInfo.size);
  const [metadata, skeleton] = await Promise.all([
    putAndMakeLink(depot2, "metadata", metadataVal),
    putAndMakeLink(depot2, "skeleton", skeletonVal)
  ]);
  const previous = previousCID != null ? make("previous", previousCID, false, await depot2.size(previousCID)) : void 0;
  const internalLinks = { metadata, skeleton, userland, previous };
  const { cid, size } = await putLinks(depot2, internalLinks);
  return {
    cid,
    userland: decodeCID(userland.cid),
    metadata: decodeCID(metadata.cid),
    size,
    isFile: false,
    skeleton: skeletonVal
  };
};
var putFile2 = async (depot2, content, metadataVal, previousCID) => {
  const userlandInfo = await putFile(depot2, content);
  const userland = make("userland", userlandInfo.cid, true, userlandInfo.size);
  const metadata = await putAndMakeLink(depot2, "metadata", metadataVal);
  const previous = previousCID != null ? make("previous", previousCID, false, await depot2.size(previousCID)) : void 0;
  const internalLinks = { metadata, userland, previous };
  const { cid, size } = await putLinks(depot2, internalLinks);
  return {
    cid,
    userland: decodeCID(userland.cid),
    metadata: decodeCID(metadata.cid),
    size,
    isFile: true,
    skeleton: {}
  };
};
var get = async (depot2, cid) => {
  const links2 = await getSimpleLinks(depot2, cid);
  const metadata = await getAndCheckValue(depot2, links2, "metadata", isMetadata);
  const skeleton = metadata.isFile ? void 0 : await getAndCheckValue(depot2, links2, "skeleton", isSkeleton);
  const userland = links2["userland"]?.cid || null;
  if (!isCID(userland))
    throw new Error("Could not find userland");
  const previous = links2["previous"]?.cid || void 0;
  return { userland, metadata, previous, skeleton };
};
var getValue = async (depot2, linksOrCID, name8) => {
  const cid = CID.asCID(linksOrCID);
  if (isCID(linksOrCID)) {
    if (!cid)
      return null;
    const links2 = await getSimpleLinks(depot2, cid);
    return getValueFromLinks(depot2, links2, name8);
  }
  return getValueFromLinks(depot2, linksOrCID, name8);
};
var getValueFromLinks = async (depot2, links2, name8) => {
  const linkCID = links2[name8]?.cid;
  if (!linkCID)
    return null;
  const file2 = await getFile(depot2, decodeCID(linkCID));
  const a = decode7(file2);
  let b;
  if (a instanceof Uint8Array) {
    b = JSON.parse(toString3(a, "utf8"));
  } else {
    b = a;
  }
  return b;
};
var getAndCheckValue = async (depot2, linksOrCid, name8, checkFn, canBeNull = false) => {
  const val = await getValue(depot2, linksOrCid, name8);
  return checkValue(val, name8, checkFn, canBeNull);
};
var checkValue = (val, name8, checkFn, canBeNull = false) => {
  if (!isValue(val)) {
    if (canBeNull)
      return val;
    throw new Error(`Could not find header value: ${name8}`);
  }
  if (checkFn(val)) {
    return val;
  }
  throw new Error(`Improperly formatted header value: ${name8}`);
};
async function putAndMakeLink(depot2, name8, val) {
  const { cid, size } = await putFile(depot2, encode5(val));
  return make(name8, cid, true, size);
}

// node_modules/@oddjs/odd/lib/fs/protocol/private/index.js
var private_exports = {};
__export(private_exports, {
  addNode: () => addNode,
  findLatestRevision: () => findLatestRevision,
  getByCID: () => getByCID,
  getByName: () => getByName2,
  getLatestByBareNameFilter: () => getLatestByBareNameFilter,
  getLatestByCID: () => getLatestByCID,
  getLatestByName: () => getLatestByName,
  getRevision: () => getRevision,
  readNode: () => readNode
});

// node_modules/@oddjs/odd/lib/fs/protocol/private/types/check.js
var isDecryptedNode = (obj) => {
  return isPrivateTreeInfo(obj) || isPrivateFileInfo(obj) || isSoftLink(obj);
};
var isPrivateFileInfo = (obj) => {
  return isObject(obj) && isMetadata(obj.metadata) && obj.metadata.isFile && isString(obj.key) && notNull(obj.content);
};
var isPrivateTreeInfo = (obj) => {
  return isObject(obj) && isMetadata(obj.metadata) && obj.metadata.isFile === false && isNum(obj.revision) && isPrivateLinks(obj.links) && isPrivateSkeleton(obj.skeleton);
};
var isPrivateLink = (obj) => {
  return isBaseLink(obj) && isString(obj.key) && isString(obj.pointer);
};
var isPrivateLinks = (obj) => {
  return isObject(obj) && Object.values(obj).every((a) => isPrivateLink(a) || isSoftLink(a));
};
var isPrivateSkeleton = (obj) => {
  return isObject(obj) && Object.values(obj).every((a) => isPrivateSkeletonInfo(a) || isSoftLink(a));
};
var isPrivateSkeletonInfo = (obj) => {
  return isObject(obj) && notNull(obj.cid) && isString(obj.key) && isPrivateSkeleton(obj.subSkeleton);
};

// node_modules/@oddjs/odd/lib/common/hex.js
var fromBytes = (bytes2) => {
  return Array.prototype.map.call(
    bytes2,
    (x) => ("00" + x.toString(16)).slice(-2)
    // '00' is for left padding
  ).join("");
};
var toBytes = (hex) => {
  const arr = new Uint8Array(hex.length / 2);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return arr;
};

// node_modules/@oddjs/odd/lib/fs/protocol/private/namefilter.js
var import_fission_bloom_filters = __toESM(require_api(), 1);
var FILTER_SIZE = 1024;
var HASH_COUNT = 16;
var SATURATION_THRESHOLD = 320;
var createBare = async (crypto3, key) => {
  const empty8 = "0".repeat(FILTER_SIZE / 4);
  return addToBare(crypto3, empty8, legacyEncodingMistake(key, "base64pad"));
};
var addToBare = async (crypto3, bareFilter, toAdd) => {
  const filter5 = fromHex(bareFilter);
  const hash3 = await crypto3.hash.sha256(toAdd);
  filter5.add(toString3(hash3, "hex"));
  return await toHex(filter5);
};
var addRevision = async (crypto3, bareFilter, key, revision) => {
  const keyStr = toString3(key, "base64pad");
  const bytes2 = fromString2(`${revision}${keyStr}`, "utf8");
  return await addToBare(crypto3, bareFilter, bytes2);
};
var toPrivateName = async (crypto3, revisionFilter) => {
  const saturated = await saturateFilter(crypto3, fromHex(revisionFilter));
  return toHash(crypto3, saturated);
};
var toHash = async (crypto3, filter5) => {
  const filterBytes = filter5.toBytes();
  const hash3 = await crypto3.hash.sha256(filterBytes);
  return fromBytes(hash3);
};
var saturate = async (crypto3, filter5, threshold = SATURATION_THRESHOLD) => {
  const saturated = await saturateFilter(crypto3, fromHex(filter5), threshold);
  return await toHex(saturated);
};
var saturateFilter = async (crypto3, filter5, threshold = SATURATION_THRESHOLD) => {
  if (threshold > filter5.toBytes().byteLength * 8) {
    throw new Error("threshold is bigger than filter size");
  }
  const bits = countOnes(filter5);
  if (bits >= threshold) {
    return filter5;
  }
  const before = filter5.toBytes();
  let toHash2 = before;
  do {
    const hash3 = await crypto3.hash.sha256(toHash2);
    filter5.add(fromBytes(hash3));
    toHash2 = hash3;
  } while (bufEquals(before, filter5.toBytes()));
  return saturateFilter(crypto3, filter5, threshold);
};
var countOnes = (filter5) => {
  const arr = new Uint32Array(filter5.toBytes());
  let count = 0;
  for (let i = 0; i < arr.length; i++) {
    count += bitCount32(arr[i]);
  }
  return count;
};
var toHex = (filter5) => {
  return fromBytes(filter5.toBytes());
};
var fromHex = (string2) => {
  const buf2 = toBytes(string2);
  return import_fission_bloom_filters.BloomFilter.fromBytes(buf2, HASH_COUNT);
};
var bufEquals = (buf1, buf2) => {
  if (buf1.byteLength !== buf2.byteLength)
    return false;
  const arr1 = new Uint8Array(buf1);
  const arr2 = new Uint8Array(buf2);
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
};
var bitCount32 = (num) => {
  const a = num - (num >> 1 & 1431655765);
  const b = (a & 858993459) + (a >> 2 & 858993459);
  return (b + (b >> 4) & 252645135) * 16843009 >> 24;
};
function legacyEncodingMistake(input, inputEncoding) {
  return fromString2(toString3(input, inputEncoding), "utf8");
}

// node_modules/@oddjs/odd/lib/fs/protocol/private/index.js
var addNode = async (depot2, crypto3, mmpt, node, key) => {
  const { cid, size } = await putEncryptedFile(depot2, crypto3, node, key);
  const filter5 = await addRevision(crypto3, node.bareNameFilter, key, node.revision);
  const name8 = await toPrivateName(crypto3, filter5);
  await mmpt.add(name8, cid);
  if (isPrivateFileInfo(node)) {
    const key2 = fromString2(node.key, "base64pad");
    const contentBareFilter = await addToBare(crypto3, node.bareNameFilter, legacyEncodingMistake(key2, "base64pad"));
    const contentFilter = await addRevision(crypto3, contentBareFilter, key2, node.revision);
    const contentName = await toPrivateName(crypto3, contentFilter);
    await mmpt.add(contentName, decodeCID(node.content));
  }
  const [skeleton, isFile3] = isPrivateFileInfo(node) ? [{}, true] : [node.skeleton, false];
  return { cid, name: name8, key, size, isFile: isFile3, skeleton };
};
var readNode = async (depot2, crypto3, cid, key) => {
  const contentBytes = await getEncryptedFile(depot2, crypto3, cid, key);
  const content = JSON.parse(toString3(contentBytes, "utf8"));
  if (!isDecryptedNode(content)) {
    throw new Error(`Could not parse a valid filesystem object: ${content}`);
  }
  return content;
};
var getByName2 = async (depot2, crypto3, mmpt, name8, key) => {
  const cid = await mmpt.get(name8);
  if (cid === null)
    return null;
  return getByCID(depot2, crypto3, cid, key);
};
var getByCID = async (depot2, crypto3, cid, key) => {
  return await readNode(depot2, crypto3, cid, key);
};
var getLatestByName = async (depot2, crypto3, mmpt, name8, key) => {
  const cid = await mmpt.get(name8);
  if (cid === null)
    return null;
  return getLatestByCID(depot2, crypto3, mmpt, cid, key);
};
var getLatestByCID = async (depot2, crypto3, mmpt, cid, key) => {
  const node = await getByCID(depot2, crypto3, cid, key);
  const latest2 = await findLatestRevision(crypto3, mmpt, node.bareNameFilter, key, node.revision);
  return latest2?.cid ? await getByCID(depot2, crypto3, decodeCID(latest2?.cid), key) : node;
};
var getLatestByBareNameFilter = async (depot2, crypto3, mmpt, bareName, key) => {
  const revisionFilter = await addRevision(crypto3, bareName, key, 1);
  const name8 = await toPrivateName(crypto3, revisionFilter);
  return getLatestByName(depot2, crypto3, mmpt, name8, key);
};
var findLatestRevision = async (crypto3, mmpt, bareName, key, lastKnownRevision) => {
  let lowerBound2 = lastKnownRevision, upperBound = null;
  let i = 0;
  let lastRevision = null;
  while (upperBound === null) {
    const toCheck = lastKnownRevision + Math.pow(2, i);
    const thisRevision = await getRevision(crypto3, mmpt, bareName, key, toCheck);
    if (thisRevision !== null) {
      lastRevision = thisRevision;
      lowerBound2 = toCheck;
    } else {
      upperBound = toCheck;
    }
    i++;
  }
  while (lowerBound2 < upperBound - 1) {
    const midpoint = Math.floor((upperBound + lowerBound2) / 2);
    const thisRevision = await getRevision(crypto3, mmpt, bareName, key, midpoint);
    if (thisRevision !== null) {
      lastRevision = thisRevision;
      lowerBound2 = midpoint;
    } else {
      upperBound = midpoint;
    }
  }
  return lastRevision;
};
var getRevision = async (crypto3, mmpt, bareName, key, revision) => {
  const filter5 = await addRevision(crypto3, bareName, key, revision);
  const name8 = await toPrivateName(crypto3, filter5);
  const cid = await mmpt.get(name8);
  return cid ? { cid, name: name8, number: revision } : null;
};

// node_modules/@oddjs/odd/lib/fs/protocol/shared/entry-index.js
async function namefilter(crypto3, { bareFilter, shareKey }) {
  const hashedKey = await crypto3.hash.sha256(fromString2(shareKey, "base64pad"));
  return saturate(crypto3, await addToBare(crypto3, bareFilter, legacyEncodingMistake(hashedKey, "hex")));
}

// node_modules/@oddjs/odd/lib/fs/protocol/shared/key.js
async function create5(crypto3, { counter, recipientExchangeDid, senderRootDid }) {
  const bytes2 = fromString2(`${recipientExchangeDid}${senderRootDid}${counter}`, "utf8");
  return toString3(await crypto3.hash.sha256(bytes2), "base64pad");
}
function payload({ entryIndexCid, symmKey, symmKeyAlgo }) {
  const cid = entryIndexCid;
  return {
    algo: symmKeyAlgo,
    key: typeof symmKey === "string" ? fromString2(symmKey, "base64pad") : symmKey,
    cid
  };
}

// node_modules/@oddjs/odd/lib/fs/base/file.js
var BaseFile = class {
  constructor(content) {
    this.content = content;
    this.readOnly = false;
  }
  async put() {
    const { cid } = await this.putDetailed();
    return cid;
  }
  async updateContent(content) {
    if (this.readOnly)
      throw new Error("File is read-only");
    this.content = content;
    return this;
  }
};
var file_default = BaseFile;

// node_modules/@oddjs/odd/lib/fs/bare/file.js
var BareFile = class _BareFile extends file_default {
  constructor(depot2, content) {
    super(content);
    this.depot = depot2;
  }
  static create(depot2, content) {
    return new _BareFile(depot2, content);
  }
  static async fromCID(depot2, cid) {
    const content = await basic_exports.getFile(depot2, cid);
    return new _BareFile(depot2, content);
  }
  static instanceOf(obj) {
    return isObject(obj) && hasProp(obj, "content");
  }
  async put() {
    const { cid } = await this.putDetailed();
    return cid;
  }
  async putDetailed() {
    return basic_exports.putFile(this.depot, this.content);
  }
};
var file_default2 = BareFile;

// node_modules/@oddjs/odd/lib/fs/base/tree.js
var BaseTree = class {
  constructor() {
    this.readOnly = false;
  }
  async put() {
    const { cid } = await this.putDetailed();
    return cid;
  }
  async ls(path) {
    const dir = await this.get(path);
    if (dir === null) {
      throw new Error("Path does not exist");
    } else if (isFile2(dir)) {
      throw new Error("Can not `ls` a file");
    }
    return dir.getLinks();
  }
  async cat(path) {
    const file2 = await this.get(path);
    if (file2 === null) {
      throw new Error("Path does not exist");
    } else if (!isFile2(file2)) {
      throw new Error("Can not `cat` a directory");
    }
    return file2.content;
  }
  async mkdir(path) {
    return this.mkdirRecurse(path, () => this.put());
  }
  async mkdirRecurse(path, onUpdate) {
    const [head, ...nextPath] = path;
    if (!head) {
      throw new Error("Invalid path: empty");
    }
    const child = await this.getOrCreateDirectChild(head, onUpdate);
    if (isFile2(child)) {
      throw new Error(`There is a file along the given path: ${log(path)}`);
    }
    if (nextPath.length) {
      await child.mkdirRecurse(nextPath, () => this.updateDirectChild(child, head, onUpdate));
    }
    return this;
  }
  async add(path, content) {
    await this.addRecurse(path, content, () => this.put());
    return this;
  }
  async addRecurse(path, content, onUpdate) {
    const [head, ...nextPath] = path;
    if (!head) {
      throw new Error("Invalid path: empty");
    }
    if (nextPath.length === 0) {
      await this.createOrUpdateChildFile(content, head, onUpdate);
    } else {
      const child = await this.getOrCreateDirectChild(head, onUpdate);
      if (isFile2(child)) {
        throw new Error(`There is a file along the given path: ${log(path)}`);
      }
      await child.addRecurse(nextPath, content, async () => {
        await this.updateDirectChild(child, head, onUpdate);
      });
    }
    return this;
  }
  async rm(path) {
    await this.rmRecurse(path, () => this.put());
    return this;
  }
  async rmRecurse(path, onUpdate) {
    const [head, ...nextPath] = path;
    if (!head) {
      throw new Error("Invalid path: empty");
    }
    if (nextPath.length === 0) {
      this.removeDirectChild(head);
      onUpdate && await onUpdate();
    } else {
      const child = await this.getDirectChild(head);
      if (child === null) {
        throw new Error("Invalid path: does not exist");
      } else if (isFile2(child)) {
        throw new Error(`There is a file along the given path: ${log(path)}`);
      }
      await child.rmRecurse(nextPath, async () => {
        await this.updateDirectChild(child, head, onUpdate);
      });
    }
    return this;
  }
  async mv(from12, to) {
    const node = await this.get(from12);
    if (node === null) {
      throw new Error(`Path does not exist: ${log(from12)}`);
    }
    if (to.length < 1) {
      throw new Error(`Path does not exist: ${log(to)}`);
    }
    const parentPath = to.slice(0, -1);
    let parent2 = await this.get(parentPath);
    if (!parent2) {
      await this.mkdir(parentPath);
      parent2 = await this.get(parentPath);
    } else if (isFile2(parent2)) {
      throw new Error(`Can not \`mv\` to a file: ${log(parentPath)}`);
    }
    await this.rm(from12);
    await [...to].reverse().reduce((acc, part, idx) => {
      return acc.then(async (child) => {
        const childParentParts = to.slice(0, -(idx + 1));
        const tree2 = childParentParts.length ? await this.get(childParentParts) : this;
        if (tree2 && !isFile2(tree2)) {
          await tree2.updateDirectChild(child, part, null);
          return tree2;
        } else {
          throw new Error("Failed to update tree while moving node");
        }
      });
    }, Promise.resolve(node));
    return this;
  }
  async exists(path) {
    const node = await this.get(path);
    return node !== null;
  }
  read(path) {
    return this.get(path);
  }
  write(path, content) {
    return this.add(path, content);
  }
  async getOrCreateDirectChild(name8, onUpdate) {
    const node = await this.getDirectChild(name8);
    return node !== null ? node : this.createChildTree(name8, onUpdate);
  }
  /**
  * `put` is called on child (result of promise) in `updateDirectChild`
  * Then for the outermost parent, `put` should be called manually.
  */
  async updateChild(child, path) {
    const chain = [];
    await path.reduce(async (promise, p, idx) => {
      const parent2 = await promise;
      chain.push([p, parent2]);
      if (idx + 1 === path.length) {
        return parent2;
      }
      const c = await parent2.getDirectChild(p);
      if (!isTree(c)) {
        const pathSoFar = path.slice(idx + 1);
        throw new Error(`Expected a tree at the given path: ${log(pathSoFar)}`);
      }
      return c;
    }, Promise.resolve(this));
    await chain.reverse().reduce(async (promise, [name8, parent2]) => {
      await parent2.updateDirectChild(await promise, name8, null);
      return parent2;
    }, Promise.resolve(child));
    return this;
  }
};
var tree_default = BaseTree;

// node_modules/@oddjs/odd/lib/fs/bare/tree.js
var BareTree = class _BareTree extends tree_default {
  constructor(depot2, links2) {
    super();
    this.type = "BareTree";
    this.links = links2;
    this.children = {};
    this.depot = depot2;
  }
  static async empty(depot2) {
    return new _BareTree(depot2, {});
  }
  static async fromCID(depot2, cid) {
    const links2 = arrToMap(await depot2.getUnixDirectory(cid));
    return new _BareTree(depot2, links2);
  }
  static fromLinks(depot2, links2) {
    return new _BareTree(depot2, links2);
  }
  static instanceOf(obj) {
    return isObject(obj) && hasProp(obj, "links") && hasProp(obj, "children") && hasProp(obj, "type") && obj.type === "BareTree";
  }
  async createChildTree(name8, onUpdate) {
    const child = await _BareTree.empty(this.depot);
    const existing = this.children[name8];
    if (existing) {
      if (isFile2(existing)) {
        throw new Error(`There is a file at the given path: ${name8}`);
      }
      return existing;
    }
    await this.updateDirectChild(child, name8, onUpdate);
    return child;
  }
  async createOrUpdateChildFile(content, name8, onUpdate) {
    const existing = await this.getDirectChild(name8);
    let file2;
    if (existing === null) {
      file2 = await file_default2.create(this.depot, content);
    } else if (file_default2.instanceOf(existing)) {
      file2 = await existing.updateContent(content);
    } else {
      throw new Error(`There is already a directory with that name: ${name8}`);
    }
    await this.updateDirectChild(file2, name8, onUpdate);
    return file2;
  }
  async putDetailed() {
    return basic_exports.putLinks(this.depot, this.links);
  }
  async putAndUpdateLink(child, name8, onUpdate) {
    const details = await child.putDetailed();
    this.updateLink(name8, details);
    onUpdate && await onUpdate();
    return this;
  }
  async updateDirectChild(child, name8, onUpdate) {
    this.children[name8] = child;
    return this.putAndUpdateLink(child, name8, onUpdate);
  }
  removeDirectChild(name8) {
    delete this.links[name8];
    if (this.children[name8]) {
      delete this.children[name8];
    }
    return this;
  }
  async getDirectChild(name8) {
    if (this.children[name8]) {
      return this.children[name8];
    }
    const link = this.links[name8] || null;
    if (link === null)
      return null;
    const cid = decodeCID(link.cid);
    const child = link.isFile ? await file_default2.fromCID(this.depot, cid) : await _BareTree.fromCID(this.depot, cid);
    if (this.children[name8]) {
      return this.children[name8];
    }
    this.children[name8] = child;
    return child;
  }
  async get(path) {
    const [head, ...nextPath] = path;
    if (!head)
      return this;
    const nextTree = await this.getDirectChild(head);
    if (!nextPath.length) {
      return nextTree;
    } else if (nextTree === null || isFile2(nextTree)) {
      return null;
    }
    return nextTree.get(nextPath);
  }
  updateLink(name8, result) {
    const { cid, size, isFile: isFile3 } = result;
    this.links[name8] = make(name8, cid, isFile3, size);
    return this;
  }
  getLinks() {
    return this.links;
  }
};
var tree_default2 = BareTree;

// node_modules/@oddjs/odd/lib/fs/protocol/private/mmpt.js
var nibbles = {
  "0": true,
  "1": true,
  "2": true,
  "3": true,
  "4": true,
  "5": true,
  "6": true,
  "7": true,
  "8": true,
  "9": true,
  "a": true,
  "b": true,
  "c": true,
  "d": true,
  "e": true,
  "f": true
};
var isNibble = (str) => nibbles[str] === true;
var MMPT = class _MMPT {
  constructor(depot2, links2) {
    this.links = links2;
    this.children = {};
    this.depot = depot2;
  }
  static create(depot2) {
    return new _MMPT(depot2, {});
  }
  static async fromCID(depot2, cid) {
    const links2 = await getSimpleLinks(depot2, cid);
    return new _MMPT(depot2, links2);
  }
  async putDetailed() {
    return putLinks(this.depot, this.links);
  }
  async put() {
    const { cid } = await this.putDetailed();
    return cid;
  }
  async add(name8, value) {
    if (!isNibble(name8[0])) {
      throw new Error(`Not a valid name, must be hexadecimal`);
    }
    const nextNameOrSib = this.nextTreeOrSiblingName(name8);
    if (name8 === nextNameOrSib) {
    } else if (nextNameOrSib === null) {
      this.links[name8] = make(name8, value, true, 0);
    } else if (nextNameOrSib.length === 1) {
      const nextTree = await this.getDirectChild(nextNameOrSib);
      await nextTree.add(name8.slice(1), value);
      await this.putAndUpdateChildLink(nextNameOrSib);
    } else {
      const newTree = this.addEmptyChild(name8[0]);
      const nextCID = this.links[nextNameOrSib].cid;
      this.removeChild(nextNameOrSib);
      await Promise.all([
        newTree.add(name8.slice(1), value),
        newTree.add(nextNameOrSib.slice(1), decodeCID(nextCID))
      ]);
      await this.putAndUpdateChildLink(name8[0]);
    }
  }
  async putAndUpdateChildLink(name8) {
    const cidBefore = this.links[name8]?.cid;
    const { cid, size } = await this.children[name8].putDetailed();
    const cidNow = this.links[name8]?.cid;
    if (cidBefore != cidNow) {
      return await this.putAndUpdateChildLink(name8);
    }
    this.links[name8] = make(name8, cid, false, size);
  }
  addEmptyChild(name8) {
    const tree2 = _MMPT.create(this.depot);
    this.children[name8] = tree2;
    return tree2;
  }
  async get(name8) {
    const nextName = this.nextTreeName(name8);
    if (nextName === null)
      return null;
    if (nextName.length > 1) {
      return decodeCID(this.links[nextName].cid);
    }
    const nextTree = await this.getDirectChild(nextName);
    return nextTree.get(name8.slice(1));
  }
  async exists(name8) {
    return await this.get(name8) !== null;
  }
  async members() {
    const children = await Promise.all(Object.values(this.links).map(async ({ name: name8, cid }) => {
      if (name8.length > 1) {
        return [{ name: name8, cid: decodeCID(cid) }];
      }
      const child = await _MMPT.fromCID(this.depot, decodeCID(cid));
      const childMembers = await child.members();
      return childMembers.map((mem) => ({
        ...mem,
        name: name8 + mem.name
      }));
    }));
    return children.reduce((acc, cur) => acc.concat(cur));
  }
  async getDirectChild(name8) {
    if (this.children[name8]) {
      return this.children[name8];
    }
    const child = await _MMPT.fromCID(this.depot, decodeCID(this.links[name8].cid));
    if (this.children[name8]) {
      return this.children[name8];
    }
    this.children[name8] = child;
    return child;
  }
  removeChild(name8) {
    delete this.links[name8];
    if (this.children[name8]) {
      delete this.children[name8];
    }
  }
  directChildExists(name8) {
    return this.links[name8] !== void 0 || this.children[name8] !== void 0;
  }
  nextTreeName(name8) {
    if (this.directChildExists(name8[0])) {
      return name8[0];
    } else if (this.directChildExists(name8)) {
      return name8;
    }
    return null;
  }
  nextTreeOrSiblingName(name8) {
    const nibble = name8[0];
    if (this.directChildExists(nibble)) {
      return nibble;
    }
    return Object.keys(this.links).find((child) => nibble === child[0]) || null;
  }
};

// node_modules/@oddjs/odd/lib/fs/metadata.js
var UnixNodeType;
(function(UnixNodeType2) {
  UnixNodeType2["Raw"] = "raw";
  UnixNodeType2["Directory"] = "dir";
  UnixNodeType2["File"] = "file";
  UnixNodeType2["Metadata"] = "metadata";
  UnixNodeType2["Symlink"] = "symlink";
  UnixNodeType2["HAMTShard"] = "hamtShard";
})(UnixNodeType || (UnixNodeType = {}));
var emptyUnix = (isFile3) => ({
  mtime: Date.now(),
  ctime: Date.now(),
  mode: isFile3 ? 644 : 755,
  _type: isFile3 ? UnixNodeType.File : UnixNodeType.Directory
});
var empty2 = (isFile3, version3) => ({
  isFile: isFile3,
  version: version3,
  unixMeta: emptyUnix(isFile3)
});
var updateMtime = (metadata) => ({
  ...metadata,
  unixMeta: {
    ...metadata.unixMeta,
    mtime: Date.now()
  }
});

// node_modules/@oddjs/odd/lib/common/semver.js
var encode8 = (major, minor, patch) => {
  return {
    major,
    minor,
    patch
  };
};
var fromString5 = (str) => {
  const parts = str.split(".").map((x) => parseInt(x));
  if (parts.length !== 3 || parts.some((p) => typeof p !== "number")) {
    return null;
  }
  return {
    major: parts[0],
    minor: parts[1],
    patch: parts[2]
  };
};
var toString6 = (version3) => {
  const { major, minor, patch } = version3;
  return `${major}.${minor}.${patch}`;
};
var equals4 = (a, b) => {
  return a.major === b.major && a.minor === b.minor && a.patch === b.patch;
};
var isSmallerThan = (a, b) => {
  if (a.major != b.major)
    return a.major < b.major;
  if (a.minor != b.minor)
    return a.minor < b.minor;
  return a.patch < b.patch;
};
var isBiggerThan = (a, b) => {
  return isSmallerThan(b, a);
};
function isBiggerThanOrEqualTo(a, b) {
  return isSmallerThan(b, a) || equals4(a, b);
}

// node_modules/@oddjs/odd/lib/fs/versions.js
var isSupported = (fsVersion) => {
  if (isSmallerThan(fsVersion, latest)) {
    return "too-low";
  } else if (isBiggerThan(fsVersion, wnfsWasm)) {
    return "too-high";
  } else {
    return true;
  }
};
var v0 = encode8(0, 0, 0);
var v1 = encode8(1, 0, 0);
var latest = encode8(2, 0, 0);
var wnfsWasm = encode8(3, 0, 0);
var supported = [latest, wnfsWasm];

// node_modules/@oddjs/odd/lib/fs/v1/PrivateHistory.js
var PrivateHistory = class {
  constructor(crypto3, depot2, node) {
    this.crypto = crypto3;
    this.depot = depot2;
    this.node = node;
  }
  /**
   * Go back one or more versions.
   *
   * @param delta Optional negative number to specify how far to go back
   */
  async back(delta = -1) {
    const n = Math.min(delta, -1);
    const revision = this.node.header?.revision;
    return revision && await this._getRevision(revision + n) || null;
  }
  // async forward(delta: number = 1): Promise<Maybe<Node>> {
  //   const n = Math.max(delta, 1)
  //   const revision = this.node.header?.revision
  //   return (revision && await this._getRevision(revision + n)) || null
  // }
  /**
   * Get a version before a given timestamp.
   *
   * @param timestamp Unix timestamp in seconds
   */
  async prior(timestamp) {
    if (this.node.header.metadata.unixMeta.mtime < timestamp) {
      return this.node;
    } else {
      return this._prior(this.node.header.revision - 1, timestamp);
    }
  }
  /**
   * List earlier versions along with the timestamp they were created.
   */
  async list(amount = 5) {
    const max = this.node.header.revision;
    return Promise.all(Array.from({ length: amount }, (_, i) => {
      const n = i + 1;
      return this._getRevisionInfoFromNumber(max - n).then((info) => ({
        revisionInfo: info,
        delta: -n
      }));
    })).then((list) => list.filter((a) => !!a.revisionInfo)).then((list) => list.map((a) => {
      const mtime = a.revisionInfo.metadata.unixMeta.mtime;
      return { delta: a.delta, timestamp: mtime };
    }));
  }
  /**
   * @internal
   */
  async _getRevision(revision) {
    const info = await this._getRevisionInfoFromNumber(revision);
    return info && await this.node.fromInfo(this.node.mmpt, this.node.key, info);
  }
  /**
   * @internal
   */
  _getRevisionInfo(revision) {
    return private_exports.readNode(this.depot, this.crypto, decodeCID(revision.cid), this.node.key);
  }
  /**
   * @internal
   */
  async _getRevisionInfoFromNumber(revision) {
    const { mmpt } = this.node;
    const { bareNameFilter: bareNameFilter2 } = this.node.header;
    const key = this.node.key;
    const r = await private_exports.getRevision(this.crypto, mmpt, bareNameFilter2, key, revision);
    return r && this._getRevisionInfo(r);
  }
  /**
   * @internal
   */
  async _prior(revision, timestamp) {
    const info = await this._getRevisionInfoFromNumber(revision);
    if (!info?.revision)
      return null;
    if (info.metadata.unixMeta.mtime < timestamp) {
      return this._getRevision(info.revision);
    } else {
      return this._prior(info.revision - 1, timestamp);
    }
  }
};

// node_modules/@oddjs/odd/lib/fs/v1/PrivateFile.js
var PrivateFile = class _PrivateFile extends file_default {
  constructor({ crypto: crypto3, depot: depot2, content, mmpt, key, header }) {
    super(content);
    this.crypto = crypto3;
    this.depot = depot2;
    this.header = header;
    this.key = key;
    this.mmpt = mmpt;
    this.history = new PrivateHistory(crypto3, depot2, toHistoryNode(this));
    function toHistoryNode(file2) {
      return {
        ...file2,
        fromInfo: async (mmpt2, key2, info) => toHistoryNode(await _PrivateFile.fromInfo(crypto3, depot2, mmpt2, key2, info))
      };
    }
  }
  static instanceOf(obj) {
    return isObject(obj) && hasProp(obj, "content") && hasProp(obj, "mmpt") && hasProp(obj, "header") && isPrivateFileInfo(obj.header);
  }
  static async create(crypto3, depot2, mmpt, content, parentNameFilter, key) {
    const contentKey = await crypto3.aes.exportKey(await crypto3.aes.genKey(DEFAULT_AES_ALG));
    const bareNameFilter2 = await addToBare(crypto3, parentNameFilter, legacyEncodingMistake(key, "base64pad"));
    const contentInfo = await basic_exports.putEncryptedFile(depot2, crypto3, content, contentKey);
    return new _PrivateFile({
      crypto: crypto3,
      depot: depot2,
      content,
      mmpt,
      key,
      header: {
        bareNameFilter: bareNameFilter2,
        key: toString3(contentKey, "base64pad"),
        revision: 1,
        metadata: empty2(true, latest),
        content: encodeCID(contentInfo.cid)
      }
    });
  }
  static async fromBareNameFilter(crypto3, depot2, mmpt, bareNameFilter2, key) {
    const info = await private_exports.getLatestByBareNameFilter(depot2, crypto3, mmpt, bareNameFilter2, key);
    return this.fromInfo(crypto3, depot2, mmpt, key, info);
  }
  static async fromLatestName(crypto3, depot2, mmpt, name8, key) {
    const info = await private_exports.getLatestByName(depot2, crypto3, mmpt, name8, key);
    return _PrivateFile.fromInfo(crypto3, depot2, mmpt, key, info);
  }
  static async fromName(crypto3, depot2, mmpt, name8, key) {
    const info = await private_exports.getByName(depot2, crypto3, mmpt, name8, key);
    return _PrivateFile.fromInfo(crypto3, depot2, mmpt, key, info);
  }
  static async fromInfo(crypto3, depot2, mmpt, key, info) {
    if (!isPrivateFileInfo(info)) {
      throw new Error(`Could not parse a valid private file using the given key`);
    }
    const content = await basic_exports.getEncryptedFile(depot2, crypto3, decodeCID(info.content), fromString2(info.key, "base64pad"));
    return new _PrivateFile({
      crypto: crypto3,
      depot: depot2,
      content,
      key,
      mmpt,
      header: info
    });
  }
  async getName() {
    const { bareNameFilter: bareNameFilter2, revision } = this.header;
    const revisionFilter = await addRevision(this.crypto, bareNameFilter2, this.key, revision);
    return toPrivateName(this.crypto, revisionFilter);
  }
  async updateParentNameFilter(parentNameFilter) {
    this.header.bareNameFilter = await addToBare(this.crypto, parentNameFilter, legacyEncodingMistake(fromString2(this.header.key, "base64pad"), "base64pad"));
    return this;
  }
  async updateContent(content) {
    const contentInfo = await basic_exports.putEncryptedFile(this.depot, this.crypto, content, fromString2(this.header.key, "base64pad"));
    this.content = content;
    this.header = {
      ...this.header,
      revision: this.header.revision + 1,
      content: encodeCID(contentInfo.cid)
    };
    return this;
  }
  async putDetailed() {
    return private_exports.addNode(this.depot, this.crypto, this.mmpt, {
      ...this.header,
      metadata: updateMtime(this.header.metadata)
    }, this.key);
  }
};
var PrivateFile_default = PrivateFile;

// node_modules/@oddjs/odd/lib/fs/v1/PrivateTree.js
var PrivateTree = class _PrivateTree extends tree_default {
  constructor({ crypto: crypto3, depot: depot2, manners: manners2, reference: reference2, mmpt, key, header }) {
    super();
    this.crypto = crypto3;
    this.depot = depot2;
    this.manners = manners2;
    this.reference = reference2;
    this.children = {};
    this.header = header;
    this.key = key;
    this.mmpt = mmpt;
    this.history = new PrivateHistory(crypto3, depot2, toHistoryNode(this));
    function toHistoryNode(tree2) {
      return {
        ...tree2,
        fromInfo: async (mmpt2, key2, info) => toHistoryNode(await _PrivateTree.fromInfo(crypto3, depot2, manners2, reference2, mmpt2, key2, info))
      };
    }
  }
  static instanceOf(obj) {
    return isObject(obj) && hasProp(obj, "mmpt") && hasProp(obj, "header") && isPrivateTreeInfo(obj.header);
  }
  static async create(crypto3, depot2, manners2, reference2, mmpt, key, parentNameFilter) {
    const bareNameFilter2 = parentNameFilter ? await addToBare(crypto3, parentNameFilter, legacyEncodingMistake(key, "base64pad")) : await createBare(crypto3, key);
    return new _PrivateTree({
      crypto: crypto3,
      depot: depot2,
      manners: manners2,
      reference: reference2,
      mmpt,
      key,
      header: {
        metadata: empty2(false, latest),
        bareNameFilter: bareNameFilter2,
        revision: 1,
        links: {},
        skeleton: {}
      }
    });
  }
  static async fromBaseKey(crypto3, depot2, manners2, reference2, mmpt, key) {
    const bareNameFilter2 = await createBare(crypto3, key);
    return this.fromBareNameFilter(crypto3, depot2, manners2, reference2, mmpt, bareNameFilter2, key);
  }
  static async fromBareNameFilter(crypto3, depot2, manners2, reference2, mmpt, bareNameFilter2, key) {
    const info = await private_exports.getLatestByBareNameFilter(depot2, crypto3, mmpt, bareNameFilter2, key);
    return this.fromInfo(crypto3, depot2, manners2, reference2, mmpt, key, info);
  }
  static async fromLatestName(crypto3, depot2, manners2, reference2, mmpt, name8, key) {
    const info = await private_exports.getLatestByName(depot2, crypto3, mmpt, name8, key);
    return this.fromInfo(crypto3, depot2, manners2, reference2, mmpt, key, info);
  }
  static async fromName(crypto3, depot2, manners2, reference2, mmpt, name8, key) {
    const info = await private_exports.getByName(depot2, crypto3, mmpt, name8, key);
    return this.fromInfo(crypto3, depot2, manners2, reference2, mmpt, key, info);
  }
  static async fromInfo(crypto3, depot2, manners2, reference2, mmpt, key, info) {
    if (!isPrivateTreeInfo(info)) {
      throw new Error(`Could not parse a valid private tree using the given key`);
    }
    return new _PrivateTree({ crypto: crypto3, depot: depot2, manners: manners2, reference: reference2, mmpt, key, header: info });
  }
  async createChildTree(name8, onUpdate) {
    const key = await this.crypto.aes.genKey(DEFAULT_AES_ALG).then(this.crypto.aes.exportKey);
    const child = await _PrivateTree.create(this.crypto, this.depot, this.manners, this.reference, this.mmpt, key, this.header.bareNameFilter);
    const existing = this.children[name8];
    if (existing) {
      if (PrivateFile_default.instanceOf(existing)) {
        throw new Error(`There is a file at the given path: ${name8}`);
      }
      return existing;
    }
    await this.updateDirectChild(child, name8, onUpdate);
    return child;
  }
  async createOrUpdateChildFile(content, name8, onUpdate) {
    const existing = await this.getDirectChild(name8);
    let file2;
    if (existing === null) {
      const key = await this.crypto.aes.genKey(DEFAULT_AES_ALG).then(this.crypto.aes.exportKey);
      file2 = await PrivateFile_default.create(this.crypto, this.depot, this.mmpt, content, this.header.bareNameFilter, key);
    } else if (PrivateFile_default.instanceOf(existing)) {
      file2 = await existing.updateContent(content);
    } else {
      throw new Error(`There is already a directory with that name: ${name8}`);
    }
    await this.updateDirectChild(file2, name8, onUpdate);
    return file2;
  }
  async putDetailed() {
    const nodeCopy = Object.assign({}, this.header);
    nodeCopy.skeleton = ensureSkeletonStringCIDs(nodeCopy.skeleton);
    return private_exports.addNode(this.depot, this.crypto, this.mmpt, nodeCopy, this.key);
  }
  async updateDirectChild(child, name8, onUpdate) {
    if (this.readOnly)
      throw new Error("Tree is read-only");
    await child.updateParentNameFilter(this.header.bareNameFilter);
    this.children[name8] = child;
    const details = await child.putDetailed();
    this.updateLink(name8, details);
    onUpdate && await onUpdate();
    return this;
  }
  removeDirectChild(name8) {
    this.header = {
      ...this.header,
      revision: this.header.revision + 1,
      links: removeKeyFromObj(this.header.links, name8),
      skeleton: removeKeyFromObj(this.header.skeleton, name8)
    };
    if (this.children[name8]) {
      delete this.children[name8];
    }
    return this;
  }
  async getDirectChild(name8) {
    let child = null;
    if (this.children[name8]) {
      return this.children[name8];
    }
    const childInfo = this.header.links[name8];
    if (childInfo === void 0)
      return null;
    if (isPrivateLink(childInfo)) {
      const key = fromString2(childInfo.key, "base64pad");
      child = childInfo.isFile ? await PrivateFile_default.fromLatestName(this.crypto, this.depot, this.mmpt, childInfo.pointer, key) : await _PrivateTree.fromLatestName(this.crypto, this.depot, this.manners, this.reference, this.mmpt, childInfo.pointer, key);
    } else if (isSoftLink(childInfo)) {
      return _PrivateTree.resolveSoftLink(this.crypto, this.depot, this.manners, this.reference, childInfo);
    }
    if (this.children[name8]) {
      return this.children[name8];
    }
    if (child)
      this.children[name8] = child;
    return child;
  }
  async getName() {
    const { bareNameFilter: bareNameFilter2, revision } = this.header;
    const revisionFilter = await addRevision(this.crypto, bareNameFilter2, this.key, revision);
    return toPrivateName(this.crypto, revisionFilter);
  }
  async updateParentNameFilter(parentNameFilter) {
    this.header.bareNameFilter = await addToBare(this.crypto, parentNameFilter, legacyEncodingMistake(this.key, "base64pad"));
    return this;
  }
  async get(path) {
    if (path.length === 0)
      return this;
    const [head, ...rest] = path;
    const next = this.header.skeleton[head];
    if (next === void 0)
      return null;
    return this.getRecurse(next, rest);
  }
  async getRecurse(nodeInfo, parts) {
    const [head, ...rest] = parts;
    if (isSoftLink(nodeInfo)) {
      const resolved = await _PrivateTree.resolveSoftLink(this.crypto, this.depot, this.manners, this.reference, nodeInfo);
      if (!resolved)
        return null;
      if (head === void 0)
        return resolved;
      if (_PrivateTree.instanceOf(resolved)) {
        return resolved.get(parts).then(makeReadOnly);
      }
      throw new Error("Was expecting a directory at: " + log(parts));
    }
    if (head === void 0)
      return getNode(this.crypto, this.depot, this.manners, this.reference, this.mmpt, nodeInfo);
    const nextChild = nodeInfo.subSkeleton[head];
    if (nextChild !== void 0)
      return this.getRecurse(nextChild, rest);
    const reloadedNode = await private_exports.getLatestByCID(this.depot, this.crypto, this.mmpt, decodeCID(nodeInfo.cid), fromString2(nodeInfo.key, "base64pad"));
    if (!isPrivateTreeInfo(reloadedNode))
      return null;
    const reloadedNext = reloadedNode.skeleton[head];
    return reloadedNext === void 0 ? null : this.getRecurse(reloadedNext, rest);
  }
  // Links
  // -----
  assignLink({ name: name8, link, skeleton }) {
    this.header.links[name8] = link;
    this.header.skeleton[name8] = skeleton;
    this.header.revision = this.header.revision + 1;
    this.header.metadata.unixMeta.mtime = Date.now();
  }
  static async resolveSoftLink(crypto3, depot2, manners2, reference2, link) {
    const domain = link.ipns.split("/")[0];
    if (!link.privateName || !link.key)
      throw new Error("Mixing public and private soft links is not supported yet.");
    const rootCid = await reference2.dns.lookupDnsLink(domain);
    if (!rootCid)
      throw new Error(`Failed to resolve the soft link: ${link.ipns} - Could not resolve DNSLink`);
    const privateCid = (await basic_exports.getSimpleLinks(depot2, decodeCID(rootCid))).private.cid;
    const mmpt = await MMPT.fromCID(depot2, decodeCID(privateCid));
    const key = fromString2(link.key, "base64pad");
    const info = await private_exports.getLatestByName(depot2, crypto3, mmpt, link.privateName, key);
    if (!info)
      return null;
    const item = info.metadata.isFile ? await PrivateFile_default.fromInfo(crypto3, depot2, mmpt, key, info) : await _PrivateTree.fromInfo(crypto3, depot2, manners2, reference2, mmpt, key, info);
    if (item)
      item.readOnly = true;
    return item;
  }
  getLinks() {
    return mapObj(this.header.links, (link) => {
      if (isSoftLink(link)) {
        return { ...link };
      } else {
        const { key, ...rest } = link;
        return { ...rest };
      }
    });
  }
  updateLink(name8, result) {
    const { cid, size, isFile: isFile3, skeleton } = result;
    const key = toString3(result.key, "base64pad");
    const pointer = result.name;
    this.assignLink({
      name: name8,
      link: { name: name8, key, pointer, size, isFile: isFile3 },
      skeleton: { cid: encodeCID(cid), key, subSkeleton: skeleton }
    });
    return this;
  }
  insertSoftLink({ name: name8, key, privateName, username }) {
    const softLink = {
      ipns: this.reference.dataRoot.domain(username),
      name: name8,
      privateName,
      key: toString3(key, "base64pad")
    };
    this.assignLink({
      name: name8,
      link: softLink,
      skeleton: softLink
    });
    return this;
  }
};
async function getNode(crypto3, depot2, manners2, reference2, mmpt, nodeInfo) {
  const key = fromString2(nodeInfo.key, "base64pad");
  const node = await private_exports.getLatestByCID(depot2, crypto3, mmpt, decodeCID(nodeInfo.cid), key);
  return isPrivateFileInfo(node) ? await PrivateFile_default.fromInfo(crypto3, depot2, mmpt, key, node) : await PrivateTree.fromInfo(crypto3, depot2, manners2, reference2, mmpt, key, node);
}
function ensureSkeletonStringCIDs(skeleton) {
  return Object.entries(skeleton).reduce((acc, [k, skeletonOrSoftLink]) => {
    let newValue = skeletonOrSoftLink;
    if (isPrivateSkeletonInfo(skeletonOrSoftLink)) {
      skeletonOrSoftLink.cid = decodeCID(skeletonOrSoftLink.cid).toString();
      skeletonOrSoftLink.subSkeleton = ensureSkeletonStringCIDs(skeletonOrSoftLink.subSkeleton);
    }
    return { ...acc, [k]: newValue };
  }, {});
}
function makeReadOnly(maybeFileOrTree) {
  if (maybeFileOrTree)
    maybeFileOrTree.readOnly = true;
  return maybeFileOrTree;
}

// node_modules/@oddjs/odd/lib/fs/share.js
var EXCHANGE_PATH = directory("public", ".well-known", "exchange");
async function privateNode(crypto3, depot2, manners2, reference2, rootTree, items, { shareWith, sharedBy }) {
  const exchangeDIDs = Array.isArray(shareWith) ? shareWith : shareWith.startsWith("did:") ? [shareWith] : await listExchangeDIDs(depot2, reference2, shareWith);
  const counter = rootTree.sharedCounter || 1;
  const mmpt = rootTree.mmpt;
  const shareKeysWithDIDs = await Promise.all(exchangeDIDs.map(async (did3) => {
    return [
      did3,
      await create5(crypto3, {
        counter,
        recipientExchangeDid: did3,
        senderRootDid: sharedBy.rootDid
      })
    ];
  }));
  const indexKey = await crypto3.aes.genKey(SymmAlg.AES_GCM).then(crypto3.aes.exportKey);
  const index2 = await PrivateTree.create(crypto3, depot2, manners2, reference2, mmpt, indexKey, null);
  await Promise.all(items.map(async ([name8, item]) => {
    const privateName = await item.getName();
    return index2.insertSoftLink({
      key: item.key,
      name: name8,
      privateName,
      username: sharedBy.username
    });
  }));
  const symmKeyAlgo = SymmAlg.AES_GCM;
  const indexNode = Object.assign({}, index2.header);
  const indexResult = await putFile(depot2, await crypto3.aes.encrypt(fromString2(JSON.stringify(indexNode), "utf8"), index2.key, symmKeyAlgo));
  if (shareKeysWithDIDs.length) {
    const namefilter2 = await namefilter(crypto3, {
      bareFilter: indexNode.bareNameFilter,
      shareKey: shareKeysWithDIDs[0][1]
    });
    await mmpt.add(namefilter2, indexResult.cid);
  }
  const payload2 = encode5(payload({
    entryIndexCid: encodeCID(indexResult.cid),
    symmKey: index2.key,
    symmKeyAlgo
  }));
  const links2 = await Promise.all(shareKeysWithDIDs.map(async ([did3, shareKey]) => {
    const { publicKey } = didToPublicKey(crypto3, did3);
    const encryptedPayload = await crypto3.rsa.encrypt(payload2, publicKey);
    const result = await depot2.putChunked(encryptedPayload);
    return {
      name: shareKey,
      cid: result.cid,
      size: result.size
    };
  }));
  await rootTree.addShares(links2);
  return { shareId: counter.toString(), sharedBy };
}
async function listExchangeDIDs(depot2, reference2, username) {
  const root3 = await reference2.dataRoot.lookup(username);
  if (!root3)
    throw new Error("This person doesn't have a filesystem yet.");
  const rootLinks = await basic_exports.getSimpleLinks(depot2, root3);
  const prettyTreeCid = rootLinks[RootBranch.Pretty]?.cid || null;
  if (!prettyTreeCid)
    throw new Error("This person's filesystem doesn't have a pretty tree.");
  const tree2 = await tree_default2.fromCID(depot2, decodeCID(prettyTreeCid));
  const exchangePath = unwrap(removePartition(EXCHANGE_PATH));
  const exchangeTree = await tree2.get(exchangePath);
  return exchangeTree && exchangeTree instanceof tree_default2 ? Object.keys(exchangeTree.getLinks()) : [];
}

// node_modules/@oddjs/odd/lib/fs/data.js
async function addSampleData(fs) {
  await fs.mkdir(directory("private", "Apps"));
  await fs.mkdir(directory("private", "Audio"));
  await fs.mkdir(directory("private", "Documents"));
  await fs.mkdir(directory("private", "Photos"));
  await fs.mkdir(directory("private", "Video"));
  await fs.write(file("private", "Welcome.txt"), new TextEncoder().encode("Welcome to your personal transportable encrypted file system \u{1F44B}"));
}
async function addPublicExchangeKey(crypto3, fs) {
  const publicDid = await exchange(crypto3);
  await fs.mkdir(combine(EXCHANGE_PATH, directory(publicDid)));
}
async function hasPublicExchangeKey(crypto3, fs) {
  const publicDid = await exchange(crypto3);
  return fs.exists(combine(EXCHANGE_PATH, directory(publicDid)));
}

// node_modules/@oddjs/odd/lib/common/root-key.js
async function retrieve({ crypto: crypto3, accountDID }) {
  const rootKeyId = await identifier(crypto3, accountDID);
  return crypto3.keystore.exportSymmKey(rootKeyId);
}
async function store({ crypto: crypto3, accountDID, readKey: readKey2 }) {
  const rootKeyId = await identifier(crypto3, accountDID);
  return crypto3.keystore.importSymmKey(readKey2, rootKeyId);
}
function fromString6(a) {
  return fromString2(a, "base64pad");
}
function identifier(crypto3, accountDID) {
  const path = directory(RootBranch.Private);
  return readKey({ crypto: crypto3, path, accountDID });
}

// node_modules/@oddjs/odd/lib/session.js
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Session_crypto;
var _Session_storage;
var _Session_eventEmitter;
var Session = class {
  constructor(props) {
    _Session_crypto.set(this, void 0);
    _Session_storage.set(this, void 0);
    _Session_eventEmitter.set(this, void 0);
    __classPrivateFieldSet(this, _Session_crypto, props.crypto, "f");
    __classPrivateFieldSet(this, _Session_storage, props.storage, "f");
    __classPrivateFieldSet(this, _Session_eventEmitter, props.eventEmitter, "f");
    this.fs = props.fs;
    this.type = props.type;
    this.username = props.username;
    __classPrivateFieldGet(this, _Session_eventEmitter, "f").emit("session:create", { session: this });
  }
  async destroy() {
    __classPrivateFieldGet(this, _Session_eventEmitter, "f").emit("session:destroy", { username: this.username });
    await __classPrivateFieldGet(this, _Session_storage, "f").removeItem(__classPrivateFieldGet(this, _Session_storage, "f").KEYS.ACCOUNT_UCAN);
    await __classPrivateFieldGet(this, _Session_storage, "f").removeItem(__classPrivateFieldGet(this, _Session_storage, "f").KEYS.CID_LOG);
    await __classPrivateFieldGet(this, _Session_storage, "f").removeItem(__classPrivateFieldGet(this, _Session_storage, "f").KEYS.SESSION);
    await __classPrivateFieldGet(this, _Session_storage, "f").removeItem(__classPrivateFieldGet(this, _Session_storage, "f").KEYS.UCANS);
    await __classPrivateFieldGet(this, _Session_crypto, "f").keystore.clearStore();
    if (this.fs)
      this.fs.deactivate();
  }
};
_Session_crypto = /* @__PURE__ */ new WeakMap(), _Session_storage = /* @__PURE__ */ new WeakMap(), _Session_eventEmitter = /* @__PURE__ */ new WeakMap();
function isSessionInfo(a) {
  return isObject(a) && hasProp(a, "username") && hasProp(a, "type");
}
async function restore(storage2) {
  return storage2.getItem(storage2.KEYS.SESSION).then((a) => a ? a : null).then((a) => a ? JSON.parse(a) : null).then((a) => isSessionInfo(a) ? a : null);
}
function provide(storage2, info) {
  return storage2.setItem(storage2.KEYS.SESSION, JSON.stringify({ type: info.type, username: info.username }));
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/base.js
var TYPE = "webCrypto";
async function canDelegateAccount(dependencies, username) {
  const didFromDNS = await dependencies.reference.didRoot.lookup(username);
  const maybeUcan = await dependencies.storage.getItem(dependencies.storage.KEYS.ACCOUNT_UCAN);
  if (maybeUcan) {
    const rootIssuerDid = rootIssuer(maybeUcan);
    const decodedUcan = decode(maybeUcan);
    const { ptc } = decodedUcan.payload;
    return didFromDNS === rootIssuerDid && ptc === "SUPER_USER";
  } else {
    const rootDid = await write(dependencies.crypto);
    return didFromDNS === rootDid;
  }
}
async function delegateAccount(dependencies, username, audience) {
  const proof = await dependencies.storage.getItem(dependencies.storage.KEYS.ACCOUNT_UCAN) ?? void 0;
  const u = await build({
    dependencies,
    audience,
    issuer: await write(dependencies.crypto),
    lifetimeInSeconds: 60 * 60 * 24 * 30 * 12 * 1e3,
    potency: "SUPER_USER",
    proof
    // TODO: UCAN v0.7.0
    // proofs: [ await localforage.getItem(dependencies.storage.KEYS.ACCOUNT_UCAN) ]
  });
  return { token: encode(u) };
}
async function linkDevice(dependencies, username, data) {
  const { token } = data;
  const u = decode(token);
  if (await isValid(dependencies.crypto, u)) {
    await dependencies.storage.setItem(dependencies.storage.KEYS.ACCOUNT_UCAN, token);
    await provide(dependencies.storage, { type: TYPE, username });
  }
}
async function register(dependencies, options) {
  await provide(dependencies.storage, { type: options.type || TYPE, username: options.username });
  return { success: true };
}
async function session(components, authedUsername, config2, eventEmitters) {
  if (authedUsername) {
    const session3 = new Session({
      crypto: components.crypto,
      storage: components.storage,
      eventEmitter: eventEmitters.session,
      type: TYPE,
      username: authedUsername
    });
    return session3;
  } else {
    return null;
  }
}
function implementation(dependencies) {
  return {
    type: TYPE,
    canDelegateAccount: (...args) => canDelegateAccount(dependencies, ...args),
    delegateAccount: (...args) => delegateAccount(dependencies, ...args),
    linkDevice: (...args) => linkDevice(dependencies, ...args),
    register: (...args) => register(dependencies, ...args),
    session,
    // Have to be implemented properly by other implementations
    createChannel: () => {
      throw new Error("Not implemented");
    },
    isUsernameValid: () => {
      throw new Error("Not implemented");
    },
    isUsernameAvailable: () => {
      throw new Error("Not implemented");
    }
  };
}

// node_modules/@oddjs/odd/lib/linking/common.js
var LinkingStep;
(function(LinkingStep2) {
  LinkingStep2["Broadcast"] = "BROADCAST";
  LinkingStep2["Negotiation"] = "NEGOTIATION";
  LinkingStep2["Delegation"] = "DELEGATION";
})(LinkingStep || (LinkingStep = {}));
var LinkingError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LinkingError";
  }
};
var LinkingWarning = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LinkingWarning";
  }
};
var handleLinkingError = (manners2, error) => {
  switch (error.name) {
    case "LinkingWarning":
      manners2.warn(error.message);
      break;
    case "LinkingError":
      throw error;
    default:
      throw error;
  }
};
var tryParseMessage = (data, typeGuard, context) => {
  try {
    const message = JSON.parse(data);
    if (typeGuard(message)) {
      return {
        ok: true,
        value: message
      };
    } else {
      return {
        ok: false,
        error: new LinkingWarning(`${context.participant} received an unexpected message in ${context.callSite}: ${data}. Ignoring message.`)
      };
    }
  } catch {
    return {
      ok: false,
      error: new LinkingWarning(`${context.participant} received a message in ${context.callSite} that it could not parse: ${data}. Ignoring message.`)
    };
  }
};

// node_modules/@oddjs/odd/lib/linking/consumer.js
var createConsumer = async (dependencies, options) => {
  const { username } = options;
  const handleLinkingError2 = (errorOrWarning) => handleLinkingError(dependencies.manners, errorOrWarning);
  let eventEmitter = new EventEmitter();
  const ls = {
    username,
    sessionKey: null,
    temporaryRsaPair: null,
    step: LinkingStep.Broadcast
  };
  const handleMessage = async (event) => {
    const { data } = event;
    const message = data.arrayBuffer ? new TextDecoder().decode(await data.arrayBuffer()) : data;
    switch (ls.step) {
      case LinkingStep.Broadcast:
        return handleLinkingError2(new LinkingWarning("Consumer is not ready to start linking"));
      case LinkingStep.Negotiation:
        if (ls.sessionKey) {
          handleLinkingError2(new LinkingWarning("Consumer already received a session key"));
        } else if (!ls.temporaryRsaPair || !ls.temporaryRsaPair.privateKey) {
          handleLinkingError2(new LinkingError("Consumer missing RSA key pair when handling session key message"));
        } else {
          const sessionKeyResult = await handleSessionKey(dependencies.crypto, ls.temporaryRsaPair.privateKey, message);
          if (sessionKeyResult.ok) {
            ls.sessionKey = sessionKeyResult.value;
            const { pin, challenge } = await generateUserChallenge(dependencies.crypto, ls.sessionKey);
            channel.send(challenge);
            eventEmitter?.emit("challenge", { pin: Array.from(pin) });
            ls.step = LinkingStep.Delegation;
          } else {
            handleLinkingError2(sessionKeyResult.error);
          }
        }
        break;
      case LinkingStep.Delegation:
        if (!ls.sessionKey) {
          handleLinkingError2(new LinkingError("Consumer was missing session key when linking device"));
        } else if (!ls.username) {
          handleLinkingError2(new LinkingError("Consumer was missing username when linking device"));
        } else {
          const linkingResult = await linkDevice2(dependencies.auth, dependencies.crypto, ls.sessionKey, ls.username, message);
          if (linkingResult.ok) {
            const { approved } = linkingResult.value;
            eventEmitter?.emit("link", { approved, username: ls.username });
            await done();
          } else {
            handleLinkingError2(linkingResult.error);
          }
        }
        break;
    }
  };
  const done = async () => {
    eventEmitter?.emit("done", void 0);
    eventEmitter = null;
    channel.close();
    clearInterval(rsaExchangeInterval);
  };
  const channel = await dependencies.auth.createChannel({ handleMessage, username });
  const rsaExchangeInterval = setInterval(async () => {
    if (!ls.sessionKey) {
      const { temporaryRsaPair, temporaryDID } = await generateTemporaryExchangeKey(dependencies.crypto);
      ls.temporaryRsaPair = temporaryRsaPair;
      ls.step = LinkingStep.Negotiation;
      channel.send(temporaryDID);
    } else {
      clearInterval(rsaExchangeInterval);
    }
  }, 2e3);
  return {
    on: (...args) => eventEmitter?.on(...args),
    cancel: done
  };
};
var generateTemporaryExchangeKey = async (crypto3) => {
  const temporaryRsaPair = await crypto3.rsa.genKey();
  const pubKey = await crypto3.rsa.exportPublicKey(temporaryRsaPair.publicKey);
  const temporaryDID = publicKeyToDid(crypto3, pubKey, "rsa");
  return { temporaryRsaPair, temporaryDID };
};
var handleSessionKey = async (crypto3, temporaryRsaPrivateKey, data) => {
  const typeGuard = (message) => {
    return isObject(message) && "iv" in message && typeof message.iv === "string" && "msg" in message && typeof message.msg === "string" && "sessionKey" in message && typeof message.sessionKey === "string";
  };
  const parseResult = tryParseMessage(data, typeGuard, { participant: "Consumer", callSite: "handleSessionKey" });
  if (parseResult.ok) {
    const { iv: encodedIV, msg, sessionKey: encodedSessionKey } = parseResult.value;
    const iv = fromString2(encodedIV, "base64pad");
    let sessionKey;
    try {
      const encryptedSessionKey = fromString2(encodedSessionKey, "base64pad");
      sessionKey = await crypto3.rsa.decrypt(encryptedSessionKey, temporaryRsaPrivateKey);
    } catch {
      return { ok: false, error: new LinkingWarning(`Consumer received a session key in handleSessionKey that it could not decrypt: ${data}. Ignoring message`) };
    }
    let encodedUcan = null;
    try {
      encodedUcan = await crypto3.aes.decrypt(fromString2(msg, "base64pad"), sessionKey, SymmAlg.AES_GCM, iv);
    } catch {
      return { ok: false, error: new LinkingError("Consumer could not decrypt closed UCAN with provided session key.") };
    }
    const decodedUcan = decode(toString3(encodedUcan, "utf8"));
    if (await isValid(crypto3, decodedUcan) === false) {
      return { ok: false, error: new LinkingError("Consumer received an invalid closed UCAN") };
    }
    if (decodedUcan.payload.ptc) {
      return { ok: false, error: new LinkingError("Consumer received a closed UCAN with potency. Closed UCAN must not have potency.") };
    }
    const sessionKeyFromFact = decodedUcan.payload.fct[0] && decodedUcan.payload.fct[0].sessionKey;
    if (!sessionKeyFromFact) {
      return { ok: false, error: new LinkingError("Consumer received a closed UCAN that was missing a session key in facts.") };
    }
    const sessionKeyWeAlreadyGot = toString3(sessionKey, "base64pad");
    if (sessionKeyFromFact !== sessionKeyWeAlreadyGot) {
      return { ok: false, error: new LinkingError("Consumer received a closed UCAN session key does not match the session key") };
    }
    return { ok: true, value: sessionKey };
  } else {
    return parseResult;
  }
};
var generateUserChallenge = async (crypto3, sessionKey) => {
  const pin = Array.from(crypto3.misc.randomNumbers({ amount: 6 })).map((n) => n % 9);
  const iv = crypto3.misc.randomNumbers({ amount: 16 });
  const msg = await crypto3.aes.encrypt(fromString2(JSON.stringify({
    did: await write(crypto3),
    pin
  }), "utf8"), sessionKey, SymmAlg.AES_GCM, iv);
  const challenge = JSON.stringify({
    iv: toString3(iv, "base64pad"),
    msg: toString3(msg, "base64pad")
  });
  return { pin, challenge };
};
var linkDevice2 = async (auth2, crypto3, sessionKey, username, data) => {
  const typeGuard = (message) => {
    return isObject(message) && "iv" in message && typeof message.iv === "string" && "msg" in message && typeof message.msg === "string";
  };
  const parseResult = tryParseMessage(data, typeGuard, { participant: "Consumer", callSite: "linkDevice" });
  if (parseResult.ok) {
    const { iv: encodedIV, msg } = parseResult.value;
    const iv = fromString2(encodedIV, "base64");
    let message = null;
    try {
      message = await crypto3.aes.decrypt(fromString2(msg, "base64pad"), sessionKey, SymmAlg.AES_GCM, iv);
    } catch {
      return { ok: false, error: new LinkingWarning("Consumer ignoring message that could not be decrypted in linkDevice.") };
    }
    const response = tryParseMessage(toString3(message, "utf8"), isObject, { participant: "Consumer", callSite: "linkDevice" });
    if (!response.ok) {
      return response;
    }
    if (response?.value.linkStatus === "DENIED") {
      return { ok: true, value: { approved: false } };
    }
    await auth2.linkDevice(username, response.value);
    return { ok: true, value: { approved: true } };
  } else {
    return parseResult;
  }
};

// node_modules/@oddjs/odd/lib/linking/producer.js
var createProducer = async (dependencies, options) => {
  const { username } = options;
  const handleLinkingError2 = (errorOrWarning) => handleLinkingError(dependencies.manners, errorOrWarning);
  const canDelegateAccount3 = await dependencies.auth.canDelegateAccount(username);
  if (!canDelegateAccount3) {
    throw new LinkingError(`Producer cannot delegate account for username ${username}`);
  }
  let eventEmitter = new EventEmitter();
  const ls = {
    username,
    sessionKey: null,
    step: LinkingStep.Broadcast
  };
  const handleMessage = async (event) => {
    const { data } = event;
    const message = data.arrayBuffer ? new TextDecoder().decode(await data.arrayBuffer()) : data;
    switch (ls.step) {
      case LinkingStep.Broadcast: {
        const { sessionKey, sessionKeyMessage } = await generateSessionKey(dependencies.crypto, message);
        ls.sessionKey = sessionKey;
        ls.step = LinkingStep.Negotiation;
        return channel.send(sessionKeyMessage);
      }
      case LinkingStep.Negotiation:
        if (ls.sessionKey) {
          const userChallengeResult = await handleUserChallenge(dependencies.crypto, ls.sessionKey, message);
          ls.step = LinkingStep.Delegation;
          if (userChallengeResult.ok) {
            const { pin, audience } = userChallengeResult.value;
            const challengeOnce = () => {
              let called = false;
              return {
                confirmPin: async () => {
                  if (!called) {
                    called = true;
                    if (ls.sessionKey) {
                      await delegateAccount2(dependencies.auth, dependencies.crypto, ls.sessionKey, username, audience, finishDelegation);
                    } else {
                      handleLinkingError2(new LinkingError("Producer missing session key when delegating account"));
                    }
                  }
                },
                rejectPin: async () => {
                  if (!called) {
                    called = true;
                    if (ls.sessionKey) {
                      await declineDelegation(dependencies.crypto, ls.sessionKey, finishDelegation);
                    } else {
                      handleLinkingError2(new LinkingError("Producer missing session key when declining account delegation"));
                    }
                  }
                }
              };
            };
            const { confirmPin, rejectPin } = challengeOnce();
            eventEmitter?.emit("challenge", { pin, confirmPin, rejectPin });
          } else {
            handleLinkingError2(userChallengeResult.error);
          }
        } else {
          handleLinkingError2(new LinkingError("Producer missing session key when handling user challenge"));
        }
        break;
      case LinkingStep.Delegation:
        return handleLinkingError2(new LinkingWarning("Producer received an unexpected message while delegating an account. The message will be ignored."));
    }
  };
  const finishDelegation = async (delegationMessage, approved) => {
    await channel.send(delegationMessage);
    if (ls.username == null)
      return;
    eventEmitter?.emit("link", { approved, username: ls.username });
    resetLinkingState();
  };
  const resetLinkingState = () => {
    ls.sessionKey = null;
    ls.step = LinkingStep.Broadcast;
  };
  const cancel = async () => {
    eventEmitter?.emit("done", void 0);
    eventEmitter = null;
    channel.close();
  };
  const channel = await dependencies.auth.createChannel({ username, handleMessage });
  return {
    on: (...args) => eventEmitter?.on(...args),
    cancel
  };
};
var generateSessionKey = async (crypto3, didThrowaway) => {
  const sessionKey = await crypto3.aes.genKey(SymmAlg.AES_GCM);
  const exportedSessionKey = await crypto3.aes.exportKey(sessionKey);
  const { publicKey } = didToPublicKey(crypto3, didThrowaway);
  const encryptedSessionKey = await crypto3.rsa.encrypt(exportedSessionKey, publicKey);
  const u = await build({
    dependencies: { crypto: crypto3 },
    issuer: await write(crypto3),
    audience: didThrowaway,
    lifetimeInSeconds: 60 * 5,
    facts: [{ sessionKey: toString3(exportedSessionKey, "base64pad") }],
    potency: null
  });
  const iv = crypto3.misc.randomNumbers({ amount: 16 });
  const msg = await crypto3.aes.encrypt(fromString2(encode(u), "utf8"), sessionKey, SymmAlg.AES_GCM, iv);
  const sessionKeyMessage = JSON.stringify({
    iv: toString3(iv, "base64pad"),
    msg: toString3(msg, "base64pad"),
    sessionKey: toString3(encryptedSessionKey, "base64pad")
  });
  return {
    sessionKey,
    sessionKeyMessage
  };
};
var handleUserChallenge = async (crypto3, sessionKey, data) => {
  const typeGuard = (message) => {
    return isObject(message) && "iv" in message && typeof message.iv === "string" && "msg" in message && typeof message.msg === "string";
  };
  const parseResult = tryParseMessage(data, typeGuard, { participant: "Producer", callSite: "handleUserChallenge" });
  if (parseResult.ok) {
    const { iv: encodedIV, msg } = parseResult.value;
    const iv = fromString2(encodedIV, "base64pad");
    let message = null;
    try {
      message = await crypto3.aes.decrypt(fromString2(msg, "base64pad"), sessionKey, SymmAlg.AES_GCM, iv);
    } catch {
      return { ok: false, error: new LinkingWarning("Ignoring message that could not be decrypted.") };
    }
    const json = JSON.parse(toString3(message, "utf8"));
    const pin = json.pin ?? null;
    const audience = json.did ?? null;
    if (pin !== null && audience !== null) {
      return { ok: true, value: { pin, audience } };
    } else {
      return { ok: false, error: new LinkingError(`Producer received invalid pin ${json.pin} or audience ${json.audience}`) };
    }
  } else {
    return parseResult;
  }
};
var delegateAccount2 = async (auth2, crypto3, sessionKey, username, audience, finishDelegation) => {
  const delegation = await auth2.delegateAccount(username, audience);
  const message = JSON.stringify(delegation);
  const iv = crypto3.misc.randomNumbers({ amount: 16 });
  const msg = await crypto3.aes.encrypt(fromString2(message, "utf8"), sessionKey, SymmAlg.AES_GCM, iv);
  const delegationMessage = JSON.stringify({
    iv: toString3(iv, "base64pad"),
    msg: toString3(msg, "base64pad")
  });
  await finishDelegation(delegationMessage, true);
};
var declineDelegation = async (crypto3, sessionKey, finishDelegation) => {
  const message = JSON.stringify({ linkStatus: "DENIED" });
  const iv = crypto3.misc.randomNumbers({ amount: 16 });
  const msg = await crypto3.aes.encrypt(fromString2(message, "utf8"), sessionKey, SymmAlg.AES_GCM, iv);
  const delegationMessage = JSON.stringify({
    iv: toString3(iv, "base64pad"),
    msg: toString3(msg, "base64pad")
  });
  await finishDelegation(delegationMessage, false);
};

// node_modules/@oddjs/odd/lib/configuration.js
function addRootFileSystemPermissions(config2) {
  return { ...config2, permissions: { ...config2.permissions, ...ROOT_FILESYSTEM_PERMISSIONS } };
}
function namespace(config2) {
  return isString(config2.namespace) ? config2.namespace : appId(config2.namespace);
}

// node_modules/@oddjs/odd/node_modules/throttle-debounce/esm/index.js
function throttle(delay, noTrailing, callback, debounceMode) {
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  }
  if (typeof noTrailing !== "boolean") {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = void 0;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear4() {
      timeoutID = void 0;
    }
    if (debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      exec();
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear4 : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}

// node_modules/@oddjs/odd/lib/fs/errors.js
var NoPermissionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NoPermissionError";
  }
};

// node_modules/@oddjs/odd/lib/fs/protocol/public/skeleton.js
function nextNonEmpty(parts) {
  const next = parts.slice(1);
  if (next.length < 1) {
    return null;
  }
  return next;
}

// node_modules/@oddjs/odd/lib/fs/v1/PublicHistory.js
var PublicHistory = class _PublicHistory {
  constructor(node) {
    this.node = node;
  }
  /**
   * Go back one or more versions.
   *
   * @param delta Optional negative number to specify how far to go back
   */
  back(delta = -1) {
    const length8 = Math.abs(Math.min(delta, -1));
    return Array.from({ length: length8 }, (_, i) => i).reduce((promise) => promise.then((n) => n ? _PublicHistory._getPreviousVersion(n) : null), Promise.resolve(this.node));
  }
  // async forward(delta: number = 1): Promise<Maybe<Node>> {}
  /**
   * Get a version before a given timestamp.
   *
   * @param timestamp Unix timestamp in seconds
   */
  async prior(timestamp) {
    return _PublicHistory._prior(this.node, timestamp);
  }
  /**
   * List earlier versions along with the timestamp they were created.
   */
  async list(amount = 5) {
    const { acc } = await Array.from({ length: amount }, (_, i) => i).reduce((promise, i) => promise.then(({ node, acc: acc2 }) => {
      if (!node)
        return Promise.resolve({ node: null, acc: acc2 });
      return _PublicHistory._getPreviousVersion(node).then((n) => ({
        node: n,
        acc: [
          ...acc2,
          { delta: -(i + 1), timestamp: node.header.metadata.unixMeta.mtime }
        ]
      }));
    }), _PublicHistory._getPreviousVersion(this.node).then((n) => ({ node: n, acc: [] })));
    return acc;
  }
  /**
   * @internal
   */
  static async _getPreviousVersion(node) {
    if (!node.header.previous)
      return Promise.resolve(null);
    return node.fromCID(decodeCID(node.header.previous));
  }
  /**
   * @internal
   */
  static async _prior(node, timestamp) {
    if (node.header.metadata.unixMeta.mtime < timestamp)
      return node;
    const previous = await _PublicHistory._getPreviousVersion(node);
    return previous ? _PublicHistory._prior(previous, timestamp) : null;
  }
};

// node_modules/@oddjs/odd/lib/fs/v1/PublicFile.js
var PublicFile = class _PublicFile extends file_default {
  constructor({ depot: depot2, content, header, cid }) {
    super(content);
    this.depot = depot2;
    this.cid = cid;
    this.header = header;
    this.history = new PublicHistory(toHistoryNode(this));
    function toHistoryNode(file2) {
      return {
        ...file2,
        fromCID: async (cid2) => toHistoryNode(await _PublicFile.fromCID(depot2, cid2))
      };
    }
  }
  static instanceOf(obj) {
    return isObject(obj) && hasProp(obj, "content") && hasProp(obj, "header") && isFileHeader(obj.header);
  }
  static async create(depot2, content) {
    return new _PublicFile({
      depot: depot2,
      content,
      header: { metadata: empty2(true, latest) },
      cid: null
    });
  }
  static async fromCID(depot2, cid) {
    const info = await public_exports.get(depot2, cid);
    return _PublicFile.fromInfo(depot2, info, cid);
  }
  static async fromInfo(depot2, info, cid) {
    const { userland, metadata, previous } = info;
    const content = await basic_exports.getFile(depot2, decodeCID(userland));
    return new _PublicFile({
      depot: depot2,
      content,
      header: { metadata, previous },
      cid
    });
  }
  async putDetailed() {
    const details = await public_exports.putFile(this.depot, this.content, updateMtime(this.header.metadata), this.cid);
    this.cid = details.cid;
    return details;
  }
};
var PublicFile_default = PublicFile;

// node_modules/@oddjs/odd/lib/fs/v1/PublicTree.js
var PublicTree = class _PublicTree extends tree_default {
  constructor({ depot: depot2, reference: reference2, links: links2, header, cid }) {
    super();
    this.depot = depot2;
    this.reference = reference2;
    this.children = {};
    this.cid = cid;
    this.links = links2;
    this.header = header;
    this.history = new PublicHistory(toHistoryNode(this));
    function toHistoryNode(tree2) {
      return {
        ...tree2,
        fromCID: async (cid2) => toHistoryNode(await _PublicTree.fromCID(depot2, reference2, cid2))
      };
    }
  }
  static async empty(depot2, reference2) {
    return new _PublicTree({
      depot: depot2,
      reference: reference2,
      links: {},
      header: {
        metadata: empty2(false, latest),
        skeleton: {}
      },
      cid: null
    });
  }
  static async fromCID(depot2, reference2, cid) {
    const info = await public_exports.get(depot2, cid);
    if (!isTreeInfo(info)) {
      throw new Error(`Could not parse a valid public tree at: ${cid}`);
    }
    return _PublicTree.fromInfo(depot2, reference2, info, cid);
  }
  static async fromInfo(depot2, reference2, info, cid) {
    const { userland, metadata, previous, skeleton } = info;
    const links2 = await basic_exports.getFileSystemLinks(depot2, decodeCID(userland));
    return new _PublicTree({
      depot: depot2,
      reference: reference2,
      links: links2,
      header: { metadata, previous, skeleton },
      cid
    });
  }
  static instanceOf(obj) {
    return hasProp(obj, "links") && hasProp(obj, "header") && isLinks(obj.links) && isTreeHeader(obj.header);
  }
  async createChildTree(name8, onUpdate) {
    const child = await _PublicTree.empty(this.depot, this.reference);
    const existing = this.children[name8];
    if (existing) {
      if (PublicFile_default.instanceOf(existing)) {
        throw new Error(`There is a file at the given path: ${name8}`);
      } else if (!_PublicTree.instanceOf(existing)) {
        throw new Error(`Not a public tree at the given path: ${name8}`);
      } else {
        return existing;
      }
    }
    await this.updateDirectChild(child, name8, onUpdate);
    return child;
  }
  async createOrUpdateChildFile(content, name8, onUpdate) {
    const existing = await this.getDirectChild(name8);
    let file2;
    if (existing === null) {
      file2 = await PublicFile_default.create(this.depot, content);
    } else if (PublicFile_default.instanceOf(existing)) {
      file2 = await existing.updateContent(content);
    } else {
      throw new Error(`There is already a directory with that name: ${name8}`);
    }
    await this.updateDirectChild(file2, name8, onUpdate);
    return file2;
  }
  async putDetailed() {
    const details = await public_exports.putTree(this.depot, this.links, this.header.skeleton, this.header.metadata, this.cid);
    this.header.previous = this.cid || void 0;
    this.cid = details.cid;
    return details;
  }
  async updateDirectChild(child, name8, onUpdate) {
    if (this.readOnly)
      throw new Error("Tree is read-only");
    this.children[name8] = child;
    const details = await child.putDetailed();
    this.updateLink(name8, details);
    onUpdate && await onUpdate();
    return this;
  }
  removeDirectChild(name8) {
    delete this.links[name8];
    delete this.header.skeleton[name8];
    if (this.children[name8]) {
      delete this.children[name8];
    }
    return this;
  }
  async getDirectChild(name8) {
    let child = null;
    if (this.children[name8]) {
      return this.children[name8];
    }
    const childInfo = this.header.skeleton[name8] || null;
    if (childInfo === null)
      return null;
    if (isSkeletonInfo(childInfo)) {
      const cid = decodeCID(childInfo.cid);
      child = childInfo.isFile ? await PublicFile_default.fromCID(this.depot, cid) : await _PublicTree.fromCID(this.depot, this.reference, cid);
    } else if (isSoftLink(childInfo)) {
      return _PublicTree.resolveSoftLink(this.depot, this.reference, childInfo);
    }
    if (this.children[name8]) {
      return this.children[name8];
    }
    if (child)
      this.children[name8] = child;
    return child;
  }
  async get(path) {
    if (path.length < 1)
      return this;
    const res = await this.getRecurse(this.header.skeleton, path);
    if (isSkeletonInfo(res)) {
      const cid = decodeCID(res.cid);
      const info = await public_exports.get(this.depot, cid);
      return isFileInfo(info) ? PublicFile_default.fromInfo(this.depot, info, cid) : _PublicTree.fromInfo(this.depot, this.reference, info, cid);
    }
    return res;
  }
  async getRecurse(skel, path) {
    const head = path[0];
    const child = skel[head] || null;
    const nextPath = nextNonEmpty(path);
    if (isSoftLink(child)) {
      const resolved = await _PublicTree.resolveSoftLink(this.depot, this.reference, child);
      if (nextPath) {
        if (_PublicTree.instanceOf(resolved)) {
          return resolved.get(nextPath).then(makeReadOnly2);
        } else {
          return null;
        }
      }
      return resolved;
    } else if (child === null || nextPath === null) {
      return child;
    } else if (child.subSkeleton) {
      return this.getRecurse(child.subSkeleton, nextPath);
    } else {
      return null;
    }
  }
  // Links
  // -----
  assignLink({ name: name8, link, skeleton }) {
    this.links[name8] = link;
    this.header.skeleton[name8] = skeleton;
    this.header.metadata.unixMeta.mtime = Date.now();
  }
  static async resolveSoftLink(depot2, reference2, link) {
    const [domain, ...pieces] = link.ipns.split("/");
    const path = fromPosix(pieces.join("/"));
    const isPublic = isOnRootBranch(RootBranch.Public, path) || isOnRootBranch(RootBranch.Pretty, path);
    if (!isPublic)
      throw new Error("Mixing public and private soft links is not supported yet.");
    const rootCid = await reference2.dns.lookupDnsLink(domain);
    if (!rootCid)
      throw new Error(`Failed to resolve the soft link: ${link.ipns} - Could not resolve DNSLink`);
    const publicCid = (await basic_exports.getSimpleLinks(depot2, decodeCID(rootCid))).public.cid;
    const publicPath = removePartition(path);
    const publicTree = await _PublicTree.fromCID(depot2, reference2, decodeCID(publicCid));
    const item = await publicTree.get(unwrap(publicPath));
    if (item)
      item.readOnly = true;
    return item;
  }
  getLinks() {
    return Object.values(this.links).reduce((acc, cur) => {
      const s = this.header.skeleton[cur.name];
      return {
        ...acc,
        [cur.name]: s && s.isFile !== void 0 ? { ...cur, isFile: s.isFile } : { ...cur }
      };
    }, {});
  }
  updateLink(name8, result) {
    const { cid, metadata, userland, size, isFile: isFile3, skeleton } = result;
    this.assignLink({
      name: name8,
      link: make(name8, cid, false, size),
      skeleton: {
        cid: encodeCID(cid),
        metadata,
        userland,
        subSkeleton: skeleton,
        isFile: isFile3
      }
    });
    return this;
  }
  insertSoftLink({ name: name8, path, username }) {
    const softLink = {
      ipns: this.reference.dataRoot.domain(username) + `/public/${toPosix(path)}`,
      name: name8
    };
    this.assignLink({
      name: name8,
      link: softLink,
      skeleton: softLink
    });
    return this;
  }
};
function makeReadOnly2(maybeFileOrTree) {
  if (maybeFileOrTree)
    maybeFileOrTree.readOnly = true;
  return maybeFileOrTree;
}
var PublicTree_default = PublicTree;

// node_modules/@oddjs/odd/node_modules/multiformats/src/hashes/hasher.js
var from2 = ({ name: name8, code: code11, encode: encode26 }) => new Hasher(name8, code11, encode26);
var Hasher = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name8, code11, encode26) {
    this.name = name8;
    this.code = code11;
    this.encode = encode26;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest5) => create(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/wnfs/wasm_wnfs.js
var wasm;
var heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var WASM_VECTOR_LEN = 0;
var cachedUint8Memory0;
function getUint8Memory0() {
  if (cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString2 = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf2 = cachedTextEncoder.encode(arg);
  view.set(buf2);
  return {
    read: arg.length,
    written: buf2.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf2 = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf2.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf2.length).set(buf2);
    WASM_VECTOR_LEN = buf2.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code11 = arg.charCodeAt(offset);
    if (code11 > 127)
      break;
    mem[ptr + offset] = code11;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory0;
function getInt32Memory0() {
  if (cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name8 = val.name;
    if (typeof name8 == "string" && name8.length > 0) {
      return `Function(${name8})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length8 = val.length;
    let debug11 = "[";
    if (length8 > 0) {
      debug11 += debugString(val[0]);
    }
    for (let i = 1; i < length8; i++) {
      debug11 += ", " + debugString(val[i]);
    }
    debug11 += "]";
    return debug11;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
var CLOSURE_DTORS = new FinalizationRegistry((state) => {
  wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
});
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
        CLOSURE_DTORS.unregister(state);
      } else {
        state.a = a;
      }
    }
  };
  real.original = state;
  CLOSURE_DTORS.register(real, state, state);
  return real;
}
function __wbg_adapter_20(arg0, arg1, arg2) {
  wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ha1ec3a5271c97341(arg0, arg1, addHeapObject(arg2));
}
var stack_pointer = 32;
function addBorrowedObject(obj) {
  if (stack_pointer == 1)
    throw new Error("out of js stack");
  heap[--stack_pointer] = obj;
  return stack_pointer;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_exn_store(addHeapObject(e));
  }
}
function __wbg_adapter_82(arg0, arg1, arg2, arg3) {
  wasm.wasm_bindgen__convert__closures__invoke2_mut__h1338dfb1e5ae1cd8(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
var Code = Object.freeze({ DagProtobuf: 112, "112": "DagProtobuf", DagCbor: 113, "113": "DagCbor", DagJson: 297, "297": "DagJson", Raw: 85, "85": "Raw" });
var ForeignBlockStoreFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_foreignblockstore_free(ptr));
var PublicDirectoryFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_publicdirectory_free(ptr));
var PublicDirectory = class _PublicDirectory {
  static __wrap(ptr) {
    const obj = Object.create(_PublicDirectory.prototype);
    obj.ptr = ptr;
    PublicDirectoryFinalization.register(obj, obj.ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    PublicDirectoryFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_publicdirectory_free(ptr);
  }
  /**
  * Creates a new directory using the given metadata.
  * @param {Date} time
  */
  constructor(time) {
    try {
      const ret = wasm.publicdirectory_new(addBorrowedObject(time));
      return _PublicDirectory.__wrap(ret);
    } finally {
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Follows a path and fetches the node at the end of the path.
  * @param {Array<any>} path_segments
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  getNode(path_segments, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_getNode(retptr, this.ptr, addBorrowedObject(path_segments), addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Looks up a node by its path name in the current directory.
  * @param {string} path_segment
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  lookupNode(path_segment, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(path_segment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.publicdirectory_lookupNode(retptr, this.ptr, ptr0, len0, addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Stores directory in provided block store.
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  store(store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_store(retptr, this.ptr, addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Loads a directory given its CID from the block store.
  * @param {Uint8Array} cid
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  static load(cid, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(cid, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.publicdirectory_load(retptr, ptr0, len0, addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Reads specified file content from the directory.
  * @param {Array<any>} path_segments
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  read(path_segments, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_read(retptr, this.ptr, addBorrowedObject(path_segments), addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Returns the name and metadata of the direct children of a directory.
  * @param {Array<any>} path_segments
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  ls(path_segments, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_ls(retptr, this.ptr, addBorrowedObject(path_segments), addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Removes a file or directory from the directory.
  * @param {Array<any>} path_segments
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  rm(path_segments, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_rm(retptr, this.ptr, addBorrowedObject(path_segments), addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Writes a file to the directory.
  * @param {Array<any>} path_segments
  * @param {Uint8Array} content_cid
  * @param {Date} time
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  write(path_segments, content_cid, time, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(content_cid, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.publicdirectory_write(retptr, this.ptr, addBorrowedObject(path_segments), ptr0, len0, addBorrowedObject(time), addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Moves a specified path to a new location.
  * @param {Array<any>} path_segments_from
  * @param {Array<any>} path_segments_to
  * @param {Date} time
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  basicMv(path_segments_from, path_segments_to, time, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_basicMv(retptr, this.ptr, addBorrowedObject(path_segments_from), addBorrowedObject(path_segments_to), addBorrowedObject(time), addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
      heap[stack_pointer++] = void 0;
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Creates a new directory at the specified path.
  *
  * This method acts like `mkdir -p` in Unix because it creates intermediate directories if they do not exist.
  * @param {Array<any>} path_segments
  * @param {Date} time
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  mkdir(path_segments, time, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_mkdir(retptr, this.ptr, addBorrowedObject(path_segments), addBorrowedObject(time), addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * @param {PublicDirectory} base
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  baseHistoryOn(base7, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(base7, _PublicDirectory);
      wasm.publicdirectory_baseHistoryOn(retptr, this.ptr, base7.ptr, addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Gets the previous cid of the directory or null if it doesn't have a previous cid.
  * @returns {any}
  */
  previousCid() {
    const ret = wasm.publicdirectory_previousCid(this.ptr);
    return takeObject(ret);
  }
  /**
  * Gets the metadata of the directory
  * @returns {any}
  */
  metadata() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_metadata(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Converts directory to a node.
  * @returns {PublicNode}
  */
  asNode() {
    const ret = wasm.publicdirectory_asNode(this.ptr);
    return PublicNode.__wrap(ret);
  }
  /**
  * Gets a unique id for node.
  * @returns {string}
  */
  getId() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicdirectory_getId(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_free(r0, r1);
    }
  }
};
var PublicFileFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_publicfile_free(ptr));
var PublicFile2 = class _PublicFile {
  static __wrap(ptr) {
    const obj = Object.create(_PublicFile.prototype);
    obj.ptr = ptr;
    PublicFileFinalization.register(obj, obj.ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    PublicFileFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_publicfile_free(ptr);
  }
  /**
  * Creates a new file in a WNFS public file system.
  * @param {Date} time
  * @param {Uint8Array} cid
  */
  constructor(time, cid) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(cid, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.publicfile_new(retptr, addBorrowedObject(time), ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return _PublicFile.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
  * Gets a unique id for node.
  * @returns {string}
  */
  getId() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicfile_getId(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_free(r0, r1);
    }
  }
  /**
  * Stores a file in provided block store.
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  store(store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicfile_store(retptr, this.ptr, addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Loads a file given its CID from the block store.
  * @param {Uint8Array} cid
  * @param {BlockStore} store
  * @returns {Promise<any>}
  */
  static load(cid, store2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(cid, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.publicfile_load(retptr, ptr0, len0, addHeapObject(store2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Gets the previous cid of the file or null if the file doesn't have a previous cid.
  * @returns {any}
  */
  previousCid() {
    const ret = wasm.publicfile_previousCid(this.ptr);
    return takeObject(ret);
  }
  /**
  * Gets the metadata of this file.
  * @returns {any}
  */
  metadata() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicfile_metadata(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Gets the content cid of the file.
  * @returns {Uint8Array}
  */
  contentCid() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicfile_contentCid(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v02 = getArrayU8FromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 1);
      return v02;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
var PublicNodeFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_publicnode_free(ptr));
var PublicNode = class _PublicNode {
  static __wrap(ptr) {
    const obj = Object.create(_PublicNode.prototype);
    obj.ptr = ptr;
    PublicNodeFinalization.register(obj, obj.ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    PublicNodeFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_publicnode_free(ptr);
  }
  /**
  * @returns {PublicDirectory}
  */
  asDir() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicnode_asDir(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return PublicDirectory.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @returns {PublicFile}
  */
  asFile() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicnode_asFile(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return PublicFile2.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @returns {boolean}
  */
  isDir() {
    const ret = wasm.publicnode_isDir(this.ptr);
    return ret !== 0;
  }
  /**
  * @returns {boolean}
  */
  isFile() {
    const ret = wasm.publicnode_isFile(this.ptr);
    return ret !== 0;
  }
  /**
  * @returns {string}
  */
  getId() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publicnode_getId(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_free(r0, r1);
    }
  }
};
async function load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes2 = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes2, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function getImports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbg_publicdirectory_new = function(arg0) {
    const ret = PublicDirectory.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_publicfile_new = function(arg0) {
    const ret = PublicFile2.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_publicnode_new = function(arg0) {
    const ret = PublicNode.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_putBlock_88cdb3be9020efb7 = function(arg0, arg1, arg2, arg3) {
    var v02 = getArrayU8FromWasm0(arg1, arg2).slice();
    wasm.__wbindgen_free(arg1, arg2 * 1);
    const ret = getObject(arg0).putBlock(v02, arg3 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getBlock_ef67031e09d5c6fd = function(arg0, arg1, arg2) {
    var v02 = getArrayU8FromWasm0(arg1, arg2).slice();
    wasm.__wbindgen_free(arg1, arg2 * 1);
    const ret = getObject(arg0).getBlock(v02);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_bigint_new = function(arg0, arg1) {
    const ret = BigInt(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbg_new_693216e109162396 = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {
    try {
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(arg0, arg1);
    }
  };
  imports.wbg.__wbg_get_f0f4f1608ebf633e = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_93debb0e2e184ab6 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_new_2ab697f1555e0dbc = function() {
    const ret = new Array();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_306ce8d57919e6ae = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_push_811c8b08bf4ff9d5 = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_new_651776e932b7e9c7 = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_9855a4612eb496cb = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getTime_7c8d3b79f51e2b87 = function(arg0) {
    const ret = getObject(arg0).getTime();
    return ret;
  };
  imports.wbg.__wbg_new_78403b138428b684 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = (arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_82(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      };
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_resolve_f269ce174f88b294 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_1c698eedca15eed6 = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_4debc41d4fc92ce5 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_buffer_de1150f91b23aa89 = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_9ca61320599a2c84 = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_97cf52648830a70d = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_a0172b213e2469e9 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_length_e09c0b925ab8de5d = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_set_b12cd0ab82903c2f = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper945 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 417, __wbg_adapter_20);
    return addHeapObject(ret);
  };
  return imports;
}
function initMemory(imports, maybe_memory) {
}
function finalizeInit(instance, module2) {
  wasm = instance.exports;
  init.__wbindgen_wasm_module = module2;
  cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  return wasm;
}
async function init(input) {
  if (typeof input === "undefined") {
    input = new URL("wasm_wnfs_bg.wasm", import.meta.url);
  }
  const imports = getImports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  initMemory(imports);
  const { instance, module: module2 } = await load(await input, imports);
  return finalizeInit(instance, module2);
}
var wasm_wnfs_default = init;

// node_modules/@oddjs/odd/lib/fs/v3/DepotBlockStore.js
var DepotBlockStore = class {
  constructor(depot2) {
    this.depot = depot2;
  }
  /** Stores an array of bytes in the block store. */
  async getBlock(cid) {
    const decodedCid = CID.decode(cid);
    return await this.depot.getBlock(decodedCid);
  }
  /** Retrieves an array of bytes from the block store with given CID. */
  async putBlock(bytes2, code11) {
    if (!isIdentifier(code11))
      throw new Error(`No codec was registered for the code: ${numberHex(code11)}`);
    const cid = await this.depot.putBlock(bytes2, code11);
    return cid.bytes;
  }
};

// node_modules/@oddjs/odd/lib/fs/v3/PublicRootWasm.js
var initialized = false;
async function loadWasm({ manners: manners2 }) {
  if (initialized)
    return;
  initialized = true;
  manners2.log(`\u23EC Loading WNFS WASM`);
  const before = performance.now();
  await wasm_wnfs_default(manners2.wnfsWasmLookup(WASM_WNFS_VERSION));
  const time = performance.now() - before;
  manners2.log(`\u{1F9EA} Loaded WNFS WASM (${time.toFixed(0)}ms)`);
}
var PublicRootWasm = class _PublicRootWasm {
  constructor(dependencies, root3, store2, readOnly) {
    this.dependencies = dependencies;
    this.root = Promise.resolve(root3);
    this.lastRoot = root3;
    this.store = store2;
    this.readOnly = readOnly;
  }
  static async empty(dependencies) {
    await loadWasm(dependencies);
    const store2 = new DepotBlockStore(dependencies.depot);
    const root3 = new PublicDirectory(/* @__PURE__ */ new Date());
    return new _PublicRootWasm(dependencies, root3, store2, false);
  }
  static async fromCID(dependencies, cid) {
    await loadWasm(dependencies);
    const store2 = new DepotBlockStore(dependencies.depot);
    const root3 = await PublicDirectory.load(cid.bytes, store2);
    return new _PublicRootWasm(dependencies, root3, store2, false);
  }
  async atomically(fn) {
    const root3 = await this.root;
    this.root = fn(root3);
    await this.root;
  }
  async withError(operation, opDescription) {
    try {
      return await operation;
    } catch (e) {
      console.error(`Error during WASM operation ${opDescription}:`);
      throw e;
    }
  }
  async ls(path) {
    const root3 = await this.root;
    const { result: node } = await this.withError(root3.getNode(path, this.store), `ls(${path.join("/")})`);
    if (node == null) {
      throw new Error(`Can't ls ${path.join("/")}: No such directory`);
    }
    if (!node.isDir()) {
      throw new Error(`Can't ls ${path.join("/")}: Not a directory`);
    }
    const directory2 = node.asDir();
    const { result: entries } = await this.withError(root3.ls(path, this.store), `ls(${path.join("/")})`);
    const result = {};
    for (const entry of entries) {
      const node2 = await directory2.lookupNode(entry.name, this.store);
      const cid = node2.isFile() ? CID.decode(await node2.asFile().store(this.store)) : CID.decode(await node2.asDir().store(this.store));
      result[entry.name] = {
        name: entry.name,
        isFile: entry.metadata.unixMeta.kind === "file",
        size: 0,
        cid
      };
    }
    return result;
  }
  async mkdir(path) {
    await this.atomically(async (root3) => {
      const { rootDir } = await this.withError(root3.mkdir(path, /* @__PURE__ */ new Date(), this.store), `mkdir(${path.join("/")})`);
      return rootDir;
    });
    return this;
  }
  async cat(path) {
    const root3 = await this.root;
    const { result: cidBytes } = await this.withError(root3.read(path, this.store), `read(${path.join("/")})`);
    const cid = CID.decode(cidBytes);
    return this.dependencies.depot.getUnixFile(cid);
  }
  async add(path, content) {
    const { cid } = await this.dependencies.depot.putChunked(content);
    await this.atomically(async (root3) => {
      const { rootDir } = await this.withError(root3.write(path, cid.bytes, /* @__PURE__ */ new Date(), this.store), `write(${path.join("/")})`);
      return rootDir;
    });
    return this;
  }
  async rm(path) {
    await this.atomically(async (root3) => {
      const { rootDir } = await this.withError(root3.rm(path, this.store), `rm(${path.join("/")})`);
      return rootDir;
    });
    return this;
  }
  async mv(from12, to) {
    await this.atomically(async (root3) => {
      const { rootDir } = await this.withError(root3.basicMv(from12, to, /* @__PURE__ */ new Date(), this.store), `basicMv(${from12.join("/")}, ${to.join("/")})`);
      return rootDir;
    });
    return this;
  }
  async get(path) {
    const root3 = await this.root;
    const { result: node } = await this.withError(root3.getNode(path, this.store), `getNode(${path.join("/")})`);
    if (node == null) {
      return null;
    }
    if (node.isFile()) {
      const cachedFile = node.asFile();
      const content = await this.cat(path);
      const directory2 = path.slice(0, -1);
      const filename = path[path.length - 1];
      return new PublicFileWasm(content, directory2, filename, this, cachedFile);
    } else if (node.isDir()) {
      const cachedDir = node.asDir();
      return new PublicDirectoryWasm(this.readOnly, path, this, cachedDir);
    }
    throw new Error(`Unknown node type. Can only handle files and directories.`);
  }
  async exists(path) {
    const root3 = await this.root;
    try {
      await root3.getNode(path, this.store);
      return true;
    } catch {
      return false;
    }
  }
  async historyStep() {
    await this.atomically(async (root3) => {
      const { rootDir: rebasedRoot } = await root3.baseHistoryOn(this.lastRoot, this.store);
      this.lastRoot = root3;
      return rebasedRoot;
    });
    return await this.root;
  }
  async put() {
    const rebasedRoot = await this.historyStep();
    const cidBytes = await rebasedRoot.store(this.store);
    return CID.decode(cidBytes);
  }
  async putDetailed() {
    return {
      cid: await this.put(),
      size: 0,
      isFile: false
    };
  }
};
var PublicDirectoryWasm = class {
  constructor(readOnly, directory2, publicRoot, cachedDir) {
    this.readOnly = readOnly;
    this.directory = directory2;
    this.publicRoot = publicRoot;
    this.cachedDir = cachedDir;
  }
  checkMutability(operation) {
    if (this.readOnly)
      throw new Error(`Directory is read-only. Cannot ${operation}`);
  }
  async updateCache() {
    const root3 = await this.publicRoot.root;
    const node = await root3.getNode(this.directory, this.publicRoot.store);
    this.cachedDir = node.asDir();
  }
  get header() {
    return nodeHeader(this.cachedDir);
  }
  async ls(path) {
    return await this.publicRoot.ls([...this.directory, ...path]);
  }
  async mkdir(path) {
    this.checkMutability(`mkdir at ${[...this.directory, ...path].join("/")}`);
    await this.publicRoot.mkdir([...this.directory, ...path]);
    await this.updateCache();
    return this;
  }
  async cat(path) {
    return await this.publicRoot.cat([...this.directory, ...path]);
  }
  async add(path, content) {
    this.checkMutability(`write at ${[...this.directory, ...path].join("/")}`);
    await this.publicRoot.add([...this.directory, ...path], content);
    await this.updateCache();
    return this;
  }
  async rm(path) {
    this.checkMutability(`remove at ${[...this.directory, ...path].join("/")}`);
    await this.publicRoot.rm([...this.directory, ...path]);
    await this.updateCache();
    return this;
  }
  async mv(from12, to) {
    this.checkMutability(`mv from ${[...this.directory, ...from12].join("/")} to ${[...this.directory, ...to].join("/")}`);
    await this.publicRoot.mv([...this.directory, ...from12], [...this.directory, ...to]);
    await this.updateCache();
    return this;
  }
  async get(path) {
    return await this.publicRoot.get([...this.directory, ...path]);
  }
  async exists(path) {
    return await this.publicRoot.exists([...this.directory, ...path]);
  }
  async put() {
    await this.publicRoot.put();
    const root3 = await this.publicRoot.root;
    const cidBytes = await root3.store(this.publicRoot.store);
    return CID.decode(cidBytes);
  }
  async putDetailed() {
    return {
      isFile: false,
      size: 0,
      cid: await this.put()
    };
  }
};
var PublicFileWasm = class extends BaseFile {
  constructor(content, directory2, filename, publicRoot, cachedFile) {
    super(content);
    this.directory = directory2;
    this.filename = filename;
    this.publicRoot = publicRoot;
    this.cachedFile = cachedFile;
  }
  async updateCache() {
    const root3 = await this.publicRoot.root;
    const node = await root3.getNode([...this.directory, this.filename], this.publicRoot.store);
    this.cachedFile = node.asFile();
  }
  get header() {
    return nodeHeader(this.cachedFile);
  }
  async updateContent(content) {
    await super.updateContent(content);
    await this.updateCache();
    return this;
  }
  async putDetailed() {
    const root3 = await this.publicRoot.root;
    const path = [...this.directory, this.filename];
    const { result: node } = await root3.getNode(path, this.publicRoot.store);
    if (node == null) {
      throw new Error(`No file at /${path.join("/")}.`);
    }
    if (!node.isFile()) {
      throw new Error(`Not a file at /${path.join("/")}`);
    }
    const file2 = node.asFile();
    return {
      isFile: true,
      size: 0,
      cid: CID.decode(await file2.store(this.publicRoot.store))
    };
  }
};
function nodeHeader(node) {
  const meta = node.metadata();
  const metadata = {
    isFile: meta.unixMeta.kind === "file",
    version: meta.version,
    unixMeta: {
      _type: meta.unixMeta.kind,
      ctime: Number(meta.unixMeta.created),
      mtime: Number(meta.unixMeta.modified),
      mode: meta.unixMeta.mode
    }
  };
  const previous = node.previousCid();
  return previous == null ? { metadata } : {
    metadata,
    previous: CID.decode(previous)
  };
}

// node_modules/@oddjs/odd/lib/fs/root/tree.js
var RootTree = class _RootTree {
  constructor({ dependencies, links: links2, mmpt, privateLog, sharedCounter, sharedLinks, publicTree, prettyTree, privateNodes }) {
    this.dependencies = dependencies;
    this.links = links2;
    this.mmpt = mmpt;
    this.privateLog = privateLog;
    this.sharedCounter = sharedCounter;
    this.sharedLinks = sharedLinks;
    this.publicTree = publicTree;
    this.prettyTree = prettyTree;
    this.privateNodes = privateNodes;
  }
  // INITIALISATION
  // --------------
  static async empty({ accountDID, dependencies, rootKey, wnfsWasm: wnfsWasm2 }) {
    if (wnfsWasm2) {
      dependencies.manners.log(`\u26A0\uFE0F Running an EXPERIMENTAL new version of the file system: 3.0.0`);
    }
    const publicTree = wnfsWasm2 ? await PublicRootWasm.empty(dependencies) : await PublicTree_default.empty(dependencies.depot, dependencies.reference);
    const prettyTree = await tree_default2.empty(dependencies.depot);
    const mmpt = MMPT.create(dependencies.depot);
    const rootPath = toPosix(directory(RootBranch.Private));
    const rootTree = await PrivateTree.create(dependencies.crypto, dependencies.depot, dependencies.manners, dependencies.reference, mmpt, rootKey, null);
    await rootTree.put();
    const tree2 = new _RootTree({
      dependencies,
      links: {},
      mmpt,
      privateLog: [],
      sharedCounter: 1,
      sharedLinks: {},
      publicTree,
      prettyTree,
      privateNodes: {
        [rootPath]: rootTree
      }
    });
    await store({ accountDID, crypto: dependencies.crypto, readKey: rootKey });
    await tree2.setVersion(wnfsWasm2 ? wnfsWasm : latest);
    await Promise.all([
      tree2.updatePuttable(RootBranch.Public, publicTree),
      tree2.updatePuttable(RootBranch.Pretty, prettyTree),
      tree2.updatePuttable(RootBranch.Private, mmpt)
    ]);
    return tree2;
  }
  static async fromCID({ accountDID, dependencies, cid, permissions }) {
    const { crypto: crypto3, depot: depot2, manners: manners2 } = dependencies;
    const links2 = await basic_exports.getSimpleLinks(dependencies.depot, cid);
    const keys = await permissionKeys(crypto3, accountDID, permissions || ROOT_FILESYSTEM_PERMISSIONS);
    const version3 = await parseVersionFromLinks(dependencies.depot, links2);
    const wnfsWasm2 = equals4(version3, wnfsWasm);
    if (wnfsWasm2) {
      dependencies.manners.log(`\u26A0\uFE0F Running an EXPERIMENTAL new version of the file system: 3.0.0`);
    }
    const publicCID = links2[RootBranch.Public]?.cid || null;
    const publicTree = publicCID === null ? await PublicTree_default.empty(dependencies.depot, dependencies.reference) : wnfsWasm2 ? await PublicRootWasm.fromCID({ depot: depot2, manners: manners2 }, decodeCID(publicCID)) : await PublicTree_default.fromCID(dependencies.depot, dependencies.reference, decodeCID(publicCID));
    const prettyTree = links2[RootBranch.Pretty] ? await tree_default2.fromCID(dependencies.depot, decodeCID(links2[RootBranch.Pretty].cid)) : await tree_default2.empty(dependencies.depot);
    const privateCID = links2[RootBranch.Private]?.cid || null;
    let mmpt, privateNodes;
    if (privateCID === null) {
      mmpt = MMPT.create(dependencies.depot);
      privateNodes = {};
    } else {
      mmpt = await MMPT.fromCID(dependencies.depot, decodeCID(privateCID));
      privateNodes = await loadPrivateNodes(dependencies, accountDID, keys, mmpt);
    }
    const privateLogCid = links2[RootBranch.PrivateLog]?.cid;
    const privateLog = privateLogCid ? await getPB(depot2, decodeCID(privateLogCid)).then((dagNode) => dagNode.Links.map(fromDAGLink)).then((links3) => links3.sort((a, b) => {
      return parseInt(a.name, 10) - parseInt(b.name, 10);
    })) : [];
    const sharedCid = links2[RootBranch.Shared]?.cid || null;
    const sharedLinks = sharedCid ? await this.getSharedLinks(depot2, decodeCID(sharedCid)) : {};
    const sharedCounterCid = links2[RootBranch.SharedCounter]?.cid || null;
    const sharedCounter = sharedCounterCid ? await basic_exports.getFile(dependencies.depot, decodeCID(sharedCounterCid)).then((a) => JSON.parse(toString3(a, "utf8"))) : 1;
    const tree2 = new _RootTree({
      dependencies,
      links: links2,
      mmpt,
      privateLog,
      sharedCounter,
      sharedLinks,
      publicTree,
      prettyTree,
      privateNodes
    });
    if (links2[RootBranch.Version] == null) {
      await tree2.setVersion(latest);
    }
    return tree2;
  }
  // MUTATIONS
  // ---------
  async put() {
    const { cid } = await this.putDetailed();
    return cid;
  }
  async putDetailed() {
    return basic_exports.putLinks(this.dependencies.depot, this.links);
  }
  updateLink(name8, result) {
    const { cid, size, isFile: isFile3 } = result;
    this.links[name8] = make(name8, cid, isFile3, size);
    return this;
  }
  async updatePuttable(name8, puttable) {
    return this.updateLink(name8, await puttable.putDetailed());
  }
  // PRIVATE TREES
  // -------------
  findPrivateNode(path) {
    return findPrivateNode(this.privateNodes, path);
  }
  async addPrivateLogEntry(depot2, cid) {
    const log11 = [...this.privateLog];
    let idx = Math.max(0, log11.length - 1);
    let lastChunk = log11[idx]?.cid ? await depot2.getUnixFile(decodeCID(log11[idx].cid)).then((a) => toString3(a, "utf8")).then((a) => a.split(",")) : [];
    const needsNewChunk = lastChunk.length + 1 > _RootTree.LOG_CHUNK_SIZE;
    if (needsNewChunk) {
      idx = idx + 1;
      lastChunk = [];
    }
    const hashedCid = await this.dependencies.crypto.hash.sha256(fromString2(encodeCID(cid), "utf8"));
    const updatedChunk = [...lastChunk, hashedCid];
    const updatedChunkDeposit = await basic_exports.putFile(this.dependencies.depot, fromString2(updatedChunk.join(","), "utf8"));
    log11[idx] = {
      name: idx.toString(),
      cid: updatedChunkDeposit.cid,
      size: updatedChunkDeposit.size
    };
    const logCID = await putPB(this.dependencies.depot, log11.map(toDAGLink));
    this.updateLink(RootBranch.PrivateLog, {
      cid: logCID,
      isFile: false,
      size: await this.dependencies.depot.size(logCID)
    });
    this.privateLog = log11;
  }
  // SHARING
  // -------
  async addShares(links2) {
    this.sharedLinks = links2.reduce((acc, link) => ({ ...acc, [link.name]: link }), this.sharedLinks);
    const cborApprovedLinks = Object.values(this.sharedLinks).reduce((acc, { cid: cid2, name: name8, size }) => ({
      ...acc,
      [name8]: { cid: cid2, name: name8, size }
    }), {});
    const cid = await this.dependencies.depot.putBlock(encode5(cborApprovedLinks), code);
    this.updateLink(RootBranch.Shared, {
      cid,
      isFile: false,
      size: await this.dependencies.depot.size(cid)
    });
    return this;
  }
  static async getSharedLinks(depot2, cid) {
    const block = await depot2.getBlock(cid);
    const decodedBlock = decode7(block);
    if (!isObject(decodedBlock))
      throw new Error("Invalid shared section, not an object");
    return Object.values(decodedBlock).reduce((acc, link) => {
      if (!isObject(link))
        return acc;
      const name8 = link.name ? link.name : null;
      const cid2 = link.cid ? decodeCID(link.cid) : null;
      if (!name8 || !cid2)
        return acc;
      return { ...acc, [name8]: { name: name8, cid: cid2, size: link.size || 0 } };
    }, {});
  }
  async setSharedCounter(counter) {
    this.sharedCounter = counter;
    const { cid, size } = await basic_exports.putFile(this.dependencies.depot, fromString2(JSON.stringify(counter), "utf8"));
    this.updateLink(RootBranch.SharedCounter, {
      cid,
      isFile: true,
      size
    });
    return counter;
  }
  async bumpSharedCounter() {
    const newCounter = this.sharedCounter + 1;
    return this.setSharedCounter(newCounter);
  }
  // VERSION
  // -------
  async setVersion(v) {
    const version3 = fromString2(toString6(v), "utf8");
    const result = await basic_exports.putFile(this.dependencies.depot, version3);
    return this.updateLink(RootBranch.Version, result);
  }
  async getVersion() {
    return await parseVersionFromLinks(this.dependencies.depot, this.links);
  }
};
RootTree.LOG_CHUNK_SIZE = 1020;
async function findBareNameFilter(crypto3, storage2, accountDID, map2, path) {
  const bareNameFilterId = await bareNameFilter({ accountDID, crypto: crypto3, path });
  const bareNameFilter2 = await storage2.getItem(bareNameFilterId);
  if (bareNameFilter2)
    return bareNameFilter2;
  const [nodePath, node] = findPrivateNode(map2, path);
  if (!node)
    return null;
  const unwrappedPath = unwrap(path);
  const relativePath = unwrappedPath.slice(unwrap(nodePath).length);
  if (PrivateFile_default.instanceOf(node)) {
    return relativePath.length === 0 ? node.header.bareNameFilter : null;
  }
  if (!node.exists(relativePath)) {
    if (isDirectory(path))
      await node.mkdir(relativePath);
    else
      await node.add(relativePath, new Uint8Array());
  }
  return node.get(relativePath).then((t) => t ? t.header.bareNameFilter : null);
}
function findPrivateNode(map2, path) {
  const t = map2[toPosix(path)];
  if (t)
    return [path, t];
  const parent2 = parent(path);
  return parent2 ? findPrivateNode(map2, parent2) : [path, null];
}
function loadPrivateNodes(dependencies, accountDID, pathKeys, mmpt) {
  const { crypto: crypto3, storage: storage2 } = dependencies;
  return sortedPathKeys(pathKeys).reduce((acc, { path, key }) => {
    return acc.then(async (map2) => {
      let privateNode2;
      const unwrappedPath = unwrap(path);
      if (unwrappedPath.length === 1 && unwrappedPath[0] === RootBranch.Private) {
        privateNode2 = await PrivateTree.fromBaseKey(dependencies.crypto, dependencies.depot, dependencies.manners, dependencies.reference, mmpt, key);
      } else {
        const bareNameFilter2 = await findBareNameFilter(crypto3, storage2, accountDID, map2, path);
        if (!bareNameFilter2)
          throw new Error(`Was trying to load the PrivateTree for the path \`${path}\`, but couldn't find the bare name filter for it.`);
        if (isDirectory(path)) {
          privateNode2 = await PrivateTree.fromBareNameFilter(dependencies.crypto, dependencies.depot, dependencies.manners, dependencies.reference, mmpt, bareNameFilter2, key);
        } else {
          privateNode2 = await PrivateFile_default.fromBareNameFilter(dependencies.crypto, dependencies.depot, mmpt, bareNameFilter2, key);
        }
      }
      const posixPath = toPosix(path);
      return { ...map2, [posixPath]: privateNode2 };
    });
  }, Promise.resolve({}));
}
async function parseVersionFromLinks(depot2, links2) {
  const file2 = await basic_exports.getFile(depot2, decodeCID(links2[RootBranch.Version].cid));
  return fromString5(toString3(file2)) ?? v0;
}
async function permissionKeys(crypto3, accountDID, permissions) {
  return permissionPaths(permissions).reduce(async (acc, path) => {
    if (isPartition(RootBranch.Public, path))
      return acc;
    const name8 = await readKey({ accountDID, crypto: crypto3, path });
    const key = await crypto3.keystore.exportSymmKey(name8);
    const pk = { path, key };
    return acc.then((list) => [...list, pk]);
  }, Promise.resolve([]));
}
function sortedPathKeys(list) {
  return list.sort((a, b) => toPosix(a.path).localeCompare(toPosix(b.path)));
}

// node_modules/@oddjs/odd/lib/fs/filesystem.js
var FileSystem = class _FileSystem {
  constructor({ account, dependencies, eventEmitter, root: root3, localOnly }) {
    this.account = account;
    this.dependencies = dependencies;
    this.eventEmitter = eventEmitter;
    this.localOnly = localOnly || false;
    this.proofs = {};
    this.publishHooks = [];
    this.root = root3;
    this._publishWhenOnline = [];
    this._publishing = false;
    this._whenOnline = this._whenOnline.bind(this);
    this._beforeLeaving = this._beforeLeaving.bind(this);
    const logCid = async (cid) => {
      await this.dependencies.reference.repositories.cidLog.add(cid);
      this.dependencies.manners.log("\u{1F4D3} Adding to the CID ledger:", cid.toString());
    };
    const updateDataRootWhenOnline = throttle(3e3, false, (cid, proof) => {
      if (globalThis.navigator.onLine) {
        this._publishing = [cid, true];
        return this.dependencies.reference.dataRoot.update(cid, proof).then(() => {
          if (this._publishing && this._publishing[0] === cid) {
            eventEmitter.emit("fileSystem:publish", { root: cid });
            this._publishing = false;
          }
        });
      }
      this._publishWhenOnline.push([cid, proof]);
    }, false);
    this.publishHooks.push(logCid);
    this.publishHooks.push(updateDataRootWhenOnline);
    if (!this.localOnly) {
      globalThis.addEventListener("online", this._whenOnline);
      globalThis.addEventListener("beforeunload", this._beforeLeaving);
    }
  }
  // INITIALISATION
  // --------------
  /**
   * Creates a file system with an empty public tree & an empty private tree at the root.
   */
  static async empty(opts) {
    const { account, dependencies, eventEmitter, localOnly } = opts;
    const rootKey = opts.rootKey || await dependencies.crypto.aes.genKey(DEFAULT_AES_ALG).then(dependencies.crypto.aes.exportKey);
    const wnfsWasm2 = opts.version === toString6(wnfsWasm);
    const root3 = await RootTree.empty({ accountDID: account.rootDID, dependencies, rootKey, wnfsWasm: wnfsWasm2 });
    return new _FileSystem({
      account,
      dependencies,
      eventEmitter,
      root: root3,
      localOnly
    });
  }
  /**
   * Loads an existing file system from a CID.
   */
  static async fromCID(cid, opts) {
    const { account, dependencies, eventEmitter, permissions, localOnly } = opts;
    const root3 = await RootTree.fromCID({ accountDID: account.rootDID, dependencies, cid, permissions });
    return new _FileSystem({
      account,
      dependencies,
      eventEmitter,
      root: root3,
      localOnly
    });
  }
  // DEACTIVATE
  // ----------
  /**
   * Deactivate a file system.
   *
   * Use this when a user signs out.
   * The only function of this is to stop listing to online/offline events.
   */
  deactivate() {
    if (this.localOnly)
      return;
    globalThis.removeEventListener("online", this._whenOnline);
    globalThis.removeEventListener("beforeunload", this._beforeLeaving);
  }
  // POSIX INTERFACE (DIRECTORIES)
  // -----------------------------
  async ls(path) {
    if (isFile(path))
      throw new Error("`ls` only accepts directory paths");
    return this.runOnNode(path, {
      public: async (root3, relPath) => {
        return root3.ls(relPath);
      },
      private: async (node, relPath) => {
        if (isFile2(node)) {
          throw new Error("Tried to `ls` a file");
        } else {
          return node.ls(relPath);
        }
      }
    });
  }
  async mkdir(path, options = {}) {
    if (isFile(path))
      throw new Error("`mkdir` only accepts directory paths");
    await this.runMutationOnNode(path, {
      public: async (root3, relPath) => {
        await root3.mkdir(relPath);
      },
      private: async (node, relPath) => {
        if (isFile2(node)) {
          throw new Error("Tried to `mkdir` a file");
        } else {
          await node.mkdir(relPath);
        }
      }
    });
    if (options.publish) {
      await this.publish();
    }
    return this;
  }
  // POSIX INTERFACE (FILES)
  // -----------------------
  async write(path, content, options = {}) {
    const contentIsSoftLinks = isSoftLink(content) || isSoftLinkDictionary(content) || isSoftLinkList(content);
    if (contentIsSoftLinks) {
      if (isFile(path)) {
        throw new Error("Can't add soft links to a file");
      }
      await this.runMutationOnNode(path, {
        public: async (root3, relPath) => {
          const links2 = Array.isArray(content) ? content : isObject(content) ? Object.values(content) : [content];
          await this.runOnChildTree(root3, relPath, async (tree2) => {
            links2.forEach((link) => {
              if (PrivateTree.instanceOf(tree2) || PublicTree_default.instanceOf(tree2))
                tree2.assignLink({
                  name: link.name,
                  link,
                  skeleton: link
                });
            });
            return tree2;
          });
        },
        private: async (node, relPath) => {
          const links2 = Array.isArray(content) ? content : isObject(content) ? Object.values(content) : [content];
          await this.runOnChildTree(node, relPath, async (tree2) => {
            links2.forEach((link) => {
              if (PrivateTree.instanceOf(tree2) || PublicTree_default.instanceOf(tree2))
                tree2.assignLink({
                  name: link.name,
                  link,
                  skeleton: link
                });
            });
            return tree2;
          });
        }
      });
    } else {
      if (isDirectory(path)) {
        throw new Error("`add` only accepts file paths when working with regular files");
      }
      await this.runMutationOnNode(path, {
        public: async (root3, relPath) => {
          await root3.add(relPath, content);
        },
        private: async (node, relPath) => {
          const destinationIsFile = isFile2(node);
          if (destinationIsFile) {
            await node.updateContent(content);
          } else {
            await node.add(relPath, content);
          }
        }
      });
    }
    if (options.publish) {
      await this.publish();
    }
    return this;
  }
  async read(path) {
    if (isDirectory(path))
      throw new Error("`cat` only accepts file paths");
    return this.runOnNode(path, {
      public: async (root3, relPath) => {
        return await root3.cat(relPath);
      },
      private: async (node, relPath) => {
        return isFile2(node) ? node.content : await node.cat(relPath);
      }
    });
  }
  // POSIX INTERFACE (GENERAL)
  // -------------------------
  async exists(path) {
    return this.runOnNode(path, {
      public: async (root3, relPath) => {
        return await root3.exists(relPath);
      },
      private: async (node, relPath) => {
        return isFile2(node) || await node.exists(relPath);
      }
    });
  }
  async get(path) {
    return this.runOnNode(path, {
      public: async (root3, relPath) => {
        return await root3.get(relPath);
      },
      private: async (node, relPath) => {
        return isFile2(node) ? node : await node.get(relPath);
      }
    });
  }
  // This is only implemented on the same tree for now and will error otherwise
  async mv(from12, to) {
    const sameTree = isSamePartition(from12, to);
    if (!isSameKind(from12, to)) {
      const kindFrom = kind(from12);
      const kindTo = kind(to);
      throw new Error(`Can't move to a different kind of path, from is a ${kindFrom} and to is a ${kindTo}`);
    }
    if (!sameTree) {
      throw new Error("`mv` is only supported on the same tree for now");
    }
    if (await this.exists(to)) {
      throw new Error("Destination already exists");
    }
    await this.runMutationOnNode(from12, {
      public: async (root3, relPath) => {
        const [_, ...nextPath] = unwrap(to);
        await root3.mv(relPath, nextPath);
      },
      private: async (node, relPath) => {
        if (isFile2(node)) {
          throw new Error("Tried to `mv` within a file");
        }
        const [_, ...nextPath] = unwrap(to);
        await node.mv(relPath, nextPath);
      }
    });
    return this;
  }
  /**
   * Resolve a symlink directly.
   * The `get` and `cat` methods will automatically resolve symlinks,
   * but sometimes when working with symlinks directly
   * you might want to use this method instead.
   */
  resolveSymlink(link) {
    if (hasProp(link, "privateName")) {
      return PrivateTree.resolveSoftLink(this.dependencies.crypto, this.dependencies.depot, this.dependencies.manners, this.dependencies.reference, link);
    } else {
      return PublicTree_default.resolveSoftLink(this.dependencies.depot, this.dependencies.reference, link);
    }
  }
  async rm(path) {
    await this.runMutationOnNode(path, {
      public: async (root3, relPath) => {
        await root3.rm(relPath);
      },
      private: async (node, relPath) => {
        if (isFile2(node)) {
          throw new Error("Cannot `rm` a file you've asked permission for");
        } else {
          await node.rm(relPath);
        }
      }
    });
    return this;
  }
  /**
   * Make a symbolic link **at** a path.
   */
  async symlink(args) {
    const { at, name: name8 } = args;
    const referringTo = args.referringTo.path;
    const username = args.referringTo.username || this.account.username;
    if (at == null)
      throw new Error("Missing parameter `symlink.at`");
    if (isFile(at))
      throw new Error("`symlink.at` only accepts directory paths");
    const sameTree = isSamePartition(at, referringTo);
    if (!username)
      throw new Error("I need a username in order to use this method");
    if (!sameTree)
      throw new Error("`link` is only supported on the same tree for now");
    await this.runMutationOnNode(at, {
      public: async (root3, relPath) => {
        if (tree_default2.instanceOf(root3))
          return;
        if (!PublicTree_default.instanceOf(root3)) {
          throw new Error(`Symlinks not supported in WASM-WNFS yet.`);
        } else {
          await this.runOnChildTree(root3, relPath, async (tree2) => {
            if (PublicTree_default.instanceOf(tree2)) {
              tree2.insertSoftLink({
                path: removePartition(referringTo),
                name: name8,
                username
              });
            }
            return tree2;
          });
        }
      },
      private: async (node, relPath) => {
        if (isFile2(node)) {
          throw new Error("Cannot add a soft link to a file");
        }
        await this.runOnChildTree(node, relPath, async (tree2) => {
          if (PrivateTree.instanceOf(tree2)) {
            const destNode = await this.runOnNode(referringTo, {
              public: async () => {
                throw new Error(`File system hit a public node within a private node. This is not supported/this should not happen.`);
              },
              private: async (a, relPath2) => {
                const b = isFile2(a) ? a : await a.get(relPath2);
                if (PrivateTree.instanceOf(b))
                  return b;
                else if (PrivateFile_default.instanceOf(b))
                  return b;
                else
                  throw new Error("`symlink.referringTo` is not of the right type");
              }
            });
            if (!destNode)
              throw new Error("Could not find the item the symlink is referring to");
            tree2.insertSoftLink({
              name: name8,
              username,
              key: destNode.key,
              privateName: await destNode.getName()
            });
          }
          return tree2;
        });
      }
    });
    return this;
  }
  // PUBLISH
  // -------
  /**
   * Ensures the latest version of the file system is added to IPFS,
   * updates your data root, and returns the root CID.
   */
  async publish() {
    const proofs = Array.from(Object.entries(this.proofs));
    this.proofs = {};
    const cid = await this.root.put();
    proofs.forEach(([_, proof]) => {
      this.publishHooks.forEach((hook) => hook(cid, proof));
    });
    return cid;
  }
  // HISTORY STEPPING
  // ----------------
  /**
   * Ensures the current version of your file system is "committed"
   * and stepped forward, so the current version will always be
   * persisted as an "step" in the history of the file system.
   *
   * This function is implicitly called every time your file system
   * changes are synced, so in most cases calling this is handled
   * for you.
   */
  async historyStep() {
    const publicTree = this.root.publicTree;
    if (hasProp(publicTree, "historyStep") && typeof publicTree.historyStep === "function") {
      await publicTree.historyStep();
    }
  }
  // SHARING
  // -------
  /**
   * Accept a share.
   * Copies the links to the items into your 'Shared with me' directory.
   * eg. `private/Shared with me/Sharer/`
   */
  async acceptShare({ shareId, sharedBy }) {
    const share = await this.loadShare({ shareId, sharedBy });
    await this.write(directory(RootBranch.Private, "Shared with me", sharedBy), await share.ls([]).then(Object.values).then((links2) => links2.filter(isSoftLink)));
    return this;
  }
  /**
   * Loads a share.
   * Returns a "entry index", in other words,
   * a private tree with symlinks (soft links) to the shared items.
   */
  async loadShare({ shareId, sharedBy }) {
    const ourExchangeDid = await exchange(this.dependencies.crypto);
    const theirRootDid = await this.dependencies.reference.didRoot.lookup(sharedBy);
    const key = await create5(this.dependencies.crypto, {
      counter: parseInt(shareId, 10),
      recipientExchangeDid: ourExchangeDid,
      senderRootDid: theirRootDid
    });
    const root3 = await this.dependencies.reference.dataRoot.lookup(sharedBy);
    if (!root3)
      throw new Error("This user doesn't have a filesystem yet.");
    const rootLinks = await basic_exports.getSimpleLinks(this.dependencies.depot, root3);
    const sharedLinksCid = rootLinks[RootBranch.Shared]?.cid || null;
    if (!sharedLinksCid)
      throw new Error("This user hasn't shared anything yet.");
    const sharedLinks = await RootTree.getSharedLinks(this.dependencies.depot, decodeCID(sharedLinksCid));
    const shareLink = isObject(sharedLinks) ? sharedLinks[key] : null;
    if (!shareLink)
      throw new Error("Couldn't find a matching share.");
    const shareLinkCid = isObject(shareLink) ? shareLink.cid : null;
    if (!shareLinkCid)
      throw new Error("Couldn't find a matching share.");
    const sharePayload = await this.dependencies.depot.getBlock(decodeCID(shareLinkCid));
    const decryptedPayload = await this.dependencies.crypto.keystore.decrypt(sharePayload);
    const decodedPayload = decode7(decryptedPayload);
    if (!hasProp(decodedPayload, "cid"))
      throw new Error("Share payload is missing the `cid` property");
    if (!hasProp(decodedPayload, "key"))
      throw new Error("Share payload is missing the `key` property");
    if (!hasProp(decodedPayload, "algo"))
      throw new Error("Share payload is missing the `algo` property");
    const entryIndexCid = decodedPayload.cid;
    const symmKey = decodedPayload.key;
    const symmKeyAlgo = decodedPayload.algo;
    const mmptCid = rootLinks[RootBranch.Private]?.cid;
    if (!mmptCid)
      throw new Error("This user's filesystem doesn't have a private branch");
    const theirMmpt = await MMPT.fromCID(this.dependencies.depot, decodeCID(rootLinks[RootBranch.Private]?.cid));
    const encryptedIndex = await this.dependencies.depot.getBlock(decodeCID(entryIndexCid));
    const indexInfoBytes = await this.dependencies.crypto.aes.decrypt(encryptedIndex, symmKey, symmKeyAlgo);
    const indexInfo = JSON.parse(toString3(indexInfoBytes, "utf8"));
    if (!isDecryptedNode(indexInfo))
      throw new Error("The share payload did not point to a valid entry index");
    return PrivateTree.fromInfo(this.dependencies.crypto, this.dependencies.depot, this.dependencies.manners, this.dependencies.reference, theirMmpt, symmKey, indexInfo);
  }
  /**
   * Share a private file with a user.
   */
  async sharePrivate(paths, { sharedBy, shareWith }) {
    const verifiedPaths = paths.filter((path) => {
      return isOnRootBranch(RootBranch.Private, path);
    });
    if (!sharedBy) {
      if (!this.account.username)
        throw new Error("I need a username in order to use this method");
      sharedBy = { rootDid: this.account.rootDID, username: this.account.username };
    }
    const items = await verifiedPaths.reduce(async (promise, path) => {
      const acc = await promise;
      const name8 = terminus(path);
      const item = await this.get(path);
      return name8 && (PrivateFile_default.instanceOf(item) || PrivateTree.instanceOf(item)) ? [...acc, [name8, item]] : acc;
    }, Promise.resolve([]));
    if (!items.length)
      throw new Error("Didn't find any items to share");
    const shareDetails = await privateNode(this.dependencies.crypto, this.dependencies.depot, this.dependencies.manners, this.dependencies.reference, this.root, items, { shareWith, sharedBy });
    await this.root.bumpSharedCounter();
    await this.root.updatePuttable(RootBranch.Private, this.root.mmpt);
    await this.publish();
    return shareDetails;
  }
  // INTERNAL
  // --------
  /** @internal */
  async checkMutationPermissionAndAddProof(path, isMutation) {
    const operation = isMutation ? "make changes to" : "query";
    if (!this.localOnly) {
      const proof = await this.dependencies.reference.repositories.ucans.lookupFilesystemUcan(path);
      if (!proof || isExpired(proof) || !proof.signature) {
        throw new NoPermissionError(`I don't have the necessary permissions to ${operation} the file system at "${toPosix(path)}"`);
      }
      this.proofs[proof.signature] = proof;
    }
  }
  /** @internal */
  async runMutationOnNode(path, handlers) {
    const parts = unwrap(path);
    const head = parts[0];
    const relPath = parts.slice(1);
    await this.checkMutationPermissionAndAddProof(path, true);
    if (head === RootBranch.Public) {
      await handlers.public(this.root.publicTree, relPath);
      await handlers.public(this.root.prettyTree, relPath);
      await Promise.all([
        this.root.updatePuttable(RootBranch.Public, this.root.publicTree),
        this.root.updatePuttable(RootBranch.Pretty, this.root.prettyTree)
      ]);
    } else if (head === RootBranch.Private) {
      const [nodePath, node] = this.root.findPrivateNode(path);
      if (!node) {
        throw new NoPermissionError(`I don't have the necessary permissions to make changes to the file system at "${toPosix(path)}"`);
      }
      await handlers.private(node, parts.slice(unwrap(nodePath).length));
      await node.put();
      await this.root.updatePuttable(RootBranch.Private, this.root.mmpt);
      const cid = await this.root.mmpt.put();
      await this.root.addPrivateLogEntry(this.dependencies.depot, cid);
    } else if (head === RootBranch.Pretty) {
      throw new Error("The pretty path is read only");
    } else {
      throw new Error("Not a valid FileSystem path");
    }
    this.eventEmitter.emit("fileSystem:local-change", { root: await this.root.put(), path });
  }
  /** @internal */
  async runOnNode(path, handlers) {
    const parts = unwrap(path);
    const head = parts[0];
    const relPath = parts.slice(1);
    await this.checkMutationPermissionAndAddProof(path, false);
    if (head === RootBranch.Public) {
      return await handlers.public(this.root.publicTree, relPath);
    } else if (head === RootBranch.Private) {
      const [nodePath, node] = this.root.findPrivateNode(path);
      if (!node) {
        throw new NoPermissionError(`I don't have the necessary permissions to query the file system at "${toPosix(path)}"`);
      }
      return await handlers.private(node, parts.slice(unwrap(nodePath).length));
    } else if (head === RootBranch.Pretty) {
      return await handlers.public(this.root.prettyTree, relPath);
    } else {
      throw new Error("Not a valid FileSystem path");
    }
  }
  /** @internal
  * `put` should be called on the node returned from the function.
  * Normally this is handled by `runOnNode`.
  */
  async runOnChildTree(node, relPath, fn) {
    let tree2 = node;
    if (relPath.length) {
      if (!await tree2.exists(relPath))
        await tree2.mkdir(relPath);
      const g = await tree2.get(relPath);
      if (isTree(g))
        tree2 = g;
      else
        throw new Error("Path does not point to a directory");
    }
    tree2 = await fn(tree2);
    if (relPath.length)
      return await node.updateChild(tree2, relPath);
    return node;
  }
  /** @internal */
  _whenOnline() {
    const toPublish = [...this._publishWhenOnline];
    this._publishWhenOnline = [];
    toPublish.forEach(([cid, proof]) => {
      this.publishHooks.forEach((hook) => hook(cid, proof));
    });
  }
  /** @internal */
  _beforeLeaving(e) {
    const msg = "Are you sure you want to leave? We don't control the browser so you may lose your data.";
    if (this._publishing || this._publishWhenOnline.length) {
      (e || globalThis.event).returnValue = msg;
      return msg;
    }
  }
};
var filesystem_default = FileSystem;

// node_modules/@oddjs/odd/lib/filesystem.js
async function loadFileSystem({ config: config2, dependencies, eventEmitter, rootKey, username }) {
  const { crypto: crypto3, depot: depot2, manners: manners2, reference: reference2, storage: storage2 } = dependencies;
  let cid;
  let fs;
  const cidLog = reference2.repositories.cidLog;
  const account = { username, rootDID: await reference2.didRoot.lookup(username) };
  const dataCid = navigator.onLine ? await getDataRoot(reference2, username, { maxRetries: 20 }) : null;
  const logIdx = dataCid ? cidLog.indexOf(dataCid) : -1;
  if (!navigator.onLine) {
    cid = cidLog.newest();
    if (cid)
      manners2.log("\u{1F4D3} Working offline, using local CID:", cid.toString());
    throw new Error("Offline, don't have a filesystem to work with.");
  } else if (!dataCid) {
    cid = cidLog.newest();
    if (cid)
      manners2.log("\u{1F4D3} No DNSLink, using local CID:", cid.toString());
    else
      manners2.log("\u{1F4D3} Creating a new file system");
  } else if (logIdx === cidLog.length() - 1) {
    cid = dataCid;
    manners2.log("\u{1F4D3} DNSLink is up to date:", cid.toString());
  } else if (logIdx !== -1 && logIdx < cidLog.length() - 1) {
    cid = cidLog.newest();
    const diff = cidLog.length() - 1 - logIdx;
    const idxLog = diff === 1 ? "1 newer local entry" : diff.toString() + " newer local entries";
    manners2.log("\u{1F4D3} DNSLink is outdated (" + idxLog + "), using local CID:", cid.toString());
  } else {
    cid = dataCid;
    await cidLog.add(cid);
    manners2.log("\u{1F4D3} DNSLink is newer:", cid.toString());
  }
  const p = config2.permissions;
  const dataComponents = { crypto: crypto3, depot: depot2, reference: reference2, storage: storage2 };
  if (cid) {
    await checkFileSystemVersion(dependencies.depot, config2, cid);
    await manners2.fileSystem.hooks.beforeLoadExisting(cid, account, dataComponents);
    fs = await filesystem_default.fromCID(cid, { account, dependencies, eventEmitter, permissions: p });
    await manners2.fileSystem.hooks.afterLoadExisting(fs, account, dataComponents);
    return fs;
  }
  await manners2.fileSystem.hooks.beforeLoadNew(account, dataComponents);
  fs = await filesystem_default.empty({
    account,
    dependencies,
    eventEmitter,
    rootKey,
    permissions: p,
    version: config2.fileSystem?.version
  });
  await manners2.fileSystem.hooks.afterLoadNew(fs, account, dataComponents);
  return fs;
}
async function recoverFileSystem({ auth: auth2, dependencies, oldUsername, newUsername, readKey: readKey2 }) {
  const { crypto: crypto3, reference: reference2, storage: storage2 } = dependencies;
  const newRootDID = await write(crypto3);
  const { success } = await auth2.register({
    username: newUsername
  });
  if (!success) {
    throw new Error("Failed to register new user");
  }
  const proof = await storage2.getItem(storage2.KEYS.ACCOUNT_UCAN);
  const ucan = await build({
    dependencies,
    potency: "APPEND",
    resource: "*",
    proof: proof ? proof : void 0,
    lifetimeInSeconds: 60 * 3,
    audience: newRootDID,
    issuer: newRootDID
  });
  const oldRootCID = await reference2.dataRoot.lookup(oldUsername);
  if (!oldRootCID) {
    throw new Error("Failed to lookup oldUsername");
  }
  await reference2.dataRoot.update(oldRootCID, ucan);
  await store({
    accountDID: newRootDID,
    crypto: crypto3,
    readKey: readKey2
  });
  return {
    success: true
  };
}
var DEFAULT_USER_MESSAGES = {
  versionMismatch: {
    newer: async () => alertIfPossible(`Sorry, we can't sync your filesystem with this app. This app only understands older versions of filesystems.

Please try to hard refresh this site or let this app's developer know.

Feel free to contact Fission support: support@fission.codes`),
    older: async () => alertIfPossible(`Sorry, we can't sync your filesystem with this app. Your filesystem version is out-dated and it needs to be migrated.

Run a migration (https://guide.fission.codes/accounts/account-signup/account-migration) or talk to Fission support: support@fission.codes`)
  }
};
async function checkFileSystemVersion(depot2, config2, filesystemCID) {
  const links2 = await basic_exports.getSimpleLinks(depot2, filesystemCID);
  const versionStr = links2[RootBranch.Version] == null ? "1.0.0" : new TextDecoder().decode(await basic_exports.getFile(depot2, decodeCID(links2[RootBranch.Version].cid)));
  const errorVersionBigger = async () => {
    await (config2.userMessages || DEFAULT_USER_MESSAGES).versionMismatch.newer(versionStr);
    return new Error(`Incompatible filesystem version. Version: ${versionStr} Supported versions: ${supported.map((v) => toString6(v)).join(", ")}. Please upgrade this app's ODD SDK version.`);
  };
  const errorVersionSmaller = async () => {
    await (config2.userMessages || DEFAULT_USER_MESSAGES).versionMismatch.older(versionStr);
    return new Error(`Incompatible filesystem version. Version: ${versionStr} Supported versions: ${supported.map((v) => toString6(v)).join(", ")}. The user should migrate their filesystem.`);
  };
  const versionParsed = fromString5(versionStr);
  if (versionParsed == null) {
    throw await errorVersionBigger();
  }
  const support = isSupported(versionParsed);
  if (support === "too-high") {
    throw await errorVersionBigger();
  }
  if (support === "too-low") {
    throw await errorVersionSmaller();
  }
}
function alertIfPossible(str) {
  if (globalThis.alert != null)
    globalThis.alert(str);
}
async function getDataRoot(reference2, username, options = {}) {
  const maxRetries = options.maxRetries ?? 0;
  const retryInterval = options.retryInterval ?? 500;
  let dataCid = await reference2.dataRoot.lookup(username).catch(() => null);
  if (dataCid)
    return dataCid.toString() === EMPTY_CID ? null : dataCid;
  return new Promise((resolve, reject) => {
    let attempt = 0;
    const dataRootInterval = setInterval(async () => {
      dataCid = await reference2.dataRoot.lookup(username).catch(() => null);
      if (!dataCid && attempt < maxRetries) {
        attempt++;
        return;
      } else if (attempt >= maxRetries) {
        reject("Failed to load data root");
      }
      clearInterval(dataRootInterval);
      resolve(dataCid?.toString() === EMPTY_CID ? null : dataCid);
    }, retryInterval);
  });
}

// node_modules/one-webcrypto/browser.mjs
var _globalReference = globalThis || window || self;
var webcrypto = _globalReference.crypto;

// node_modules/@oddjs/odd/lib/components/crypto/implementation/browser.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/keystore-idb/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// node_modules/keystore-idb/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});

// node_modules/keystore-idb/node_modules/multiformats/esm/vendor/base-x.js
function base2(ALPHABET, name8) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode26(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length8 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length8) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      pbegin++;
    }
    var it2 = size - length8;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length8 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length8) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length8;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode33(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name8} character`);
  }
  return {
    encode: encode26,
    decodeUnsafe,
    decode: decode33
  };
}
var src2 = base2;
var _brrp__multiformats_scope_baseX2 = src2;
var base_x_default2 = _brrp__multiformats_scope_baseX2;

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bytes.js
var empty3 = new Uint8Array(0);
var equals5 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce3 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString7 = (str) => new TextEncoder().encode(str);
var toString7 = (b) => new TextDecoder().decode(b);

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base.js
var Encoder2 = class {
  constructor(name8, prefix, baseEncode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder2 = class {
  constructor(name8, prefix, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder2 = class {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder2({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec2 = class {
  constructor(name8, prefix, baseEncode, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder2(name8, prefix, baseEncode);
    this.decoder = new Decoder2(name8, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from3 = ({ name: name8, prefix, encode: encode26, decode: decode33 }) => new Codec2(name8, prefix, encode26, decode33);
var baseX2 = ({ prefix, name: name8, alphabet: alphabet4 }) => {
  const { encode: encode26, decode: decode33 } = base_x_default2(alphabet4, name8);
  return from3({
    prefix,
    name: name8,
    encode: encode26,
    decode: (text) => coerce3(decode33(text))
  });
};
var decode10 = (string2, alphabet4, bitsPerChar, name8) => {
  const codes2 = {};
  for (let i = 0; i < alphabet4.length; ++i) {
    codes2[alphabet4[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name8} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode9 = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46482 = ({ name: name8, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from3({
    prefix,
    name: name8,
    encode(input) {
      return encode9(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode10(input, alphabet4, bitsPerChar, name8);
    }
  });
};

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/identity.js
var identity = from3({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString7(buf2),
  decode: (str) => fromString7(str)
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22 = rfc46482({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc46482({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX2({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc46482({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc46482({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});
var base322 = rfc46482({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper2 = rfc46482({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad2 = rfc46482({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper2 = rfc46482({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex2 = rfc46482({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper2 = rfc46482({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad2 = rfc46482({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper2 = rfc46482({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z2 = rfc46482({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX2({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX2({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});
var base58btc2 = baseX2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr2 = baseX2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc46482({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc46482({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc46482({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc46482({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode10(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode11(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from3({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode10,
  decode: decode11
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/keystore-idb/node_modules/multiformats/esm/vendor/varint.js
var encode_12 = encode11;
var MSB2 = 128;
var REST2 = 127;
var MSBALL2 = ~REST2;
var INT2 = Math.pow(2, 31);
function encode11(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode11.bytes = offset - oldOffset + 1;
  return out;
}
var decode12 = read2;
var MSB$12 = 128;
var REST$12 = 127;
function read2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var N82 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length2 = function(value) {
  return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
};
var varint2 = {
  encode: encode_12,
  decode: decode12,
  encodingLength: length2
};
var _brrp_varint2 = varint2;
var varint_default2 = _brrp_varint2;

// node_modules/keystore-idb/node_modules/multiformats/esm/src/varint.js
var decode13 = (data, offset = 0) => {
  const code11 = varint_default2.decode(data, offset);
  return [
    code11,
    varint_default2.decode.bytes
  ];
};
var encodeTo2 = (int, target, offset = 0) => {
  varint_default2.encode(int, target, offset);
  return target;
};
var encodingLength2 = (int) => {
  return varint_default2.encodingLength(int);
};

// node_modules/keystore-idb/node_modules/multiformats/esm/src/hashes/digest.js
var create6 = (code11, digest5) => {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength2(code11);
  const digestOffset = sizeOffset + encodingLength2(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo2(code11, bytes2, 0);
  encodeTo2(size, bytes2, sizeOffset);
  bytes2.set(digest5, digestOffset);
  return new Digest2(code11, size, digest5, bytes2);
};
var decode14 = (multihash) => {
  const bytes2 = coerce3(multihash);
  const [code11, sizeOffset] = decode13(bytes2);
  const [size, digestOffset] = decode13(bytes2.subarray(sizeOffset));
  const digest5 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code11, size, digest5, bytes2);
};
var equals6 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals5(a.bytes, b.bytes);
  }
};
var Digest2 = class {
  constructor(code11, size, digest5, bytes2) {
    this.code = code11;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes2;
  }
};

// node_modules/keystore-idb/node_modules/multiformats/esm/src/hashes/hasher.js
var from4 = ({ name: name8, code: code11, encode: encode26 }) => new Hasher2(name8, code11, encode26);
var Hasher2 = class {
  constructor(name8, code11, encode26) {
    this.name = name8;
    this.code = code11;
    this.encode = encode26;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create6(this.code, result) : result.then((digest5) => create6(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/keystore-idb/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha = (name8) => async (data) => new Uint8Array(await crypto.subtle.digest(name8, data));
var sha256 = from4({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from4({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/keystore-idb/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code4 = 0;
var name4 = "identity";
var encode12 = coerce3;
var digest = (input) => create6(code4, encode12(input));
var identity2 = {
  code: code4,
  name: name4,
  encode: encode12,
  digest
};

// node_modules/keystore-idb/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// node_modules/keystore-idb/node_modules/multiformats/esm/src/cid.js
var CID3 = class _CID {
  constructor(version3, code11, multihash, bytes2) {
    this.code = code11;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code11, multihash } = this;
        if (code11 !== DAG_PB_CODE2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code11, digest: digest5 } = this.multihash;
        const multihash = create6(code11, digest5);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals6(this.multihash, other.multihash);
  }
  toString(base7) {
    const { bytes: bytes2, version: version3, _baseCache } = this;
    switch (version3) {
      case 0:
        return toStringV02(bytes2, _baseCache, base7 || base58btc2.encoder);
      default:
        return toStringV12(bytes2, _baseCache, base7 || base322.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol2] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version3, code: code11, multihash, bytes: bytes2 } = value;
      return new _CID(version3, code11, multihash, bytes2 || encodeCID3(version3, code11, multihash.bytes));
    } else if (value != null && value[cidSymbol2] === true) {
      const { version: version3, multihash, code: code11 } = value;
      const digest5 = decode14(multihash);
      return _CID.create(version3, code11, digest5);
    } else {
      return null;
    }
  }
  static create(version3, code11, digest5) {
    if (typeof code11 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version3) {
      case 0: {
        if (code11 !== DAG_PB_CODE2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
        } else {
          return new _CID(version3, code11, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID3(version3, code11, digest5.bytes);
        return new _CID(version3, code11, digest5, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE2, digest5);
  }
  static createV1(code11, digest5) {
    return _CID.create(1, code11, digest5);
  }
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce3(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest5 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest5) : _CID.createV1(specs.codec, digest5);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length8] = decode13(initialBytes.subarray(offset));
      offset += length8;
      return i;
    };
    let version3 = next();
    let codec = DAG_PB_CODE2;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else if (version3 === 1) {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version3,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base7) {
    const [prefix, bytes2] = parseCIDtoBytes2(source, base7);
    const cid = _CID.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes2 = (source, base7) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base7 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder = base7 || base58btc2;
      return [
        base58btc2.prefix,
        decoder.decode(source)
      ];
    }
    case base322.prefix: {
      const decoder = base7 || base322;
      return [
        base322.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base7 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base7.decode(source)
      ];
    }
  }
};
var toStringV02 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  if (prefix !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
  }
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2).slice(1);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV12 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE2 = 112;
var SHA_256_CODE2 = 18;
var encodeCID3 = (version3, code11, multihash) => {
  const codeOffset = encodingLength2(version3);
  const hashOffset = codeOffset + encodingLength2(code11);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version3, bytes2, 0);
  encodeTo2(code11, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/keystore-idb/node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports2,
  ...base36_exports,
  ...base58_exports2,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_browser_exports,
  ...identity_exports2
};

// node_modules/keystore-idb/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name8, prefix, encode26, decode33) {
  return {
    name: name8,
    prefix,
    encoder: {
      name: name8,
      prefix,
      encode: encode26
    },
    decoder: { decode: decode33 }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string2 += String.fromCharCode(buf2[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/keystore-idb/node_modules/uint8arrays/esm/src/from-string.js
function fromString8(string2, encoding = "utf8") {
  const base7 = bases_default[encoding];
  if (!base7) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base7.decoder.decode(`${base7.prefix}${string2}`);
}

// node_modules/keystore-idb/node_modules/uint8arrays/esm/src/to-string.js
function toString8(array, encoding = "utf8") {
  const base7 = bases_default[encoding];
  if (!base7) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base7.encoder.encode(array).substring(1);
}

// node_modules/keystore-idb/lib/errors.js
var KeyDoesNotExist = new Error("Key does not exist. Make sure you properly instantiated the keystore.");
var NotKeyPair = new Error("Retrieved a symmetric key when an asymmetric keypair was expected. Please use a different key name.");
var NotKey = new Error("Retrieved an asymmetric keypair when an symmetric key was expected. Please use a different key name.");
var ECCNotEnabled = new Error("ECC is not enabled for this browser. Please use RSA instead.");
var UnsupportedCrypto = new Error("Cryptosystem not supported. Please use ECC or RSA");
var InvalidKeyUse = new Error("Invalid key use. Please use 'exchange' or 'write");
var InvalidMaxValue = new Error("Max must be less than 256 and greater than 0");
function checkIsKeyPair(keypair) {
  if (!keypair || keypair === null) {
    throw KeyDoesNotExist;
  } else if (keypair.privateKey === void 0) {
    throw NotKeyPair;
  }
  return keypair;
}
function checkIsKey(key) {
  if (!key || key === null) {
    throw KeyDoesNotExist;
  } else if (key.privateKey !== void 0 || key.algorithm === void 0) {
    throw NotKey;
  }
  return key;
}
function checkValidCryptoSystem(type) {
  checkValid(type, [CryptoSystem.ECC, CryptoSystem.RSA], UnsupportedCrypto);
}
function checkValidKeyUse(use) {
  checkValid(use, [KeyUse.Exchange, KeyUse.Write], InvalidKeyUse);
}
function checkValid(toCheck, opts, error) {
  const match = opts.some((opt) => opt === toCheck);
  if (!match) {
    throw error;
  }
}
var errors_default = {
  KeyDoesNotExist,
  NotKeyPair,
  NotKey,
  ECCNotEnabled,
  UnsupportedCrypto,
  InvalidKeyUse,
  checkIsKeyPair,
  checkIsKey,
  checkValidCryptoSystem,
  checkValidKeyUse,
  InvalidMaxValue
};

// node_modules/keystore-idb/lib/utils.js
function arrBufToStr(buf2, charSize) {
  const arr = charSize === 8 ? new Uint8Array(buf2) : new Uint16Array(buf2);
  return Array.from(arr).map((b) => String.fromCharCode(b)).join("");
}
function arrBufToBase64(buf2) {
  return toString8(new Uint8Array(buf2), "base64pad");
}
function strToArrBuf(str, charSize) {
  const view = charSize === 8 ? new Uint8Array(str.length) : new Uint16Array(str.length);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    view[i] = str.charCodeAt(i);
  }
  return view.buffer;
}
function base64ToArrBuf(string2) {
  return fromString8(string2, "base64pad").buffer;
}
function publicExponent() {
  return new Uint8Array([1, 0, 1]);
}
function randomBuf(length8, { max } = { max: 255 }) {
  if (max < 1 || max > 255) {
    throw errors_default.InvalidMaxValue;
  }
  const arr = new Uint8Array(length8);
  if (max == 255) {
    webcrypto.getRandomValues(arr);
    return arr.buffer;
  }
  let index2 = 0;
  const interval = max + 1;
  const divisibleMax = Math.floor(256 / interval) * interval;
  const tmp = new Uint8Array(1);
  while (index2 < arr.length) {
    webcrypto.getRandomValues(tmp);
    if (tmp[0] < divisibleMax) {
      arr[index2] = tmp[0] % interval;
      index2++;
    }
  }
  return arr.buffer;
}
function joinBufs(fst, snd) {
  const view1 = new Uint8Array(fst);
  const view2 = new Uint8Array(snd);
  const joined = new Uint8Array(view1.length + view2.length);
  joined.set(view1);
  joined.set(view2, view1.length);
  return joined.buffer;
}
var normalizeUtf8ToBuf = (msg) => {
  return normalizeToBuf(msg, (str) => strToArrBuf(str, CharSize.B8));
};
var normalizeUtf16ToBuf = (msg) => {
  return normalizeToBuf(msg, (str) => strToArrBuf(str, CharSize.B16));
};
var normalizeBase64ToBuf = (msg) => {
  return normalizeToBuf(msg, base64ToArrBuf);
};
var normalizeUnicodeToBuf = (msg, charSize) => {
  switch (charSize) {
    case 8:
      return normalizeUtf8ToBuf(msg);
    default:
      return normalizeUtf16ToBuf(msg);
  }
};
var normalizeToBuf = (msg, strConv) => {
  if (typeof msg === "string") {
    return strConv(msg);
  } else if (typeof msg === "object" && msg.byteLength !== void 0) {
    const temp = new Uint8Array(msg);
    return temp.buffer;
  } else {
    throw new Error("Improper value. Must be a string, ArrayBuffer, Uint8Array");
  }
};
async function structuralClone(obj) {
  return new Promise((resolve) => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = (ev) => resolve(ev.data);
    port1.postMessage(obj);
  });
}
var utils_default = {
  arrBufToStr,
  arrBufToBase64,
  strToArrBuf,
  base64ToArrBuf,
  publicExponent,
  randomBuf,
  joinBufs,
  normalizeUtf8ToBuf,
  normalizeUtf16ToBuf,
  normalizeBase64ToBuf,
  normalizeToBuf,
  structuralClone
};

// node_modules/keystore-idb/lib/constants.js
var ECC_EXCHANGE_ALG = "ECDH";
var ECC_WRITE_ALG = "ECDSA";
var RSA_EXCHANGE_ALG = "RSA-OAEP";
var RSA_WRITE_ALG = "RSASSA-PKCS1-v1_5";
var SALT_LENGTH = 128;
var DEFAULT_CRYPTOSYSTEM = "ecc";
var DEFAULT_ECC_CURVE = EccCurve.P_256;
var DEFAULT_RSA_SIZE = RsaSize.B2048;
var DEFAULT_SYMM_ALG = SymmAlg.AES_CTR;
var DEFAULT_SYMM_LEN = SymmKeyLength.B256;
var DEFAULT_CTR_LEN = 64;
var DEFAULT_HASH_ALG = HashAlg.SHA_256;
var DEFAULT_CHAR_SIZE = CharSize.B16;
var DEFAULT_STORE_NAME = "keystore";
var DEFAULT_EXCHANGE_KEY_NAME = "exchange-key";
var DEFAULT_WRITE_KEY_NAME = "write-key";

// node_modules/keystore-idb/lib/aes/keys.js
async function makeKey(opts) {
  return webcrypto.subtle.generateKey({
    name: opts?.alg || DEFAULT_SYMM_ALG,
    length: opts?.length || DEFAULT_SYMM_LEN
  }, true, ["encrypt", "decrypt"]);
}
async function importKey(base64key, opts) {
  const buf2 = utils_default.base64ToArrBuf(base64key);
  return webcrypto.subtle.importKey("raw", buf2, {
    name: opts?.alg || DEFAULT_SYMM_ALG,
    length: opts?.length || DEFAULT_SYMM_LEN
  }, true, ["encrypt", "decrypt"]);
}
var keys_default = {
  makeKey,
  importKey
};

// node_modules/keystore-idb/lib/aes/operations.js
async function encryptBytes(msg, key, opts) {
  const data = utils_default.normalizeUtf16ToBuf(msg);
  const importedKey = typeof key === "string" ? await keys_default.importKey(key, opts) : key;
  const alg = opts?.alg || DEFAULT_SYMM_ALG;
  const iv = opts?.iv || utils_default.randomBuf(16);
  const cipherBuf = await webcrypto.subtle.encrypt({
    name: alg,
    // AES-CTR uses a counter, AES-GCM/AES-CBC use an initialization vector
    iv: alg === SymmAlg.AES_CTR ? void 0 : iv,
    counter: alg === SymmAlg.AES_CTR ? new Uint8Array(iv) : void 0,
    length: alg === SymmAlg.AES_CTR ? DEFAULT_CTR_LEN : void 0
  }, importedKey, data);
  return utils_default.joinBufs(iv, cipherBuf);
}
async function decryptBytes(msg, key, opts) {
  const cipherText = utils_default.normalizeBase64ToBuf(msg);
  const importedKey = typeof key === "string" ? await keys_default.importKey(key, opts) : key;
  const alg = opts?.alg || DEFAULT_SYMM_ALG;
  const iv = cipherText.slice(0, 16);
  const cipherBytes = cipherText.slice(16);
  const msgBuff = await webcrypto.subtle.decrypt({
    name: alg,
    // AES-CTR uses a counter, AES-GCM/AES-CBC use an initialization vector
    iv: alg === SymmAlg.AES_CTR ? void 0 : iv,
    counter: alg === SymmAlg.AES_CTR ? new Uint8Array(iv) : void 0,
    length: alg === SymmAlg.AES_CTR ? DEFAULT_CTR_LEN : void 0
  }, importedKey, cipherBytes);
  return msgBuff;
}
async function encrypt(msg, key, opts) {
  const cipherText = await encryptBytes(msg, key, opts);
  return utils_default.arrBufToBase64(cipherText);
}
async function decrypt(msg, key, opts) {
  const msgBytes = await decryptBytes(msg, key, opts);
  return utils_default.arrBufToStr(msgBytes, 16);
}
async function exportKey(key) {
  const raw = await webcrypto.subtle.exportKey("raw", key);
  return utils_default.arrBufToBase64(raw);
}
var operations_default = {
  encryptBytes,
  decryptBytes,
  encrypt,
  decrypt,
  exportKey
};

// node_modules/keystore-idb/lib/aes/index.js
var aes_default = {
  ...keys_default,
  ...operations_default
};

// node_modules/keystore-idb/lib/rsa/keys.js
async function makeKeypair(size, hashAlg, use) {
  checkValidKeyUse(use);
  const alg = use === KeyUse.Exchange ? RSA_EXCHANGE_ALG : RSA_WRITE_ALG;
  const uses = use === KeyUse.Exchange ? ["encrypt", "decrypt"] : ["sign", "verify"];
  return webcrypto.subtle.generateKey({
    name: alg,
    modulusLength: size,
    publicExponent: utils_default.publicExponent(),
    hash: { name: hashAlg }
  }, false, uses);
}
function stripKeyHeader(base64Key) {
  return base64Key.replace("-----BEGIN PUBLIC KEY-----\n", "").replace("\n-----END PUBLIC KEY-----", "");
}
async function importPublicKey(base64Key, hashAlg, use) {
  checkValidKeyUse(use);
  const alg = use === KeyUse.Exchange ? RSA_EXCHANGE_ALG : RSA_WRITE_ALG;
  const uses = use === KeyUse.Exchange ? ["encrypt"] : ["verify"];
  const buf2 = utils_default.base64ToArrBuf(stripKeyHeader(base64Key));
  return webcrypto.subtle.importKey("spki", buf2, { name: alg, hash: { name: hashAlg } }, true, uses);
}
var keys_default2 = {
  makeKeypair,
  importPublicKey
};

// node_modules/keystore-idb/lib/rsa/operations.js
async function sign(msg, privateKey, charSize = DEFAULT_CHAR_SIZE) {
  return webcrypto.subtle.sign({ name: RSA_WRITE_ALG, saltLength: SALT_LENGTH }, privateKey, normalizeUnicodeToBuf(msg, charSize));
}
async function verify(msg, sig, publicKey, charSize = DEFAULT_CHAR_SIZE, hashAlg = DEFAULT_HASH_ALG) {
  return webcrypto.subtle.verify({ name: RSA_WRITE_ALG, saltLength: SALT_LENGTH }, typeof publicKey === "string" ? await keys_default2.importPublicKey(publicKey, hashAlg, KeyUse.Write) : publicKey, normalizeBase64ToBuf(sig), normalizeUnicodeToBuf(msg, charSize));
}
async function encrypt2(msg, publicKey, charSize = DEFAULT_CHAR_SIZE, hashAlg = DEFAULT_HASH_ALG) {
  return webcrypto.subtle.encrypt({ name: RSA_EXCHANGE_ALG }, typeof publicKey === "string" ? await keys_default2.importPublicKey(publicKey, hashAlg, KeyUse.Exchange) : publicKey, normalizeUnicodeToBuf(msg, charSize));
}
async function decrypt2(msg, privateKey) {
  const normalized = normalizeBase64ToBuf(msg);
  return webcrypto.subtle.decrypt({ name: RSA_EXCHANGE_ALG }, privateKey, normalized);
}
async function getPublicKey(keypair) {
  const spki = await webcrypto.subtle.exportKey("spki", keypair.publicKey);
  return utils_default.arrBufToBase64(spki);
}
var operations_default2 = {
  sign,
  verify,
  encrypt: encrypt2,
  decrypt: decrypt2,
  getPublicKey
};

// node_modules/keystore-idb/lib/idb.js
var import_localforage = __toESM(require_localforage(), 1);
function createStore(name8) {
  return import_localforage.default.createInstance({ name: name8 });
}
async function createIfDoesNotExist(id, makeFn, store2 = import_localforage.default) {
  if (await exists(id, store2)) {
    return;
  }
  const key = await makeFn();
  await put(id, key, store2);
}
async function put(id, key, store2 = import_localforage.default) {
  return store2.setItem(id, key);
}
async function getKeypair(id, store2 = import_localforage.default) {
  return get2(id, checkIsKeyPair, store2);
}
async function getKey(id, store2 = import_localforage.default) {
  return get2(id, checkIsKey, store2);
}
async function get2(id, checkFn, store2 = import_localforage.default) {
  const item = await store2.getItem(id);
  return item === null ? null : checkFn(item);
}
async function exists(id, store2 = import_localforage.default) {
  const key = await store2.getItem(id);
  return key !== null;
}
async function rm(id, store2 = import_localforage.default) {
  return store2.removeItem(id);
}
async function dropStore(store2) {
  return store2.dropInstance();
}
async function clear(store2) {
  if (store2) {
    return dropStore(store2);
  } else {
    return import_localforage.default.clear();
  }
}
var idb_default = {
  createStore,
  createIfDoesNotExist,
  put,
  getKeypair,
  getKey,
  exists,
  rm,
  dropStore,
  clear
};

// node_modules/keystore-idb/lib/ecc/keys.js
async function makeKeypair2(curve, use) {
  checkValidKeyUse(use);
  const alg = use === KeyUse.Exchange ? ECC_EXCHANGE_ALG : ECC_WRITE_ALG;
  const uses = use === KeyUse.Exchange ? ["deriveKey", "deriveBits"] : ["sign", "verify"];
  return webcrypto.subtle.generateKey({ name: alg, namedCurve: curve }, false, uses);
}
async function importPublicKey2(base64Key, curve, use) {
  checkValidKeyUse(use);
  const alg = use === KeyUse.Exchange ? ECC_EXCHANGE_ALG : ECC_WRITE_ALG;
  const uses = use === KeyUse.Exchange ? [] : ["verify"];
  const buf2 = utils_default.base64ToArrBuf(base64Key);
  return webcrypto.subtle.importKey("raw", buf2, { name: alg, namedCurve: curve }, true, uses);
}
var keys_default3 = {
  makeKeypair: makeKeypair2,
  importPublicKey: importPublicKey2
};

// node_modules/keystore-idb/lib/config.js
var defaultConfig = {
  type: DEFAULT_CRYPTOSYSTEM,
  curve: DEFAULT_ECC_CURVE,
  rsaSize: DEFAULT_RSA_SIZE,
  symmAlg: DEFAULT_SYMM_ALG,
  symmLen: DEFAULT_SYMM_LEN,
  hashAlg: DEFAULT_HASH_ALG,
  charSize: DEFAULT_CHAR_SIZE,
  storeName: DEFAULT_STORE_NAME,
  exchangeKeyName: DEFAULT_EXCHANGE_KEY_NAME,
  writeKeyName: DEFAULT_WRITE_KEY_NAME
};
function normalize(maybeCfg, eccEnabled2 = true) {
  let cfg;
  if (!maybeCfg) {
    cfg = defaultConfig;
  } else {
    cfg = {
      ...defaultConfig,
      ...maybeCfg
    };
  }
  if (!maybeCfg?.type) {
    cfg.type = eccEnabled2 ? CryptoSystem.ECC : CryptoSystem.RSA;
  }
  return cfg;
}
async function eccEnabled() {
  const keypair = await keys_default3.makeKeypair(DEFAULT_ECC_CURVE, KeyUse.Exchange);
  try {
    await utils_default.structuralClone(keypair);
  } catch (err) {
    return false;
  }
  return true;
}
function merge2(cfg, overwrites = {}) {
  return {
    ...cfg,
    ...overwrites
  };
}
function symmKeyOpts(cfg) {
  return { alg: cfg.symmAlg, length: cfg.symmLen };
}
var config_default = {
  defaultConfig,
  normalize,
  eccEnabled,
  merge: merge2,
  symmKeyOpts
};

// node_modules/keystore-idb/lib/keystore/base.js
var KeyStoreBase = class {
  constructor(cfg, store2) {
    this.cfg = cfg;
    this.store = store2;
  }
  async writeKey() {
    const maybeKey = await idb_default.getKeypair(this.cfg.writeKeyName, this.store);
    return checkIsKeyPair(maybeKey);
  }
  async exchangeKey() {
    const maybeKey = await idb_default.getKeypair(this.cfg.exchangeKeyName, this.store);
    return checkIsKeyPair(maybeKey);
  }
  async getSymmKey(keyName, cfg) {
    const mergedCfg = config_default.merge(this.cfg, cfg);
    const maybeKey = await idb_default.getKey(keyName, this.store);
    if (maybeKey !== null) {
      return maybeKey;
    }
    const key = await aes_default.makeKey(config_default.symmKeyOpts(mergedCfg));
    await idb_default.put(keyName, key, this.store);
    return key;
  }
  async keyExists(keyName) {
    const key = await idb_default.getKey(keyName, this.store);
    return key !== null;
  }
  async deleteKey(keyName) {
    return idb_default.rm(keyName, this.store);
  }
  async destroy() {
    return idb_default.dropStore(this.store);
  }
  async importSymmKey(keyStr, keyName, cfg) {
    const mergedCfg = config_default.merge(this.cfg, cfg);
    const key = await aes_default.importKey(keyStr, config_default.symmKeyOpts(mergedCfg));
    await idb_default.put(keyName, key, this.store);
  }
  async exportSymmKey(keyName, cfg) {
    const key = await this.getSymmKey(keyName, cfg);
    return aes_default.exportKey(key);
  }
  async encryptWithSymmKey(msg, keyName, cfg) {
    const mergedCfg = config_default.merge(this.cfg, cfg);
    const key = await this.getSymmKey(keyName, cfg);
    const cipherText = await aes_default.encryptBytes(utils_default.strToArrBuf(msg, mergedCfg.charSize), key, config_default.symmKeyOpts(mergedCfg));
    return utils_default.arrBufToBase64(cipherText);
  }
  async decryptWithSymmKey(cipherText, keyName, cfg) {
    const mergedCfg = config_default.merge(this.cfg, cfg);
    const key = await this.getSymmKey(keyName, cfg);
    const msgBytes = await aes_default.decryptBytes(utils_default.base64ToArrBuf(cipherText), key, config_default.symmKeyOpts(mergedCfg));
    return utils_default.arrBufToStr(msgBytes, mergedCfg.charSize);
  }
};

// node_modules/keystore-idb/lib/rsa/keystore.js
var RSAKeyStore = class _RSAKeyStore extends KeyStoreBase {
  static async init(maybeCfg) {
    const cfg = config_default.normalize({
      ...maybeCfg || {},
      type: CryptoSystem.RSA
    });
    const { rsaSize, hashAlg, storeName, exchangeKeyName, writeKeyName } = cfg;
    const store2 = idb_default.createStore(storeName);
    await idb_default.createIfDoesNotExist(exchangeKeyName, () => keys_default2.makeKeypair(rsaSize, hashAlg, KeyUse.Exchange), store2);
    await idb_default.createIfDoesNotExist(writeKeyName, () => keys_default2.makeKeypair(rsaSize, hashAlg, KeyUse.Write), store2);
    return new _RSAKeyStore(cfg, store2);
  }
  async sign(msg, cfg) {
    const mergedCfg = config_default.merge(this.cfg, cfg);
    const writeKey = await this.writeKey();
    return utils_default.arrBufToBase64(await operations_default2.sign(msg, writeKey.privateKey, mergedCfg.charSize));
  }
  async verify(msg, sig, publicKey, cfg) {
    const mergedCfg = config_default.merge(this.cfg, cfg);
    return operations_default2.verify(msg, sig, publicKey, mergedCfg.charSize, mergedCfg.hashAlg);
  }
  async encrypt(msg, publicKey, cfg) {
    const mergedCfg = config_default.merge(this.cfg, cfg);
    return utils_default.arrBufToBase64(await operations_default2.encrypt(msg, publicKey, mergedCfg.charSize, mergedCfg.hashAlg));
  }
  async decrypt(cipherText, publicKey, cfg) {
    const exchangeKey = await this.exchangeKey();
    const mergedCfg = config_default.merge(this.cfg, cfg);
    return utils_default.arrBufToStr(await operations_default2.decrypt(cipherText, exchangeKey.privateKey), mergedCfg.charSize);
  }
  async publicExchangeKey() {
    const exchangeKey = await this.exchangeKey();
    return operations_default2.getPublicKey(exchangeKey);
  }
  async publicWriteKey() {
    const writeKey = await this.writeKey();
    return operations_default2.getPublicKey(writeKey);
  }
};
var keystore_default = RSAKeyStore;

// node_modules/keystore-idb/lib/rsa/index.js
var rsa_default = {
  ...keys_default2,
  ...operations_default2,
  ...keystore_default
};

// node_modules/@oddjs/odd/lib/components/crypto/implementation/browser.js
var aes = {
  decrypt: aesDecrypt,
  encrypt: aesEncrypt,
  exportKey: aesExportKey,
  genKey: aesGenKey
};
function importAesKey(key, alg) {
  return webcrypto.subtle.importKey("raw", key, {
    name: alg,
    length: SymmKeyLength.B256
  }, true, ["encrypt", "decrypt"]);
}
async function aesDecrypt(encrypted, key, alg, iv) {
  const cryptoKey = isCryptoKey(key) ? key : await importAesKey(key, alg);
  const decrypted = iv ? await webcrypto.subtle.decrypt({ name: alg, iv }, cryptoKey, encrypted) : await decryptBytes(encrypted, cryptoKey, { alg });
  return new Uint8Array(decrypted);
}
async function aesEncrypt(data, key, alg, iv) {
  const cryptoKey = isCryptoKey(key) ? key : await importAesKey(key, alg);
  const encrypted = iv ? await webcrypto.subtle.encrypt({ name: alg, iv }, cryptoKey, data) : await encryptBytes(data, cryptoKey, { alg });
  return new Uint8Array(encrypted);
}
async function aesExportKey(key) {
  const buffer2 = await webcrypto.subtle.exportKey("raw", key);
  return new Uint8Array(buffer2);
}
function aesGenKey(alg) {
  return makeKey({ length: SymmKeyLength.B256, alg });
}
var did2 = {
  keyTypes: {
    "bls12-381": {
      magicBytes: new Uint8Array([234, 1]),
      verify: () => {
        throw new Error("Not implemented");
      }
    },
    "ed25519": {
      magicBytes: new Uint8Array([237, 1]),
      verify: ed25519Verify
    },
    "rsa": {
      magicBytes: new Uint8Array([0, 245, 2]),
      verify: rsaVerify
    }
  }
};
async function ed25519Verify({ message, publicKey, signature }) {
  return import_tweetnacl.default.sign.detached.verify(message, signature, publicKey);
}
async function rsaVerify({ message, publicKey, signature }) {
  return rsa_default.verify(message, signature, await webcrypto.subtle.importKey("spki", publicKey, { name: RSA_WRITE_ALG, hash: RSA_HASHING_ALGORITHM }, false, ["verify"]), 8);
}
var hash = {
  sha256: sha2562
};
async function sha2562(bytes2) {
  return new Uint8Array(await webcrypto.subtle.digest("sha-256", bytes2));
}
function ksClearStore(ks) {
  return ks.destroy();
}
async function ksDecrypt(ks, cipherText) {
  const exchangeKey = await ks.exchangeKey();
  return rsaDecrypt(cipherText, exchangeKey.privateKey);
}
async function ksExportSymmKey(ks, keyName) {
  if (await ks.keyExists(keyName) === false) {
    throw new Error(`Expected a key under the name '${keyName}', but couldn't find anything`);
  }
  const key = await ks.getSymmKey(keyName);
  const raw = await webcrypto.subtle.exportKey("raw", key);
  return new Uint8Array(raw);
}
function ksGetAlgorithm(ks) {
  return Promise.resolve("rsa");
}
function ksGetUcanAlgorithm(ks) {
  return Promise.resolve("RS256");
}
function ksImportSymmKey(ks, key, name8) {
  return ks.importSymmKey(toString3(key, "base64pad"), name8);
}
function ksKeyExists(ks, keyName) {
  return ks.keyExists(keyName);
}
async function ksPublicExchangeKey(ks) {
  const keypair = await ks.exchangeKey();
  const spki = await webcrypto.subtle.exportKey("spki", keypair.publicKey);
  return new Uint8Array(spki);
}
async function ksPublicWriteKey(ks) {
  const keypair = await ks.writeKey();
  const spki = await webcrypto.subtle.exportKey("spki", keypair.publicKey);
  return new Uint8Array(spki);
}
async function ksSign(ks, message) {
  const writeKey = await ks.writeKey();
  const arrayBuffer = await rsa_default.sign(message, writeKey.privateKey, ks.cfg.charSize);
  return new Uint8Array(arrayBuffer);
}
var misc = {
  randomNumbers
};
function randomNumbers(options) {
  return webcrypto.getRandomValues(new Uint8Array(options.amount));
}
var rsa = {
  decrypt: rsaDecrypt,
  encrypt: rsaEncrypt,
  exportPublicKey: rsaExportPublicKey,
  genKey: rsaGenKey
};
var RSA_ALGORITHM = "RSA-OAEP";
var RSA_HASHING_ALGORITHM = "SHA-256";
function importRsaKey(key, keyUsages) {
  return webcrypto.subtle.importKey("spki", key, { name: RSA_ALGORITHM, hash: RSA_HASHING_ALGORITHM }, false, keyUsages);
}
async function rsaDecrypt(data, privateKey) {
  const arrayBuffer = await webcrypto.subtle.decrypt({
    name: RSA_ALGORITHM
  }, isCryptoKey(privateKey) ? privateKey : await importRsaKey(privateKey, ["decrypt"]), data);
  return new Uint8Array(arrayBuffer);
}
async function rsaEncrypt(message, publicKey) {
  const key = isCryptoKey(publicKey) ? publicKey : await importRsaKey(publicKey, ["encrypt"]);
  const arrayBuffer = await webcrypto.subtle.encrypt({
    name: RSA_ALGORITHM
  }, key, message);
  return new Uint8Array(arrayBuffer);
}
async function rsaExportPublicKey(key) {
  const buffer2 = await webcrypto.subtle.exportKey("spki", key);
  return new Uint8Array(buffer2);
}
function rsaGenKey() {
  return webcrypto.subtle.generateKey({
    name: RSA_ALGORITHM,
    modulusLength: 2048,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: RSA_HASHING_ALGORITHM }
  }, true, ["encrypt", "decrypt"]);
}
async function implementation2({ storeName, exchangeKeyName, writeKeyName }) {
  const ks = await RSAKeyStore.init({
    charSize: 8,
    hashAlg: HashAlg.SHA_256,
    storeName,
    exchangeKeyName,
    writeKeyName
  });
  return {
    aes,
    did: did2,
    hash,
    misc,
    rsa,
    keystore: {
      clearStore: (...args) => ksClearStore(ks, ...args),
      decrypt: (...args) => ksDecrypt(ks, ...args),
      exportSymmKey: (...args) => ksExportSymmKey(ks, ...args),
      getAlgorithm: (...args) => ksGetAlgorithm(ks, ...args),
      getUcanAlgorithm: (...args) => ksGetUcanAlgorithm(ks, ...args),
      importSymmKey: (...args) => ksImportSymmKey(ks, ...args),
      keyExists: (...args) => ksKeyExists(ks, ...args),
      publicExchangeKey: (...args) => ksPublicExchangeKey(ks, ...args),
      publicWriteKey: (...args) => ksPublicWriteKey(ks, ...args),
      sign: (...args) => ksSign(ks, ...args)
    }
  };
}

// node_modules/@oddjs/odd/lib/components/storage/implementation/browser.js
var import_localforage2 = __toESM(require_localforage(), 1);

// node_modules/@oddjs/odd/lib/components/storage/implementation/keys/default.js
var KEYS = {
  ACCOUNT_UCAN: "account-ucan",
  CID_LOG: "cid-log",
  SESSION: "session",
  UCANS: "permissioned-ucans"
};

// node_modules/@oddjs/odd/lib/components/storage/implementation/browser.js
function getItem(db, key) {
  assertBrowser("storage.getItem");
  return db.getItem(key);
}
function setItem(db, key, val) {
  assertBrowser("storage.setItem");
  return db.setItem(key, val);
}
function removeItem(db, key) {
  assertBrowser("storage.removeItem");
  return db.removeItem(key);
}
async function clear2(db) {
  assertBrowser("storage.clear");
  return db.clear();
}
function implementation3({ name: name8 }) {
  const db = import_localforage2.default.createInstance({ name: name8 });
  return {
    KEYS,
    getItem: (...args) => getItem(db, ...args),
    setItem: (...args) => setItem(db, ...args),
    removeItem: (...args) => removeItem(db, ...args),
    clear: (...args) => clear2(db, ...args)
  };
}

// node_modules/@libp2p/interface-keys/dist/src/index.js
var RSA = "RSA";

// node_modules/@chainsafe/is-ip/lib/parser.js
var Parser = class {
  index = 0;
  input = "";
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index2 = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index2;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index2, inner) {
    return this.readAtomically(() => {
      if (index2 > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i = 0; i < out.length; i++) {
        const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i = 0; i < groups.length / 2; i++) {
        const ix = i * 2;
        if (i < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPAddr());
}

// node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}

// node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes2 = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes2 = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes2[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes2;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i;
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes2(sections[i]);
        sections[i] = toString2(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i < 8) {
        sections.splice(i, 0, toString2(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ""; i++)
        ;
      const argv = [i, 1];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes2 = new Uint8Array(offset + 16);
    for (i = 0; i < sections.length; i++) {
      const word = parseInt(sections[i], 16);
      bytes2[offset++] = word >> 8 & 255;
      bytes2[offset++] = word & 255;
    }
    return bytes2;
  }
  throw new Error("invalid ip address");
};
var toString9 = function(buf2, offset = 0, length8) {
  offset = ~~offset;
  length8 = length8 ?? buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length8 === 4) {
    const result = [];
    for (let i = 0; i < length8; i++) {
      result.push(buf2[offset + i]);
    }
    return result.join(".");
  }
  if (length8 === 16) {
    const result = [];
    for (let i = 0; i < length8; i += 2) {
      result.push(view.getUint16(offset + i).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};

// node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
var V = -1;
var names = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [281, 0, "webrtc-w3c"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [448, 0, "tls"],
  [449, V, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code11, size, name8, resolvable, path) {
  return {
    code: code11,
    size,
    name: name8,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}

// node_modules/multiformats/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
var identity3 = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString5(buf2),
  decode: (str) => fromString4(str)
});

// node_modules/multiformats/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base23
});
var base23 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/multiformats/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/multiformats/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
var base102 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/multiformats/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper2 = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/multiformats/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper2 = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/multiformats/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base642,
  base64pad: () => base64pad2,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad2
});
var base642 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad2 = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url2 = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad2 = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars2 = (
  /** @type {string[]} */
  alphabet2.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes2 = (
  /** @type {number[]} */
  alphabet2.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode13(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode15(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji2 = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode13,
  decode: decode15
});

// node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2563,
  sha512: () => sha5122
});

// node_modules/multiformats/src/hashes/hasher.js
var from5 = ({ name: name8, code: code11, encode: encode26 }) => new Hasher3(name8, code11, encode26);
var Hasher3 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name8, code11, encode26) {
    this.name = name8;
    this.code = code11;
    this.encode = encode26;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest5) => create4(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/multiformats/src/hashes/sha2-browser.js
var sha2 = (name8) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name8, data))
);
var sha2563 = from5({
  name: "sha2-256",
  code: 18,
  encode: sha2("SHA-256")
});
var sha5122 = from5({
  name: "sha2-512",
  code: 19,
  encode: sha2("SHA-512")
});

// node_modules/multiformats/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});
var code5 = 0;
var name5 = "identity";
var encode14 = coerce2;
var digest2 = (input) => create4(code5, encode14(input));
var identity4 = { code: code5, name: name5, encode: encode14, digest: digest2 };

// node_modules/multiformats/src/codecs/json.js
var textEncoder5 = new TextEncoder();
var textDecoder4 = new TextDecoder();

// node_modules/multiformats/src/basics.js
var bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports, ...base36_exports2, ...base58_exports, ...base64_exports2, ...base256emoji_exports2 };
var hashes2 = { ...sha2_browser_exports2, ...identity_exports4 };

// node_modules/@multiformats/multiaddr/dist/src/convert.js
var import_varint3 = __toESM(require_varint(), 1);
function convertToString(proto, buf2) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    case 41:
      return bytes2ip(buf2);
    case 42:
      return bytes2str(buf2);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    default:
      return toString2(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString(str, "base16");
  }
}
var decoders = Object.values(bases2).map((c) => c.decoder);
var anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d) => acc = acc.or(d));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes2(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString9(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString(str);
  const size = Uint8Array.from(import_varint3.default.encode(buf2.length));
  return concat([size, buf2], size.length + buf2.length);
}
function bytes2str(buf2) {
  const size = import_varint3.default.decode(buf2);
  buf2 = buf2.slice(import_varint3.default.decode.bytes);
  if (buf2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString2(buf2);
}
function mh2bytes(hash3) {
  let mh;
  if (hash3[0] === "Q" || hash3[0] === "1") {
    mh = decode5(base58btc.decode(`z${hash3}`)).bytes;
  } else {
    mh = CID2.parse(hash3).multihash.bytes;
  }
  const size = Uint8Array.from(import_varint3.default.encode(mh.length));
  return concat([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(import_varint3.default.encode(mb.length));
  return concat([size, mb], size.length + mb.length);
}
function bytes2mb(buf2) {
  const size = import_varint3.default.decode(buf2);
  const hash3 = buf2.slice(import_varint3.default.decode.bytes);
  if (hash3.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString2(hash3, "base64url");
}
function bytes2mh(buf2) {
  const size = import_varint3.default.decode(buf2);
  const address = buf2.slice(import_varint3.default.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString2(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base32.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString2(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}

// node_modules/@multiformats/multiaddr/dist/src/codec.js
var import_varint4 = __toESM(require_varint(), 1);
function stringToStringTuples(str) {
  const tuples = [];
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return [];
  }
  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        // should we need to check each path part to see if it's a proto?
        // This would allow for other protocols to be added after a unix path,
        // however it would have issues if the path had a protocol name in the path
        cleanPath(parts.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes2(concat(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf2 = Uint8Array.from(import_varint4.default.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat([buf2, tup[1]]);
    }
    return buf2;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = import_varint4.default.decode(addr);
    return size + (import_varint4.default.decode.bytes ?? 0);
  }
}
function bytesToTuples(buf2) {
  const tuples = [];
  let i = 0;
  while (i < buf2.length) {
    const code11 = import_varint4.default.decode(buf2, i);
    const n = import_varint4.default.decode.bytes ?? 0;
    const p = getProtocol(code11);
    const size = sizeForAddr(p, buf2.slice(i + n));
    if (size === 0) {
      tuples.push([code11]);
      i += n;
      continue;
    }
    const addr = buf2.slice(i + n, i + n + size);
    i += size + n;
    if (i > buf2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString2(buf2, "base16"));
    }
    tuples.push([code11, addr]);
  }
  return tuples;
}
function bytesToString(buf2) {
  const a = bytesToTuples(buf2);
  const b = tuplesToStringTuples(a);
  return stringTuplesToString(b);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b = stringTuplesToTuples(a);
  return tuplesToBytes(b);
}
function fromString9(str) {
  return stringToBytes(str);
}
function fromBytes2(buf2) {
  const err = validateBytes(buf2);
  if (err != null) {
    throw err;
  }
  return Uint8Array.from(buf2);
}
function validateBytes(buf2) {
  try {
    bytesToTuples(buf2);
  } catch (err) {
    return err;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}

// node_modules/@multiformats/multiaddr/dist/src/index.js
var import_varint5 = __toESM(require_varint(), 1);
var import_err_code = __toESM(require_err_code(), 1);
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _DefaultMultiaddr_string;
var _DefaultMultiaddr_tuples;
var _DefaultMultiaddr_stringTuples;
var _a;
var inspect = Symbol.for("nodejs.util.inspect.custom");
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var resolvers = /* @__PURE__ */ new Map();
var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function isMultiaddr(value) {
  return Boolean(value?.[symbol]);
}
var DefaultMultiaddr = class _DefaultMultiaddr {
  constructor(addr) {
    _DefaultMultiaddr_string.set(this, void 0);
    _DefaultMultiaddr_tuples.set(this, void 0);
    _DefaultMultiaddr_stringTuples.set(this, void 0);
    this[_a] = true;
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes2(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString9(addr);
    } else if (isMultiaddr(addr)) {
      this.bytes = fromBytes2(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    if (__classPrivateFieldGet2(this, _DefaultMultiaddr_string, "f") == null) {
      __classPrivateFieldSet2(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
    }
    return __classPrivateFieldGet2(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code11, value] of this.stringTuples()) {
      if (code11 === ip6zone.code) {
        zone = `%${value ?? ""}`;
      }
      if (DNS_CODES.includes(code11)) {
        transport = tcp.name;
        port = 443;
        host = `${value ?? ""}${zone}`;
        family = code11 === dns6.code ? 6 : 4;
      }
      if (code11 === tcp.code || code11 === udp.code) {
        transport = getProtocol(code11).name;
        port = parseInt(value ?? "");
      }
      if (code11 === ip4.code || code11 === ip6.code) {
        transport = getProtocol(code11).name;
        host = `${value ?? ""}${zone}`;
        family = code11 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code11) => Object.assign({}, getProtocol(code11)));
  }
  protoCodes() {
    const codes2 = [];
    const buf2 = this.bytes;
    let i = 0;
    while (i < buf2.length) {
      const code11 = import_varint5.default.decode(buf2, i);
      const n = import_varint5.default.decode.bytes ?? 0;
      const p = getProtocol(code11);
      const size = sizeForAddr(p, buf2.slice(i + n));
      i += size + n;
      codes2.push(code11);
    }
    return codes2;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    if (__classPrivateFieldGet2(this, _DefaultMultiaddr_tuples, "f") == null) {
      __classPrivateFieldSet2(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
    }
    return __classPrivateFieldGet2(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    if (__classPrivateFieldGet2(this, _DefaultMultiaddr_stringTuples, "f") == null) {
      __classPrivateFieldSet2(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
    }
    return __classPrivateFieldGet2(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(addr) {
    addr = new _DefaultMultiaddr(addr);
    return new _DefaultMultiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i = s.lastIndexOf(addrString);
    if (i < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _DefaultMultiaddr(s.slice(0, i));
  }
  decapsulateCode(code11) {
    const tuples = this.tuples();
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code11) {
        return new _DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString2(base58btc.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString2(CID2.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path = null;
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path == null) {
        path = null;
      }
    } catch {
      path = null;
    }
    return path;
  }
  equals(addr) {
    return equals(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw (0, import_err_code.default)(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a) => new _DefaultMultiaddr(a));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a = symbol, inspect)]() {
    return `Multiaddr(${bytesToString(this.bytes)})`;
  }
};
function multiaddr(addr) {
  return new DefaultMultiaddr(addr);
}

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/varint.js
var encode_13 = encode15;
var MSB3 = 128;
var REST3 = 127;
var MSBALL3 = ~REST3;
var INT3 = Math.pow(2, 31);
function encode15(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT3) {
    out[offset++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode15.bytes = offset - oldOffset + 1;
  return out;
}
var decode16 = read3;
var MSB$13 = 128;
var REST$13 = 127;
function read3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset;
  return res;
}
var N13 = Math.pow(2, 7);
var N23 = Math.pow(2, 14);
var N33 = Math.pow(2, 21);
var N43 = Math.pow(2, 28);
var N53 = Math.pow(2, 35);
var N63 = Math.pow(2, 42);
var N73 = Math.pow(2, 49);
var N83 = Math.pow(2, 56);
var N93 = Math.pow(2, 63);
var length3 = function(value) {
  return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
};
var varint6 = {
  encode: encode_13,
  decode: decode16,
  encodingLength: length3
};
var _brrp_varint3 = varint6;
var varint_default3 = _brrp_varint3;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/varint.js
var decode17 = (data, offset = 0) => {
  const code11 = varint_default3.decode(data, offset);
  return [code11, varint_default3.decode.bytes];
};
var encodeTo3 = (int, target, offset = 0) => {
  varint_default3.encode(int, target, offset);
  return target;
};
var encodingLength3 = (int) => {
  return varint_default3.encodingLength(int);
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bytes.js
var empty4 = new Uint8Array(0);
var equals8 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce4 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString10 = (str) => new TextEncoder().encode(str);
var toString10 = (b) => new TextDecoder().decode(b);

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/digest.js
var create7 = (code11, digest5) => {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength3(code11);
  const digestOffset = sizeOffset + encodingLength3(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo3(code11, bytes2, 0);
  encodeTo3(size, bytes2, sizeOffset);
  bytes2.set(digest5, digestOffset);
  return new Digest3(code11, size, digest5, bytes2);
};
var decode18 = (multihash) => {
  const bytes2 = coerce4(multihash);
  const [code11, sizeOffset] = decode17(bytes2);
  const [size, digestOffset] = decode17(bytes2.subarray(sizeOffset));
  const digest5 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code11, size, digest5, bytes2);
};
var equals9 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals8(a.bytes, data.bytes);
  }
};
var Digest3 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code11, size, digest5, bytes2) {
    this.code = code11;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes2;
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58_exports3 = {};
__export(base58_exports3, {
  base58btc: () => base58btc3,
  base58flickr: () => base58flickr3
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/vendor/base-x.js
function base3(ALPHABET, name8) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode26(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length8 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length8) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      pbegin++;
    }
    var it2 = size - length8;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length8 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length8) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length8;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode33(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name8} character`);
  }
  return {
    encode: encode26,
    decodeUnsafe,
    decode: decode33
  };
}
var src3 = base3;
var _brrp__multiformats_scope_baseX3 = src3;
var base_x_default3 = _brrp__multiformats_scope_baseX3;

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base.js
var Encoder3 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name8, prefix, baseEncode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder3 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
};
var ComposedDecoder3 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or3(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or3 = (left, right) => new ComposedDecoder3(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec3 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseEncode, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder3(name8, prefix, baseEncode);
    this.decoder = new Decoder3(name8, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from6 = ({ name: name8, prefix, encode: encode26, decode: decode33 }) => new Codec3(name8, prefix, encode26, decode33);
var baseX3 = ({ prefix, name: name8, alphabet: alphabet4 }) => {
  const { encode: encode26, decode: decode33 } = base_x_default3(alphabet4, name8);
  return from6({
    prefix,
    name: name8,
    encode: encode26,
    /**
     * @param {string} text
     */
    decode: (text) => coerce4(decode33(text))
  });
};
var decode19 = (string2, alphabet4, bitsPerChar, name8) => {
  const codes2 = {};
  for (let i = 0; i < alphabet4.length; ++i) {
    codes2[alphabet4[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name8} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode16 = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46483 = ({ name: name8, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from6({
    prefix,
    name: name8,
    encode(input) {
      return encode16(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode19(input, alphabet4, bitsPerChar, name8);
    }
  });
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base58.js
var base58btc3 = baseX3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr3 = baseX3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base32.js
var base32_exports3 = {};
__export(base32_exports3, {
  base32: () => base323,
  base32hex: () => base32hex3,
  base32hexpad: () => base32hexpad3,
  base32hexpadupper: () => base32hexpadupper3,
  base32hexupper: () => base32hexupper3,
  base32pad: () => base32pad3,
  base32padupper: () => base32padupper3,
  base32upper: () => base32upper3,
  base32z: () => base32z3
});
var base323 = rfc46483({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper3 = rfc46483({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad3 = rfc46483({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper3 = rfc46483({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex3 = rfc46483({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper3 = rfc46483({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad3 = rfc46483({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper3 = rfc46483({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z3 = rfc46483({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/cid.js
var format2 = (link, base7) => {
  const { bytes: bytes2, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV03(
        bytes2,
        baseCache2(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base7 || base58btc3.encoder
      );
    default:
      return toStringV13(
        bytes2,
        baseCache2(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base7 || base323.encoder
      );
  }
};
var cache2 = /* @__PURE__ */ new WeakMap();
var baseCache2 = (cid) => {
  const baseCache6 = cache2.get(cid);
  if (baseCache6 == null) {
    const baseCache7 = /* @__PURE__ */ new Map();
    cache2.set(cid, baseCache7);
    return baseCache7;
  }
  return baseCache6;
};
var CID4 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version3, code11, multihash, bytes2) {
    this.code = code11;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code11, multihash } = this;
        if (code11 !== DAG_PB_CODE3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code11, digest: digest5 } = this.multihash;
        const multihash = create7(code11, digest5);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals9(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base7) {
    return format2(this, base7);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returs null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code11, multihash, bytes: bytes2 } = value;
      return new _CID(
        version3,
        code11,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes2 || encodeCID4(version3, code11, multihash.bytes)
      );
    } else if (value[cidSymbol3] === true) {
      const { version: version3, multihash, code: code11 } = value;
      const digest5 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode18(multihash)
      );
      return _CID.create(version3, code11, digest5);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version3, code11, digest5) {
    if (typeof code11 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code11 !== DAG_PB_CODE3) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`
          );
        } else {
          return new _CID(version3, code11, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID4(version3, code11, digest5.bytes);
        return new _CID(version3, code11, digest5, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE3, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code11, digest5) {
    return _CID.create(1, code11, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce4(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest5 = new Digest3(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest5
    ) : _CID.createV1(specs.codec, digest5);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length8] = decode17(initialBytes.subarray(offset));
      offset += length8;
      return i;
    };
    let version3 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE3
    );
    if (
      /** @type {number} */
      version3 === 18
    ) {
      version3 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base7) {
    const [prefix, bytes2] = parseCIDtoBytes3(source, base7);
    const cid = _CID.decode(bytes2);
    baseCache2(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes3 = (source, base7) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base7 || base58btc3;
      return [
        /** @type {Prefix} */
        base58btc3.prefix,
        decoder.decode(`${base58btc3.prefix}${source}`)
      ];
    }
    case base58btc3.prefix: {
      const decoder = base7 || base58btc3;
      return [
        /** @type {Prefix} */
        base58btc3.prefix,
        decoder.decode(source)
      ];
    }
    case base323.prefix: {
      const decoder = base7 || base323;
      return [
        /** @type {Prefix} */
        base323.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base7 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base7.decode(source)
      ];
    }
  }
};
var toStringV03 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  if (prefix !== base58btc3.prefix) {
    throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
  }
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2).slice(1);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV13 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE3 = 112;
var SHA_256_CODE3 = 18;
var encodeCID4 = (version3, code11, multihash) => {
  const codeOffset = encodingLength3(version3);
  const hashOffset = codeOffset + encodingLength3(code11);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo3(version3, bytes2, 0);
  encodeTo3(code11, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol3 = Symbol.for("@ipld/js-cid/CID");

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/identity.js
var identity_exports5 = {};
__export(identity_exports5, {
  identity: () => identity5
});
var identity5 = from6({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString10(buf2),
  decode: (str) => fromString10(str)
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base2.js
var base2_exports3 = {};
__export(base2_exports3, {
  base2: () => base24
});
var base24 = rfc46483({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base8.js
var base8_exports3 = {};
__export(base8_exports3, {
  base8: () => base83
});
var base83 = rfc46483({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base10.js
var base10_exports3 = {};
__export(base10_exports3, {
  base10: () => base103
});
var base103 = baseX3({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base16.js
var base16_exports3 = {};
__export(base16_exports3, {
  base16: () => base163,
  base16upper: () => base16upper3
});
var base163 = rfc46483({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper3 = rfc46483({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base36.js
var base36_exports3 = {};
__export(base36_exports3, {
  base36: () => base363,
  base36upper: () => base36upper3
});
var base363 = baseX3({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper3 = baseX3({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base64.js
var base64_exports3 = {};
__export(base64_exports3, {
  base64: () => base643,
  base64pad: () => base64pad3,
  base64url: () => base64url3,
  base64urlpad: () => base64urlpad3
});
var base643 = rfc46483({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad3 = rfc46483({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url3 = rfc46483({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad3 = rfc46483({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/bases/base256emoji.js
var base256emoji_exports3 = {};
__export(base256emoji_exports3, {
  base256emoji: () => base256emoji3
});
var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars3 = (
  /** @type {string[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[i] = c;
      return p;
    },
    /** @type {string[]} */
    []
  )
);
var alphabetCharsToBytes3 = (
  /** @type {number[]} */
  alphabet3.reduce(
    (p, c, i) => {
      p[
        /** @type {number} */
        c.codePointAt(0)
      ] = i;
      return p;
    },
    /** @type {number[]} */
    []
  )
);
function encode17(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars3[c];
    return p;
  }, "");
}
function decode20(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes3[
      /** @type {number} */
      char.codePointAt(0)
    ];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji3 = from6({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode17,
  decode: decode20
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha2_browser_exports3 = {};
__export(sha2_browser_exports3, {
  sha256: () => sha2564,
  sha512: () => sha5123
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/hasher.js
var from7 = ({ name: name8, code: code11, encode: encode26 }) => new Hasher4(name8, code11, encode26);
var Hasher4 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name8, code11, encode26) {
    this.name = name8;
    this.code = code11;
    this.encode = encode26;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create7(this.code, result) : result.then((digest5) => create7(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/sha2-browser.js
var sha3 = (name8) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name8, data))
);
var sha2564 = from7({
  name: "sha2-256",
  code: 18,
  encode: sha3("SHA-256")
});
var sha5123 = from7({
  name: "sha2-512",
  code: 19,
  encode: sha3("SHA-512")
});

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/hashes/identity.js
var identity_exports6 = {};
__export(identity_exports6, {
  identity: () => identity6
});
var code6 = 0;
var name6 = "identity";
var encode18 = coerce4;
var digest3 = (input) => create7(code6, encode18(input));
var identity6 = { code: code6, name: name6, encode: encode18, digest: digest3 };

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/codecs/json.js
var textEncoder6 = new TextEncoder();
var textDecoder5 = new TextDecoder();

// node_modules/@libp2p/peer-id/node_modules/multiformats/src/basics.js
var bases3 = { ...identity_exports5, ...base2_exports3, ...base8_exports3, ...base10_exports3, ...base16_exports3, ...base32_exports3, ...base36_exports3, ...base58_exports3, ...base64_exports3, ...base256emoji_exports3 };
var hashes3 = { ...sha2_browser_exports3, ...identity_exports6 };

// node_modules/@libp2p/peer-id/dist/src/index.js
var import_err_code2 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/interface-peer-id/dist/src/index.js
var symbol2 = Symbol.for("@libp2p/peer-id");

// node_modules/@libp2p/peer-id/dist/src/index.js
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
var baseDecoder = Object.values(bases3).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases3.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var PeerIdImpl = class {
  constructor(init2) {
    this.type = init2.type;
    this.multihash = init2.multihash;
    this.privateKey = init2.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  get [symbol2]() {
    return true;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc3.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID4.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON encoded object
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect2]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  constructor(init2) {
    super({ ...init2, type: "RSA" });
    this.type = "RSA";
    this.publicKey = init2.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  constructor(init2) {
    super({ ...init2, type: "Ed25519" });
    this.type = "Ed25519";
    this.publicKey = init2.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  constructor(init2) {
    super({ ...init2, type: "secp256k1" });
    this.type = "secp256k1";
    this.publicKey = init2.multihash.digest;
  }
};
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode18(base58btc3.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf2) {
  try {
    const multihash = decode18(buf2);
    if (multihash.code === identity6.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha2564.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID4.decode(buf2));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha2564.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity6.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}

// node_modules/just-safe-get/index.mjs
var objectSafeGet = get3;
function get3(obj, propsArg, defaultValue) {
  if (!obj) {
    return defaultValue;
  }
  var props, prop;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  while (props.length) {
    prop = props.shift();
    if (!obj) {
      return defaultValue;
    }
    obj = obj[prop];
    if (obj === void 0) {
      return defaultValue;
    }
  }
  return obj;
}

// node_modules/ipfs-repo/src/index.js
var import_debug9 = __toESM(require_browser(), 1);
var import_err_code9 = __toESM(require_err_code(), 1);

// node_modules/ipfs-repo-migrations/node_modules/multiformats/vendor/varint.js
var encode_14 = encode19;
var MSB4 = 128;
var REST4 = 127;
var MSBALL4 = ~REST4;
var INT4 = Math.pow(2, 31);
function encode19(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT4) {
    out[offset++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode19.bytes = offset - oldOffset + 1;
  return out;
}
var decode21 = read4;
var MSB$14 = 128;
var REST$14 = 127;
function read4(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read4.bytes = counter - offset;
  return res;
}
var N14 = Math.pow(2, 7);
var N24 = Math.pow(2, 14);
var N34 = Math.pow(2, 21);
var N44 = Math.pow(2, 28);
var N54 = Math.pow(2, 35);
var N64 = Math.pow(2, 42);
var N74 = Math.pow(2, 49);
var N84 = Math.pow(2, 56);
var N94 = Math.pow(2, 63);
var length4 = function(value) {
  return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
};
var varint7 = {
  encode: encode_14,
  decode: decode21,
  encodingLength: length4
};
var _brrp_varint4 = varint7;
var varint_default4 = _brrp_varint4;

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/varint.js
var decode22 = (data, offset = 0) => {
  const code11 = varint_default4.decode(data, offset);
  return [code11, varint_default4.decode.bytes];
};
var encodeTo4 = (int, target, offset = 0) => {
  varint_default4.encode(int, target, offset);
  return target;
};
var encodingLength4 = (int) => {
  return varint_default4.encodingLength(int);
};

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/bytes.js
var empty5 = new Uint8Array(0);
var equals10 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce5 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/hashes/digest.js
var create8 = (code11, digest5) => {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength4(code11);
  const digestOffset = sizeOffset + encodingLength4(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo4(code11, bytes2, 0);
  encodeTo4(size, bytes2, sizeOffset);
  bytes2.set(digest5, digestOffset);
  return new Digest4(code11, size, digest5, bytes2);
};
var decode23 = (multihash) => {
  const bytes2 = coerce5(multihash);
  const [code11, sizeOffset] = decode22(bytes2);
  const [size, digestOffset] = decode22(bytes2.subarray(sizeOffset));
  const digest5 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest4(code11, size, digest5, bytes2);
};
var equals11 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals10(a.bytes, data.bytes);
  }
};
var Digest4 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code11, size, digest5, bytes2) {
    this.code = code11;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes2;
  }
};

// node_modules/ipfs-repo-migrations/node_modules/multiformats/vendor/base-x.js
function base4(ALPHABET, name8) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode26(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length8 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length8) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      pbegin++;
    }
    var it2 = size - length8;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length8 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length8) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length8;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode33(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name8} character`);
  }
  return {
    encode: encode26,
    decodeUnsafe,
    decode: decode33
  };
}
var src4 = base4;
var _brrp__multiformats_scope_baseX4 = src4;
var base_x_default4 = _brrp__multiformats_scope_baseX4;

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/bases/base.js
var Encoder4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name8, prefix, baseEncode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or4(this, decoder);
  }
};
var ComposedDecoder4 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or4(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or4 = (left, right) => new ComposedDecoder4(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec4 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseEncode, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder4(name8, prefix, baseEncode);
    this.decoder = new Decoder4(name8, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from8 = ({ name: name8, prefix, encode: encode26, decode: decode33 }) => new Codec4(name8, prefix, encode26, decode33);
var baseX4 = ({ prefix, name: name8, alphabet: alphabet4 }) => {
  const { encode: encode26, decode: decode33 } = base_x_default4(alphabet4, name8);
  return from8({
    prefix,
    name: name8,
    encode: encode26,
    /**
     * @param {string} text
     */
    decode: (text) => coerce5(decode33(text))
  });
};
var decode24 = (string2, alphabet4, bitsPerChar, name8) => {
  const codes2 = {};
  for (let i = 0; i < alphabet4.length; ++i) {
    codes2[alphabet4[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name8} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode20 = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46484 = ({ name: name8, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from8({
    prefix,
    name: name8,
    encode(input) {
      return encode20(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode24(input, alphabet4, bitsPerChar, name8);
    }
  });
};

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/bases/base58.js
var base58btc4 = baseX4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr4 = baseX4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/bases/base32.js
var base324 = rfc46484({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper4 = rfc46484({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad4 = rfc46484({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper4 = rfc46484({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex4 = rfc46484({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper4 = rfc46484({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad4 = rfc46484({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper4 = rfc46484({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z4 = rfc46484({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/cid.js
var format3 = (link, base7) => {
  const { bytes: bytes2, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV04(
        bytes2,
        baseCache3(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base7 || base58btc4.encoder
      );
    default:
      return toStringV14(
        bytes2,
        baseCache3(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base7 || base324.encoder
      );
  }
};
var cache3 = /* @__PURE__ */ new WeakMap();
var baseCache3 = (cid) => {
  const baseCache6 = cache3.get(cid);
  if (baseCache6 == null) {
    const baseCache7 = /* @__PURE__ */ new Map();
    cache3.set(cid, baseCache7);
    return baseCache7;
  }
  return baseCache6;
};
var CID5 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version3, code11, multihash, bytes2) {
    this.code = code11;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code11, multihash } = this;
        if (code11 !== DAG_PB_CODE4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code11, digest: digest5 } = this.multihash;
        const multihash = create8(code11, digest5);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals11(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base7) {
    return format3(this, base7);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returs null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code11, multihash, bytes: bytes2 } = value;
      return new _CID(
        version3,
        code11,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes2 || encodeCID5(version3, code11, multihash.bytes)
      );
    } else if (value[cidSymbol4] === true) {
      const { version: version3, multihash, code: code11 } = value;
      const digest5 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode23(multihash)
      );
      return _CID.create(version3, code11, digest5);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version3, code11, digest5) {
    if (typeof code11 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code11 !== DAG_PB_CODE4) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`
          );
        } else {
          return new _CID(version3, code11, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID5(version3, code11, digest5.bytes);
        return new _CID(version3, code11, digest5, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE4, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code11, digest5) {
    return _CID.create(1, code11, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce5(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest5 = new Digest4(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest5
    ) : _CID.createV1(specs.codec, digest5);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length8] = decode22(initialBytes.subarray(offset));
      offset += length8;
      return i;
    };
    let version3 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE4
    );
    if (
      /** @type {number} */
      version3 === 18
    ) {
      version3 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base7) {
    const [prefix, bytes2] = parseCIDtoBytes4(source, base7);
    const cid = _CID.decode(bytes2);
    baseCache3(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes4 = (source, base7) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base7 || base58btc4;
      return [
        /** @type {Prefix} */
        base58btc4.prefix,
        decoder.decode(`${base58btc4.prefix}${source}`)
      ];
    }
    case base58btc4.prefix: {
      const decoder = base7 || base58btc4;
      return [
        /** @type {Prefix} */
        base58btc4.prefix,
        decoder.decode(source)
      ];
    }
    case base324.prefix: {
      const decoder = base7 || base324;
      return [
        /** @type {Prefix} */
        base324.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base7 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base7.decode(source)
      ];
    }
  }
};
var toStringV04 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  if (prefix !== base58btc4.prefix) {
    throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
  }
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2).slice(1);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV14 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE4 = 112;
var SHA_256_CODE4 = 18;
var encodeCID5 = (version3, code11, multihash) => {
  const codeOffset = encodingLength4(version3);
  const hashOffset = codeOffset + encodingLength4(code11);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo4(version3, bytes2, 0);
  encodeTo4(code11, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol4 = Symbol.for("@ipld/js-cid/CID");

// node_modules/interface-datastore/node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s, clean) {
    if (typeof s === "string") {
      this._buf = fromString(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString2(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')
   * ```
   */
  static random() {
    return new _Key(nanoid().replace(/-/g, ""));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s) {
    return new _Key(this.toString() + ":" + s);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   *
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/ipfs-repo-migrations/src/migrations/migration-8/index.js
var import_debug = __toESM(require_browser(), 1);

// node_modules/it-length/dist/src/index.js
async function length5(iterator) {
  let count = 0;
  for await (const _ of iterator) {
    count++;
  }
  return count;
}

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/codecs/raw.js
var code7 = 85;

// node_modules/ipfs-repo-migrations/src/migrations/migration-8/index.js
var log2 = (0, import_debug.default)("ipfs:repo:migrator:migration-8");
function unwrap2(blockstore) {
  if (blockstore.child) {
    return unwrap2(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash(key) {
  try {
    const buf2 = base324.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID5.decode(buf2).multihash.bytes;
    const multihashStr = base324.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err) {
    return key;
  }
}
function keyToCid(key) {
  try {
    const buf2 = base324.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest5 = decode23(buf2);
    const multihash = base324.encode(CID5.createV1(code7, digest5).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process2(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap2(blockstore);
  const blockCount = await length5(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log2(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
var migration = {
  version: 8,
  description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
  migrate: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToMultihash);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToCid);
  }
};

// node_modules/ipfs-repo-migrations/src/migrations/migration-9/pin.js
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["default"] || (import_minimal.default.roots["default"] = {});
var ipfs = $root.ipfs = (() => {
  const ipfs2 = {};
  ipfs2.pin = function() {
    const pin = {};
    pin.Set = function() {
      function Set2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Set2.prototype.version = 0;
      Set2.prototype.fanout = 0;
      Set2.prototype.seed = 0;
      Set2.encode = function encode26(m, w) {
        if (!w)
          w = $Writer.create();
        if (m.version != null && Object.hasOwnProperty.call(m, "version"))
          w.uint32(8).uint32(m.version);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(16).uint32(m.fanout);
        if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
          w.uint32(29).fixed32(m.seed);
        return w;
      };
      Set2.decode = function decode33(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.ipfs.pin.Set();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.version = r.uint32();
              break;
            case 2:
              m.fanout = r.uint32();
              break;
            case 3:
              m.seed = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Set2.fromObject = function fromObject(d) {
        if (d instanceof $root.ipfs.pin.Set)
          return d;
        var m = new $root.ipfs.pin.Set();
        if (d.version != null) {
          m.version = d.version >>> 0;
        }
        if (d.fanout != null) {
          m.fanout = d.fanout >>> 0;
        }
        if (d.seed != null) {
          m.seed = d.seed >>> 0;
        }
        return m;
      };
      Set2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.version = 0;
          d.fanout = 0;
          d.seed = 0;
        }
        if (m.version != null && m.hasOwnProperty("version")) {
          d.version = m.version;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          d.fanout = m.fanout;
        }
        if (m.seed != null && m.hasOwnProperty("seed")) {
          d.seed = m.seed;
        }
        return d;
      };
      Set2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      return Set2;
    }();
    return pin;
  }();
  return ipfs2;
})();

// node_modules/ipfs-repo-migrations/src/migrations/migration-9/pin-set.js
var import_fnv1a = __toESM(require_fnv1a(), 1);
var import_varint8 = __toESM(require_varint(), 1);

// node_modules/ipfs-repo-migrations/src/migrations/migration-9/utils.js
var PIN_DS_KEY = new Key("/local/pins");
var DEFAULT_FANOUT = 256;
var MAX_ITEMS = 8192;
var EMPTY_KEY = CID5.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
var PinTypes = {
  direct: "direct",
  recursive: "recursive"
};
function cidToKey(cid) {
  return new Key(`/${base324.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/hashes/hasher.js
var from9 = ({ name: name8, code: code11, encode: encode26 }) => new Hasher5(name8, code11, encode26);
var Hasher5 = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name8, code11, encode26) {
    this.name = name8;
    this.code = code11;
    this.encode = encode26;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create8(this.code, result) : result.then((digest5) => create8(this.code, digest5));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/ipfs-repo-migrations/node_modules/multiformats/src/hashes/sha2-browser.js
var sha4 = (name8) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name8, data))
);
var sha2565 = from9({
  name: "sha2-256",
  code: 18,
  encode: sha4("SHA-256")
});
var sha5124 = from9({
  name: "sha2-512",
  code: 19,
  encode: sha4("SHA-512")
});

// node_modules/ipfs-repo-migrations/src/migrations/migration-9/pin-set.js
var PinSet = ipfs.pin.Set;
function readHeader(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = import_varint8.default.decode(rootData);
  const vBytes = import_varint8.default.decode.bytes;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash2(seed, key) {
  const buffer2 = new Uint8Array(4);
  const dataView2 = new DataView(buffer2.buffer);
  dataView2.setUint32(0, seed, true);
  const encodedKey = fromString(key.toString());
  const data = concat([buffer2, encodedKey], buffer2.byteLength + encodedKey.byteLength);
  return (0, import_fnv1a.default)(toString2(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf2 = await blockstore.get(linkHash);
        const node2 = decode8(buf2);
        yield* walkItems(blockstore, node2);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name8) {
  const link = rootNode.Links.find((l) => l.Name === name8);
  if (!link) {
    throw new Error("No link found with name " + name8);
  }
  const buf2 = await blockstore.get(link.Hash);
  const node = decode8(buf2);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = import_varint8.default.encode(pbHeader.length);
    const headerBuf = concat([header, pbHeader]);
    const fanoutLinks = [];
    for (let i = 0; i < DEFAULT_FANOUT; i++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return compare(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat([headerBuf, ...nodes.map((item) => item.data)]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash2(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf2 = encode6(child);
      const digest5 = await sha2565.digest(buf2);
      const cid = CID5.createV0(digest5);
      await blockstore.put(cid, buf2);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf2.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return {
      key: cid2
    };
  }));
  const buf2 = encode6(rootNode);
  const digest5 = await sha2565.digest(buf2);
  const cid = CID5.createV0(digest5);
  await blockstore.put(cid, buf2);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf2.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}

// node_modules/ipfs-repo-migrations/src/migrations/migration-9/index.js
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(PIN_DS_KEY);
  const cid = CID5.decode(mh);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode8(pinRootBuf);
  let counter = 0;
  const pinCount = await length5(loadSet(blockstore, pinRoot, PinTypes.recursive)) + await length5(loadSet(blockstore, pinRoot, PinTypes.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes.recursive)) {
    counter++;
    const pin = {
      depth: Infinity
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code2) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode2(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes.direct)) {
    counter++;
    const pin = {
      depth: 0
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code2) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode2(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await length5(pinstore.queryKeys({}));
  for await (const { key, value } of pinstore.query({})) {
    counter++;
    const pin = decode2(value);
    const cid2 = CID5.create(
      pin.version || 0,
      pin.codec || code2,
      decode23(base324.decode("b" + key.toString().toLowerCase().split("/").pop()))
    );
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes.direct, directPins),
      await storeSet(blockstore, PinTypes.recursive, recursivePins)
    ]
  };
  const buf2 = encode6(pinRoot);
  const digest5 = await sha2565.digest(buf2);
  const cid = CID5.createV0(digest5);
  await blockstore.put(cid, buf2);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process3(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
var migration2 = {
  version: 9,
  description: "Migrates pins to datastore",
  migrate: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDAG);
  }
};

// node_modules/datastore-core/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  dbDeleteFailedError: () => dbDeleteFailedError,
  dbOpenFailedError: () => dbOpenFailedError,
  dbWriteFailedError: () => dbWriteFailedError,
  notFoundError: () => notFoundError
});
var import_err_code3 = __toESM(require_err_code(), 1);
function dbOpenFailedError(err) {
  err = err || new Error("Cannot open database");
  return (0, import_err_code3.default)(err, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err) {
  err = err || new Error("Delete failed");
  return (0, import_err_code3.default)(err, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err) {
  err = err || new Error("Write failed");
  return (0, import_err_code3.default)(err, "ERR_DB_WRITE_FAILED");
}
function notFoundError(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code3.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code3.default)(err, "ERR_ABORTED");
}

// node_modules/ipfs-repo-migrations/src/utils.js
var CONFIG_KEY = new Key("/config");
var VERSION_KEY = new Key("/version");
function findLevelJs(store2) {
  let db = store2;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback(key, has, store2) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store2);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get5, has, store2) {
  if (await has(key)) {
    return get5(key);
  }
  const levelJs = findLevelJs(store2);
  if (!levelJs) {
    throw notFoundError();
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve(req.result);
      }
      reject(notFoundError());
    };
  });
}
function wrapStore(store2) {
  const originalGet = store2.get.bind(store2);
  const originalHas = store2.has.bind(store2);
  store2.get = (key) => getWithFallback(key, originalGet, originalHas, store2);
  store2.has = (key) => hasWithFallback(key, originalHas, store2);
  return store2;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}

// node_modules/ipfs-repo-migrations/src/migrations/migration-10/index.js
async function keysToBinary(name8, store2, onProgress = () => {
}) {
  const db = findLevelJs(store2);
  if (!db) {
    onProgress(`${name8} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name8}`);
  const upgrade = (key, value) => {
    return [
      { type: "del", key },
      { type: "put", key: fromString(key), value }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name8, store2, onProgress = () => {
}) {
  const db = findLevelJs(store2);
  if (!db) {
    onProgress(`${name8} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name8}`);
  const downgrade = (key, value) => {
    return [
      { type: "del", key },
      { type: "put", key: toString2(key), value }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap3(store2) {
  if (store2.child) {
    return unwrap3(store2.child);
  }
  return store2;
}
async function process4(backends, onProgress, fn) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({ key, backend: unwrap3(backend) })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message) => {
    onProgress(Math.round(migrated / datastores.length * 100), message);
  };
  for (const { name: name8, store: store2 } of datastores) {
    await store2.open();
    try {
      await fn(name8, store2, progress);
    } finally {
      migrated++;
      await store2.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
var migration3 = {
  version: 10,
  description: "Migrates datastore-level keys to binary",
  migrate: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToBinary);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToStrings);
  }
};
function withEach(db, fn) {
  function batch2(operations, next) {
    const store2 = db.store("readwrite");
    const transaction = store2.transaction;
    let index2 = 0;
    let error;
    transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index2++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store2.delete(key) : store2.put(op.value, key);
      } catch (err) {
        error = err;
        transaction.abort();
        return;
      }
      if (index2 < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err, key, value) => {
        if (err || key === void 0) {
          const handleEnd = (err2) => {
            if (err2) {
              reject(err2);
              return;
            }
            resolve();
          };
          it.end(handleEnd);
          return;
        }
        batch2(fn(key, value), next);
      };
      it.next(handleNext);
    }
  });
}

// node_modules/ipfs-repo-migrations/src/migrations/migration-11/index.js
var MFS_ROOT_KEY = new Key("/local/filesroot");
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY)) {
    const root3 = await backends.root.get(MFS_ROOT_KEY);
    await backends.datastore.put(MFS_ROOT_KEY, root3);
    await backends.root.delete(MFS_ROOT_KEY);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY)) {
    const root3 = await backends.datastore.get(MFS_ROOT_KEY);
    await backends.root.put(MFS_ROOT_KEY, root3);
    await backends.datastore.delete(MFS_ROOT_KEY);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
var migration4 = {
  version: 11,
  description: "Store mfs root in the datastore",
  migrate: storeMfsRootInDatastore,
  revert: storeMfsRootInRoot
};

// node_modules/ipfs-repo-migrations/src/migrations/migration-12/index.js
var import_minimal7 = __toESM(require_minimal2(), 1);

// node_modules/ipfs-repo-migrations/src/migrations/migration-12/pb/proto-book.js
var import_minimal2 = __toESM(require_minimal2(), 1);
var $Reader2 = import_minimal2.default.Reader;
var $Writer2 = import_minimal2.default.Writer;
var $util2 = import_minimal2.default.util;
var $root2 = import_minimal2.default.roots["default"] || (import_minimal2.default.roots["default"] = {});
var Protocols = $root2.Protocols = (() => {
  function Protocols2(p) {
    this.protocols = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Protocols2.prototype.protocols = $util2.emptyArray;
  Protocols2.encode = function encode26(m, w) {
    if (!w)
      w = $Writer2.create();
    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i)
        w.uint32(10).string(m.protocols[i]);
    }
    return w;
  };
  Protocols2.decode = function decode33(r, l) {
    if (!(r instanceof $Reader2))
      r = $Reader2.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root2.Protocols();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Protocols2.fromObject = function fromObject(d) {
    if (d instanceof $root2.Protocols)
      return d;
    var m = new $root2.Protocols();
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];
      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }
    return m;
  };
  Protocols2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.protocols = [];
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    return d;
  };
  Protocols2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
  };
  return Protocols2;
})();

// node_modules/ipfs-repo-migrations/src/migrations/migration-12/pb/address-book.js
var import_minimal3 = __toESM(require_minimal2(), 1);
var $Reader3 = import_minimal3.default.Reader;
var $Writer3 = import_minimal3.default.Writer;
var $util3 = import_minimal3.default.util;
var $root3 = import_minimal3.default.roots["default"] || (import_minimal3.default.roots["default"] = {});
var Addresses = $root3.Addresses = (() => {
  function Addresses2(p) {
    this.addrs = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Addresses2.prototype.addrs = $util3.emptyArray;
  Addresses2.prototype.certifiedRecord = null;
  Addresses2.encode = function encode26(m, w) {
    if (!w)
      w = $Writer3.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i = 0; i < m.addrs.length; ++i)
        $root3.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
      $root3.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses2.decode = function decode33(r, l) {
    if (!(r instanceof $Reader3))
      r = $Reader3.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root3.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length))
            m.addrs = [];
          m.addrs.push($root3.Addresses.Address.decode(r, r.uint32()));
          break;
        case 2:
          m.certifiedRecord = $root3.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Addresses2.fromObject = function fromObject(d) {
    if (d instanceof $root3.Addresses)
      return d;
    var m = new $root3.Addresses();
    if (d.addrs) {
      if (!Array.isArray(d.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];
      for (var i = 0; i < d.addrs.length; ++i) {
        if (typeof d.addrs[i] !== "object")
          throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i] = $root3.Addresses.Address.fromObject(d.addrs[i]);
      }
    }
    if (d.certifiedRecord != null) {
      if (typeof d.certifiedRecord !== "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root3.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }
    return m;
  };
  Addresses2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addrs = [];
    }
    if (o.defaults) {
      d.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root3.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d.certifiedRecord = $root3.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d;
  };
  Addresses2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal3.default.util.toJSONOptions);
  };
  Addresses2.Address = function() {
    function Address2(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    Address2.prototype.multiaddr = $util3.newBuffer([]);
    Address2.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address2.prototype, "_isCertified", {
      get: $util3.oneOfGetter($oneOfFields = ["isCertified"]),
      set: $util3.oneOfSetter($oneOfFields)
    });
    Address2.encode = function encode26(m, w) {
      if (!w)
        w = $Writer3.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address2.decode = function decode33(r, l) {
      if (!(r instanceof $Reader3))
        r = $Reader3.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root3.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          case 2:
            m.isCertified = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Address2.fromObject = function fromObject(d) {
      if (d instanceof $root3.Addresses.Address)
        return d;
      var m = new $root3.Addresses.Address();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util3.base64.decode(d.multiaddr, m.multiaddr = $util3.newBuffer($util3.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }
      return m;
    };
    Address2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util3.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util3.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d.isCertified = m.isCertified;
        if (o.oneofs)
          d._isCertified = "isCertified";
      }
      return d;
    };
    Address2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal3.default.util.toJSONOptions);
    };
    return Address2;
  }();
  Addresses2.CertifiedRecord = function() {
    function CertifiedRecord(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    CertifiedRecord.prototype.seq = $util3.Long ? $util3.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util3.newBuffer([]);
    CertifiedRecord.encode = function encode26(m, w) {
      if (!w)
        w = $Writer3.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode33(r, l) {
      if (!(r instanceof $Reader3))
        r = $Reader3.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root3.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;
          case 2:
            m.raw = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root3.Addresses.CertifiedRecord)
        return d;
      var m = new $root3.Addresses.CertifiedRecord();
      if (d.seq != null) {
        if ($util3.Long)
          (m.seq = $util3.Long.fromValue(d.seq)).unsigned = true;
        else if (typeof d.seq === "string")
          m.seq = parseInt(d.seq, 10);
        else if (typeof d.seq === "number")
          m.seq = d.seq;
        else if (typeof d.seq === "object")
          m.seq = new $util3.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }
      if (d.raw != null) {
        if (typeof d.raw === "string")
          $util3.base64.decode(d.raw, m.raw = $util3.newBuffer($util3.base64.length(d.raw)), 0);
        else if (d.raw.length)
          m.raw = d.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if ($util3.Long) {
          var n = new $util3.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d.seq = o.longs === String ? "0" : 0;
        if (o.bytes === String)
          d.raw = "";
        else {
          d.raw = [];
          if (o.bytes !== Array)
            d.raw = $util3.newBuffer(d.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number")
          d.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d.seq = o.longs === String ? $util3.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util3.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty("raw")) {
        d.raw = o.bytes === String ? $util3.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d;
    };
    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal3.default.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses2;
})();

// node_modules/ipfs-repo-migrations/src/migrations/migration-12/pb/peer.js
var import_minimal4 = __toESM(require_minimal2(), 1);
var $Reader4 = import_minimal4.default.Reader;
var $Writer4 = import_minimal4.default.Writer;
var $util4 = import_minimal4.default.util;
var $root4 = import_minimal4.default.roots["default"] || (import_minimal4.default.roots["default"] = {});
var Peer = $root4.Peer = (() => {
  function Peer2(p) {
    this.addresses = [];
    this.protocols = [];
    this.metadata = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Peer2.prototype.addresses = $util4.emptyArray;
  Peer2.prototype.protocols = $util4.emptyArray;
  Peer2.prototype.metadata = $util4.emptyArray;
  Peer2.prototype.pubKey = null;
  Peer2.prototype.peerRecordEnvelope = null;
  let $oneOfFields;
  Object.defineProperty(Peer2.prototype, "_pubKey", {
    get: $util4.oneOfGetter($oneOfFields = ["pubKey"]),
    set: $util4.oneOfSetter($oneOfFields)
  });
  Object.defineProperty(Peer2.prototype, "_peerRecordEnvelope", {
    get: $util4.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
    set: $util4.oneOfSetter($oneOfFields)
  });
  Peer2.encode = function encode26(m, w) {
    if (!w)
      w = $Writer4.create();
    if (m.addresses != null && m.addresses.length) {
      for (var i = 0; i < m.addresses.length; ++i)
        $root4.Address.encode(m.addresses[i], w.uint32(10).fork()).ldelim();
    }
    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i)
        w.uint32(18).string(m.protocols[i]);
    }
    if (m.metadata != null && m.metadata.length) {
      for (var i = 0; i < m.metadata.length; ++i)
        $root4.Metadata.encode(m.metadata[i], w.uint32(26).fork()).ldelim();
    }
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(34).bytes(m.pubKey);
    if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
      w.uint32(42).bytes(m.peerRecordEnvelope);
    return w;
  };
  Peer2.decode = function decode33(r, l) {
    if (!(r instanceof $Reader4))
      r = $Reader4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Peer();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root4.Address.decode(r, r.uint32()));
          break;
        case 2:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        case 3:
          if (!(m.metadata && m.metadata.length))
            m.metadata = [];
          m.metadata.push($root4.Metadata.decode(r, r.uint32()));
          break;
        case 4:
          m.pubKey = r.bytes();
          break;
        case 5:
          m.peerRecordEnvelope = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Peer2.fromObject = function fromObject(d) {
    if (d instanceof $root4.Peer)
      return d;
    var m = new $root4.Peer();
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".Peer.addresses: array expected");
      m.addresses = [];
      for (var i = 0; i < d.addresses.length; ++i) {
        if (typeof d.addresses[i] !== "object")
          throw TypeError(".Peer.addresses: object expected");
        m.addresses[i] = $root4.Address.fromObject(d.addresses[i]);
      }
    }
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Peer.protocols: array expected");
      m.protocols = [];
      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }
    if (d.metadata) {
      if (!Array.isArray(d.metadata))
        throw TypeError(".Peer.metadata: array expected");
      m.metadata = [];
      for (var i = 0; i < d.metadata.length; ++i) {
        if (typeof d.metadata[i] !== "object")
          throw TypeError(".Peer.metadata: object expected");
        m.metadata[i] = $root4.Metadata.fromObject(d.metadata[i]);
      }
    }
    if (d.pubKey != null) {
      if (typeof d.pubKey === "string")
        $util4.base64.decode(d.pubKey, m.pubKey = $util4.newBuffer($util4.base64.length(d.pubKey)), 0);
      else if (d.pubKey.length)
        m.pubKey = d.pubKey;
    }
    if (d.peerRecordEnvelope != null) {
      if (typeof d.peerRecordEnvelope === "string")
        $util4.base64.decode(d.peerRecordEnvelope, m.peerRecordEnvelope = $util4.newBuffer($util4.base64.length(d.peerRecordEnvelope)), 0);
      else if (d.peerRecordEnvelope.length)
        m.peerRecordEnvelope = d.peerRecordEnvelope;
    }
    return m;
  };
  Peer2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
      d.protocols = [];
      d.metadata = [];
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root4.Address.toObject(m.addresses[j], o);
      }
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    if (m.metadata && m.metadata.length) {
      d.metadata = [];
      for (var j = 0; j < m.metadata.length; ++j) {
        d.metadata[j] = $root4.Metadata.toObject(m.metadata[j], o);
      }
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util4.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
      if (o.oneofs)
        d._pubKey = "pubKey";
    }
    if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
      d.peerRecordEnvelope = o.bytes === String ? $util4.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
      if (o.oneofs)
        d._peerRecordEnvelope = "peerRecordEnvelope";
    }
    return d;
  };
  Peer2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
  };
  return Peer2;
})();
var Address = $root4.Address = (() => {
  function Address2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Address2.prototype.multiaddr = $util4.newBuffer([]);
  Address2.prototype.isCertified = null;
  let $oneOfFields;
  Object.defineProperty(Address2.prototype, "_isCertified", {
    get: $util4.oneOfGetter($oneOfFields = ["isCertified"]),
    set: $util4.oneOfSetter($oneOfFields)
  });
  Address2.encode = function encode26(m, w) {
    if (!w)
      w = $Writer4.create();
    if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
      w.uint32(10).bytes(m.multiaddr);
    if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
      w.uint32(16).bool(m.isCertified);
    return w;
  };
  Address2.decode = function decode33(r, l) {
    if (!(r instanceof $Reader4))
      r = $Reader4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Address();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Address2.fromObject = function fromObject(d) {
    if (d instanceof $root4.Address)
      return d;
    var m = new $root4.Address();
    if (d.multiaddr != null) {
      if (typeof d.multiaddr === "string")
        $util4.base64.decode(d.multiaddr, m.multiaddr = $util4.newBuffer($util4.base64.length(d.multiaddr)), 0);
      else if (d.multiaddr.length)
        m.multiaddr = d.multiaddr;
    }
    if (d.isCertified != null) {
      m.isCertified = Boolean(d.isCertified);
    }
    return m;
  };
  Address2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.multiaddr = "";
      else {
        d.multiaddr = [];
        if (o.bytes !== Array)
          d.multiaddr = $util4.newBuffer(d.multiaddr);
      }
    }
    if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
      d.multiaddr = o.bytes === String ? $util4.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
    }
    if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
      d.isCertified = m.isCertified;
      if (o.oneofs)
        d._isCertified = "isCertified";
    }
    return d;
  };
  Address2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
  };
  return Address2;
})();
var Metadata = $root4.Metadata = (() => {
  function Metadata2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata2.prototype.key = "";
  Metadata2.prototype.value = $util4.newBuffer([]);
  Metadata2.encode = function encode26(m, w) {
    if (!w)
      w = $Writer4.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
      w.uint32(10).string(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(18).bytes(m.value);
    return w;
  };
  Metadata2.decode = function decode33(r, l) {
    if (!(r instanceof $Reader4))
      r = $Reader4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.key = r.string();
          break;
        case 2:
          m.value = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata2.fromObject = function fromObject(d) {
    if (d instanceof $root4.Metadata)
      return d;
    var m = new $root4.Metadata();
    if (d.key != null) {
      m.key = String(d.key);
    }
    if (d.value != null) {
      if (typeof d.value === "string")
        $util4.base64.decode(d.value, m.value = $util4.newBuffer($util4.base64.length(d.value)), 0);
      else if (d.value.length)
        m.value = d.value;
    }
    return m;
  };
  Metadata2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.key = "";
      if (o.bytes === String)
        d.value = "";
      else {
        d.value = [];
        if (o.bytes !== Array)
          d.value = $util4.newBuffer(d.value);
      }
    }
    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = m.key;
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util4.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    return d;
  };
  Metadata2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
  };
  return Metadata2;
})();

// node_modules/ipfs-repo-migrations/src/migrations/migration-12/pb/envelope.js
var import_minimal5 = __toESM(require_minimal2(), 1);
var $Reader5 = import_minimal5.default.Reader;
var $Writer5 = import_minimal5.default.Writer;
var $util5 = import_minimal5.default.util;
var $root5 = import_minimal5.default.roots["default"] || (import_minimal5.default.roots["default"] = {});
var Envelope = $root5.Envelope = (() => {
  function Envelope2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Envelope2.prototype.publicKey = $util5.newBuffer([]);
  Envelope2.prototype.payloadType = $util5.newBuffer([]);
  Envelope2.prototype.payload = $util5.newBuffer([]);
  Envelope2.prototype.signature = $util5.newBuffer([]);
  Envelope2.encode = function encode26(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope2.decode = function decode33(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;
        case 2:
          m.payloadType = r.bytes();
          break;
        case 3:
          m.payload = r.bytes();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Envelope2.fromObject = function fromObject(d) {
    if (d instanceof $root5.Envelope)
      return d;
    var m = new $root5.Envelope();
    if (d.publicKey != null) {
      if (typeof d.publicKey === "string")
        $util5.base64.decode(d.publicKey, m.publicKey = $util5.newBuffer($util5.base64.length(d.publicKey)), 0);
      else if (d.publicKey.length)
        m.publicKey = d.publicKey;
    }
    if (d.payloadType != null) {
      if (typeof d.payloadType === "string")
        $util5.base64.decode(d.payloadType, m.payloadType = $util5.newBuffer($util5.base64.length(d.payloadType)), 0);
      else if (d.payloadType.length)
        m.payloadType = d.payloadType;
    }
    if (d.payload != null) {
      if (typeof d.payload === "string")
        $util5.base64.decode(d.payload, m.payload = $util5.newBuffer($util5.base64.length(d.payload)), 0);
      else if (d.payload.length)
        m.payload = d.payload;
    }
    if (d.signature != null) {
      if (typeof d.signature === "string")
        $util5.base64.decode(d.signature, m.signature = $util5.newBuffer($util5.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    return m;
  };
  Envelope2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.publicKey = "";
      else {
        d.publicKey = [];
        if (o.bytes !== Array)
          d.publicKey = $util5.newBuffer(d.publicKey);
      }
      if (o.bytes === String)
        d.payloadType = "";
      else {
        d.payloadType = [];
        if (o.bytes !== Array)
          d.payloadType = $util5.newBuffer(d.payloadType);
      }
      if (o.bytes === String)
        d.payload = "";
      else {
        d.payload = [];
        if (o.bytes !== Array)
          d.payload = $util5.newBuffer(d.payload);
      }
      if (o.bytes === String)
        d.signature = "";
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util5.newBuffer(d.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util5.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d.payloadType = o.bytes === String ? $util5.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty("payload")) {
      d.payload = o.bytes === String ? $util5.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util5.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d;
  };
  Envelope2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
  };
  return Envelope2;
})();

// node_modules/ipfs-repo-migrations/src/migrations/migration-12/pb/peer-record.js
var import_minimal6 = __toESM(require_minimal2(), 1);
var $Reader6 = import_minimal6.default.Reader;
var $Writer6 = import_minimal6.default.Writer;
var $util6 = import_minimal6.default.util;
var $root6 = import_minimal6.default.roots["default"] || (import_minimal6.default.roots["default"] = {});
var PeerRecord = $root6.PeerRecord = (() => {
  function PeerRecord2(p) {
    this.addresses = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  PeerRecord2.prototype.peerId = $util6.newBuffer([]);
  PeerRecord2.prototype.seq = $util6.Long ? $util6.Long.fromBits(0, 0, true) : 0;
  PeerRecord2.prototype.addresses = $util6.emptyArray;
  PeerRecord2.encode = function encode26(m, w) {
    if (!w)
      w = $Writer6.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
      w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
      w.uint32(16).uint64(m.seq);
    if (m.addresses != null && m.addresses.length) {
      for (var i = 0; i < m.addresses.length; ++i)
        $root6.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();
    }
    return w;
  };
  PeerRecord2.decode = function decode33(r, l) {
    if (!(r instanceof $Reader6))
      r = $Reader6.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root6.PeerRecord();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;
        case 2:
          m.seq = r.uint64();
          break;
        case 3:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root6.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  PeerRecord2.fromObject = function fromObject(d) {
    if (d instanceof $root6.PeerRecord)
      return d;
    var m = new $root6.PeerRecord();
    if (d.peerId != null) {
      if (typeof d.peerId === "string")
        $util6.base64.decode(d.peerId, m.peerId = $util6.newBuffer($util6.base64.length(d.peerId)), 0);
      else if (d.peerId.length)
        m.peerId = d.peerId;
    }
    if (d.seq != null) {
      if ($util6.Long)
        (m.seq = $util6.Long.fromValue(d.seq)).unsigned = true;
      else if (typeof d.seq === "string")
        m.seq = parseInt(d.seq, 10);
      else if (typeof d.seq === "number")
        m.seq = d.seq;
      else if (typeof d.seq === "object")
        m.seq = new $util6.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
    }
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];
      for (var i = 0; i < d.addresses.length; ++i) {
        if (typeof d.addresses[i] !== "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i] = $root6.PeerRecord.AddressInfo.fromObject(d.addresses[i]);
      }
    }
    return m;
  };
  PeerRecord2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
    }
    if (o.defaults) {
      if (o.bytes === String)
        d.peerId = "";
      else {
        d.peerId = [];
        if (o.bytes !== Array)
          d.peerId = $util6.newBuffer(d.peerId);
      }
      if ($util6.Long) {
        var n = new $util6.Long(0, 0, true);
        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.seq = o.longs === String ? "0" : 0;
    }
    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d.peerId = o.bytes === String ? $util6.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }
    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number")
        d.seq = o.longs === String ? String(m.seq) : m.seq;
      else
        d.seq = o.longs === String ? $util6.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util6.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root6.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }
    return d;
  };
  PeerRecord2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  PeerRecord2.AddressInfo = function() {
    function AddressInfo(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    AddressInfo.prototype.multiaddr = $util6.newBuffer([]);
    AddressInfo.encode = function encode26(m, w) {
      if (!w)
        w = $Writer6.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    AddressInfo.decode = function decode33(r, l) {
      if (!(r instanceof $Reader6))
        r = $Reader6.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root6.PeerRecord.AddressInfo();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    AddressInfo.fromObject = function fromObject(d) {
      if (d instanceof $root6.PeerRecord.AddressInfo)
        return d;
      var m = new $root6.PeerRecord.AddressInfo();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util6.base64.decode(d.multiaddr, m.multiaddr = $util6.newBuffer($util6.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      return m;
    };
    AddressInfo.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util6.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util6.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      return d;
    };
    AddressInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
    };
    return AddressInfo;
  }();
  return PeerRecord2;
})();

// node_modules/ipfs-repo-migrations/src/migrations/migration-12/index.js
import_minimal7.default.util.Long = void 0;
import_minimal7.default.configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a single datastore key");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [, prefix, type, peerId, metadataKey] = keyStr.split("/");
    if (prefix !== "peers") {
      continue;
    }
    if (!["protos", "addrs", "metadata", "keys"].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === "protos") {
      const protos = Protocols.decode(value);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === "addrs") {
      const addrs = Addresses.decode(value);
      peers[peerId].addresses = addrs.addrs.sort((a, b) => {
        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === "metadata") {
      peers[peerId].metadata.push({ key: metadataKey, value });
    } else if (type === "keys") {
      peers[peerId].pubKey = value;
    }
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const peerId of Object.keys(peers)) {
    const peer = peers[peerId];
    peer.metadata = peer.metadata.sort((a, b) => a.key.localeCompare(b.key));
    const data = Peer.encode(peer).finish();
    await backends.datastore.put(new Key(`/peers/${peerId}`), data);
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a multiple datastore keys");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [, , peerId] = keyStr.split("/");
    peers[peerId] = Peer.decode(value);
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({
        protocols: peer.protocols
      }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope = Envelope.decode(peerRecordEnvelope);
        const record = PeerRecord.decode(envelope.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const { key, value } of peer.metadata) {
        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under multiple datastore keys");
}
var migration5 = {
  version: 12,
  description: "Store each peerstore peer under a single datastore key",
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};

// node_modules/ipfs-repo-migrations/src/migrations/index.js
var emptyMigration = {
  description: "Empty migration.",
  // @ts-ignore
  migrate: () => {
  },
  // @ts-ignore
  revert: () => {
  },
  empty: true
};
var migrations_default = [
  Object.assign({ version: 1 }, emptyMigration),
  Object.assign({ version: 2 }, emptyMigration),
  Object.assign({ version: 3 }, emptyMigration),
  Object.assign({ version: 4 }, emptyMigration),
  Object.assign({ version: 5 }, emptyMigration),
  Object.assign({ version: 6 }, emptyMigration),
  Object.assign({ version: 7 }, emptyMigration),
  migration,
  migration2,
  migration3,
  migration4,
  migration5
];

// node_modules/ipfs-repo-migrations/src/repo/init.js
var import_debug2 = __toESM(require_browser(), 1);

// node_modules/ipfs-repo-migrations/src/errors.js
var errors_exports2 = {};
__export(errors_exports2, {
  InvalidValueError: () => InvalidValueError,
  MissingRepoOptionsError: () => MissingRepoOptionsError,
  NonReversibleMigrationError: () => NonReversibleMigrationError,
  NotInitializedRepoError: () => NotInitializedRepoError,
  RequiredParameterError: () => RequiredParameterError
});
var NonReversibleMigrationError = class _NonReversibleMigrationError extends Error {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(message);
    this.name = "NonReversibleMigrationError";
    this.code = _NonReversibleMigrationError.code;
    this.message = message;
  }
};
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
var NotInitializedRepoError = class _NotInitializedRepoError extends Error {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(message);
    this.name = "NotInitializedRepoError";
    this.code = _NotInitializedRepoError.code;
    this.message = message;
  }
};
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
var RequiredParameterError = class _RequiredParameterError extends Error {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(message);
    this.name = "RequiredParameterError";
    this.code = _RequiredParameterError.code;
    this.message = message;
  }
};
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
var InvalidValueError = class _InvalidValueError extends Error {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(message);
    this.name = "InvalidValueError";
    this.code = _InvalidValueError.code;
    this.message = message;
  }
};
InvalidValueError.code = "ERR_INVALID_VALUE";
var MissingRepoOptionsError = class _MissingRepoOptionsError extends Error {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(message);
    this.name = "MissingRepoOptionsError";
    this.code = _MissingRepoOptionsError.code;
    this.message = message;
  }
};
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";

// node_modules/ipfs-repo-migrations/src/repo/init.js
var log3 = (0, import_debug2.default)("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root3 = backends.root;
  try {
    await root3.open();
    const versionCheck = await root3.has(VERSION_KEY);
    const configCheck = await root3.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log3(`Version entry present: ${versionCheck}`);
      log3(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log3("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root3 !== void 0) {
      try {
        await root3.close();
      } catch {
      }
    }
  }
}

// node_modules/ipfs-repo-migrations/src/repo/version.js
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store2 = backends.root;
  await store2.open();
  try {
    return parseInt(toString2(await store2.get(VERSION_KEY)));
  } finally {
    await store2.close();
  }
}
async function setVersion(version3, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store2 = backends.root;
  await store2.open();
  await store2.put(VERSION_KEY, fromString(String(version3)));
  await store2.close();
}

// node_modules/ipfs-repo-migrations/src/index.js
var import_debug3 = __toESM(require_browser(), 1);
var log4 = (0, import_debug3.default)("ipfs:repo:migrator");
function getLatestMigrationVersion(migrations) {
  migrations = migrations || migrations_default;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log4("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path);
  }
  try {
    for (const migration6 of migrations) {
      if (toVersion !== void 0 && migration6.version > toVersion) {
        break;
      }
      if (migration6.version <= currentVersion) {
        continue;
      }
      log4(`Migrating version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration6.version, percent.toFixed(2), message);
          }
          await migration6.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration6.version - 1;
        log4(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration6.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log4(`Migrating to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log4("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
async function revert(path, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log4("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path);
  }
  log4(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration6 of reversedMigrationArray) {
      if (migration6.version <= toVersion) {
        break;
      }
      if (migration6.version > currentVersion) {
        continue;
      }
      log4(`Reverting migration version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration6.version, percent.toFixed(2), message);
          }
          await migration6.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration6.version;
        log4(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration6.version} exception was raised: ${e.message}`;
        throw e;
      }
      log4(`Reverting to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log4(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration6 of migrations) {
    if (migration6.version > toVersion) {
      break;
    }
    if (migration6.version > fromVersion) {
      if (checkReversibility && !migration6.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration6.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
var errors = errors_exports2;

// node_modules/ipfs-repo/src/index.js
var import_bytes31 = __toESM(require_bytes(), 1);

// node_modules/merge-options/index.mjs
var import_index4 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index4.default;

// node_modules/ipfs-repo/src/constants.js
var repoVersion = 12;

// node_modules/ipfs-repo/src/version.js
var import_debug4 = __toESM(require_browser(), 1);

// node_modules/ipfs-repo/src/errors.js
var LockExistsError = class _LockExistsError extends Error {
  /**
   * @param {string} [message]
   */
  constructor(message) {
    super(message);
    this.name = "LockExistsError";
    this.code = _LockExistsError.code;
  }
};
LockExistsError.code = "ERR_LOCK_EXISTS";
var NotFoundError = class _NotFoundError extends Error {
  /**
   * @param {string} [message]
   */
  constructor(message) {
    super(message);
    this.name = "NotFoundError";
    this.code = _NotFoundError.code;
  }
};
NotFoundError.code = "ERR_NOT_FOUND";
var InvalidRepoVersionError = class _InvalidRepoVersionError extends Error {
  /**
   * @param {string} [message]
   */
  constructor(message) {
    super(message);
    this.name = "InvalidRepoVersionError";
    this.code = _InvalidRepoVersionError.code;
  }
};
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
var ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
var ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
var ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";

// node_modules/ipfs-repo/src/utils/level.js
async function hasWithFallback2(key, has, store2) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs2(store2);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve(Boolean(req.result));
    };
  });
}
async function getWithFallback2(key, get5, has, store2) {
  if (await has(key)) {
    return get5(key);
  }
  const levelJs = findLevelJs2(store2);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs2(store2) {
  let db = store2;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}

// node_modules/ipfs-repo/src/version.js
var log5 = (0, import_debug4.default)("ipfs:repo:version");
var versionKey = new Key("version");
function version2(store2) {
  return {
    /**
     * Check if a version file exists.
     *
     */
    async exists() {
      return hasWithFallback2(versionKey, store2.has.bind(store2), store2);
    },
    /**
     * Get the current version.
     *
     * @returns {Promise<number>}
     */
    async get() {
      const buf2 = await getWithFallback2(versionKey, store2.get.bind(store2), store2.has.bind(store2), store2);
      return parseInt(toString2(buf2), 10);
    },
    /**
     * Set the version of the repo, writing it to the underlying store.
     *
     * @param {number} version
     * @returns {Promise<void>}
     */
    set(version3) {
      return store2.put(versionKey, fromString(String(version3)));
    },
    /**
     * Check the current version, and returns true if versions matches
     *
     * @param {number} expected
     */
    async check(expected) {
      const version3 = await this.get();
      log5("comparing version: %s and %s", version3, expected);
      const compatibleVersion = version3 === 6 && expected === 7 || expected === 6 && version3 === 7;
      return version3 === expected || compatibleVersion;
    }
  };
}

// node_modules/p-queue/dist/index.js
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// node_modules/p-queue/node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}

// node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
var PriorityQueue = class {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet3(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet3(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index2 = lowerBound(__classPrivateFieldGet3(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet3(this, _PriorityQueue_queue, "f").splice(index2, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet3(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet3(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet3(this, _PriorityQueue_queue, "f").length;
  }
};
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();

// node_modules/p-queue/dist/index.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances;
var _PQueue_carryoverConcurrencyCount;
var _PQueue_isIntervalIgnored;
var _PQueue_intervalCount;
var _PQueue_intervalCap;
var _PQueue_interval;
var _PQueue_intervalEnd;
var _PQueue_intervalId;
var _PQueue_timeoutId;
var _PQueue_queue;
var _PQueue_queueClass;
var _PQueue_pending;
var _PQueue_concurrency;
var _PQueue_isPaused;
var _PQueue_throwOnTimeout;
var _PQueue_doesIntervalAllowAnother_get;
var _PQueue_doesConcurrentAllowAnother_get;
var _PQueue_next;
var _PQueue_onResumeInterval;
var _PQueue_isIntervalPaused_get;
var _PQueue_tryToStartAnother;
var _PQueue_initializeIntervalIfNeeded;
var _PQueue_onInterval;
var _PQueue_processQueue;
var _PQueue_throwOnAbort;
var _PQueue_onEvent;
var AbortError2 = class extends Error {
};
var PQueue = class extends import_eventemitter3.default {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a2, _b, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pending.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a2 = options.intervalCap) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet3(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet3(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet3(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet3(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet3(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet3(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet3(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet3(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet4(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet3(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __classPrivateFieldGet4(this, _PQueue_throwOnTimeout, "f"),
      ...options
    };
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet4(this, _PQueue_queue, "f").enqueue(async () => {
        var _a2;
        var _b, _c;
        __classPrivateFieldSet3(this, _PQueue_pending, (_b = __classPrivateFieldGet4(this, _PQueue_pending, "f"), _b++, _b), "f");
        __classPrivateFieldSet3(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet4(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a2 = options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            throw new AbortError2("The task was aborted.");
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), options.timeout);
          }
          if (options.signal) {
            operation = Promise.race([operation, __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_next).call(this);
        }
      }, options);
      this.emit("add");
      __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__classPrivateFieldGet4(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet3(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __classPrivateFieldSet3(this, _PQueue_isPaused, true, "f");
  }
  /**
  Clear the queue.
  */
  clear() {
    __classPrivateFieldSet3(this, _PQueue_queue, new (__classPrivateFieldGet4(this, _PQueue_queueClass, "f"))(), "f");
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__classPrivateFieldGet4(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet4(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet4(this, _PQueue_queue, "f").size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__classPrivateFieldGet4(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet4(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __classPrivateFieldGet4(this, _PQueue_queue, "f").size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __classPrivateFieldGet4(this, _PQueue_queue, "f").filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __classPrivateFieldGet4(this, _PQueue_pending, "f");
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __classPrivateFieldGet4(this, _PQueue_isPaused, "f");
  }
};
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet4(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet4(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet4(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet4(this, _PQueue_pending, "f") < __classPrivateFieldGet4(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a2;
  __classPrivateFieldSet3(this, _PQueue_pending, (_a2 = __classPrivateFieldGet4(this, _PQueue_pending, "f"), _a2--, _a2), "f");
  __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet3(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet4(this, _PQueue_intervalId, "f") === void 0) {
    const delay = __classPrivateFieldGet4(this, _PQueue_intervalEnd, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet3(this, _PQueue_intervalCount, __classPrivateFieldGet4(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet4(this, _PQueue_pending, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet4(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet3(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet4(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet4(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet4(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet3(this, _PQueue_intervalId, void 0, "f");
    this.emit("empty");
    if (__classPrivateFieldGet4(this, _PQueue_pending, "f") === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__classPrivateFieldGet4(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet4(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet4(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet4(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet4(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet4(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet4(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet3(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet4(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet3(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet4(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet4(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet4(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet4(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet4(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet3(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet3(this, _PQueue_intervalCount, __classPrivateFieldGet4(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet4(this, _PQueue_pending, "f") : 0, "f");
  __classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet4(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort2(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(new AbortError2("The task was aborted."));
    }, { once: true });
  });
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter5) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter5 && !filter5()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};

// node_modules/just-safe-set/index.mjs
var objectSafeSet = set;
function set(obj, propsArg, value) {
  var props, lastProp;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  lastProp = props.pop();
  if (!lastProp) {
    return false;
  }
  prototypeCheck(lastProp);
  var thisProp;
  while (thisProp = props.shift()) {
    prototypeCheck(thisProp);
    if (typeof obj[thisProp] == "undefined") {
      obj[thisProp] = {};
    }
    obj = obj[thisProp];
    if (!obj || typeof obj != "object") {
      return false;
    }
  }
  obj[lastProp] = value;
  return true;
}
function prototypeCheck(prop) {
  if (prop == "__proto__" || prop == "constructor" || prop == "prototype") {
    throw new Error("setting of prototype values not supported");
  }
}

// node_modules/ipfs-repo/src/config.js
var import_err_code4 = __toESM(require_err_code(), 1);
var Queue = PQueue.default ? PQueue.default : PQueue;
var configKey = new Key("config");
function config(store2) {
  const setQueue = new Queue({ concurrency: 1 });
  const configStore = {
    /**
     * Get the current configuration from the repo.
     *
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config read
     * @returns {Promise<Config>}
     */
    async getAll(options = {}) {
      const encodedValue = await getWithFallback2(configKey, store2.get.bind(store2), store2.has.bind(store2), store2);
      return JSON.parse(toString2(encodedValue));
    },
    /**
     * Get the value for the passed configuration key from the repo.
     *
     * @param {string} key - the config key to get
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config read
     */
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value = objectSafeGet(config2, key);
      if (value === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value;
    },
    /**
     * Set the current configuration for this repo.
     *
     * @param {string} key - the config key to be written
     * @param {any} [value] - the config value to be written
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config write
     */
    set(key, value, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw (0, import_err_code4.default)(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value === void 0 || value instanceof Uint8Array) {
        throw (0, import_err_code4.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value
      }, options.signal));
    },
    /**
     * Set the current configuration for this repo.
     *
     * @param {Config} [value] - the config value to be written
     * @param {object} [options] - options
     * @param {AbortSignal} [options.signal] - abort this config write
     */
    replace(value, options = {}) {
      if (!value || value instanceof Uint8Array) {
        throw (0, import_err_code4.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value
      }, options.signal));
    },
    /**
     * Check if a config file exists.
     *
     */
    async exists() {
      return hasWithFallback2(configKey, store2.has.bind(store2), store2);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        objectSafeSet(config2, key, value);
      }
      return _saveAll(config2);
    }
    return _saveAll(value);
  }
  function _saveAll(config2) {
    const buf2 = fromString(JSON.stringify(config2, null, 2));
    return store2.put(configKey, buf2);
  }
}

// node_modules/sort-keys/node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/sort-keys/index.js
function sortKeys(object, options = {}) {
  if (!isPlainObject(object) && !Array.isArray(object)) {
    throw new TypeError("Expected a plain object or array");
  }
  const { deep, compare: compare4 } = options;
  const seenInput = [];
  const seenOutput = [];
  const deepSortArray = (array) => {
    const seenIndex = seenInput.indexOf(array);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = [];
    seenInput.push(array);
    seenOutput.push(result);
    result.push(...array.map((item) => {
      if (Array.isArray(item)) {
        return deepSortArray(item);
      }
      if (isPlainObject(item)) {
        return _sortKeys(item);
      }
      return item;
    }));
    return result;
  };
  const _sortKeys = (object2) => {
    const seenIndex = seenInput.indexOf(object2);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = {};
    const keys = Object.keys(object2).sort(compare4);
    seenInput.push(object2);
    seenOutput.push(result);
    for (const key of keys) {
      const value = object2[key];
      let newValue;
      if (deep && Array.isArray(value)) {
        newValue = deepSortArray(value);
      } else {
        newValue = deep && isPlainObject(value) ? _sortKeys(value) : value;
      }
      Object.defineProperty(result, key, {
        ...Object.getOwnPropertyDescriptor(object2, key),
        value: newValue
      });
    }
    return result;
  };
  if (Array.isArray(object)) {
    return deep ? deepSortArray(object) : object.slice();
  }
  return _sortKeys(object);
}

// node_modules/ipfs-repo/src/spec.js
var specKey = new Key("datastore_spec");
function spec(store2) {
  return {
    /**
     * Check if a datastore spec file exists.
     *
     */
    exists() {
      return store2.has(specKey);
    },
    /**
     * Get the current datastore spec.
     *
     * @returns {Promise<Uint8Array>}
     */
    async get() {
      const buf2 = await store2.get(specKey);
      return JSON.parse(toString2(buf2));
    },
    /**
     * Set the datastore spec of the repo, writing it to the underlying store.
     * TODO unclear on what the type should be or if it's required
     *
     * @param {any} spec
     * @returns {Promise<void>}
     */
    async set(spec2) {
      return store2.put(specKey, fromString(JSON.stringify(sortKeys(spec2, { deep: true }))));
    }
  };
}

// node_modules/ipfs-repo/src/api-addr.js
var apiFile = new Key("api");
function apiAddr(store2) {
  return {
    /**
     * Get the current configuration from the repo.
     *
     * @returns {Promise<string>}
     */
    async get() {
      const value = await store2.get(apiFile);
      return value && value.toString();
    },
    /**
     * Set the current configuration for this repo.
     * TODO: fix find the proper type or remove this API
     *
     * @param {string} value - the api address to be written
     */
    set(value) {
      return store2.put(apiFile, fromString(value.toString()));
    },
    /**
     * Deletes api file
     */
    delete() {
      return store2.delete(apiFile);
    }
  };
}

// node_modules/ipfs-repo/node_modules/it-filter/dist/src/index.js
async function* filter(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}

// node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(options = {}) {
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// node_modules/it-pushable/dist/src/index.js
function pushable(options = {}) {
  const getNext = (buffer2) => {
    const next = buffer2.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer2 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  const waitNext = async () => {
    if (!buffer2.isEmpty()) {
      return getNext(buffer2);
    }
    if (ended) {
      return { done: true };
    }
    return await new Promise((resolve, reject) => {
      onNext = (next) => {
        onNext = null;
        buffer2.push(next);
        try {
          resolve(getNext(buffer2));
        } catch (err) {
          reject(err);
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer2 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer2.push({ error: err });
    return pushable2;
  };
  const push = (value) => {
    if (ended) {
      return pushable2;
    }
    if (options?.objectMode !== true && value?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer2.size;
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    }
  };
  return pushable2;
}

// node_modules/ipfs-repo/node_modules/it-drain/dist/src/index.js
async function drain(source) {
  for await (const _ of source) {
  }
}

// node_modules/ipfs-repo/node_modules/multiformats/vendor/varint.js
var encode_15 = encode21;
var MSB5 = 128;
var REST5 = 127;
var MSBALL5 = ~REST5;
var INT5 = Math.pow(2, 31);
function encode21(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT5) {
    out[offset++] = num & 255 | MSB5;
    num /= 128;
  }
  while (num & MSBALL5) {
    out[offset++] = num & 255 | MSB5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode21.bytes = offset - oldOffset + 1;
  return out;
}
var decode25 = read5;
var MSB$15 = 128;
var REST$15 = 127;
function read5(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read5.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$15);
  read5.bytes = counter - offset;
  return res;
}
var N15 = Math.pow(2, 7);
var N25 = Math.pow(2, 14);
var N35 = Math.pow(2, 21);
var N45 = Math.pow(2, 28);
var N55 = Math.pow(2, 35);
var N65 = Math.pow(2, 42);
var N75 = Math.pow(2, 49);
var N85 = Math.pow(2, 56);
var N95 = Math.pow(2, 63);
var length6 = function(value) {
  return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
};
var varint9 = {
  encode: encode_15,
  decode: decode25,
  encodingLength: length6
};
var _brrp_varint5 = varint9;
var varint_default5 = _brrp_varint5;

// node_modules/ipfs-repo/node_modules/multiformats/src/varint.js
var decode26 = (data, offset = 0) => {
  const code11 = varint_default5.decode(data, offset);
  return [code11, varint_default5.decode.bytes];
};
var encodeTo5 = (int, target, offset = 0) => {
  varint_default5.encode(int, target, offset);
  return target;
};
var encodingLength5 = (int) => {
  return varint_default5.encodingLength(int);
};

// node_modules/ipfs-repo/node_modules/multiformats/src/bytes.js
var empty6 = new Uint8Array(0);
var equals12 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce6 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/ipfs-repo/node_modules/multiformats/src/hashes/digest.js
var create9 = (code11, digest5) => {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength5(code11);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo5(code11, bytes2, 0);
  encodeTo5(size, bytes2, sizeOffset);
  bytes2.set(digest5, digestOffset);
  return new Digest5(code11, size, digest5, bytes2);
};
var decode27 = (multihash) => {
  const bytes2 = coerce6(multihash);
  const [code11, sizeOffset] = decode26(bytes2);
  const [size, digestOffset] = decode26(bytes2.subarray(sizeOffset));
  const digest5 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest5(code11, size, digest5, bytes2);
};
var equals13 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals12(a.bytes, data.bytes);
  }
};
var Digest5 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code11, size, digest5, bytes2) {
    this.code = code11;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes2;
  }
};

// node_modules/ipfs-repo/node_modules/multiformats/vendor/base-x.js
function base5(ALPHABET, name8) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode26(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length8 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length8) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      pbegin++;
    }
    var it2 = size - length8;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length8 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length8) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length8;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode33(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name8} character`);
  }
  return {
    encode: encode26,
    decodeUnsafe,
    decode: decode33
  };
}
var src5 = base5;
var _brrp__multiformats_scope_baseX5 = src5;
var base_x_default5 = _brrp__multiformats_scope_baseX5;

// node_modules/ipfs-repo/node_modules/multiformats/src/bases/base.js
var Encoder5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name8, prefix, baseEncode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or5(this, decoder);
  }
};
var ComposedDecoder5 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or5(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or5 = (left, right) => new ComposedDecoder5(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec5 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseEncode, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder5(name8, prefix, baseEncode);
    this.decoder = new Decoder5(name8, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from10 = ({ name: name8, prefix, encode: encode26, decode: decode33 }) => new Codec5(name8, prefix, encode26, decode33);
var baseX5 = ({ prefix, name: name8, alphabet: alphabet4 }) => {
  const { encode: encode26, decode: decode33 } = base_x_default5(alphabet4, name8);
  return from10({
    prefix,
    name: name8,
    encode: encode26,
    /**
     * @param {string} text
     */
    decode: (text) => coerce6(decode33(text))
  });
};
var decode28 = (string2, alphabet4, bitsPerChar, name8) => {
  const codes2 = {};
  for (let i = 0; i < alphabet4.length; ++i) {
    codes2[alphabet4[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name8} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode22 = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46485 = ({ name: name8, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from10({
    prefix,
    name: name8,
    encode(input) {
      return encode22(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode28(input, alphabet4, bitsPerChar, name8);
    }
  });
};

// node_modules/ipfs-repo/node_modules/multiformats/src/bases/base58.js
var base58btc5 = baseX5({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr5 = baseX5({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/ipfs-repo/node_modules/multiformats/src/bases/base32.js
var base325 = rfc46485({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper5 = rfc46485({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad5 = rfc46485({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper5 = rfc46485({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex5 = rfc46485({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper5 = rfc46485({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad5 = rfc46485({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper5 = rfc46485({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z5 = rfc46485({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/ipfs-repo/node_modules/multiformats/src/cid.js
var format4 = (link, base7) => {
  const { bytes: bytes2, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV05(
        bytes2,
        baseCache4(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base7 || base58btc5.encoder
      );
    default:
      return toStringV15(
        bytes2,
        baseCache4(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base7 || base325.encoder
      );
  }
};
var cache4 = /* @__PURE__ */ new WeakMap();
var baseCache4 = (cid) => {
  const baseCache6 = cache4.get(cid);
  if (baseCache6 == null) {
    const baseCache7 = /* @__PURE__ */ new Map();
    cache4.set(cid, baseCache7);
    return baseCache7;
  }
  return baseCache6;
};
var CID6 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version3, code11, multihash, bytes2) {
    this.code = code11;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code11, multihash } = this;
        if (code11 !== DAG_PB_CODE5) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE5) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code11, digest: digest5 } = this.multihash;
        const multihash = create9(code11, digest5);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals13(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base7) {
    return format4(this, base7);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returs null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code11, multihash, bytes: bytes2 } = value;
      return new _CID(
        version3,
        code11,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes2 || encodeCID6(version3, code11, multihash.bytes)
      );
    } else if (value[cidSymbol5] === true) {
      const { version: version3, multihash, code: code11 } = value;
      const digest5 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode27(multihash)
      );
      return _CID.create(version3, code11, digest5);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version3, code11, digest5) {
    if (typeof code11 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code11 !== DAG_PB_CODE5) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`
          );
        } else {
          return new _CID(version3, code11, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID6(version3, code11, digest5.bytes);
        return new _CID(version3, code11, digest5, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE5, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code11, digest5) {
    return _CID.create(1, code11, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce6(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest5 = new Digest5(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest5
    ) : _CID.createV1(specs.codec, digest5);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length8] = decode26(initialBytes.subarray(offset));
      offset += length8;
      return i;
    };
    let version3 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE5
    );
    if (
      /** @type {number} */
      version3 === 18
    ) {
      version3 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base7) {
    const [prefix, bytes2] = parseCIDtoBytes5(source, base7);
    const cid = _CID.decode(bytes2);
    baseCache4(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes5 = (source, base7) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base7 || base58btc5;
      return [
        /** @type {Prefix} */
        base58btc5.prefix,
        decoder.decode(`${base58btc5.prefix}${source}`)
      ];
    }
    case base58btc5.prefix: {
      const decoder = base7 || base58btc5;
      return [
        /** @type {Prefix} */
        base58btc5.prefix,
        decoder.decode(source)
      ];
    }
    case base325.prefix: {
      const decoder = base7 || base325;
      return [
        /** @type {Prefix} */
        base325.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base7 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base7.decode(source)
      ];
    }
  }
};
var toStringV05 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  if (prefix !== base58btc5.prefix) {
    throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
  }
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2).slice(1);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV15 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE5 = 112;
var SHA_256_CODE5 = 18;
var encodeCID6 = (version3, code11, multihash) => {
  const codeOffset = encodingLength5(version3);
  const hashOffset = codeOffset + encodingLength5(code11);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo5(version3, bytes2, 0);
  encodeTo5(code11, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");

// node_modules/ipfs-repo/src/idstore.js
var import_err_code5 = __toESM(require_err_code(), 1);

// node_modules/ipfs-repo/node_modules/multiformats/src/hashes/identity.js
var code8 = 0;
var name7 = "identity";
var encode23 = coerce6;
var digest4 = (input) => create9(code8, encode23(input));
var identity7 = { code: code8, name: name7, encode: encode23, digest: digest4 };

// node_modules/ipfs-repo/src/idstore.js
function createIdStore(store2) {
  return {
    open() {
      return store2.open();
    },
    close() {
      return store2.close();
    },
    query(query, options) {
      return store2.query(query, options);
    },
    queryKeys(query, options) {
      return store2.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store2.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf2, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store2.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      const output = pushable({
        objectMode: true
      });
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await drain(store2.putMany(async function* () {
            for await (const { key, value } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield { key, value };
              }
              output.push({ key, value });
            }
          }()));
          output.end();
        } catch (err) {
          output.end(err);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store2.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store2.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store2.deleteMany(filter(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch2 = store2.batch();
      return {
        put(cid, buf2) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.put(cid, buf2);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.delete(cid);
        },
        commit: (options) => {
          return batch2.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID6.asCID(k);
  if (cid == null) {
    throw (0, import_err_code5.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity7.code) {
    return {
      isIdentity: false
    };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}

// node_modules/ipfs-repo/src/locks/memory.js
var import_debug5 = __toESM(require_browser(), 1);
var log6 = (0, import_debug5.default)("ipfs:repo:lock:memory");
var lockFile = "repo.lock";
var LOCKS = {};
async function lock(dir) {
  const file2 = dir + "/" + lockFile;
  log6("locking %s", file2);
  if (LOCKS[file2] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file2}`);
  }
  LOCKS[file2] = true;
  const closer = {
    async close() {
      if (LOCKS[file2]) {
        delete LOCKS[file2];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file2 = dir + "/" + lockFile;
  log6(`checking lock: ${file2}`);
  return Boolean(LOCKS[file2]);
}
var MemoryLock = {
  lock,
  locked
};

// node_modules/ipfs-repo/src/default-options.js
var default_options_default = {
  autoMigrate: true,
  onMigrationProgress: () => {
  },
  repoOwner: true,
  repoLock: MemoryLock
};

// node_modules/ipfs-repo/src/default-datastore.js
var default_datastore_default = {
  Spec: {
    type: "mount",
    mounts: [
      {
        mountpoint: "/blocks",
        type: "measure",
        prefix: "flatfs.datastore",
        child: {
          type: "flatfs",
          path: "blocks",
          sync: true,
          shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
        }
      },
      {
        mountpoint: "/",
        type: "measure",
        prefix: "leveldb.datastore",
        child: {
          type: "levelds",
          path: "datastore",
          compression: "none"
        }
      }
    ]
  }
};

// node_modules/ipfs-repo/src/pin-manager.js
var import_err_code7 = __toESM(require_err_code(), 1);
var import_debug7 = __toESM(require_browser(), 1);

// node_modules/it-first/dist/src/index.js
async function first(source) {
  for await (const entry of source) {
    return entry;
  }
  return void 0;
}

// node_modules/ipfs-repo/node_modules/multiformats/src/block.js
function readonly2({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path, value) {
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (const [index2, element] of value.entries()) {
        const elementPath = [...path, index2];
        const cid = CID6.asCID(element);
        if (cid) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links(element, elementPath);
        }
      }
    } else {
      const cid = CID6.asCID(value);
      if (cid) {
        yield [path.join("/"), cid];
      } else {
        yield* links(value, path);
      }
    }
  }
}
function* links(source, base7) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base7, key]
    );
    yield* linksWithin(path, value);
  }
}
function* treeWithin(path, value) {
  if (Array.isArray(value)) {
    for (const [index2, element] of value.entries()) {
      const elementPath = [...path, index2];
      yield elementPath.join("/");
      if (typeof element === "object" && !CID6.asCID(element)) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value, path);
  }
}
function* tree(source, base7) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base7, key]
    );
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID6.asCID(value)) {
      yield* treeWithin(path, value);
    }
  }
}
function get4(source, path) {
  let node = (
    /** @type {Record<string, any>} */
    source
  );
  for (const [index2, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID6.asCID(node);
    if (cid) {
      return { value: cid, remaining: path.slice(index2 + 1).join("/") };
    }
  }
  return { value: node };
}
var Block = class {
  /**
   * @param {object} options
   * @param {CID<T, C, A, V>} options.cid
   * @param {API.ByteView<T>} options.bytes
   * @param {T} options.value
   */
  constructor({ cid, bytes: bytes2, value }) {
    if (!cid || !bytes2 || typeof value === "undefined") {
      throw new Error("Missing required argument");
    }
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  /**
   *
   * @param {string} [path]
   * @returns {API.BlockCursorView<unknown>}
   */
  get(path = "/") {
    return get4(this.value, path.split("/").filter(Boolean));
  }
};
function createUnsafe({ bytes: bytes2, cid, value: maybeValue, codec }) {
  const value = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block({
    // eslint-disable-next-line object-shorthand
    cid: (
      /** @type {CID<T, Code, Alg, V>} */
      cid
    ),
    bytes: bytes2,
    value
  });
}

// node_modules/ipfs-repo/src/utils/blockstore.js
var import_err_code6 = __toESM(require_err_code(), 1);
function cidToKey2(c) {
  const cid = CID6.asCID(c);
  if (cid == null) {
    throw (0, import_err_code6.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base325.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash2(key) {
  return decode27(base325.decode(`b${key.toString().toLowerCase().substring(1)}`));
}

// node_modules/ipfs-repo/src/utils/walk-dag.js
var import_debug6 = __toESM(require_browser(), 1);
var log7 = (0, import_debug6.default)("ipfs:repo:utils:walk-dag");
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes2 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({ bytes: bytes2, cid, codec });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err) {
    log7("Could not walk DAG for CID", cid.toString(), err);
    throw err;
  }
}

// node_modules/ipfs-repo/src/pin-types.js
var PinTypes2 = {
  /** @type {'direct'} */
  direct: "direct",
  /** @type {'recursive'} */
  recursive: "recursive",
  /** @type {'indirect'} */
  indirect: "indirect",
  /** @type {'all'} */
  all: "all"
};

// node_modules/ipfs-repo/node_modules/quick-lru/index.js
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(cache6) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache6) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache6) {
    const item = cache6.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value,
        expiry
      });
    } else {
      this._set(key, { value, expiry });
    }
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.oldCache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this._entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};

// node_modules/ipfs-repo/src/pin-manager.js
var CID_CACHE_MAX_SIZE = 2048;
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return (0, import_err_code7.default)(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
var PinManager = class {
  /**
   * @param {object} config
   * @param {import('interface-datastore').Datastore} config.pinstore
   * @param {import('interface-blockstore').Blockstore} config.blockstore
   * @param {import('./types').loadCodec} config.loadCodec
   */
  constructor({ pinstore, blockstore, loadCodec }) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = (0, import_debug7.default)("ipfs:repo:pin");
    this.directPins = /* @__PURE__ */ new Set();
    this.recursivePins = /* @__PURE__ */ new Set();
  }
  /**
   * @param {CID} cid
   * @param {PinOptions & AbortOptions} [options]
   */
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = {
      depth: 0
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code2) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(cidToKey2(cid), encode2(pin));
  }
  /**
   * @param {CID} cid
   * @param {AbortOptions} [options]
   */
  unpin(cid, options) {
    return this.pinstore.delete(cidToKey2(cid), options);
  }
  /**
   * @param {CID} cid
   * @param {PinOptions & FetchCompleteDagOptions & AbortOptions} [options]
   */
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = {
      depth: Infinity
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code2) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(cidToKey2(cid), encode2(pin));
  }
  /**
   * @param {AbortOptions} [options]
   */
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode2(entry2.value);
        return pin.depth === 0;
      }]
    })) {
      const pin = decode2(entry.value);
      const version3 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code2;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID6.create(version3, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  /**
   * @param {AbortOptions} [options]
   */
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode2(entry2.value);
        return pin.depth === Infinity;
      }]
    })) {
      const pin = decode2(entry.value);
      const version3 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code2;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID6.create(version3, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  /**
   * @param {AbortOptions} [options]
   */
  async *indirectKeys(options) {
    for await (const { cid } of this.recursiveKeys()) {
      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types = [
          PinTypes2.recursive
        ];
        const result = await this.isPinnedWithType(childCid, types);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  /**
   * @param {CID} cid
   * @param {PinQueryType|PinQueryType[]} types
   * @param {AbortOptions} [options]
   */
  async isPinnedWithType(cid, types, options) {
    if (!Array.isArray(types)) {
      types = [types];
    }
    const all4 = types.includes(PinTypes2.all);
    const direct = types.includes(PinTypes2.direct);
    const recursive = types.includes(PinTypes2.recursive);
    const indirect = types.includes(PinTypes2.indirect);
    if (recursive || direct || all4) {
      const result = await first(this.pinstore.query({
        prefix: cidToKey2(cid).toString(),
        filters: [(entry) => {
          if (all4) {
            return true;
          }
          const pin = decode2(entry.value);
          return types.includes(pin.depth === 0 ? PinTypes2.direct : PinTypes2.recursive);
        }],
        limit: 1
      }));
      if (result) {
        const pin = decode2(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? PinTypes2.direct : PinTypes2.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self2 = this;
    async function* findChild(key, source) {
      for await (const { cid: parentCid } of source) {
        for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all4 || indirect) {
      const parentCid = await first(findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: PinTypes2.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  /**
   * @param {CID} cid
   * @param {FetchCompleteDagOptions} [options]
   */
  async fetchCompleteDag(cid, options = {}) {
    const seen = new QuickLRU({ maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE });
    const walkDag2 = async (cid2, options2) => {
      if (seen.has(cid2.toString())) {
        return;
      }
      seen.set(cid2.toString(), true);
      const bytes2 = await this.blockstore.get(cid2, options2);
      const codec = await this.loadCodec(cid2.code);
      const block = createUnsafe({ bytes: bytes2, cid: cid2, codec });
      await Promise.all(
        [...block.links()].map(([, childCid]) => walkDag2(childCid, options2))
      );
    };
    await walkDag2(cid, options);
  }
  /**
   * Throws an error if the pin type is invalid
   *
   * @param {any} type
   * @returns {type is PinType}
   */
  static checkPinType(type) {
    if (typeof type !== "string" || !Object.keys(PinTypes2).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
};

// node_modules/it-map/dist/src/index.js
async function* map(source, func) {
  for await (const val of source) {
    yield func(val);
  }
}

// node_modules/ipfs-repo/src/pinned-blockstore.js
var import_err_code8 = __toESM(require_err_code(), 1);
function createPinnedBlockstore(pins, store2) {
  return {
    open() {
      return store2.open();
    },
    close() {
      return store2.close();
    },
    query(query, options) {
      return store2.query(query, options);
    },
    queryKeys(query, options) {
      return store2.queryKeys(query, options);
    },
    async get(cid, options) {
      return store2.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store2.getMany(cids, options);
    },
    async put(cid, buf2, options) {
      await store2.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      yield* store2.putMany(pairs, options);
    },
    has(cid, options) {
      return store2.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store2.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store2.deleteMany(map(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store2.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes2.all);
  if (pinned) {
    throw (0, import_err_code8.default)(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}

// node_modules/p-timeout/index.js
var TimeoutError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError3 = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException2 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError3(errorMessage) : new DOMException(errorMessage);
var getAbortedReason2 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException2("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException2(reason);
};
function pTimeout2(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason2(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason2(signal));
      });
    }
    const timeoutError = new TimeoutError2();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/mortice/node_modules/nanoid/index.browser.js
var nanoid2 = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default = observable;

// node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name8, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid2();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name8
    });
    return await new Promise((resolve) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name8
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions = {
  singleProcess: false
};
var browser_default = (options) => {
  options = Object.assign({}, defaultOptions, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name8) => makeWorkerLockRequest(name8, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name8) => makeWorkerLockRequest(name8, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation4;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => await pTimeout2((async () => {
    return await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p;
}
var createMutex = (name8, options) => {
  if (implementation4.isWorker === true) {
    return {
      readLock: implementation4.readLock(name8, options),
      writeLock: implementation4.writeLock(name8, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions2, options);
  if (implementation4 == null) {
    implementation4 = browser_default(opts);
    if (implementation4.isWorker !== true) {
      implementation4.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation4.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// node_modules/ipfs-repo/src/gc.js
var import_debug8 = __toESM(require_browser(), 1);

// node_modules/it-batch/dist/src/index.js
async function* batch(source, size = 1) {
  let things = [];
  if (size < 1) {
    size = 1;
  }
  for await (const thing of source) {
    things.push(thing);
    while (things.length >= size) {
      yield things.slice(0, size);
      things = things.slice(size);
    }
  }
  while (things.length > 0) {
    yield things.slice(0, size);
    things = things.slice(size);
  }
}

// node_modules/it-parallel-batch/dist/src/index.js
async function* parallelBatch(source, size = 1) {
  for await (const tasks of batch(source, size)) {
    const things = tasks.map(async (p) => {
      return await p().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
    });
    for (let i = 0; i < things.length; i++) {
      const result = await things[i];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}

// node_modules/it-merge/dist/src/index.js
async function* merge3(...sources) {
  const output = pushable({
    objectMode: true
  });
  void Promise.resolve().then(async () => {
    try {
      await Promise.all(sources.map(async (source) => {
        for await (const item of source) {
          output.push(item);
        }
      }));
      output.end();
    } catch (err) {
      output.end(err);
    }
  });
  yield* output;
}

// node_modules/it-pipe/dist/src/index.js
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isIterable = (obj) => {
  return obj != null && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
};
var isDuplex = (obj) => {
  return obj != null && typeof obj.sink === "function" && isIterable(obj.source);
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if (p.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      const sourceWrap = async function* () {
        yield* duplex.source;
        stream.end();
      };
      return merge3(stream, sourceWrap());
    }
    return duplex.source;
  };
};
function pipe(first2, ...rest) {
  if (isDuplex(first2)) {
    const duplex = first2;
    first2 = () => duplex.source;
  } else if (isIterable(first2)) {
    const source = first2;
    first2 = () => source;
  }
  const fns = [first2, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i]);
      }
    }
  }
  return rawPipe(...fns);
}

// node_modules/ipfs-repo/src/gc.js
var log8 = (0, import_debug8.default)("ipfs:repo:gc");
var ERR_NOT_FOUND = notFoundError().code;
var BLOCK_RM_CONCURRENCY = 256;
var MFS_ROOT_KEY2 = new Key("/local/filesroot");
function gc({ gcLock, pins, blockstore, root: root3, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log8("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({ pins, blockstore, root: root3, loadCodec });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log8(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root: root3 }) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root3.get(MFS_ROOT_KEY2);
    } catch (err) {
      if (err.code === ERR_NOT_FOUND) {
        log8("No blocks in MFS");
        return;
      }
      throw err;
    }
    const rootCid = CID6.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = merge3(
    map(pins.recursiveKeys(), ({ cid }) => cid),
    pins.indirectKeys(),
    map(pins.directKeys(), ({ cid }) => cid),
    mfsSource
  );
  const output = /* @__PURE__ */ new Set();
  for await (const cid of merge3(pinsSource, mfsSource)) {
    output.add(base325.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base325.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err) {
          return {
            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)
          };
        }
        return { cid };
      } catch (err) {
        const msg = `Could delete block with CID ${cid}`;
        log8(msg, err);
        return { err: new Error(msg + `: ${err.message}`) };
      }
    };
  };
  yield* pipe(
    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),
    // filter nulls (blocks that were retained)
    (source) => filter(source, Boolean)
  );
  log8(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}

// node_modules/ipfs-repo/src/index.js
var log9 = (0, import_debug9.default)("ipfs:repo");
var noLimit = Number.MAX_SAFE_INTEGER;
var AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
var Repo2 = class {
  /**
   * @param {string} path - Where this repo is stored
   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs
   * @param {Backends} backends - backends used by this repo
   * @param {Partial<Options>} [options] - Configuration
   */
  constructor(path, loadCodec, backends, options) {
    if (typeof path !== "string") {
      throw new Error("missing repo path");
    }
    if (typeof loadCodec !== "function") {
      throw new Error("missing codec loader");
    }
    this.options = merge_options_default(default_options_default, options);
    this.closed = true;
    this.path = path;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new PinManager({ pinstore, blockstore, loadCodec });
    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
    this.blocks = createIdStore(pinnedBlockstore);
    this.version = version2(this.root);
    this.config = config(this.root);
    this.spec = spec(this.root);
    this.apiAddr = apiAddr(this.root);
    this.gcLock = createMortice({
      name: path,
      singleProcess: this.options.repoOwner !== false
    });
    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec });
  }
  /**
   * Initialize a new repo.
   *
   * @param {import('./types').Config} config - config to write into `config`.
   * @returns {Promise<void>}
   */
  async init(config2) {
    log9("initializing at: %s", this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config2));
    await this.spec.set(buildDatastoreSpec(config2));
    await this.version.set(repoVersion);
  }
  /**
   * Check if the repo is already initialized.
   *
   * @returns {Promise<boolean>}
   */
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err) {
      return false;
    }
  }
  /**
   * Open the repo. If the repo is already open an error will be thrown.
   * If the repo is not initialized it will throw an error.
   *
   * @returns {Promise<void>}
   */
  async open() {
    if (!this.closed) {
      throw (0, import_err_code9.default)(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    }
    log9("opening at: %s", this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log9("acquired repo.lock");
      const isCompatible = await this.version.check(repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        }
      }
      log9("creating datastore");
      await this.datastore.open();
      log9("creating blocks");
      await this.blocks.open();
      log9("creating keystore");
      await this.keys.open();
      log9("creating pins");
      await this.pins.pinstore.open();
      this.closed = false;
      log9("all opened");
    } catch (err) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err2) {
          log9("error removing lock", err2);
        }
      }
      throw err;
    }
  }
  /**
   * Opens the root backend, catching and ignoring an 'Already open' error
   *
   * @private
   */
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err) {
      if (err.message !== "Already open") {
        throw err;
      }
    }
  }
  /**
   * Creates a lock on the repo if a locker is specified. The lockfile object will
   * be returned in the callback if one has been created.
   *
   * @private
   * @returns {Promise<LockCloser>}
   */
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== "function") {
      throw (0, import_err_code9.default)(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    }
    return lockfile;
  }
  /**
   * Closes the lock on the repo
   *
   * @private
   */
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  /**
   * Check if the repo is already initialized.
   *
   * @private
   */
  async _checkInitialized() {
    log9("init check");
    let config2;
    try {
      [config2] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err) {
      if (err.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code9.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
          path: this.path
        });
      }
      throw err;
    }
    if (!config2) {
      throw (0, import_err_code9.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
        path: this.path
      });
    }
  }
  /**
   * Close the repo and cleanup.
   *
   * @returns {Promise<void>}
   */
  async close() {
    if (this.closed) {
      throw (0, import_err_code9.default)(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    }
    log9("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (err) {
      if (err.code !== ERR_REPO_NOT_INITIALIZED && !err.message.startsWith("ENOENT")) {
        throw err;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map((store2) => store2 && store2.close()));
    log9("unlocking");
    this.closed = true;
    await this._closeLock();
  }
  /**
   * Check if a repo exists.
   *
   * @returns {Promise<boolean>}
   */
  exists() {
    return this.version.exists();
  }
  /**
   * Get repo status.
   *
   * @returns {Promise<Stat>}
   */
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version3, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size + datastore + keys;
      return {
        repoPath: this.path,
        storageMax,
        version: version3,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    throw (0, import_err_code9.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
      path: this.path
    });
  }
  /**
   * @private
   */
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  /**
   * Internal migration
   *
   * @private
   * @param {number} toVersion
   * @param {Backends} backends
   */
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log9(`reverting to version ${toVersion}`);
      return revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log9(`migrating to version ${toVersion}`);
      return migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  /**
   * @private
   */
  async _storageMaxStat() {
    try {
      const max = (
        /** @type {number} */
        await this.config.get("Datastore.StorageMax")
      );
      return BigInt((0, import_bytes31.default)(max));
    } catch (err) {
      return BigInt(noLimit);
    }
  }
  /**
   * @private
   */
  async _blockStat() {
    let count = BigInt(0);
    let size = BigInt(0);
    if (this.blocks) {
      for await (const { key, value } of this.blocks.query({})) {
        count += BigInt(1);
        size += BigInt(value.byteLength);
        size += BigInt(key.bytes.byteLength);
      }
    }
    return { count, size };
  }
};
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo(path, loadCodec, backends, options) {
  return new Repo2(path, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, default_datastore_default, objectSafeGet(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...default_datastore_default.Spec,
    ...objectSafeGet(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}

// node_modules/blockstore-datastore-adapter/node_modules/it-drain/dist/src/index.js
async function drain2(source) {
  for await (const _ of source) {
  }
}

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/vendor/varint.js
var encode_16 = encode24;
var MSB6 = 128;
var REST6 = 127;
var MSBALL6 = ~REST6;
var INT6 = Math.pow(2, 31);
function encode24(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT6) {
    out[offset++] = num & 255 | MSB6;
    num /= 128;
  }
  while (num & MSBALL6) {
    out[offset++] = num & 255 | MSB6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode24.bytes = offset - oldOffset + 1;
  return out;
}
var decode29 = read6;
var MSB$16 = 128;
var REST$16 = 127;
function read6(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read6.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$16) << shift : (b & REST$16) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$16);
  read6.bytes = counter - offset;
  return res;
}
var N16 = Math.pow(2, 7);
var N26 = Math.pow(2, 14);
var N36 = Math.pow(2, 21);
var N46 = Math.pow(2, 28);
var N56 = Math.pow(2, 35);
var N66 = Math.pow(2, 42);
var N76 = Math.pow(2, 49);
var N86 = Math.pow(2, 56);
var N96 = Math.pow(2, 63);
var length7 = function(value) {
  return value < N16 ? 1 : value < N26 ? 2 : value < N36 ? 3 : value < N46 ? 4 : value < N56 ? 5 : value < N66 ? 6 : value < N76 ? 7 : value < N86 ? 8 : value < N96 ? 9 : 10;
};
var varint10 = {
  encode: encode_16,
  decode: decode29,
  encodingLength: length7
};
var _brrp_varint6 = varint10;
var varint_default6 = _brrp_varint6;

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/varint.js
var decode30 = (data, offset = 0) => {
  const code11 = varint_default6.decode(data, offset);
  return [code11, varint_default6.decode.bytes];
};
var encodeTo6 = (int, target, offset = 0) => {
  varint_default6.encode(int, target, offset);
  return target;
};
var encodingLength6 = (int) => {
  return varint_default6.encodingLength(int);
};

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/bytes.js
var empty7 = new Uint8Array(0);
var equals14 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce7 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/hashes/digest.js
var create10 = (code11, digest5) => {
  const size = digest5.byteLength;
  const sizeOffset = encodingLength6(code11);
  const digestOffset = sizeOffset + encodingLength6(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo6(code11, bytes2, 0);
  encodeTo6(size, bytes2, sizeOffset);
  bytes2.set(digest5, digestOffset);
  return new Digest6(code11, size, digest5, bytes2);
};
var decode31 = (multihash) => {
  const bytes2 = coerce7(multihash);
  const [code11, sizeOffset] = decode30(bytes2);
  const [size, digestOffset] = decode30(bytes2.subarray(sizeOffset));
  const digest5 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest5.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest6(code11, size, digest5, bytes2);
};
var equals15 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    const data = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      b
    );
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals14(a.bytes, data.bytes);
  }
};
var Digest6 = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code11, size, digest5, bytes2) {
    this.code = code11;
    this.size = size;
    this.digest = digest5;
    this.bytes = bytes2;
  }
};

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/vendor/base-x.js
function base6(ALPHABET, name8) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode26(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length8 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length8) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      pbegin++;
    }
    var it2 = size - length8;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length8 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length8) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length8 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length8;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode33(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name8} character`);
  }
  return {
    encode: encode26,
    decodeUnsafe,
    decode: decode33
  };
}
var src6 = base6;
var _brrp__multiformats_scope_baseX6 = src6;
var base_x_default6 = _brrp__multiformats_scope_baseX6;

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/bases/base.js
var Encoder6 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name8, prefix, baseEncode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder6 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or6(this, decoder);
  }
};
var ComposedDecoder6 = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or6(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or6 = (left, right) => new ComposedDecoder6(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec6 = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name8, prefix, baseEncode, baseDecode) {
    this.name = name8;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder6(name8, prefix, baseEncode);
    this.decoder = new Decoder6(name8, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from11 = ({ name: name8, prefix, encode: encode26, decode: decode33 }) => new Codec6(name8, prefix, encode26, decode33);
var baseX6 = ({ prefix, name: name8, alphabet: alphabet4 }) => {
  const { encode: encode26, decode: decode33 } = base_x_default6(alphabet4, name8);
  return from11({
    prefix,
    name: name8,
    encode: encode26,
    /**
     * @param {string} text
     */
    decode: (text) => coerce7(decode33(text))
  });
};
var decode32 = (string2, alphabet4, bitsPerChar, name8) => {
  const codes2 = {};
  for (let i = 0; i < alphabet4.length; ++i) {
    codes2[alphabet4[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes2[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name8} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode25 = (data, alphabet4, bitsPerChar) => {
  const pad = alphabet4[alphabet4.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet4[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet4[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc46486 = ({ name: name8, prefix, bitsPerChar, alphabet: alphabet4 }) => {
  return from11({
    prefix,
    name: name8,
    encode(input) {
      return encode25(input, alphabet4, bitsPerChar);
    },
    decode(input) {
      return decode32(input, alphabet4, bitsPerChar, name8);
    }
  });
};

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/bases/base58.js
var base58btc6 = baseX6({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr6 = baseX6({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/bases/base32.js
var base326 = rfc46486({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper6 = rfc46486({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad6 = rfc46486({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper6 = rfc46486({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex6 = rfc46486({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper6 = rfc46486({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad6 = rfc46486({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper6 = rfc46486({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z6 = rfc46486({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/cid.js
var format5 = (link, base7) => {
  const { bytes: bytes2, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV06(
        bytes2,
        baseCache5(link),
        /** @type {API.MultibaseEncoder<"z">} */
        base7 || base58btc6.encoder
      );
    default:
      return toStringV16(
        bytes2,
        baseCache5(link),
        /** @type {API.MultibaseEncoder<Prefix>} */
        base7 || base326.encoder
      );
  }
};
var cache5 = /* @__PURE__ */ new WeakMap();
var baseCache5 = (cid) => {
  const baseCache6 = cache5.get(cid);
  if (baseCache6 == null) {
    const baseCache7 = /* @__PURE__ */ new Map();
    cache5.set(cid, baseCache7);
    return baseCache7;
  }
  return baseCache6;
};
var CID7 = class _CID {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(version3, code11, multihash, bytes2) {
    this.code = code11;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes2;
    this["/"] = bytes2;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0: {
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      }
      case 1: {
        const { code: code11, multihash } = this;
        if (code11 !== DAG_PB_CODE6) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE6) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          _CID.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            multihash
          )
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
      }
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code11, digest: digest5 } = this.multihash;
        const multihash = create10(code11, digest5);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          _CID.createV1(this.code, multihash)
        );
      }
      case 1: {
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      }
      default: {
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
      }
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(other) {
    return _CID.equals(this, other);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(self2, other) {
    const unknown = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      other
    );
    return unknown && self2.code === unknown.code && self2.version === unknown.version && equals15(self2.multihash, unknown.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(base7) {
    return format5(this, base7);
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returs null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value = (
      /** @type {any} */
      input
    );
    if (value instanceof _CID) {
      return value;
    } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
      const { version: version3, code: code11, multihash, bytes: bytes2 } = value;
      return new _CID(
        version3,
        code11,
        /** @type {API.MultihashDigest<Alg>} */
        multihash,
        bytes2 || encodeCID7(version3, code11, multihash.bytes)
      );
    } else if (value[cidSymbol6] === true) {
      const { version: version3, multihash, code: code11 } = value;
      const digest5 = (
        /** @type {API.MultihashDigest<Alg>} */
        decode31(multihash)
      );
      return _CID.create(version3, code11, digest5);
    } else {
      return null;
    }
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(version3, code11, digest5) {
    if (typeof code11 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest5.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code11 !== DAG_PB_CODE6) {
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`
          );
        } else {
          return new _CID(version3, code11, digest5, digest5.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID7(version3, code11, digest5.bytes);
        return new _CID(version3, code11, digest5, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(digest5) {
    return _CID.create(0, DAG_PB_CODE6, digest5);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(code11, digest5) {
    return _CID.create(1, code11, digest5);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(bytes2) {
    const [cid, remainder] = _CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(bytes2) {
    const specs = _CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce7(
      bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
    );
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(
      specs.multihashSize - specs.digestSize
    );
    const digest5 = new Digest6(
      specs.multihashCode,
      specs.digestSize,
      digestBytes,
      multihashBytes
    );
    const cid = specs.version === 0 ? _CID.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      digest5
    ) : _CID.createV1(specs.codec, digest5);
    return [
      /** @type {CID<T, C, A, V>} */
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length8] = decode30(initialBytes.subarray(offset));
      offset += length8;
      return i;
    };
    let version3 = (
      /** @type {V} */
      next()
    );
    let codec = (
      /** @type {C} */
      DAG_PB_CODE6
    );
    if (
      /** @type {number} */
      version3 === 18
    ) {
      version3 = /** @type {V} */
      0;
      offset = 0;
    } else {
      codec = /** @type {C} */
      next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = (
      /** @type {A} */
      next()
    );
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(source, base7) {
    const [prefix, bytes2] = parseCIDtoBytes6(source, base7);
    const cid = _CID.decode(bytes2);
    baseCache5(cid).set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes6 = (source, base7) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base7 || base58btc6;
      return [
        /** @type {Prefix} */
        base58btc6.prefix,
        decoder.decode(`${base58btc6.prefix}${source}`)
      ];
    }
    case base58btc6.prefix: {
      const decoder = base7 || base58btc6;
      return [
        /** @type {Prefix} */
        base58btc6.prefix,
        decoder.decode(source)
      ];
    }
    case base326.prefix: {
      const decoder = base7 || base326;
      return [
        /** @type {Prefix} */
        base326.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base7 == null) {
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      }
      return [
        /** @type {Prefix} */
        source[0],
        base7.decode(source)
      ];
    }
  }
};
var toStringV06 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  if (prefix !== base58btc6.prefix) {
    throw Error(`Cannot string encode V0 in ${base7.name} encoding`);
  }
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2).slice(1);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV16 = (bytes2, cache6, base7) => {
  const { prefix } = base7;
  const cid = cache6.get(prefix);
  if (cid == null) {
    const cid2 = base7.encode(bytes2);
    cache6.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE6 = 112;
var SHA_256_CODE6 = 18;
var encodeCID7 = (version3, code11, multihash) => {
  const codeOffset = encodingLength6(version3);
  const hashOffset = codeOffset + encodingLength6(code11);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo6(version3, bytes2, 0);
  encodeTo6(code11, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
var cidSymbol6 = Symbol.for("@ipld/js-cid/CID");

// node_modules/blockstore-datastore-adapter/node_modules/multiformats/src/codecs/raw.js
var code10 = 85;

// node_modules/blockstore-datastore-adapter/src/index.js
var import_err_code10 = __toESM(require_err_code(), 1);

// node_modules/blockstore-core/src/base.js
var import_it_drain2 = __toESM(require_it_drain(), 1);
var import_it_filter3 = __toESM(require_it_filter(), 1);
var import_it_take = __toESM(require_it_take(), 1);
var import_it_all = __toESM(require_it_all(), 1);
var sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await (0, import_it_all.default)(iterable);
    yield* values.sort(sorter);
  }();
};
var BaseBlockstore = class {
  /**
   * @returns {Promise<void>}
   */
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  /**
   * @returns {Promise<void>}
   */
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Uint8Array} val
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<Uint8Array>}
   */
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<boolean>}
   */
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  /**
   * @param {CID} key
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  /**
   * @param {AwaitIterable<Pair>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  /**
   * @param {AwaitIterable<CID>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Uint8Array>}
   */
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  /**
   * @param {AwaitIterable<CID>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<CID>}
   */
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  /**
   * @returns {Batch}
   */
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await (0, import_it_drain2.default)(this.putMany(puts, options));
        puts = [];
        await (0, import_it_drain2.default)(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   *
   * @param {Query} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   *
   * @param {KeyQuery} q
   * @param {Options} [options]
   * @returns {AsyncIterable<CID>}
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  /**
   * @param {Query} q
   * @param {Options} [options]
   */
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter3.default)(
        it,
        (e) => e.key.toString().startsWith(q.prefix || "")
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter3.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter3.default)(it, () => i++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
  /**
   * @param {KeyQuery} q
   * @param {Options} [options]
   */
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter3.default)(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter3.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter3.default)(it, () => i++ >= /** @type {number} */
      q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
};

// node_modules/blockstore-datastore-adapter/src/index.js
function cidToKey3(cid) {
  const c = CID7.asCID(cid);
  if (!c) {
    throw (0, import_err_code10.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base326.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid2(key) {
  return CID7.createV1(code10, decode31(base326.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base326.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad6.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc6.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc6.decode("z" + input);
  } else {
    decoder = (input) => base326.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes2;
  for (let i = 1; i < prefix.length; i++) {
    try {
      bytes2 = decoder(prefix.substring(0, i));
    } catch (err) {
      if (err.message !== "Unexpected end of data") {
        throw err;
      }
    }
  }
  let str = "/C";
  if (bytes2) {
    str = `/${base326.encode(bytes2).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter5) => (pair) => {
        return filter5({ key: keyToCid2(pair.key), value: pair.value });
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order({ key: keyToCid2(a.key), value: a.value }, { key: keyToCid2(b.key), value: b.value });
      }
    ) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter5) => (key) => {
        return filter5(keyToCid2(key));
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order(keyToCid2(a), keyToCid2(b));
      }
    ) : void 0
  };
}
var BlockstoreDatastoreAdapter = class extends BaseBlockstore {
  /**
   * @param {Datastore} datastore
   */
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  /**
   * @param {Query} query
   * @param {Options} [options]
   */
  async *query(query, options) {
    for await (const { key, value } of this.child.query(convertQuery(query), options)) {
      yield { key: keyToCid2(key), value };
    }
  }
  /**
   * @param {KeyQuery} query
   * @param {Options} [options]
   */
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid2(key);
    }
  }
  /**
   * @param {CID} cid
   * @param {Options} [options]
   * @returns
   */
  async get(cid, options) {
    return this.child.get(cidToKey3(cid), options);
  }
  /**
   * @param {AsyncIterable<CID> | Iterable<CID>} cids
   * @param {Options} [options]
   */
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  /**
   * @param {CID} cid
   * @param {Uint8Array} value
   * @param {Options} [options]
   */
  async put(cid, value, options) {
    await this.child.put(cidToKey3(cid), value, options);
  }
  /**
   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks
   * @param {Options} [options]
   */
  async *putMany(blocks, options) {
    const output = pushable({
      objectMode: true
    });
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store2 = this.child;
        await drain2(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey3(block.key);
            const exists2 = await store2.has(key, options);
            if (!exists2) {
              yield { key, value: block.value };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err) {
        output.end(err);
      }
    });
    yield* output;
  }
  /**
   * @param {CID} cid
   * @param {Options} [options]
   */
  has(cid, options) {
    return this.child.has(cidToKey3(cid), options);
  }
  /**
   * @param {CID} cid
   * @param {Options} [options]
   */
  delete(cid, options) {
    return this.child.delete(cidToKey3(cid), options);
  }
  /**
   * @param {AsyncIterable<CID> | Iterable<CID>} cids
   * @param {Options} [options]
   */
  deleteMany(cids, options) {
    const out = pushable({
      objectMode: true
    });
    drain2(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey3(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch((err) => {
      out.end(err);
    });
    return out;
  }
};

// node_modules/datastore-core/node_modules/it-all/dist/src/index.js
async function all2(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// node_modules/datastore-core/src/utils.js
var sortAll2 = (iterable, sorter) => {
  return async function* () {
    const values = await all2(iterable);
    yield* values.sort(sorter);
  }();
};

// node_modules/datastore-core/node_modules/it-drain/dist/src/index.js
async function drain4(source) {
  for await (const _ of source) {
  }
}

// node_modules/datastore-core/node_modules/it-filter/dist/src/index.js
async function* filter3(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}

// node_modules/datastore-core/node_modules/it-take/dist/src/index.js
async function* take2(source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}

// node_modules/datastore-core/src/base.js
var BaseDatastore = class {
  /**
   * @returns {Promise<void>}
   */
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  /**
   * @returns {Promise<void>}
   */
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Uint8Array} val
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<Uint8Array>}
   */
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<boolean>}
   */
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   * @returns {Promise<void>}
   */
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  /**
   * @param {AwaitIterable<Pair>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  /**
   * @param {AwaitIterable<Key>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Uint8Array>}
   */
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  /**
   * @param {AwaitIterable<Key>} source
   * @param {Options} [options]
   * @returns {AsyncIterable<Key>}
   */
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  /**
   * @returns {Batch}
   */
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await drain4(this.putMany(puts, options));
        puts = [];
        await drain4(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   *
   * @param {Query} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Pair>}
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   *
   * @param {KeyQuery} q
   * @param {Options} [options]
   * @returns {AsyncIterable<Key>}
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  /**
   * @param {Query} q
   * @param {Options} [options]
   */
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = filter3(
        it,
        (e) => e.key.toString().startsWith(
          /** @type {string} */
          q.prefix
        )
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter3(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = filter3(it, () => i++ >= /** @type {number} */
      q.offset);
    }
    if (q.limit != null) {
      it = take2(it, q.limit);
    }
    return it;
  }
  /**
   * @param {KeyQuery} q
   * @param {Options} [options]
   */
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = filter3(
        it,
        (key) => key.toString().startsWith(
          /** @type {string} */
          q.prefix
        )
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter3(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = filter3(it, () => i++ >= /** @type {number} */
      q.offset);
    }
    if (q.limit != null) {
      it = take2(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  /**
   * @param {Key} key
   * @param {Uint8Array} val
   */
  async put(key, val) {
    this.data[key.toString()] = val;
  }
  /**
   * @param {Key} key
   */
  async get(key) {
    const exists2 = await this.has(key);
    if (!exists2)
      throw notFoundError();
    return this.data[key.toString()];
  }
  /**
   * @param {Key} key
   */
  async has(key) {
    return this.data[key.toString()] !== void 0;
  }
  /**
   * @param {Key} key
   */
  async delete(key) {
    delete this.data[key.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value]) => ({ key: new Key(key), value }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => new Key(key));
  }
};

// node_modules/datastore-core/src/shard.js
var SHARDING_FN = "SHARDING";
var README_FN = "_README";

// node_modules/datastore-core/src/sharding.js
var shardKey = new Key(SHARDING_FN);
var shardReadmeKey = new Key(README_FN);

// node_modules/@libp2p/logger/dist/src/index.js
var import_debug10 = __toESM(require_browser(), 1);
import_debug10.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
import_debug10.default.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
import_debug10.default.formatters.m = (v) => {
  return v == null ? "undefined" : base642.baseEncode(v);
};
import_debug10.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug10.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug10.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger(namespace2) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace2;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function logger(name8) {
  let trace = createDisabledLogger(`${name8}:trace`);
  if (import_debug10.default.enabled(`${name8}:trace`) && import_debug10.default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = (0, import_debug10.default)(`${name8}:trace`);
  }
  return Object.assign((0, import_debug10.default)(name8), {
    error: (0, import_debug10.default)(`${name8}:error`),
    trace
  });
}

// node_modules/datastore-core/src/tiered.js
var log10 = logger("datastore:core:tiered");

// node_modules/datastore-level/node_modules/it-filter/dist/src/index.js
async function* filter4(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}

// node_modules/datastore-level/node_modules/it-take/dist/src/index.js
async function* take3(source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}

// node_modules/it-sort/node_modules/it-all/dist/src/index.js
async function all3(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// node_modules/it-sort/dist/src/index.js
async function* sort(source, sorter) {
  const arr = await all3(source);
  yield* arr.sort(sorter);
}

// node_modules/datastore-level/src/index.js
var import_level3 = __toESM(require_browser2(), 1);
var LevelDatastore = class extends BaseDatastore {
  /**
   * @param {string | LevelDb} path
   * @param {import('level').DatabaseOptions<string, Uint8Array> & import('level').OpenOptions} [opts]
   */
  constructor(path, opts = {}) {
    super();
    this.db = typeof path === "string" ? new import_level3.Level(path, {
      ...opts,
      keyEncoding: "utf8",
      valueEncoding: "view"
    }) : path;
    this.opts = {
      createIfMissing: true,
      compression: false,
      // same default as go
      ...opts
    };
  }
  async open() {
    try {
      await this.db.open(this.opts);
    } catch (err) {
      throw errors_exports.dbOpenFailedError(err);
    }
  }
  /**
   * @param {Key} key
   * @param {Uint8Array} value
   */
  async put(key, value) {
    try {
      await this.db.put(key.toString(), value);
    } catch (err) {
      throw errors_exports.dbWriteFailedError(err);
    }
  }
  /**
   * @param {Key} key
   * @returns {Promise<Uint8Array>}
   */
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        throw errors_exports.notFoundError(err);
      throw errors_exports.dbWriteFailedError(err);
    }
    return data;
  }
  /**
   * @param {Key} key
   * @returns {Promise<boolean>}
   */
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        return false;
      throw err;
    }
    return true;
  }
  /**
   * @param {Key} key
   * @returns {Promise<void>}
   */
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err) {
      throw errors_exports.dbDeleteFailedError(err);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  /**
   * @returns {Batch}
   */
  batch() {
    const ops = [];
    return {
      put: (key, value) => {
        ops.push({
          type: "put",
          key: key.toString(),
          value
        });
      },
      delete: (key) => {
        ops.push({
          type: "del",
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  /**
   * @param {Query} q
   */
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter4(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i = 0;
      it = filter4(it, () => i++ >= offset);
    }
    if (limit) {
      it = take3(it, limit);
    }
    return it;
  }
  /**
   * @param {KeyQuery} q
   */
  queryKeys(q) {
    let it = map(this._query({
      values: false,
      prefix: q.prefix
    }), ({ key }) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter4(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i = 0;
      it = filter4(it, () => i++ >= offset);
    }
    if (limit) {
      it = take3(it, limit);
    }
    return it;
  }
  /**
   * @param {object} opts
   * @param {boolean} opts.values
   * @param {string} [opts.prefix]
   * @returns {AsyncIterable<Pair>}
   */
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyEncoding: "buffer",
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + "\xFF";
    }
    const iterator = this.db.iterator(iteratorOpts);
    if (iterator[Symbol.asyncIterator]) {
      return levelIteratorToIterator(iterator);
    }
    if (iterator.next != null && iterator.end != null) {
      return oldLevelIteratorToIterator(iterator);
    }
    throw new Error("Level returned incompatible iterator");
  }
};
async function* levelIteratorToIterator(li) {
  for await (const [key, value] of li) {
    yield { key: new Key(key, false), value };
  }
  await li.close();
}
function oldLevelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve, reject) => {
          li.next((err, key, value) => {
            if (err)
              return reject(err);
            if (key == null) {
              return li.end((err2) => {
                if (err2)
                  return reject(err2);
                resolve({ done: true, value: void 0 });
              });
            }
            resolve({ done: false, value: { key: new Key(key, false), value } });
          });
        }),
        return: () => new Promise((resolve, reject) => {
          li.end((err) => {
            if (err)
              return reject(err);
            resolve({ done: true, value: void 0 });
          });
        })
      };
    }
  };
}

// node_modules/@oddjs/odd/lib/components/depot/implementation/ipfs/node/repo.js
function create11(repoName) {
  const memoryDs = new MemoryDatastore();
  return createRepo(repoName, (codeOrName) => {
    const lookup2 = {
      [code2]: src_exports3,
      [name2]: src_exports3,
      [code]: src_exports2,
      [name]: src_exports2,
      [code3]: raw_exports,
      [name3]: raw_exports
    };
    return Promise.resolve(lookup2[codeOrName]);
  }, {
    root: new LevelDatastore(`${repoName}/root`, { prefix: "", version: 2 }),
    blocks: new BlockstoreDatastoreAdapter(new LevelDatastore(`${repoName}/blocks`, { prefix: "", version: 2 })),
    keys: new LevelDatastore(`${repoName}/keys`, { prefix: "", version: 2 }),
    datastore: memoryDs,
    pins: new LevelDatastore(`${repoName}/pins`, { prefix: "", version: 2 })
  }, {
    repoLock: {
      lock: async () => ({ close: async () => {
        return;
      } }),
      locked: async () => false
    },
    autoMigrate: false
  });
}

// node_modules/@oddjs/odd/lib/components/depot/implementation/ipfs/node.js
var latestPeerTimeoutIds = {};
var isSafari = /^((?!chrome|android).)*safari/i.test(globalThis.navigator?.userAgent || "");
var KEEP_ALIVE_INTERVAL = 1 * 60 * 1e3;
var KEEP_TRYING_INTERVAL = 5 * 60 * 1e3;
var BACKOFF_INIT = {
  retryNumber: 0,
  lastBackoff: 0,
  currentBackoff: 1e3
};
var OPTIONS = {
  config: {
    Addresses: {
      Delegates: []
    },
    Bootstrap: [],
    Discovery: {
      webRTCStar: { Enabled: false }
    },
    Pubsub: {
      Enabled: false
    }
  },
  preload: {
    enabled: false,
    addresses: []
  },
  libp2p: {
    peerDiscovery: [],
    connectionManager: {
      autoDial: false
    }
  },
  init: {
    algorithm: isSafari ? RSA : void 0,
    emptyRepo: true
  }
};
async function createAndConnect(dependencies, pkg, peersUrl, repoName, logging) {
  const peers = await listPeers(dependencies.storage, peersUrl);
  if (peers.length === 0) {
    throw new Error("\u{1F4A5} Couldn't start IPFS node, peer list is empty");
  }
  const repo = create11(repoName);
  const ipfs2 = await pkg.create({ ...OPTIONS, repo });
  peers.forEach((peer) => {
    latestPeerTimeoutIds[peer.toString()] = null;
    tryConnecting(ipfs2, peer, logging);
  });
  globalThis.addEventListener("online", async () => {
    (await listPeers(dependencies.storage, peersUrl)).filter((peer) => {
      const peerStr = peer.toString();
      return !peerStr.includes("/localhost/") && !peerStr.includes("/127.0.0.1/") && !peerStr.includes("/0.0.0.0/");
    }).forEach((peer) => {
      tryConnecting(ipfs2, peer, logging);
    });
  });
  if (logging)
    console.log("\u{1F680} Started IPFS node");
  return { ipfs: ipfs2, repo };
}
function fetchPeers(peersUrl) {
  return fetch(peersUrl).then((r) => r.json()).then((r) => Array.isArray(r) ? r : []).then((r) => r.filter((p) => isString(p) && p.includes("/wss/"))).catch(() => {
    throw new Error("\u{1F4A5} Couldn't start IPFS node, failed to fetch peer list");
  });
}
async function listPeers(storage2, peersUrl) {
  let peers;
  const storageKey = `ipfs-peers-${peersUrl}`;
  const maybePeers = await storage2.getItem(storageKey);
  if (isString(maybePeers) && maybePeers.trim() !== "") {
    peers = JSON.parse(maybePeers);
    fetchPeers(peersUrl).then((list) => storage2.setItem(storageKey, JSON.stringify(list))).catch((err) => {
      console.error(err);
    });
  } else {
    peers = await fetchPeers(peersUrl);
    await storage2.setItem(storageKey, JSON.stringify(peers));
  }
  return peers.map(multiaddr);
}
function keepAlive(ipfs2, peer, backoff, status) {
  let timeoutId = null;
  if (backoff.currentBackoff < KEEP_TRYING_INTERVAL) {
    timeoutId = setTimeout(() => reconnect(ipfs2, peer, backoff, status), backoff.currentBackoff);
  } else {
    timeoutId = setTimeout(() => reconnect(ipfs2, peer, backoff, status), KEEP_TRYING_INTERVAL);
  }
  latestPeerTimeoutIds[peer.toString()] = timeoutId;
  ping(ipfs2, peer).then(({ latency }) => {
    const updatedStatus = { connected: true, lastConnectedAt: Date.now(), latency };
    report(peer, updatedStatus);
    if (timeoutId)
      clearTimeout(timeoutId);
    if (timeoutId === latestPeerTimeoutIds[peer.toString()]) {
      setTimeout(() => keepAlive(ipfs2, peer, BACKOFF_INIT, updatedStatus), KEEP_ALIVE_INTERVAL);
    }
  }).catch(() => {
  });
}
async function reconnect(ipfs2, peer, backoff, status) {
  const updatedStatus = { ...status, connected: false, latency: null };
  report(peer, updatedStatus);
  try {
    await ipfs2.swarm.disconnect(peer);
    await ipfs2.swarm.connect(peer);
  } catch {
  }
  if (backoff.currentBackoff < KEEP_TRYING_INTERVAL) {
    const nextBackoff = {
      retryNumber: backoff.retryNumber + 1,
      lastBackoff: backoff.currentBackoff,
      currentBackoff: backoff.lastBackoff + backoff.currentBackoff
    };
    keepAlive(ipfs2, peer, nextBackoff, updatedStatus);
  } else {
    keepAlive(ipfs2, peer, backoff, updatedStatus);
  }
}
function tryConnecting(ipfs2, peer, logging) {
  ping(ipfs2, peer).then(({ latency }) => {
    return ipfs2.swarm.connect(peer, { timeout: 60 * 1e3 }).then(() => {
      if (logging)
        console.log(`\u{1FA90} Connected to ${peer}`);
      const status = { connected: true, lastConnectedAt: Date.now(), latency };
      report(peer, status);
      setTimeout(() => keepAlive(ipfs2, peer, BACKOFF_INIT, status), KEEP_ALIVE_INTERVAL);
    });
  }).catch(() => {
    if (logging)
      console.log(`\u{1FA93} Could not connect to ${peer}`);
    const status = { connected: false, lastConnectedAt: null, latency: null };
    report(peer, status);
    keepAlive(ipfs2, peer, BACKOFF_INIT, status);
  });
}
async function ping(ipfs2, peer) {
  return ipfs2.libp2p.ping(peer).then((latency) => ({ latency }));
}
var peerConnections = [];
var monitoringPeers = false;
function report(peer, status) {
  peerConnections = peerConnections.filter((connection) => connection.peer !== peer).concat({ peer, status });
  const offline = peerConnections.every((connection) => !connection.status.connected);
  const lastConnectedAt = peerConnections.reduce((newest, { status: status2 }) => newest >= (status2.lastConnectedAt || 0) ? newest : status2.lastConnectedAt || 0, 0);
  const activeConnections = peerConnections.filter((connection) => connection.status.latency !== null);
  const averageLatency = activeConnections.length > 0 ? peerConnections.reduce((sum, connection) => sum + (connection.status.latency || 0), 0) / activeConnections.length : null;
  if (monitoringPeers) {
    console.table(peerConnections);
    console.log("offline", offline);
    console.log("last connected at", lastConnectedAt === 0 ? null : lastConnectedAt);
    console.log("average latency", averageLatency);
  }
}

// node_modules/@oddjs/odd/lib/components/depot/implementation/ipfs/config.js
var DEFAULT_CDN_URL = "https://unpkg.com/ipfs-core@0.17.0/dist/index.min.js";
var nodeWithPkg = (dependencies, pkg, peersUrl, repoName, logging) => {
  return createAndConnect(dependencies, pkg, peersUrl, repoName, logging);
};
var pkgFromCDN = async (cdn_url) => {
  if (!cdn_url)
    throw new Error("This function requires a URL to a CDN");
  return import(
    /* @vite-ignore */
    /* webpackIgnore: true */
    cdn_url
  ).then((_) => self.IpfsCore);
};

// node_modules/@oddjs/odd/node_modules/multiformats/src/hashes/sha2-browser.js
var sha5 = (name8) => (
  /**
   * @param {Uint8Array} data
   */
  async (data) => new Uint8Array(await crypto.subtle.digest(name8, data))
);
var sha2566 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha5("SHA-256")
});
var sha5125 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha5("SHA-512")
});

// node_modules/@oddjs/odd/lib/components/depot/implementation/ipfs.js
async function implementation5(getIpfs) {
  return {
    // GET
    getBlock: async (cid) => {
      const { ipfs: ipfs2 } = await getIpfs();
      return ipfs2.block.get(cid);
    },
    getUnixDirectory: async (cid) => {
      const { ipfs: ipfs2 } = await getIpfs();
      const entries = [];
      for await (const entry of ipfs2.ls(cid)) {
        const { name: name8 = "", cid: cid2, size, type } = entry;
        entries.push({
          name: name8,
          cid: cid2,
          size,
          isFile: type !== "dir"
        });
      }
      return entries;
    },
    getUnixFile: async (cid) => {
      const { ipfs: ipfs2 } = await getIpfs();
      const chunks = [];
      for await (const chunk of ipfs2.cat(cid)) {
        chunks.push(chunk);
      }
      return concat2(chunks);
    },
    // PUT
    putBlock: async (data, codecId) => {
      const { repo } = await getIpfs();
      const codec = getByIdentifier(codecId);
      const multihash = await sha2566.digest(data);
      const cid = CID.createV1(codec.code, multihash);
      await repo.blocks.put(cid, data);
      return cid;
    },
    putChunked: async (data) => {
      const { ipfs: ipfs2 } = await getIpfs();
      const addResult = await ipfs2.add(data, {
        cidVersion: 1,
        hashAlg: "sha2-256",
        rawLeaves: true,
        wrapWithDirectory: false,
        preload: false,
        pin: false
      });
      return { ...addResult, isFile: true };
    },
    // STATS
    size: async (cid) => {
      const { ipfs: ipfs2 } = await getIpfs();
      const stat = await ipfs2.files.stat(`/ipfs/${cid}`);
      return stat.cumulativeSize;
    }
  };
}

// node_modules/@oddjs/odd/lib/components/depot/implementation/ipfs-default-pkg.js
async function implementation6(dependencies, peersUrl, repoName) {
  let instance = null;
  return implementation5(async () => {
    if (instance)
      return instance;
    instance = await nodeWithPkg(dependencies, await pkgFromCDN(DEFAULT_CDN_URL), peersUrl, repoName, false);
    return instance;
  });
}

// node_modules/@oddjs/odd/lib/components/depot/implementation/fission-ipfs-production.js
async function implementation7(dependencies, repoName) {
  return implementation6(dependencies, PRODUCTION.server + "/ipfs/peers", repoName);
}

// node_modules/@oddjs/odd/lib/components/depot/implementation/fission-ipfs-staging.js
async function implementation8(dependencies, repoName) {
  return implementation6(dependencies, STAGING.server + "/ipfs/peers", repoName);
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission/channel.js
function endpoint(host) {
  return ({ rootDID }) => {
    return `${host}/user/link/${rootDID}`;
  };
}

// node_modules/@oddjs/odd/lib/components/auth/channel.js
var createWssChannel = async (reference2, socketEndpoint, options) => {
  const { username, handleMessage } = options;
  const rootDID = await waitForRootDid(reference2, username);
  if (!rootDID) {
    throw new Error(`Failed to lookup DID for ${username}`);
  }
  const topic = `deviceLink#${rootDID}`;
  console.log("Opening channel", topic);
  const socket = new WebSocket(socketEndpoint({ rootDID }));
  await waitForOpenConnection(socket);
  socket.onmessage = handleMessage;
  const send = publishOnWssChannel(socket);
  const close = closeWssChannel(socket);
  return {
    send,
    close
  };
};
var waitForRootDid = async (reference2, username) => {
  let rootDid = await reference2.didRoot.lookup(username).catch(() => {
    console.warn("Could not fetch root DID. Retrying.");
    return null;
  });
  if (rootDid) {
    return rootDid;
  }
  return new Promise((resolve, reject) => {
    const maxRetries = 10;
    let tries = 0;
    const rootDidInterval = setInterval(async () => {
      rootDid = await reference2.didRoot.lookup(username).catch(() => {
        console.warn("Could not fetch root DID. Retrying.");
        return null;
      });
      if (!rootDid && tries < maxRetries) {
        tries++;
        return;
      } else if (!rootDid && tries === maxRetries) {
        reject("Failed to fetch root DID.");
      }
      clearInterval(rootDidInterval);
      resolve(rootDid);
    }, 1e3);
  });
};
var waitForOpenConnection = async (socket) => {
  return new Promise((resolve, reject) => {
    socket.onopen = () => resolve();
    socket.onerror = () => reject("Websocket channel could not be opened");
  });
};
var closeWssChannel = (socket) => {
  return function() {
    if (socket)
      socket.close(1e3);
  };
};
var publishOnWssChannel = (socket) => {
  return function(data) {
    const binary = typeof data === "string" ? new TextEncoder().encode(data).buffer : data;
    socket?.send(binary);
  };
};

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission/blocklist.js
var USERNAME_BLOCKLIST = [
  "fission",
  "ipfs",
  "ipns",
  "did",
  "id",
  "identity",
  ".htaccess",
  "htaccess",
  ".htpasswd",
  "htpasswd",
  ".well-known",
  "well-known",
  "400",
  "401",
  "403",
  "404",
  "405",
  "406",
  "407",
  "408",
  "409",
  "410",
  "411",
  "412",
  "413",
  "414",
  "415",
  "416",
  "417",
  "421",
  "422",
  "423",
  "424",
  "426",
  "428",
  "429",
  "431",
  "500",
  "501",
  "502",
  "503",
  "504",
  "505",
  "506",
  "507",
  "508",
  "509",
  "510",
  "511",
  "_domainkey",
  "about",
  "about-us",
  "abuse",
  "access",
  "account",
  "accounts",
  "ad",
  "add",
  "admin",
  "administration",
  "administrator",
  "ads",
  "ads.txt",
  "advertise",
  "advertising",
  "aes128-ctr",
  "aes128-gcm",
  "aes192-ctr",
  "aes256-ctr",
  "aes256-gcm",
  "affiliate",
  "affiliates",
  "ajax",
  "alert",
  "alerts",
  "alpha",
  "amp",
  "analytics",
  "api",
  "app",
  "app-ads.txt",
  "apps",
  "asc",
  "assets",
  "atom",
  "auth",
  "authentication",
  "authorize",
  "autoconfig",
  "autodiscover",
  "avatar",
  "backup",
  "banner",
  "banners",
  "bbs",
  "beta",
  "billing",
  "billings",
  "blog",
  "blogs",
  "board",
  "bookmark",
  "bookmarks",
  "broadcasthost",
  "business",
  "buy",
  "cache",
  "calendar",
  "campaign",
  "captcha",
  "careers",
  "cart",
  "cas",
  "categories",
  "category",
  "cdn",
  "cgi",
  "cgi-bin",
  "chacha20-poly1305",
  "change",
  "channel",
  "channels",
  "chart",
  "chat",
  "checkout",
  "clear",
  "client",
  "close",
  "cloud",
  "cms",
  "com",
  "comment",
  "comments",
  "community",
  "compare",
  "compose",
  "config",
  "connect",
  "contact",
  "contest",
  "cookies",
  "copy",
  "copyright",
  "count",
  "cp",
  "cpanel",
  "create",
  "crossdomain.xml",
  "css",
  "curve25519-sha256",
  "customer",
  "customers",
  "customize",
  "dashboard",
  "db",
  "deals",
  "debug",
  "delete",
  "desc",
  "destroy",
  "dev",
  "developer",
  "developers",
  "diffie-hellman-group-exchange-sha256",
  "diffie-hellman-group14-sha1",
  "disconnect",
  "discuss",
  "dns",
  "dns0",
  "dns1",
  "dns2",
  "dns3",
  "dns4",
  "docs",
  "documentation",
  "domain",
  "download",
  "downloads",
  "downvote",
  "draft",
  "drop",
  "ecdh-sha2-nistp256",
  "ecdh-sha2-nistp384",
  "ecdh-sha2-nistp521",
  "edit",
  "editor",
  "email",
  "enterprise",
  "error",
  "errors",
  "event",
  "events",
  "example",
  "exception",
  "exit",
  "explore",
  "export",
  "extensions",
  "false",
  "family",
  "faq",
  "faqs",
  "favicon.ico",
  "features",
  "feed",
  "feedback",
  "feeds",
  "file",
  "files",
  "filter",
  "follow",
  "follower",
  "followers",
  "following",
  "fonts",
  "forgot",
  "forgot-password",
  "forgotpassword",
  "form",
  "forms",
  "forum",
  "forums",
  "friend",
  "friends",
  "ftp",
  "get",
  "git",
  "go",
  "graphql",
  "group",
  "groups",
  "guest",
  "guidelines",
  "guides",
  "head",
  "header",
  "help",
  "hide",
  "hmac-sha",
  "hmac-sha1",
  "hmac-sha1-etm",
  "hmac-sha2-256",
  "hmac-sha2-256-etm",
  "hmac-sha2-512",
  "hmac-sha2-512-etm",
  "home",
  "host",
  "hosting",
  "hostmaster",
  "htpasswd",
  "http",
  "httpd",
  "https",
  "humans.txt",
  "icons",
  "images",
  "imap",
  "img",
  "import",
  "index",
  "info",
  "insert",
  "investors",
  "invitations",
  "invite",
  "invites",
  "invoice",
  "is",
  "isatap",
  "issues",
  "it",
  "jobs",
  "join",
  "js",
  "json",
  "keybase.txt",
  "learn",
  "legal",
  "license",
  "licensing",
  "like",
  "limit",
  "live",
  "load",
  "local",
  "localdomain",
  "localhost",
  "lock",
  "login",
  "logout",
  "lost-password",
  "m",
  "mail",
  "mail0",
  "mail1",
  "mail2",
  "mail3",
  "mail4",
  "mail5",
  "mail6",
  "mail7",
  "mail8",
  "mail9",
  "mailer-daemon",
  "mailerdaemon",
  "map",
  "marketing",
  "marketplace",
  "master",
  "me",
  "media",
  "member",
  "members",
  "message",
  "messages",
  "metrics",
  "mis",
  "mobile",
  "moderator",
  "modify",
  "more",
  "mx",
  "mx1",
  "my",
  "net",
  "network",
  "new",
  "news",
  "newsletter",
  "newsletters",
  "next",
  "nil",
  "no-reply",
  "nobody",
  "noc",
  "none",
  "noreply",
  "notification",
  "notifications",
  "ns",
  "ns0",
  "ns1",
  "ns2",
  "ns3",
  "ns4",
  "ns5",
  "ns6",
  "ns7",
  "ns8",
  "ns9",
  "null",
  "oauth",
  "oauth2",
  "offer",
  "offers",
  "online",
  "openid",
  "order",
  "orders",
  "overview",
  "owa",
  "owner",
  "page",
  "pages",
  "partners",
  "passwd",
  "password",
  "pay",
  "payment",
  "payments",
  "photo",
  "photos",
  "pixel",
  "plans",
  "plugins",
  "policies",
  "policy",
  "pop",
  "pop3",
  "popular",
  "portal",
  "portfolio",
  "post",
  "postfix",
  "postmaster",
  "poweruser",
  "preferences",
  "premium",
  "press",
  "previous",
  "pricing",
  "print",
  "privacy",
  "privacy-policy",
  "private",
  "prod",
  "product",
  "production",
  "profile",
  "profiles",
  "project",
  "projects",
  "public",
  "purchase",
  "put",
  "quota",
  "recover",
  "recovery",
  "redirect",
  "reduce",
  "refund",
  "refunds",
  "register",
  "registration",
  "remove",
  "replies",
  "reply",
  "report",
  "request",
  "request-password",
  "reset",
  "reset-password",
  "response",
  "return",
  "returns",
  "review",
  "reviews",
  "robots.txt",
  "root",
  "rootuser",
  "rsa-sha2-2",
  "rsa-sha2-512",
  "rss",
  "rules",
  "sales",
  "save",
  "script",
  "sdk",
  "search",
  "secure",
  "security",
  "select",
  "services",
  "session",
  "sessions",
  "settings",
  "setup",
  "share",
  "shift",
  "shop",
  "signin",
  "signup",
  "site",
  "sitemap",
  "sites",
  "smtp",
  "sort",
  "source",
  "sql",
  "ssh",
  "ssh-rsa",
  "ssl",
  "ssladmin",
  "ssladministrator",
  "sslwebmaster",
  "stage",
  "staging",
  "stat",
  "static",
  "statistics",
  "stats",
  "status",
  "store",
  "style",
  "styles",
  "stylesheet",
  "stylesheets",
  "subdomain",
  "subscribe",
  "sudo",
  "super",
  "superuser",
  "support",
  "survey",
  "sync",
  "sysadmin",
  "system",
  "tablet",
  "tag",
  "tags",
  "team",
  "telnet",
  "terms",
  "terms-of-use",
  "test",
  "testimonials",
  "theme",
  "themes",
  "today",
  "tools",
  "topic",
  "topics",
  "tour",
  "training",
  "translate",
  "translations",
  "trending",
  "trial",
  "true",
  "umac-128",
  "umac-128-etm",
  "umac-64",
  "umac-64-etm",
  "undefined",
  "unfollow",
  "unlike",
  "unsubscribe",
  "update",
  "upgrade",
  "usenet",
  "user",
  "username",
  "users",
  "uucp",
  "var",
  "verify",
  "video",
  "view",
  "void",
  "vote",
  "vpn",
  "webmail",
  "webmaster",
  "website",
  "widget",
  "widgets",
  "wiki",
  "wpad",
  "write",
  "www",
  "www-data",
  "www1",
  "www2",
  "www3",
  "www4",
  "you",
  "yourname",
  "yourusername",
  "zlib"
];

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission/index.js
async function createAccount(endpoints, dependencies, userProps) {
  const jwt = encode(await build({
    audience: await did(endpoints),
    dependencies,
    issuer: await write(dependencies.crypto)
  }));
  const response = await fetch(apiUrl(endpoints, "/user"), {
    method: "PUT",
    headers: {
      "authorization": `Bearer ${jwt}`,
      "content-type": "application/json"
    },
    body: JSON.stringify(userProps)
  });
  return {
    success: response.status < 300
  };
}
async function isUsernameAvailable(endpoints, username) {
  const resp = await fetch(apiUrl(endpoints, `/user/data/${username}`));
  return !resp.ok;
}
function isUsernameValid(username) {
  return !username.startsWith("-") && !username.endsWith("-") && !username.startsWith("_") && /^[a-zA-Z0-9_-]+$/.test(username) && !USERNAME_BLOCKLIST.includes(username.toLowerCase());
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission-base.js
function createChannel(endpoints, dependencies, options) {
  return createWssChannel(dependencies.reference, endpoint(`${endpoints.server}${endpoints.apiPath}`.replace(/^https?:\/\//, "wss://")), options);
}
var isUsernameAvailable2 = async (endpoints, username) => {
  return isUsernameAvailable(endpoints, username);
};
var isUsernameValid2 = async (username) => {
  return isUsernameValid(username);
};
var register2 = async (endpoints, dependencies, options) => {
  const { success } = await createAccount(endpoints, dependencies, options);
  if (success)
    return register(dependencies, { ...options, type: TYPE });
  return { success: false };
};
function implementation9(endpoints, dependencies) {
  const base7 = implementation(dependencies);
  return {
    type: base7.type,
    canDelegateAccount: base7.canDelegateAccount,
    delegateAccount: base7.delegateAccount,
    linkDevice: base7.linkDevice,
    session: base7.session,
    isUsernameValid: isUsernameValid2,
    createChannel: (...args) => createChannel(endpoints, dependencies, ...args),
    isUsernameAvailable: (...args) => isUsernameAvailable2(endpoints, ...args),
    register: (...args) => register2(endpoints, dependencies, ...args)
  };
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission-base-production.js
function implementation10(dependencies) {
  return implementation9(PRODUCTION, dependencies);
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission-base-staging.js
function implementation11(dependencies) {
  return implementation9(STAGING, dependencies);
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/wnfs.js
async function canDelegateAccount2(dependencies, username) {
  const accountDID = await dependencies.reference.didRoot.lookup(username);
  const readKey2 = await retrieve({ crypto: dependencies.crypto, accountDID });
  if (!readKey2)
    return false;
  return canDelegateAccount(dependencies, username);
}
async function delegateAccount3(dependencies, username, audience) {
  const accountDID = await dependencies.reference.didRoot.lookup(username);
  const readKey2 = await retrieve({ crypto: dependencies.crypto, accountDID });
  const { token } = await delegateAccount(dependencies, username, audience);
  return { readKey: toString3(readKey2, "base64pad"), ucan: token };
}
async function linkDevice3(dependencies, username, data) {
  if (!isWnfsLinkingData(data)) {
    throw new LinkingError(`Consumer received invalid link device response from producer: Expected read key and ucan, but got ${JSON.stringify(data)}`);
  }
  const { readKey: readKey2, ucan: encodedToken } = data;
  const ucan = decode(encodedToken);
  if (await isValid(dependencies.crypto, ucan)) {
    await dependencies.storage.setItem(dependencies.storage.KEYS.ACCOUNT_UCAN, encodedToken);
    await store({
      accountDID: await dependencies.reference.didRoot.lookup(username),
      crypto: dependencies.crypto,
      readKey: fromString6(readKey2)
    });
    const issuer = await write(dependencies.crypto);
    const fsUcan = await build({
      dependencies,
      potency: "APPEND",
      resource: "*",
      proof: encodedToken,
      lifetimeInSeconds: 60 * 60 * 24 * 30 * 12 * 1e3,
      audience: issuer,
      issuer
    });
    await dependencies.reference.repositories.ucans.add(fsUcan);
  } else {
    throw new LinkingError(`Consumer received invalid link device response from producer. Given ucan is invalid: ${data.ucan}`);
  }
  await provide(dependencies.storage, { type: TYPE, username });
}
async function session2(components, authedUsername, config2, eventEmitters) {
  if (authedUsername) {
    const hasSelfAuthorisedFsUcan = components.reference.repositories.ucans.find((ucan) => {
      if (ucan.payload.exp < Date.now() + 60 * 60 * 24 * 7)
        return false;
      return ucan.payload.ptc === "APPEND" && ucan.payload.rsc === "*";
    });
    if (!hasSelfAuthorisedFsUcan) {
      const issuer = await write(components.crypto);
      const proof = await components.storage.getItem(components.storage.KEYS.ACCOUNT_UCAN);
      const fsUcan = await build({
        dependencies: components,
        potency: "APPEND",
        resource: "*",
        proof: proof ? proof : void 0,
        lifetimeInSeconds: 60 * 60 * 24 * 30 * 12 * 1e3,
        audience: issuer,
        issuer
      });
      await components.reference.repositories.ucans.add(fsUcan);
    }
    const fs = config2.fileSystem?.loadImmediately === false ? void 0 : await loadFileSystem({
      config: config2,
      dependencies: {
        crypto: components.crypto,
        depot: components.depot,
        manners: components.manners,
        reference: components.reference,
        storage: components.storage
      },
      eventEmitter: eventEmitters.fileSystem,
      username: authedUsername
    });
    const session3 = new Session({
      crypto: components.crypto,
      fs,
      eventEmitter: eventEmitters.session,
      storage: components.storage,
      type: TYPE,
      username: authedUsername
    });
    return session3;
  }
  return null;
}
function isWnfsLinkingData(data) {
  return isObject(data) && "readKey" in data && typeof data.readKey === "string" && "ucan" in data && typeof data.ucan === "string";
}
function implementation12(dependencies) {
  const base7 = implementation(dependencies);
  return {
    type: base7.type,
    session: session2,
    canDelegateAccount: (...args) => canDelegateAccount2(dependencies, ...args),
    delegateAccount: (...args) => delegateAccount3(dependencies, ...args),
    linkDevice: (...args) => linkDevice3(dependencies, ...args),
    // Have to be implemented properly by other implementations
    createChannel: base7.createChannel,
    isUsernameValid: base7.isUsernameValid,
    isUsernameAvailable: base7.isUsernameAvailable,
    register: base7.register
  };
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission-wnfs.js
function implementation13(endpoints, dependencies) {
  const fissionBase = implementation9(endpoints, dependencies);
  const wnfs = implementation12(dependencies);
  return {
    type: wnfs.type,
    canDelegateAccount: wnfs.canDelegateAccount,
    delegateAccount: wnfs.delegateAccount,
    linkDevice: wnfs.linkDevice,
    session: wnfs.session,
    createChannel: fissionBase.createChannel,
    isUsernameValid: fissionBase.isUsernameValid,
    isUsernameAvailable: fissionBase.isUsernameAvailable,
    register: fissionBase.register
  };
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission-wnfs-production.js
function implementation14(dependencies) {
  return implementation13(PRODUCTION, dependencies);
}

// node_modules/@oddjs/odd/lib/components/auth/implementation/fission-wnfs-staging.js
function implementation15(dependencies) {
  return implementation13(STAGING, dependencies);
}

// node_modules/@oddjs/odd/lib/components/capabilities/implementation/fission-lobby.js
async function collect2(endpoints, dependencies) {
  const url = new URL(self.location.href);
  const username = url.searchParams.get("username") ?? "";
  if (!username)
    return null;
  const info = await retry(() => getClassifiedViaPostMessage(endpoints, dependencies.crypto), {
    tries: 20,
    timeout: 6e4,
    timeoutMessage: "Trying to retrieve UCAN(s) and readKey(s) from the auth lobby timed out after 60 seconds."
  });
  const secrets = await translateClassifiedInfo(dependencies, info);
  if (!secrets) {
    throw new Error("Failed to retrieve secrets from lobby url parameters");
  }
  url.searchParams.delete("authorised");
  url.searchParams.delete("cancelled");
  url.searchParams.delete("newUser");
  url.searchParams.delete("username");
  history.replaceState(null, document.title, url.toString());
  return { ...secrets, username };
}
async function request(endpoints, dependencies, options = {}) {
  const { permissions } = options;
  const app = permissions?.app;
  const fs = permissions?.fs;
  const platform = permissions?.platform;
  const raw = permissions?.raw;
  const sharing = permissions?.sharing;
  const exchangeDid = await exchange(dependencies.crypto);
  const writeDid = await write(dependencies.crypto);
  const sharedRepo = false;
  const redirectTo = options.returnUrl || window.location.href;
  const params = [
    ["didExchange", exchangeDid],
    ["didWrite", writeDid],
    ["redirectTo", redirectTo],
    ["sdk", VERSION.toString()],
    ["sharedRepo", sharedRepo ? "t" : "f"],
    ["sharing", sharing ? "t" : "f"]
  ].concat(app ? [["appFolder", `${app.creator}/${app.name}`]] : [], fs?.private ? fs.private.map((p) => ["privatePath", toPosix(p, { absolute: true })]) : [], fs?.public ? fs.public.map((p) => ["publicPath", toPosix(p, { absolute: true })]) : [], raw ? [["raw", urlEncode(JSON.stringify(raw))]] : [], options.extraParams ? Object.entries(options.extraParams) : []).concat((() => {
    const apps = platform?.apps;
    switch (typeof apps) {
      case "string":
        return [["app", apps]];
      case "object":
        return apps.map((a) => ["app", a]);
      default:
        return [];
    }
  })());
  window.location.href = endpoints.lobby + "?" + params.map(([k, v]) => encodeURIComponent(k) + "=" + encodeURIComponent(v)).join("&");
}
async function getClassifiedViaPostMessage(endpoints, crypto3) {
  const didExchange = await exchange(crypto3);
  const iframe = await new Promise((resolve) => {
    const iframe2 = document.createElement("iframe");
    iframe2.id = "odd-secret-exchange";
    iframe2.style.width = "0";
    iframe2.style.height = "0";
    iframe2.style.border = "none";
    iframe2.style.display = "none";
    document.body.appendChild(iframe2);
    iframe2.onload = () => {
      resolve(iframe2);
    };
    iframe2.src = `${endpoints.lobby}/exchange.html`;
  });
  return new Promise((resolve, reject) => {
    function stop() {
      globalThis.removeEventListener("message", listen2);
      document.body.removeChild(iframe);
      reject();
    }
    function listen2(event) {
      if (new URL(event.origin).host !== new URL(endpoints.lobby).host)
        return stop();
      if (event.data == null)
        return stop();
      let classifiedInfo;
      try {
        classifiedInfo = JSON.parse(event.data);
      } catch {
        stop();
      }
      if (!isLobbyClassifiedInfo(classifiedInfo))
        stop();
      globalThis.removeEventListener("message", listen2);
      try {
        document.body.removeChild(iframe);
      } catch {
      }
      resolve(classifiedInfo);
    }
    globalThis.addEventListener("message", listen2);
    if (iframe.contentWindow == null) {
      throw new Error("Can't import UCANs & readKey(s): No access to its contentWindow");
    }
    const message = {
      odd: "exchange-secrets",
      didExchange
    };
    iframe.contentWindow.postMessage(message, iframe.src);
  });
}
function isLobbyClassifiedInfo(obj) {
  return isObject(obj) && isString(obj.sessionKey) && isString(obj.secrets) && isString(obj.iv);
}
function isLobbySecrets(obj) {
  return isObject(obj) && isObject(obj.fs) && Object.values(obj.fs).every((a) => hasProp(a, "key") && hasProp(a, "bareNameFilter")) && Array.isArray(obj.ucans) && obj.ucans.every((a) => isString(a));
}
async function translateClassifiedInfo({ crypto: crypto3 }, classifiedInfo) {
  const rawSessionKey = await crypto3.keystore.decrypt(fromString2(classifiedInfo.sessionKey, "base64pad"));
  const isUtf16 = rawSessionKey[1] === 0;
  const sessionKey = isUtf16 ? fromString2(new TextDecoder("utf-16").decode(rawSessionKey), "base64pad") : rawSessionKey;
  const secretsStr = await crypto3.aes.decrypt(fromString2(classifiedInfo.secrets, "base64pad"), sessionKey, SymmAlg.AES_GCM, fromString2(classifiedInfo.iv, "base64pad"));
  const secrets = JSON.parse(toString3(secretsStr, "utf8"));
  if (!isLobbySecrets(secrets))
    throw new Error("Invalid secrets received");
  const fileSystemSecrets = isLobbySecrets(secrets) ? Object.entries(secrets.fs).map(([posixPath, { bareNameFilter: bareNameFilter2, key }]) => {
    return {
      bareNameFilter: bareNameFilter2,
      path: fromPosix(posixPath),
      readKey: fromString2(key, "base64pad")
    };
  }) : [];
  const ucans = secrets.ucans.map((u) => decode(u));
  return {
    fileSystemSecrets,
    ucans
  };
}
async function retry(action, options) {
  return new Promise((resolve, reject) => {
    if (options.tries > 0) {
      const unoMas = () => {
        retry(action, { ...options, tries: options.tries - 1 });
      };
      const timeoutId = setTimeout(unoMas, options.timeout);
      action().then(resolve, unoMas).finally(() => clearTimeout(timeoutId));
    } else {
      reject(new Error(options.timeoutMessage));
    }
  });
}
function implementation16(endpoints, dependencies) {
  return {
    collect: () => collect2(endpoints, dependencies),
    request: (...args) => request(endpoints, dependencies, ...args)
  };
}

// node_modules/@oddjs/odd/lib/components/capabilities/implementation/fission-lobby-production.js
function implementation17(dependencies) {
  return implementation16(PRODUCTION, dependencies);
}

// node_modules/@oddjs/odd/lib/components/capabilities/implementation/fission-lobby-staging.js
function implementation18(dependencies) {
  return implementation16(STAGING, dependencies);
}

// node_modules/@oddjs/odd/lib/repositories/cid-log.js
function create12({ storage: storage2 }) {
  return Repo3.create({
    storage: storage2,
    storageName: storage2.KEYS.CID_LOG
  });
}
var Repo3 = class extends Repository {
  constructor(options) {
    super(options);
  }
  fromJSON(a) {
    return decodeCID(a);
  }
  toJSON(a) {
    return a.toString();
  }
  indexOf(item) {
    return this.memoryCache.map((c) => c.toString()).indexOf(item.toString());
  }
  newest() {
    return this.memoryCache[this.memoryCache.length - 1];
  }
};

// node_modules/@oddjs/odd/lib/components/reference/implementation/base.js
async function didRootLookup(dependencies, username) {
  const maybeUcan = await dependencies.storage.getItem(dependencies.storage.KEYS.ACCOUNT_UCAN);
  return maybeUcan ? rootIssuer(maybeUcan) : await write(dependencies.crypto);
}
async function implementation19(dependencies) {
  return {
    dataRoot: {
      domain: () => {
        throw new Error("Not implemented");
      },
      lookup: () => {
        throw new Error("Not implemented");
      },
      update: () => {
        throw new Error("Not implemented");
      }
    },
    didRoot: {
      lookup: (...args) => didRootLookup(dependencies, ...args)
    },
    dns: {
      lookupDnsLink,
      lookupTxtRecord
    },
    repositories: {
      cidLog: await create12({ storage: dependencies.storage }),
      ucans: await create2({ storage: dependencies.storage })
    }
  };
}

// node_modules/@oddjs/odd/lib/components/reference/implementation/fission/data-root.js
async function lookup(endpoints, dependencies, username) {
  const maybeRoot = await lookupOnFisson(endpoints, dependencies, username);
  if (!maybeRoot)
    return null;
  if (maybeRoot !== null)
    return maybeRoot;
  try {
    const cid = await lookupDnsLink(username + ".files." + endpoints.userDomain);
    return !cid ? null : decodeCID(cid);
  } catch (err) {
    console.error(err);
    throw new Error("Could not locate user root in DNS");
  }
}
async function lookupOnFisson(endpoints, dependencies, username) {
  try {
    const resp = await fetch(
      apiUrl(endpoints, `user/data/${username}`),
      { cache: "reload" }
      // don't use cache
    );
    const cid = await resp.json();
    return decodeCID(cid);
  } catch (err) {
    dependencies.manners.log("Could not locate user root on Fission server: ", hasProp(err, "toString") ? err.toString() : err);
    return null;
  }
}
async function update(endpoints, dependencies, cidInstance, proof) {
  const cid = cidInstance.toString();
  dependencies.manners.log("\u{1F30A} Updating your DNSLink:", cid);
  return await fetchWithRetry(apiUrl(endpoints, `user/data/${cid}`), {
    headers: async () => {
      const jwt = encode(await build({
        dependencies,
        audience: await did(endpoints),
        issuer: await write(dependencies.crypto),
        potency: "APPEND",
        proof: encode(proof),
        // TODO: Waiting on API change.
        //       Should be `username.fission.name/*`
        resource: proof.payload.rsc
      }));
      return { "authorization": `Bearer ${jwt}` };
    },
    retries: 100,
    retryDelay: 5e3,
    retryOn: [502, 503, 504]
  }, {
    method: "PUT"
  }).then((response) => {
    if (response.status < 300)
      dependencies.manners.log("\u{1FAB4} DNSLink updated:", cid);
    else
      dependencies.manners.log("\u{1F525} Failed to update DNSLink for:", cid);
    return { success: response.status < 300 };
  }).catch((err) => {
    dependencies.manners.log("\u{1F525} Failed to update DNSLink for:", cid);
    console.error(err);
    return { success: false };
  });
}
async function fetchWithRetry(url, retryOptions, fetchOptions, retry2 = 0) {
  const headers = await retryOptions.headers();
  const response = await fetch(url, {
    ...fetchOptions,
    headers: { ...fetchOptions.headers, ...headers }
  });
  if (retryOptions.retryOn.includes(response.status)) {
    if (retry2 < retryOptions.retries) {
      return await new Promise((resolve, reject) => setTimeout(() => fetchWithRetry(url, retryOptions, fetchOptions, retry2 + 1).then(resolve, reject), retryOptions.retryDelay));
    } else {
      throw new Error("Too many retries for fetch");
    }
  }
  return response;
}

// node_modules/@oddjs/odd/lib/components/reference/implementation/fission/did.js
async function root2(endpoints, username) {
  try {
    const maybeDid = await lookupTxtRecord(`_did.${username}.${endpoints.userDomain}`);
    if (maybeDid !== null)
      return maybeDid;
  } catch (_err) {
  }
  throw new Error("Could not locate user DID in DNS.");
}

// node_modules/@oddjs/odd/lib/components/reference/implementation/fission-base.js
async function implementation20(endpoints, dependencies) {
  const base7 = await implementation19(dependencies);
  base7.dataRoot.domain = (username) => `${username}.files.${endpoints.userDomain}`;
  base7.dataRoot.lookup = (...args) => lookup(endpoints, dependencies, ...args);
  base7.dataRoot.update = (...args) => update(endpoints, dependencies, ...args);
  base7.didRoot.lookup = (...args) => root2(endpoints, ...args);
  return base7;
}

// node_modules/@oddjs/odd/lib/components/reference/implementation/fission-production.js
function implementation21(dependencies) {
  return implementation20(PRODUCTION, dependencies);
}

// node_modules/@oddjs/odd/lib/components/reference/implementation/fission-staging.js
function implementation22(dependencies) {
  return implementation20(STAGING, dependencies);
}

// node_modules/@oddjs/odd/lib/components/storage/implementation/memory.js
async function getItem2(mem, key) {
  return mem[key];
}
async function setItem2(mem, key, val) {
  mem[key] = val;
  return val;
}
async function removeItem2(mem, key) {
  delete mem[key];
}
async function clear3(mem) {
  for (const k in mem)
    delete mem[k];
}
function implementation23() {
  const mem = {};
  return {
    KEYS,
    getItem: (...args) => getItem2(mem, ...args),
    setItem: (...args) => setItem2(mem, ...args),
    removeItem: (...args) => removeItem2(mem, ...args),
    clear: (...args) => clear3(mem, ...args)
  };
}

// node_modules/@oddjs/odd/lib/components/manners/implementation/base.js
function implementation24(opts) {
  return {
    log: opts.configuration.debug ? console.log : () => {
    },
    warn: opts.configuration.debug ? console.warn : () => {
    },
    // WASM
    wnfsWasmLookup: (wnfsVersion) => fetch(`https://unpkg.com/wnfs@${wnfsVersion}/wasm_wnfs_bg.wasm`),
    // File system
    fileSystem: {
      hooks: {
        afterLoadExisting: async () => {
        },
        afterLoadNew: async (fs) => {
          await fs.publish();
        },
        beforeLoadExisting: async () => {
        },
        beforeLoadNew: async () => {
        }
      }
    }
  };
}

// node_modules/@oddjs/odd/lib/components/auth/implementation.js
var implementation_exports2 = {};

// node_modules/@oddjs/odd/lib/components/capabilities/implementation.js
var implementation_exports3 = {};

// node_modules/@oddjs/odd/lib/components/depot/implementation.js
var implementation_exports4 = {};

// node_modules/@oddjs/odd/lib/components/manners/implementation.js
var implementation_exports5 = {};

// node_modules/@oddjs/odd/lib/components/reference/implementation.js
var implementation_exports6 = {};

// node_modules/@oddjs/odd/lib/components/storage/implementation.js
var implementation_exports7 = {};

// node_modules/@oddjs/odd/lib/apps/index.js
var apps_exports = {};
__export(apps_exports, {
  create: () => create13,
  deleteByDomain: () => deleteByDomain,
  index: () => index,
  publish: () => publish
});
async function index(endpoints, dependencies) {
  const localUcan = await dependencies.reference.repositories.ucans.lookupAppUcan("*");
  if (localUcan === null) {
    throw "Could not find your local UCAN";
  }
  const jwt = encode(await build({
    dependencies,
    audience: await did(endpoints),
    issuer: await write(dependencies.crypto),
    proof: localUcan,
    potency: null
  }));
  const response = await fetch(apiUrl(endpoints, "/app"), {
    method: "GET",
    headers: {
      "authorization": `Bearer ${jwt}`
    }
  });
  const data = await response.json();
  return Object.values(data).filter((v) => v.urls.length > 0).map(({ urls, insertedAt, modifiedAt }) => ({ domains: urls, insertedAt, modifiedAt }));
}
async function create13(endpoints, dependencies, subdomain) {
  const localUcan = await dependencies.reference.repositories.ucans.lookupAppUcan("*");
  if (localUcan === null) {
    throw "Could not find your local UCAN";
  }
  const jwt = encode(await build({
    dependencies,
    audience: await did(endpoints),
    issuer: await write(dependencies.crypto),
    proof: localUcan,
    potency: null
  }));
  const url = isString(subdomain) ? apiUrl(endpoints, `/app?subdomain=${encodeURIComponent(subdomain)}`) : apiUrl(endpoints, `/app`);
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "authorization": `Bearer ${jwt}`
    }
  });
  const data = await response.json();
  const nowIso = (/* @__PURE__ */ new Date()).toISOString();
  return {
    domains: [data],
    insertedAt: nowIso,
    modifiedAt: nowIso
  };
}
async function deleteByDomain(endpoints, dependencies, domain) {
  const localUcan = await dependencies.reference.repositories.ucans.lookupAppUcan(domain);
  if (localUcan === null) {
    throw new Error("Could not find your local UCAN");
  }
  const jwt = encode(await build({
    dependencies,
    audience: await did(endpoints),
    issuer: await write(dependencies.crypto),
    proof: localUcan,
    potency: null
  }));
  const appIndexResponse = await fetch(apiUrl(endpoints, "/app"), {
    method: "GET",
    headers: {
      "authorization": `Bearer ${jwt}`
    }
  });
  const index2 = await appIndexResponse.json();
  const appToDelete = Object.entries(index2).find(([_, app]) => app.urls.includes(domain));
  if (appToDelete == null) {
    throw new Error(`Couldn't find an app with domain ${domain}`);
  }
  await fetch(apiUrl(endpoints, `/app/${encodeURIComponent(appToDelete[0])}`), {
    method: "DELETE",
    headers: {
      "authorization": `Bearer ${jwt}`
    }
  });
}
async function publish(endpoints, dependencies, domain, cid) {
  const localUcan = await dependencies.reference.repositories.ucans.lookupAppUcan(domain);
  if (localUcan === null) {
    throw "Could not find your local UCAN";
  }
  const jwt = encode(await build({
    dependencies,
    audience: await did(endpoints),
    issuer: await write(dependencies.crypto),
    proof: localUcan,
    potency: null
  }));
  const url = apiUrl(endpoints, `/app/${domain}/${cid}`);
  await fetch(url, {
    method: "PUT",
    headers: {
      "authorization": `Bearer ${jwt}`
    }
  });
}

// node_modules/@oddjs/odd/lib/index.js
var ProgramError;
(function(ProgramError2) {
  ProgramError2["InsecureContext"] = "INSECURE_CONTEXT";
  ProgramError2["UnsupportedBrowser"] = "UNSUPPORTED_BROWSER";
})(ProgramError || (ProgramError = {}));
async function program(settings) {
  if (!settings)
    throw new Error("Expected a settings object of the type `Partial<Components> & Configuration` as the first parameter");
  if (globalThis.isSecureContext === false)
    throw ProgramError.InsecureContext;
  if (await isSupported2() === false)
    throw ProgramError.UnsupportedBrowser;
  const components = await gatherComponents(settings);
  return assemble(extractConfig(settings), components);
}
var auth = {
  /**
   * A standalone authentication system that uses the browser's Web Crypto API
   * to create an identity based on a RSA key-pair.
   *
   * NOTE: This uses a Fission server to register an account (DID).
   *       Check out the `wnfs` and `base` auth implementations if
   *       you want to build something without the Fission infrastructure.
   */
  async fissionWebCrypto(settings) {
    const { disableWnfs, staging } = settings;
    const manners2 = settings.manners || defaultMannersComponent(settings);
    const crypto3 = settings.crypto || await defaultCryptoComponent(settings);
    const storage2 = settings.storage || defaultStorageComponent(settings);
    const reference2 = settings.reference || await defaultReferenceComponent({ crypto: crypto3, manners: manners2, storage: storage2 });
    if (disableWnfs) {
      if (staging)
        return implementation11({ crypto: crypto3, reference: reference2, storage: storage2 });
      return implementation10({ crypto: crypto3, reference: reference2, storage: storage2 });
    } else {
      if (staging)
        return implementation15({ crypto: crypto3, reference: reference2, storage: storage2 });
      return implementation14({ crypto: crypto3, reference: reference2, storage: storage2 });
    }
  }
};
var capabilities = {
  /**
   * A secure enclave in the form of a ODD app which serves as the root authority.
   * Your app is redirected to the lobby where the user can create an account or link a device,
   * and then request permissions from the user for reading or write to specific parts of the filesystem.
   */
  async fissionLobby(settings) {
    const { staging } = settings;
    const crypto3 = settings.crypto || await defaultCryptoComponent(settings);
    if (staging)
      return implementation18({ crypto: crypto3 });
    return implementation17({ crypto: crypto3 });
  }
};
var crypto2 = {
  /**
   * The default crypto component, uses primarily the Web Crypto API and [keystore-idb](https://github.com/fission-codes/keystore-idb).
   * Keys are stored in a non-exportable way in indexedDB using the Web Crypto API.
   *
   * IndexedDB store is namespaced.
   */
  browser(settings) {
    return defaultCryptoComponent(settings);
  }
};
var depot = {
  /**
   * This depot uses IPFS and the Fission servers.
   * The data is transferred to the Fission IPFS node,
   * where all of your encrypted and public data lives.
   * Other ODD programs with this depot fetch the data from there.
   */
  async fissionIPFS(settings) {
    const repoName = `${namespace(settings)}/ipfs`;
    const storage2 = settings.storage || defaultStorageComponent(settings);
    if (settings.staging)
      return implementation8({ storage: storage2 }, repoName);
    return implementation7({ storage: storage2 }, repoName);
  }
};
var manners = {
  /**
   * The default ODD SDK behaviour.
   */
  default(settings) {
    return defaultMannersComponent(settings);
  }
};
var reference = {
  /**
   * Use the Fission servers as your reference.
   */
  async fission(settings) {
    const { staging } = settings;
    const manners2 = settings.manners || defaultMannersComponent(settings);
    const crypto3 = settings.crypto || await defaultCryptoComponent(settings);
    const storage2 = settings.storage || defaultStorageComponent(settings);
    if (staging)
      return implementation22({ crypto: crypto3, manners: manners2, storage: storage2 });
    return implementation21({ crypto: crypto3, manners: manners2, storage: storage2 });
  }
};
var storage = {
  /**
   * IndexedDB through the `localForage` library, automatically namespaced.
   */
  browser(settings) {
    return defaultStorageComponent(settings);
  },
  /**
   * In-memory store.
   */
  memory() {
    return implementation23();
  }
};
async function assemble(config2, components) {
  const permissions = config2.permissions;
  await ensureBackwardsCompatibility(components, config2);
  const fsEvents = createEmitter();
  const sessionEvents = createEmitter();
  const allEvents = merge(fsEvents, sessionEvents);
  const sessionInfo = await restore(components.storage);
  const auth2 = ((method) => {
    return {
      implementation: method,
      accountConsumer(username) {
        return createConsumer({ auth: method, crypto: components.crypto, manners: components.manners }, { username });
      },
      accountProducer(username) {
        return createProducer({ auth: method, crypto: components.crypto, manners: components.manners }, { username });
      },
      isUsernameAvailable: method.isUsernameAvailable,
      isUsernameValid: method.isUsernameValid,
      register: method.register,
      async session() {
        const newSessionInfo = await restore(components.storage);
        if (!newSessionInfo)
          return null;
        return this.implementation.session(components, newSessionInfo.username, config2, { fileSystem: fsEvents, session: sessionEvents });
      }
    };
  })(components.auth);
  const capabilities2 = {
    async collect() {
      const c = await components.capabilities.collect();
      if (!c)
        return null;
      await collect({
        capabilities: c,
        crypto: components.crypto,
        reference: components.reference,
        storage: components.storage
      });
      return c.username;
    },
    request(options) {
      return components.capabilities.request({
        permissions,
        ...options || {}
      });
    },
    async session(username) {
      const ucan = validatePermissions(components.reference.repositories.ucans, permissions || {});
      if (!ucan) {
        console.warn("The present UCANs did not satisfy the configured permissions.");
        return null;
      }
      const accountDID = await components.reference.didRoot.lookup(username);
      const validSecrets = await validateSecrets(components.crypto, accountDID, permissions || {});
      if (!validSecrets) {
        console.warn("The present filesystem secrets did not satisfy the configured permissions.");
        return null;
      }
      await provide(components.storage, { type: SESSION_TYPE, username });
      const fs = config2.fileSystem?.loadImmediately === false ? void 0 : await loadFileSystem({
        config: config2,
        dependencies: components,
        eventEmitter: fsEvents,
        username
      });
      return new Session({
        fs,
        username,
        crypto: components.crypto,
        storage: components.storage,
        type: SESSION_TYPE,
        eventEmitter: sessionEvents
      });
    }
  };
  let session3 = null;
  if (isCapabilityBasedAuthConfiguration(config2)) {
    const username = await capabilities2.collect();
    if (username)
      session3 = await capabilities2.session(username);
    if (sessionInfo && sessionInfo.type === SESSION_TYPE)
      session3 = await capabilities2.session(sessionInfo.username);
  } else if (sessionInfo && sessionInfo.type !== SESSION_TYPE) {
    session3 = await auth2.session();
  }
  const shorthands = {
    // DIDs
    accountDID: (username) => components.reference.didRoot.lookup(username),
    agentDID: () => write(components.crypto),
    sharingDID: () => exchange(components.crypto),
    // File system
    fileSystem: {
      addPublicExchangeKey: (fs) => addPublicExchangeKey(components.crypto, fs),
      addSampleData: (fs) => addSampleData(fs),
      hasPublicExchangeKey: (fs) => hasPublicExchangeKey(components.crypto, fs),
      load: (username) => loadFileSystem({ config: config2, username, dependencies: components, eventEmitter: fsEvents }),
      recover: (params) => recoverFileSystem({ auth: auth2, dependencies: components, ...params })
    }
  };
  const program2 = {
    ...shorthands,
    ...listenTo(allEvents),
    configuration: { ...config2 },
    auth: auth2,
    components,
    capabilities: capabilities2,
    session: session3
  };
  if (config2.debug) {
    const inject = config2.debugging?.injectIntoGlobalContext === void 0 ? true : config2.debugging?.injectIntoGlobalContext;
    if (inject) {
      const container = globalThis;
      container.__odd = container.__odd || {};
      container.__odd.programs = container.__odd.programs || {};
      container.__odd.programs[namespace(config2)] = program2;
    }
    const emitMessages = config2.debugging?.emitWindowPostMessages === void 0 ? true : config2.debugging?.emitWindowPostMessages;
    if (emitMessages) {
      const { connect: connect2, disconnect: disconnect2 } = await create3({
        namespace: config2.namespace,
        session: session3,
        capabilities: config2.permissions,
        dependencies: components,
        eventEmitters: {
          fileSystem: fsEvents,
          session: sessionEvents
        }
      });
      const container = globalThis;
      container.__odd = container.__odd || {};
      container.__odd.extension = container.__odd.extension || {};
      container.__odd.extension.connect = connect2;
      container.__odd.extension.disconnect = disconnect2;
      globalThis.postMessage({
        id: "odd-devtools-ready-message"
      });
    }
  }
  return program2;
}
var compositions = {
  /**
   * The default Fission stack using web crypto auth.
   */
  async fission(settings) {
    const crypto3 = settings.crypto || await defaultCryptoComponent(settings);
    const manners2 = settings.manners || defaultMannersComponent(settings);
    const storage2 = settings.storage || defaultStorageComponent(settings);
    const settingsWithComponents = { ...settings, crypto: crypto3, manners: manners2, storage: storage2 };
    const r = await reference.fission(settingsWithComponents);
    const d = await depot.fissionIPFS(settingsWithComponents);
    const c = await capabilities.fissionLobby(settingsWithComponents);
    const a = await auth.fissionWebCrypto({ ...settingsWithComponents, reference: r });
    return {
      auth: a,
      capabilities: c,
      depot: d,
      reference: r,
      crypto: crypto3,
      manners: manners2,
      storage: storage2
    };
  }
};
async function gatherComponents(setup) {
  const config2 = extractConfig(setup);
  const crypto3 = setup.crypto || await defaultCryptoComponent(config2);
  const manners2 = setup.manners || defaultMannersComponent(config2);
  const storage2 = setup.storage || defaultStorageComponent(config2);
  const reference2 = setup.reference || await defaultReferenceComponent({ crypto: crypto3, manners: manners2, storage: storage2 });
  const depot2 = setup.depot || await defaultDepotComponent({ storage: storage2 }, config2);
  const capabilities2 = setup.capabilities || defaultCapabilitiesComponent({ crypto: crypto3 });
  const auth2 = setup.auth || defaultAuthComponent({ crypto: crypto3, reference: reference2, storage: storage2 });
  return {
    auth: auth2,
    capabilities: capabilities2,
    crypto: crypto3,
    depot: depot2,
    manners: manners2,
    reference: reference2,
    storage: storage2
  };
}
function defaultAuthComponent({ crypto: crypto3, reference: reference2, storage: storage2 }) {
  return implementation14({
    crypto: crypto3,
    reference: reference2,
    storage: storage2
  });
}
function defaultCapabilitiesComponent({ crypto: crypto3 }) {
  return implementation17({ crypto: crypto3 });
}
function defaultCryptoComponent(config2) {
  return implementation2({
    storeName: namespace(config2),
    exchangeKeyName: "exchange-key",
    writeKeyName: "write-key"
  });
}
function defaultDepotComponent({ storage: storage2 }, config2) {
  return implementation7({ storage: storage2 }, `${namespace(config2)}/ipfs`);
}
function defaultMannersComponent(config2) {
  return implementation24({
    configuration: config2
  });
}
function defaultReferenceComponent({ crypto: crypto3, manners: manners2, storage: storage2 }) {
  return implementation21({
    crypto: crypto3,
    manners: manners2,
    storage: storage2
  });
}
function defaultStorageComponent(config2) {
  return implementation3({
    name: namespace(config2)
  });
}
async function isSupported2() {
  return import_localforage3.default.supports(import_localforage3.default.INDEXEDDB) && await (() => new Promise((resolve) => {
    const db = indexedDB.open("testDatabase");
    db.onsuccess = () => resolve(true);
    db.onerror = () => resolve(false);
  }))();
}
async function ensureBackwardsCompatibility(components, config2) {
  const [migK, migV] = ["migrated", VERSION];
  const currentVersion = fromString5(VERSION);
  if (!currentVersion)
    throw new Error("The ODD SDK VERSION should be a semver string");
  const migrationOccurred = await components.storage.getItem(migK).then((v) => typeof v === "string" ? fromString5(v) : null).then((v) => v && isBiggerThanOrEqualTo(v, currentVersion));
  if (migrationOccurred)
    return;
  if (!globalThis.indexedDB)
    return;
  const existingDatabases = globalThis.indexedDB.databases ? (await globalThis.indexedDB.databases()).map((db) => db.name) : ["keystore", "localforage"];
  const keystoreDB = existingDatabases.includes("keystore") ? await bwOpenDatabase("keystore") : null;
  if (keystoreDB) {
    const exchangeKeyPair = await bwGetValue(keystoreDB, "keyvaluepairs", "exchange-key");
    const writeKeyPair = await bwGetValue(keystoreDB, "keyvaluepairs", "write-key");
    if (exchangeKeyPair && writeKeyPair) {
      await components.storage.setItem("exchange-key", exchangeKeyPair);
      await components.storage.setItem("write-key", writeKeyPair);
    }
  }
  const localforageDB = existingDatabases.includes("localforage") ? await bwOpenDatabase("localforage") : null;
  if (localforageDB) {
    const accountUcan = await bwGetValue(localforageDB, "keyvaluepairs", "ucan");
    const permissionedUcans = await bwGetValue(localforageDB, "keyvaluepairs", "webnative.auth_ucans");
    const rootKey = await bwGetValue(localforageDB, "keyvaluepairs", "readKey");
    const authedUser = await bwGetValue(localforageDB, "keyvaluepairs", "webnative.auth_username");
    if (rootKey && isString(rootKey)) {
      const anyUcan = accountUcan || (Array.isArray(permissionedUcans) ? permissionedUcans[0] : void 0);
      const accountDID = anyUcan ? rootIssuer(anyUcan) : typeof authedUser === "string" ? await components.reference.didRoot.lookup(authedUser) : null;
      if (!accountDID)
        throw new Error("Failed to retrieve account DID");
      await store({
        accountDID,
        crypto: components.crypto,
        readKey: fromString2(rootKey, "base64pad")
      });
    }
    if (accountUcan) {
      await components.storage.setItem(components.storage.KEYS.ACCOUNT_UCAN, accountUcan);
    }
    if (authedUser) {
      await components.storage.setItem(components.storage.KEYS.SESSION, JSON.stringify({
        type: isCapabilityBasedAuthConfiguration(config2) ? SESSION_TYPE : TYPE,
        username: authedUser
      }));
    }
  }
  await components.storage.setItem(migK, migV);
}
function bwGetValue(db, storeName, key) {
  return new Promise((resolve, reject) => {
    if (!db.objectStoreNames.contains(storeName))
      return resolve(null);
    const transaction = db.transaction([storeName], "readonly");
    const store2 = transaction.objectStore(storeName);
    const req = store2.get(key);
    req.onerror = () => {
      resolve(null);
    };
    req.onsuccess = () => {
      resolve(req.result);
    };
  });
}
function bwOpenDatabase(name8) {
  return new Promise((resolve, reject) => {
    const req = globalThis.indexedDB.open(name8);
    req.onerror = () => {
      resolve(null);
    };
    req.onsuccess = () => {
      resolve(req.result);
    };
    req.onupgradeneeded = (e) => {
      req.transaction?.abort();
      globalThis.indexedDB.deleteDatabase(name8);
    };
  });
}
function extractConfig(opts) {
  return {
    namespace: opts.namespace,
    debug: opts.debug,
    fileSystem: opts.fileSystem,
    permissions: opts.permissions,
    userMessages: opts.userMessages
  };
}
function isCapabilityBasedAuthConfiguration(config2) {
  return !!config2.permissions;
}
export {
  implementation_exports2 as Auth,
  CID,
  implementation_exports3 as Capabilities,
  implementation_exports as Crypto,
  implementation_exports4 as Depot,
  EMPTY_CID,
  FileSystem,
  implementation_exports5 as Manners,
  ProgramError,
  ROOT_FILESYSTEM_PERMISSIONS,
  implementation_exports6 as Reference,
  Session,
  implementation_exports7 as Storage,
  VERSION,
  WASM_WNFS_VERSION,
  addRootFileSystemPermissions,
  appId,
  apps_exports as apps,
  assemble,
  auth,
  capabilities,
  compositions,
  crypto2 as crypto,
  decodeCID,
  defaultAuthComponent,
  defaultCapabilitiesComponent,
  defaultCryptoComponent,
  defaultDepotComponent,
  defaultMannersComponent,
  defaultReferenceComponent,
  defaultStorageComponent,
  depot,
  did_exports as did,
  encodeCID,
  extractConfig,
  fission_exports as fission,
  gatherComponents,
  isCapabilityBasedAuthConfiguration,
  isSupported2 as isSupported,
  manners,
  namespace,
  path_exports as path,
  permissionPaths,
  program,
  reference,
  storage,
  ucan_exports as ucan
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel-limit/index.js:
  (*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
