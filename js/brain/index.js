import {
  fromString,
  require_browser,
  require_events,
  require_localforage,
  toString
} from "./chunk-OPNLH3GE.js";
import {
  Buffer,
  __commonJS,
  __toESM,
  global,
  init_node_shims,
  process,
  require_buffer,
  require_ieee754
} from "./chunk-2WJT5GS6.js";

// node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS({
  "node_modules/peek-readable/lib/EndOfFileStream.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EndOfStreamError = exports2.defaultMessages = void 0;
    exports2.defaultMessages = "End-Of-Stream";
    var EndOfStreamError = class extends Error {
      constructor() {
        super(exports2.defaultMessages);
      }
    };
    exports2.EndOfStreamError = EndOfStreamError;
  }
});

// node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS({
  "node_modules/peek-readable/lib/Deferred.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve2, reject2) => {
          this.reject = reject2;
          this.resolve = resolve2;
        });
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS({
  "node_modules/peek-readable/lib/StreamReader.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    var Deferred_1 = require_Deferred();
    var EndOfFileStream_2 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_2.EndOfStreamError;
    } });
    var maxStreamReadSize = 1 * 1024 * 1024;
    var StreamReader = class {
      constructor(s) {
        this.s = s;
        this.deferred = null;
        this.endOfStream = false;
        this.peekQueue = [];
        if (!s.read || !s.once) {
          throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
        this.s.once("error", (err) => this.reject(err));
        this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      /**
       * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
       * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes peeked
       */
      async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes read
       */
      async read(buffer, offset, length) {
        if (length === 0) {
          return 0;
        }
        if (this.peekQueue.length === 0 && this.endOfStream) {
          throw new EndOfFileStream_1.EndOfStreamError();
        }
        let remaining = length;
        let bytesRead = 0;
        while (this.peekQueue.length > 0 && remaining > 0) {
          const peekData = this.peekQueue.pop();
          if (!peekData)
            throw new Error("peekData should be defined");
          const lenCopy = Math.min(peekData.length, remaining);
          buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
          bytesRead += lenCopy;
          remaining -= lenCopy;
          if (lenCopy < peekData.length) {
            this.peekQueue.push(peekData.subarray(lenCopy));
          }
        }
        while (remaining > 0 && !this.endOfStream) {
          const reqLen = Math.min(remaining, maxStreamReadSize);
          const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
          bytesRead += chunkLen;
          if (chunkLen < reqLen)
            break;
          remaining -= chunkLen;
        }
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset Offset target
       * @param length Number of bytes to read
       * @returns Number of bytes read
       */
      async readFromStream(buffer, offset, length) {
        const readBuffer = this.s.read(length);
        if (readBuffer) {
          buffer.set(readBuffer, offset);
          return readBuffer.length;
        } else {
          const request = {
            buffer,
            offset,
            length,
            deferred: new Deferred_1.Deferred()
          };
          this.deferred = request.deferred;
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
          return request.deferred.promise;
        }
      }
      /**
       * Process deferred read request
       * @param request Deferred read request
       */
      readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
          request.buffer.set(readBuffer, request.offset);
          request.deferred.resolve(readBuffer.length);
          this.deferred = null;
        } else {
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
        }
      }
      reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.reject(err);
          this.deferred = null;
        }
      }
    };
    exports2.StreamReader = StreamReader;
  }
});

// node_modules/peek-readable/lib/index.js
var require_lib = __commonJS({
  "node_modules/peek-readable/lib/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_1.EndOfStreamError;
    } });
    var StreamReader_1 = require_StreamReader();
    Object.defineProperty(exports2, "StreamReader", { enumerable: true, get: function() {
      return StreamReader_1.StreamReader;
    } });
  }
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS({
  "node_modules/strtok3/lib/AbstractTokenizer.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractTokenizer = void 0;
    var peek_readable_1 = require_lib();
    var AbstractTokenizer = class {
      constructor(fileInfo) {
        this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = fileInfo ? fileInfo : {};
      }
      /**
       * Read a token from the tokenizer-stream
       * @param token - The token to read
       * @param position - If provided, the desired position in the tokenizer-stream
       * @returns Promise with token data
       */
      async readToken(token, position = this.position) {
        const uint8Array = Buffer.alloc(token.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Peek a token from the tokenizer-stream.
       * @param token - Token to peek from the tokenizer-stream.
       * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
       * @returns Promise with token data
       */
      async peekToken(token, position = this.position) {
        const uint8Array = Buffer.alloc(token.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Ignore number of bytes, advances the pointer in under tokenizer-stream.
       * @param length - Number of bytes to ignore
       * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
       */
      async ignore(length) {
        if (this.fileInfo.size !== void 0) {
          const bytesLeft = this.fileInfo.size - this.position;
          if (length > bytesLeft) {
            this.position += bytesLeft;
            return bytesLeft;
          }
        }
        this.position += length;
        return length;
      }
      async close() {
      }
      normalizeOptions(uint8Array, options) {
        if (options && options.position !== void 0 && options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (options) {
          return {
            mayBeLess: options.mayBeLess === true,
            offset: options.offset ? options.offset : 0,
            length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
            position: options.position ? options.position : this.position
          };
        }
        return {
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        };
      }
    };
    exports2.AbstractTokenizer = AbstractTokenizer;
  }
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS({
  "node_modules/strtok3/lib/ReadStreamTokenizer.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadStreamTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var peek_readable_1 = require_lib();
    var maxBufferSize = 256e3;
    var ReadStreamTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(stream2, fileInfo) {
        super(fileInfo);
        this.streamReader = new peek_readable_1.StreamReader(stream2);
      }
      /**
       * Get file information, an HTTP-client may implement this doing a HEAD request
       * @return Promise with file information
       */
      async getFileInfo() {
        return this.fileInfo;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
       * @param options - Read behaviour options
       * @returns Promise with number of bytes read
       */
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          await this.ignore(skipBytes);
          return this.readBuffer(uint8Array, options);
        } else if (skipBytes < 0) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (normOptions.length === 0) {
          return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise with number of bytes peeked
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
            bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
            uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
            return bytesRead - skipBytes;
          } else if (skipBytes < 0) {
            throw new Error("Cannot peek from a negative offset in a stream");
          }
        }
        if (normOptions.length > 0) {
          try {
            bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
          } catch (err) {
            if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
              return 0;
            }
            throw err;
          }
          if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
            throw new peek_readable_1.EndOfStreamError();
          }
        }
        return bytesRead;
      }
      async ignore(length) {
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length) {
          const remaining = length - totBytesRead;
          const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
          if (bytesRead < 0) {
            return bytesRead;
          }
          totBytesRead += bytesRead;
        }
        return totBytesRead;
      }
    };
    exports2.ReadStreamTokenizer = ReadStreamTokenizer;
  }
});

// node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS({
  "node_modules/strtok3/lib/BufferTokenizer.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferTokenizer = void 0;
    var peek_readable_1 = require_lib();
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var BufferTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      /**
       * Construct BufferTokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param fileInfo - Pass additional file information to the tokenizer
       */
      constructor(uint8Array, fileInfo) {
        super(fileInfo);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async readBuffer(uint8Array, options) {
        if (options && options.position) {
          if (options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        } else {
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
          return bytes2read;
        }
      }
      async close() {
      }
    };
    exports2.BufferTokenizer = BufferTokenizer;
  }
});

// node_modules/strtok3/lib/core.js
var require_core = __commonJS({
  "node_modules/strtok3/lib/core.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBuffer = exports2.fromStream = exports2.EndOfStreamError = void 0;
    var ReadStreamTokenizer_1 = require_ReadStreamTokenizer();
    var BufferTokenizer_1 = require_BufferTokenizer();
    var peek_readable_1 = require_lib();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return peek_readable_1.EndOfStreamError;
    } });
    function fromStream2(stream2, fileInfo) {
      fileInfo = fileInfo ? fileInfo : {};
      return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
    function fromBuffer2(uint8Array, fileInfo) {
      return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
    }
    exports2.fromBuffer = fromBuffer2;
  }
});

// node_modules/music-metadata-browser/node_modules/token-types/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/music-metadata-browser/node_modules/token-types/lib/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnsiStringType = exports2.StringType = exports2.BufferType = exports2.Uint8ArrayType = exports2.IgnoreType = exports2.Float80_LE = exports2.Float80_BE = exports2.Float64_LE = exports2.Float64_BE = exports2.Float32_LE = exports2.Float32_BE = exports2.Float16_LE = exports2.Float16_BE = exports2.INT64_BE = exports2.UINT64_BE = exports2.INT64_LE = exports2.UINT64_LE = exports2.INT32_LE = exports2.INT32_BE = exports2.INT24_BE = exports2.INT24_LE = exports2.INT16_LE = exports2.INT16_BE = exports2.INT8 = exports2.UINT32_BE = exports2.UINT32_LE = exports2.UINT24_BE = exports2.UINT24_LE = exports2.UINT16_BE = exports2.UINT16_LE = exports2.UINT8 = void 0;
    var ieee754 = require_ieee754();
    function dv(array) {
      return new DataView(array.buffer, array.byteOffset);
    }
    exports2.UINT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getUint8(offset);
      },
      put(array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
      }
    };
    exports2.UINT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
      }
    };
    exports2.UINT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
      }
    };
    exports2.UINT24_LE = {
      len: 3,
      get(array, offset) {
        const dataView = dv(array);
        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 255);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
      }
    };
    exports2.UINT24_BE = {
      len: 3,
      get(array, offset) {
        const dataView = dv(array);
        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 255);
        return offset + 3;
      }
    };
    exports2.UINT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
      }
    };
    exports2.UINT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
      }
    };
    exports2.INT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getInt8(offset);
      },
      put(array, offset, value) {
        dv(array).setInt8(offset, value);
        return offset + 1;
      }
    };
    exports2.INT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset);
      },
      put(array, offset, value) {
        dv(array).setInt16(offset, value);
        return offset + 2;
      }
    };
    exports2.INT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset, true);
      },
      put(array, offset, value) {
        dv(array).setInt16(offset, value, true);
        return offset + 2;
      }
    };
    exports2.INT24_LE = {
      len: 3,
      get(array, offset) {
        const unsigned = exports2.UINT24_LE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 255);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
      }
    };
    exports2.INT24_BE = {
      len: 3,
      get(array, offset) {
        const unsigned = exports2.UINT24_BE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 255);
        return offset + 3;
      }
    };
    exports2.INT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset);
      },
      put(array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
      }
    };
    exports2.INT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setInt32(offset, value, true);
        return offset + 4;
      }
    };
    exports2.UINT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
      }
    };
    exports2.INT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setBigInt64(offset, value, true);
        return offset + 8;
      }
    };
    exports2.UINT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset);
      },
      put(array, offset, value) {
        dv(array).setBigUint64(offset, value);
        return offset + 8;
      }
    };
    exports2.INT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset);
      },
      put(array, offset, value) {
        dv(array).setBigInt64(offset, value);
        return offset + 8;
      }
    };
    exports2.Float16_BE = {
      len: 2,
      get(dataView, offset) {
        return ieee754.read(dataView, offset, false, 10, this.len);
      },
      put(dataView, offset, value) {
        ieee754.write(dataView, value, offset, false, 10, this.len);
        return offset + this.len;
      }
    };
    exports2.Float16_LE = {
      len: 2,
      get(array, offset) {
        return ieee754.read(array, offset, true, 10, this.len);
      },
      put(array, offset, value) {
        ieee754.write(array, value, offset, true, 10, this.len);
        return offset + this.len;
      }
    };
    exports2.Float32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset);
      },
      put(array, offset, value) {
        dv(array).setFloat32(offset, value);
        return offset + 4;
      }
    };
    exports2.Float32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setFloat32(offset, value, true);
        return offset + 4;
      }
    };
    exports2.Float64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset);
      },
      put(array, offset, value) {
        dv(array).setFloat64(offset, value);
        return offset + 8;
      }
    };
    exports2.Float64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setFloat64(offset, value, true);
        return offset + 8;
      }
    };
    exports2.Float80_BE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, false, 63, this.len);
      },
      put(array, offset, value) {
        ieee754.write(array, value, offset, false, 63, this.len);
        return offset + this.len;
      }
    };
    exports2.Float80_LE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, true, 63, this.len);
      },
      put(array, offset, value) {
        ieee754.write(array, value, offset, true, 63, this.len);
        return offset + this.len;
      }
    };
    var IgnoreType = class {
      /**
       * @param len number of bytes to ignore
       */
      constructor(len) {
        this.len = len;
      }
      // ToDo: don't read, but skip data
      get(array, off) {
      }
    };
    exports2.IgnoreType = IgnoreType;
    var Uint8ArrayType = class {
      constructor(len) {
        this.len = len;
      }
      get(array, offset) {
        return array.subarray(offset, offset + this.len);
      }
    };
    exports2.Uint8ArrayType = Uint8ArrayType;
    var BufferType = class {
      constructor(len) {
        this.len = len;
      }
      get(uint8Array, off) {
        return Buffer.from(uint8Array.subarray(off, off + this.len));
      }
    };
    exports2.BufferType = BufferType;
    var StringType = class {
      constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
      }
      get(uint8Array, offset) {
        return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
      }
    };
    exports2.StringType = StringType;
    var AnsiStringType = class _AnsiStringType {
      constructor(len) {
        this.len = len;
      }
      static decode(buffer, offset, until) {
        let str = "";
        for (let i = offset; i < until; ++i) {
          str += _AnsiStringType.codePointToString(_AnsiStringType.singleByteDecoder(buffer[i]));
        }
        return str;
      }
      static inRange(a, min, max) {
        return min <= a && a <= max;
      }
      static codePointToString(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        } else {
          cp -= 65536;
          return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
        }
      }
      static singleByteDecoder(bite) {
        if (_AnsiStringType.inRange(bite, 0, 127)) {
          return bite;
        }
        const codePoint = _AnsiStringType.windows1252[bite - 128];
        if (codePoint === null) {
          throw Error("invaliding encoding");
        }
        return codePoint;
      }
      get(buffer, offset = 0) {
        return _AnsiStringType.decode(buffer, offset, offset + this.len);
      }
    };
    exports2.AnsiStringType = AnsiStringType;
    AnsiStringType.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ];
  }
});

// node_modules/music-metadata-browser/node_modules/file-type/util.js
var require_util = __commonJS({
  "node_modules/music-metadata-browser/node_modules/file-type/util.js"(exports2) {
    "use strict";
    init_node_shims();
    exports2.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
    exports2.tarHeaderChecksumMatches = (buffer, offset = 0) => {
      const readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
      if (isNaN(readSum)) {
        return false;
      }
      let sum = 8 * 32;
      for (let i = offset; i < offset + 148; i++) {
        sum += buffer[i];
      }
      for (let i = offset + 156; i < offset + 512; i++) {
        sum += buffer[i];
      }
      return readSum === sum;
    };
    exports2.uint32SyncSafeToken = {
      get: (buffer, offset) => {
        return buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
      },
      len: 4
    };
  }
});

// node_modules/music-metadata-browser/node_modules/file-type/supported.js
var require_supported = __commonJS({
  "node_modules/music-metadata-browser/node_modules/file-type/supported.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    module2.exports = {
      extensions: [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "ai",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf"
      ],
      mimeTypes: [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/x-apache-arrow",
        "video/mp4",
        "audio/midi",
        "video/x-matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/vnd.wave",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "audio/opus",
        "video/ogg",
        "audio/ogg",
        "application/ogg",
        "audio/x-flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd"
      ]
    };
  }
});

// node_modules/music-metadata-browser/node_modules/file-type/core.js
var require_core2 = __commonJS({
  "node_modules/music-metadata-browser/node_modules/file-type/core.js"(exports, module) {
    "use strict";
    init_node_shims();
    var Token = require_lib2();
    var strtok3 = require_core();
    var {
      stringToBytes,
      tarHeaderChecksumMatches,
      uint32SyncSafeToken
    } = require_util();
    var supported = require_supported();
    var minimumBytes = 4100;
    async function fromStream(stream2) {
      const tokenizer = await strtok3.fromStream(stream2);
      try {
        return await fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async function fromBuffer(input) {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer = input instanceof Buffer ? input : Buffer.from(input);
      if (!(buffer && buffer.length > 1)) {
        return;
      }
      const tokenizer = strtok3.fromBuffer(buffer);
      return fromTokenizer(tokenizer);
    }
    function _check(buffer, headers, options) {
      options = {
        offset: 0,
        ...options
      };
      for (const [index, header] of headers.entries()) {
        if (options.mask) {
          if (header !== (options.mask[index] & buffer[index + options.offset])) {
            return false;
          }
        } else if (header !== buffer[index + options.offset]) {
          return false;
        }
      }
      return true;
    }
    async function fromTokenizer(tokenizer) {
      try {
        return _fromTokenizer(tokenizer);
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError)) {
          throw error;
        }
      }
    }
    async function _fromTokenizer(tokenizer) {
      let buffer = Buffer.alloc(minimumBytes);
      const bytesRead = 12;
      const check = (header, options) => _check(buffer, header, options);
      const checkString = (header, options) => check(stringToBytes(header), options);
      if (!tokenizer.fileInfo.size) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: true });
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (check([37, 33])) {
        await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: true });
        if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLen);
        return fromTokenizer(tokenizer);
      }
      if (checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (check([80, 75, 3, 4])) {
        try {
          while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
            await tokenizer.readBuffer(buffer, { length: 30 });
            const zipHeader = {
              compressedSize: buffer.readUInt32LE(18),
              uncompressedSize: buffer.readUInt32LE(22),
              filenameLength: buffer.readUInt16LE(26),
              extraFieldLength: buffer.readUInt16LE(28)
            };
            zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
            await tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.filename === "META-INF/mozilla.rsa") {
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            }
            if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
              const type = zipHeader.filename.split("/")[0];
              switch (type) {
                case "_rels":
                  break;
                case "word":
                  return {
                    ext: "docx",
                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  };
                case "ppt":
                  return {
                    ext: "pptx",
                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  };
                case "xl":
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                default:
                  break;
              }
            }
            if (zipHeader.filename.startsWith("xl/")) {
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
            if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
              return {
                ext: "3mf",
                mime: "model/3mf"
              };
            }
            if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
              const mimeType2 = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
              switch (mimeType2) {
                case "application/epub+zip":
                  return {
                    ext: "epub",
                    mime: "application/epub+zip"
                  };
                case "application/vnd.oasis.opendocument.text":
                  return {
                    ext: "odt",
                    mime: "application/vnd.oasis.opendocument.text"
                  };
                case "application/vnd.oasis.opendocument.spreadsheet":
                  return {
                    ext: "ods",
                    mime: "application/vnd.oasis.opendocument.spreadsheet"
                  };
                case "application/vnd.oasis.opendocument.presentation":
                  return {
                    ext: "odp",
                    mime: "application/vnd.oasis.opendocument.presentation"
                  };
                default:
              }
            }
            if (zipHeader.compressedSize === 0) {
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                await tokenizer.peekBuffer(buffer, { mayBeLess: true });
                nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex");
                await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
              }
            } else {
              await tokenizer.ignore(zipHeader.compressedSize);
            }
          }
        } catch (error) {
          if (!(error instanceof strtok3.EndOfStreamError)) {
            throw error;
          }
        }
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("OggS")) {
        await tokenizer.ignore(28);
        const type = Buffer.alloc(8);
        await tokenizer.readBuffer(type);
        if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/opus"
          };
        }
        if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("ftyp", { offset: 4 }) && (buffer[8] & 96) !== 0) {
        const brandMajor = buffer.toString("binary", 8, 12).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (checkString("%PDF")) {
        await tokenizer.ignore(1350);
        const maxBufferSize = 10 * 1024 * 1024;
        const buffer2 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
        await tokenizer.readBuffer(buffer2, { mayBeLess: true });
        if (buffer2.includes(Buffer.from("AIPrivateData"))) {
          return {
            ext: "ai",
            mime: "application/postscript"
          };
        }
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([73, 73, 42, 0])) {
        if (checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 })) {
          return {
            ext: "nef",
            mime: "image/x-nikon-nef"
          };
        }
        if (check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 }))) {
          return {
            ext: "dng",
            mime: "image/x-adobe-dng"
          };
        }
        buffer = Buffer.alloc(24);
        await tokenizer.peekBuffer(buffer);
        if ((check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
        check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
          return {
            ext: "arw",
            mime: "image/x-sony-arw"
          };
        }
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(Token.UINT8);
          let mask = 128;
          let ic = 0;
          while ((msb & mask) === 0 && mask !== 0) {
            ++ic;
            mask >>= 1;
          }
          const id = Buffer.alloc(ic + 1);
          await tokenizer.readBuffer(id);
          return id;
        }
        async function readElement() {
          const id = await readField();
          const lenField = await readField();
          lenField[0] ^= 128 >> lenField.length - 1;
          const nrLen = Math.min(6, lenField.length);
          return {
            id: id.readUIntBE(0, id.length),
            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
          };
        }
        async function readChildren(level, children) {
          while (children > 0) {
            const e = await readElement();
            if (e.id === 17026) {
              return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
            }
            await tokenizer.ignore(e.len);
            --children;
          }
        }
        const re = await readElement();
        const docType = await readChildren(1, re.len);
        switch (docType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          default:
            return;
        }
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (checkString("MSCF") || checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (check([0, 0, 1, 186])) {
        if (check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        }
        if (check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
        }
      }
      if (checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const str = await tokenizer.readToken(new Token.StringType(13, "ascii"));
        if (str === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(Token.INT32_BE),
            type: await tokenizer.readToken(new Token.StringType(4, "binary"))
          };
        }
        do {
          const chunk = await readChunkHeader();
          if (chunk.length < 0) {
            return;
          }
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/x-apache-arrow"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
      check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // `moov`
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          const guid = Buffer.alloc(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(Token.UINT64_LE))
          };
        }
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = Buffer.alloc(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type = await tokenizer.readToken(new Token.StringType(4, "ascii"));
        switch (type) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (checkString("BEGIN:")) {
        if (checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (check([4, 0, 0, 0]) && buffer.length >= 16) {
        const jsonSize = buffer.readUInt32LE(12);
        if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
          try {
            const header = buffer.slice(16, jsonSize + 16).toString();
            const json = JSON.parse(header);
            if (json.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch (_) {
          }
        }
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (tarHeaderChecksumMatches(buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      if (checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
      if (buffer.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
        if (check([16], { offset: 1, mask: [22] })) {
          if (check([8], { offset: 1, mask: [8] })) {
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        if (check([2], { offset: 1, mask: [6] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([4], { offset: 1, mask: [6] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([6], { offset: 1, mask: [6] })) {
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
        }
      }
    }
    var stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.on("error", reject);
      readableStream.once("readable", async () => {
        const pass = new stream.PassThrough();
        let outputStream;
        if (stream.pipeline) {
          outputStream = stream.pipeline(readableStream, pass, () => {
          });
        } else {
          outputStream = readableStream.pipe(pass);
        }
        const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
        try {
          const fileType2 = await fromBuffer(chunk);
          pass.fileType = fileType2;
        } catch (error) {
          reject(error);
        }
        resolve(outputStream);
      });
    });
    var fileType = {
      fromStream,
      fromTokenizer,
      fromBuffer,
      stream
    };
    Object.defineProperty(fileType, "extensions", {
      get() {
        return new Set(supported.extensions);
      }
    });
    Object.defineProperty(fileType, "mimeTypes", {
      get() {
        return new Set(supported.mimeTypes);
      }
    });
    module.exports = fileType;
  }
});

// node_modules/content-type/index.js
var require_content_type = __commonJS({
  "node_modules/content-type/index.js"(exports2) {
    "use strict";
    init_node_shims();
    var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
    var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    exports2.format = format;
    exports2.parse = parse;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || !TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = type;
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          if (!TOKEN_REGEXP.test(param)) {
            throw new TypeError("invalid parameter name");
          }
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      }
      return string;
    }
    function parse(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      var header = typeof string === "object" ? getcontenttype(string) : string;
      if (typeof header !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var index = header.indexOf(";");
      var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (!TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid media type");
      }
      var obj = new ContentType(type.toLowerCase());
      if (index !== -1) {
        var key;
        var match;
        var value;
        PARAM_REGEXP.lastIndex = index;
        while (match = PARAM_REGEXP.exec(header)) {
          if (match.index !== index) {
            throw new TypeError("invalid parameter format");
          }
          index += match[0].length;
          key = match[1].toLowerCase();
          value = match[2];
          if (value.charCodeAt(0) === 34) {
            value = value.slice(1, -1);
            if (value.indexOf("\\") !== -1) {
              value = value.replace(QESC_REGEXP, "$1");
            }
          }
          obj.parameters[key] = value;
        }
        if (index !== header.length) {
          throw new TypeError("invalid parameter format");
        }
      }
      return obj;
    }
    function getcontenttype(obj) {
      var header;
      if (typeof obj.getHeader === "function") {
        header = obj.getHeader("content-type");
      } else if (typeof obj.headers === "object") {
        header = obj.headers && obj.headers["content-type"];
      }
      if (typeof header !== "string") {
        throw new TypeError("content-type header is missing from object");
      }
      return header;
    }
    function qstring(val) {
      var str = String(val);
      if (TOKEN_REGEXP.test(str)) {
        return str;
      }
      if (str.length > 0 && !TEXT_REGEXP.test(str)) {
        throw new TypeError("invalid parameter value");
      }
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ContentType(type) {
      this.parameters = /* @__PURE__ */ Object.create(null);
      this.type = type;
    }
  }
});

// node_modules/media-typer/index.js
var require_media_typer = __commonJS({
  "node_modules/media-typer/index.js"(exports2) {
    "use strict";
    init_node_shims();
    var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
    var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
    var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    exports2.format = format;
    exports2.parse = parse;
    exports2.test = test;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var subtype = obj.subtype;
      var suffix = obj.suffix;
      var type = obj.type;
      if (!type || !TYPE_NAME_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
        throw new TypeError("invalid subtype");
      }
      var string = type + "/" + subtype;
      if (suffix) {
        if (!TYPE_NAME_REGEXP.test(suffix)) {
          throw new TypeError("invalid suffix");
        }
        string += "+" + suffix;
      }
      return string;
    }
    function test(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      if (typeof string !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      return TYPE_REGEXP.test(string.toLowerCase());
    }
    function parse(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      if (typeof string !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var match = TYPE_REGEXP.exec(string.toLowerCase());
      if (!match) {
        throw new TypeError("invalid media type");
      }
      var type = match[1];
      var subtype = match[2];
      var suffix;
      var index = subtype.lastIndexOf("+");
      if (index !== -1) {
        suffix = subtype.substr(index + 1);
        subtype = subtype.substr(0, index);
      }
      return new MediaType(type, subtype, suffix);
    }
    function MediaType(type, subtype, suffix) {
      this.type = type;
      this.subtype = subtype;
      this.suffix = suffix;
    }
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/types.js
var require_types = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/types.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrackType = exports2.TargetType = exports2.DataType = void 0;
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["string"] = 0] = "string";
      DataType2[DataType2["uint"] = 1] = "uint";
      DataType2[DataType2["uid"] = 2] = "uid";
      DataType2[DataType2["bool"] = 3] = "bool";
      DataType2[DataType2["binary"] = 4] = "binary";
      DataType2[DataType2["float"] = 5] = "float";
    })(DataType = exports2.DataType || (exports2.DataType = {}));
    var TargetType;
    (function(TargetType2) {
      TargetType2[TargetType2["shot"] = 10] = "shot";
      TargetType2[TargetType2["scene"] = 20] = "scene";
      TargetType2[TargetType2["track"] = 30] = "track";
      TargetType2[TargetType2["part"] = 40] = "part";
      TargetType2[TargetType2["album"] = 50] = "album";
      TargetType2[TargetType2["edition"] = 60] = "edition";
      TargetType2[TargetType2["collection"] = 70] = "collection";
    })(TargetType = exports2.TargetType || (exports2.TargetType = {}));
    var TrackType;
    (function(TrackType2) {
      TrackType2[TrackType2["video"] = 1] = "video";
      TrackType2[TrackType2["audio"] = 2] = "audio";
      TrackType2[TrackType2["complex"] = 3] = "complex";
      TrackType2[TrackType2["logo"] = 4] = "logo";
      TrackType2[TrackType2["subtitle"] = 17] = "subtitle";
      TrackType2[TrackType2["button"] = 18] = "button";
      TrackType2[TrackType2["control"] = 32] = "control";
    })(TrackType = exports2.TrackType || (exports2.TrackType = {}));
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/type.js
var require_type = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/type.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrackType = void 0;
    var types_1 = require_types();
    Object.defineProperty(exports2, "TrackType", { enumerable: true, get: function() {
      return types_1.TrackType;
    } });
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/GenericTagTypes.js
var require_GenericTagTypes = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/GenericTagTypes.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUnique = exports2.isSingleton = exports2.commonTags = void 0;
    exports2.commonTags = {
      year: { multiple: false },
      track: { multiple: false },
      disk: { multiple: false },
      title: { multiple: false },
      artist: { multiple: false },
      artists: { multiple: true, unique: true },
      albumartist: { multiple: false },
      album: { multiple: false },
      date: { multiple: false },
      originaldate: { multiple: false },
      originalyear: { multiple: false },
      comment: { multiple: true, unique: false },
      genre: { multiple: true, unique: true },
      picture: { multiple: true, unique: true },
      composer: { multiple: true, unique: true },
      lyrics: { multiple: true, unique: false },
      albumsort: { multiple: false, unique: true },
      titlesort: { multiple: false, unique: true },
      work: { multiple: false, unique: true },
      artistsort: { multiple: false, unique: true },
      albumartistsort: { multiple: false, unique: true },
      composersort: { multiple: false, unique: true },
      lyricist: { multiple: true, unique: true },
      writer: { multiple: true, unique: true },
      conductor: { multiple: true, unique: true },
      remixer: { multiple: true, unique: true },
      arranger: { multiple: true, unique: true },
      engineer: { multiple: true, unique: true },
      producer: { multiple: true, unique: true },
      technician: { multiple: true, unique: true },
      djmixer: { multiple: true, unique: true },
      mixer: { multiple: true, unique: true },
      label: { multiple: true, unique: true },
      grouping: { multiple: false },
      subtitle: { multiple: true },
      discsubtitle: { multiple: false },
      totaltracks: { multiple: false },
      totaldiscs: { multiple: false },
      compilation: { multiple: false },
      rating: { multiple: true },
      bpm: { multiple: false },
      mood: { multiple: false },
      media: { multiple: false },
      catalognumber: { multiple: true, unique: true },
      tvShow: { multiple: false },
      tvShowSort: { multiple: false },
      tvSeason: { multiple: false },
      tvEpisode: { multiple: false },
      tvEpisodeId: { multiple: false },
      tvNetwork: { multiple: false },
      podcast: { multiple: false },
      podcasturl: { multiple: false },
      releasestatus: { multiple: false },
      releasetype: { multiple: true },
      releasecountry: { multiple: false },
      script: { multiple: false },
      language: { multiple: false },
      copyright: { multiple: false },
      license: { multiple: false },
      encodedby: { multiple: false },
      encodersettings: { multiple: false },
      gapless: { multiple: false },
      barcode: { multiple: false },
      isrc: { multiple: true },
      asin: { multiple: false },
      musicbrainz_recordingid: { multiple: false },
      musicbrainz_trackid: { multiple: false },
      musicbrainz_albumid: { multiple: false },
      musicbrainz_artistid: { multiple: true },
      musicbrainz_albumartistid: { multiple: true },
      musicbrainz_releasegroupid: { multiple: false },
      musicbrainz_workid: { multiple: false },
      musicbrainz_trmid: { multiple: false },
      musicbrainz_discid: { multiple: false },
      acoustid_id: { multiple: false },
      acoustid_fingerprint: { multiple: false },
      musicip_puid: { multiple: false },
      musicip_fingerprint: { multiple: false },
      website: { multiple: false },
      "performer:instrument": { multiple: true, unique: true },
      averageLevel: { multiple: false },
      peakLevel: { multiple: false },
      notes: { multiple: true, unique: false },
      key: { multiple: false },
      originalalbum: { multiple: false },
      originalartist: { multiple: false },
      discogs_artist_id: { multiple: true, unique: true },
      discogs_release_id: { multiple: false },
      discogs_label_id: { multiple: false },
      discogs_master_release_id: { multiple: false },
      discogs_votes: { multiple: false },
      discogs_rating: { multiple: false },
      replaygain_track_peak: { multiple: false },
      replaygain_track_gain: { multiple: false },
      replaygain_album_peak: { multiple: false },
      replaygain_album_gain: { multiple: false },
      replaygain_track_minmax: { multiple: false },
      replaygain_album_minmax: { multiple: false },
      replaygain_undo: { multiple: false },
      description: { multiple: true },
      longDescription: { multiple: false },
      category: { multiple: true },
      hdVideo: { multiple: false },
      keywords: { multiple: true },
      movement: { multiple: false },
      movementIndex: { multiple: false },
      movementTotal: { multiple: false },
      podcastId: { multiple: false },
      showMovement: { multiple: false },
      stik: { multiple: false }
    };
    function isSingleton(alias) {
      return exports2.commonTags.hasOwnProperty(alias) && !exports2.commonTags[alias].multiple;
    }
    exports2.isSingleton = isSingleton;
    function isUnique(alias) {
      return !exports2.commonTags[alias].multiple || exports2.commonTags[alias].unique;
    }
    exports2.isUnique = isUnique;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/GenericTagMapper.js
var require_GenericTagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/GenericTagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommonTagMapper = void 0;
    var CommonTagMapper = class {
      static toIntOrNull(str) {
        const cleaned = parseInt(str, 10);
        return isNaN(cleaned) ? null : cleaned;
      }
      // TODO: a string of 1of1 would fail to be converted
      // converts 1/10 to no : 1, of : 10
      // or 1 to no : 1, of : 0
      static normalizeTrack(origVal) {
        const split = origVal.toString().split("/");
        return {
          no: parseInt(split[0], 10) || null,
          of: parseInt(split[1], 10) || null
        };
      }
      constructor(tagTypes, tagMap) {
        this.tagTypes = tagTypes;
        this.tagMap = tagMap;
      }
      /**
       * Process and set common tags
       * write common tags to
       * @param tag Native tag
       * @param warnings Register warnings
       * @return common name
       */
      mapGenericTag(tag, warnings) {
        tag = { id: tag.id, value: tag.value };
        this.postMap(tag, warnings);
        const id = this.getCommonName(tag.id);
        return id ? { id, value: tag.value } : null;
      }
      /**
       * Convert native tag key to common tag key
       * @tag  Native header tag
       * @return common tag name (alias)
       */
      getCommonName(tag) {
        return this.tagMap[tag];
      }
      /**
       * Handle post mapping exceptions / correction
       * @param tag Tag e.g. {"alb", "Buena Vista Social Club")
       * @param warnings Used to register warnings
       */
      postMap(tag, warnings) {
        return;
      }
    };
    CommonTagMapper.maxRatingScore = 1;
    exports2.CommonTagMapper = CommonTagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js
var require_ID3v1TagMap = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ID3v1TagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    var id3v1TagMap = {
      title: "title",
      artist: "artist",
      album: "album",
      year: "year",
      comment: "comment",
      track: "track",
      genre: "genre"
    };
    var ID3v1TagMapper = class extends GenericTagMapper_1.CommonTagMapper {
      constructor() {
        super(["ID3v1"], id3v1TagMap);
      }
    };
    exports2.ID3v1TagMapper = ID3v1TagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js
var require_CaseInsensitiveTagMap = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CaseInsensitiveTagMap = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    var CaseInsensitiveTagMap = class extends GenericTagMapper_1.CommonTagMapper {
      constructor(tagTypes, tagMap) {
        const upperCaseMap = {};
        for (const tag of Object.keys(tagMap)) {
          upperCaseMap[tag.toUpperCase()] = tagMap[tag];
        }
        super(tagTypes, upperCaseMap);
      }
      /**
       * @tag  Native header tag
       * @return common tag name (alias)
       */
      getCommonName(tag) {
        return this.tagMap[tag.toUpperCase()];
      }
    };
    exports2.CaseInsensitiveTagMap = CaseInsensitiveTagMap;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/Util.js
var require_Util = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/Util.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toRatio = exports2.dbToRatio = exports2.ratioToDb = exports2.a2hex = exports2.isBitSet = exports2.getBitAllignedNumber = exports2.stripNulls = exports2.decodeString = exports2.trimRightNull = exports2.findZero = exports2.getBit = void 0;
    function getBit(buf, off, bit) {
      return (buf[off] & 1 << bit) !== 0;
    }
    exports2.getBit = getBit;
    function findZero(uint8Array, start, end, encoding) {
      let i = start;
      if (encoding === "utf16le") {
        while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {
          if (i >= end)
            return end;
          i += 2;
        }
        return i;
      } else {
        while (uint8Array[i] !== 0) {
          if (i >= end)
            return end;
          i++;
        }
        return i;
      }
    }
    exports2.findZero = findZero;
    function trimRightNull(x) {
      const pos0 = x.indexOf("\0");
      return pos0 === -1 ? x : x.substr(0, pos0);
    }
    exports2.trimRightNull = trimRightNull;
    function swapBytes(uint8Array) {
      const l = uint8Array.length;
      if ((l & 1) !== 0)
        throw new Error("Buffer length must be even");
      for (let i = 0; i < l; i += 2) {
        const a = uint8Array[i];
        uint8Array[i] = uint8Array[i + 1];
        uint8Array[i + 1] = a;
      }
      return uint8Array;
    }
    function decodeString(uint8Array, encoding) {
      if (uint8Array[0] === 255 && uint8Array[1] === 254) {
        return decodeString(uint8Array.subarray(2), encoding);
      } else if (encoding === "utf16le" && uint8Array[0] === 254 && uint8Array[1] === 255) {
        if ((uint8Array.length & 1) !== 0)
          throw new Error("Expected even number of octets for 16-bit unicode string");
        return decodeString(swapBytes(uint8Array), encoding);
      }
      return Buffer.from(uint8Array).toString(encoding);
    }
    exports2.decodeString = decodeString;
    function stripNulls(str) {
      str = str.replace(/^\x00+/g, "");
      str = str.replace(/\x00+$/g, "");
      return str;
    }
    exports2.stripNulls = stripNulls;
    function getBitAllignedNumber(source, byteOffset, bitOffset, len) {
      const byteOff = byteOffset + ~~(bitOffset / 8);
      const bitOff = bitOffset % 8;
      let value = source[byteOff];
      value &= 255 >> bitOff;
      const bitsRead = 8 - bitOff;
      const bitsLeft = len - bitsRead;
      if (bitsLeft < 0) {
        value >>= 8 - bitOff - len;
      } else if (bitsLeft > 0) {
        value <<= bitsLeft;
        value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);
      }
      return value;
    }
    exports2.getBitAllignedNumber = getBitAllignedNumber;
    function isBitSet(source, byteOffset, bitOffset) {
      return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;
    }
    exports2.isBitSet = isBitSet;
    function a2hex(str) {
      const arr = [];
      for (let i = 0, l = str.length; i < l; i++) {
        const hex = Number(str.charCodeAt(i)).toString(16);
        arr.push(hex.length === 1 ? "0" + hex : hex);
      }
      return arr.join(" ");
    }
    exports2.a2hex = a2hex;
    function ratioToDb(ratio) {
      return 10 * Math.log10(ratio);
    }
    exports2.ratioToDb = ratioToDb;
    function dbToRatio(dB) {
      return Math.pow(10, dB / 10);
    }
    exports2.dbToRatio = dbToRatio;
    function toRatio(value) {
      const ps = value.split(" ").map((p) => p.trim().toLowerCase());
      if (ps.length >= 1) {
        const v = parseFloat(ps[0]);
        return ps.length === 2 && ps[1] === "db" ? {
          dB: v,
          ratio: dbToRatio(v)
        } : {
          dB: ratioToDb(v),
          ratio: v
        };
      }
    }
    exports2.toRatio = toRatio;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js
var require_ID3v24TagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ID3v24TagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap();
    var util = require_Util();
    var id3v24TagMap = {
      // id3v2.3
      TIT2: "title",
      TPE1: "artist",
      "TXXX:Artists": "artists",
      TPE2: "albumartist",
      TALB: "album",
      TDRV: "date",
      /**
       * Original release year
       */
      TORY: "originalyear",
      TPOS: "disk",
      TCON: "genre",
      APIC: "picture",
      TCOM: "composer",
      "USLT:description": "lyrics",
      TSOA: "albumsort",
      TSOT: "titlesort",
      TOAL: "originalalbum",
      TSOP: "artistsort",
      TSO2: "albumartistsort",
      TSOC: "composersort",
      TEXT: "lyricist",
      "TXXX:Writer": "writer",
      TPE3: "conductor",
      // 'IPLS:instrument': 'performer:instrument', // ToDo
      TPE4: "remixer",
      "IPLS:arranger": "arranger",
      "IPLS:engineer": "engineer",
      "IPLS:producer": "producer",
      "IPLS:DJ-mix": "djmixer",
      "IPLS:mix": "mixer",
      TPUB: "label",
      TIT1: "grouping",
      TIT3: "subtitle",
      TRCK: "track",
      TCMP: "compilation",
      POPM: "rating",
      TBPM: "bpm",
      TMED: "media",
      "TXXX:CATALOGNUMBER": "catalognumber",
      "TXXX:MusicBrainz Album Status": "releasestatus",
      "TXXX:MusicBrainz Album Type": "releasetype",
      /**
       * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
       */
      "TXXX:MusicBrainz Album Release Country": "releasecountry",
      /**
       * Release country as implemented // ToDo: report
       */
      "TXXX:RELEASECOUNTRY": "releasecountry",
      "TXXX:SCRIPT": "script",
      TLAN: "language",
      TCOP: "copyright",
      WCOP: "license",
      TENC: "encodedby",
      TSSE: "encodersettings",
      "TXXX:BARCODE": "barcode",
      "TXXX:ISRC": "isrc",
      TSRC: "isrc",
      "TXXX:ASIN": "asin",
      "TXXX:originalyear": "originalyear",
      "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
      "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
      "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
      "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
      "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
      "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
      "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
      "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
      "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
      "TXXX:ACOUSTID_ID": "acoustid_id",
      "TXXX:Acoustid Id": "acoustid_id",
      "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
      "TXXX:MusicIP PUID": "musicip_puid",
      "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
      WOAR: "website",
      // id3v2.4
      // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
      TDRC: "date",
      TYER: "year",
      TDOR: "originaldate",
      // 'TMCL:instrument': 'performer:instrument',
      "TIPL:arranger": "arranger",
      "TIPL:engineer": "engineer",
      "TIPL:producer": "producer",
      "TIPL:DJ-mix": "djmixer",
      "TIPL:mix": "mixer",
      TMOO: "mood",
      // additional mappings:
      SYLT: "lyrics",
      TSST: "discsubtitle",
      TKEY: "key",
      COMM: "comment",
      TOPE: "originalartist",
      // Windows Media Player
      "PRIV:AverageLevel": "averageLevel",
      "PRIV:PeakLevel": "peakLevel",
      // Discogs
      "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
      "TXXX:DISCOGS_ARTISTS": "artists",
      "TXXX:DISCOGS_ARTIST_NAME": "artists",
      "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
      "TXXX:DISCOGS_CATALOG": "catalognumber",
      "TXXX:DISCOGS_COUNTRY": "releasecountry",
      "TXXX:DISCOGS_DATE": "originaldate",
      "TXXX:DISCOGS_LABEL": "label",
      "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
      "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
      "TXXX:DISCOGS_RATING": "discogs_rating",
      "TXXX:DISCOGS_RELEASED": "date",
      "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
      "TXXX:DISCOGS_VOTES": "discogs_votes",
      "TXXX:CATALOGID": "catalognumber",
      "TXXX:STYLE": "genre",
      "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
      "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
      "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
      "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
      "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
      "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
      "TXXX:MP3GAIN_UNDO": "replaygain_undo",
      MVNM: "movement",
      MVIN: "movementIndex",
      PCST: "podcast",
      TCAT: "category",
      TDES: "description",
      TDRL: "date",
      TGID: "podcastId",
      TKWD: "keywords",
      WFED: "podcasturl"
    };
    var ID3v24TagMapper = class _ID3v24TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      static toRating(popm) {
        return {
          source: popm.email,
          rating: popm.rating > 0 ? (popm.rating - 1) / 254 * GenericTagMapper_1.CommonTagMapper.maxRatingScore : void 0
        };
      }
      constructor() {
        super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
      }
      /**
       * Handle post mapping exceptions / correction
       * @param tag to post map
       * @param warnings Wil be used to register (collect) warnings
       * @return Common value e.g. "Buena Vista Social Club"
       */
      postMap(tag, warnings) {
        switch (tag.id) {
          case "UFID":
            if (tag.value.owner_identifier === "http://musicbrainz.org") {
              tag.id += ":" + tag.value.owner_identifier;
              tag.value = util.decodeString(tag.value.identifier, "latin1");
            }
            break;
          case "PRIV":
            switch (tag.value.owner_identifier) {
              case "AverageLevel":
              case "PeakValue":
                tag.id += ":" + tag.value.owner_identifier;
                tag.value = tag.value.data.length === 4 ? tag.value.data.readUInt32LE(0) : null;
                if (tag.value === null) {
                  warnings.addWarning(`Failed to parse PRIV:PeakValue`);
                }
                break;
              default:
                warnings.addWarning(`Unknown PRIV owner-identifier: ${tag.value.owner_identifier}`);
            }
            break;
          case "COMM":
            tag.value = tag.value ? tag.value.text : null;
            break;
          case "POPM":
            tag.value = _ID3v24TagMapper.toRating(tag.value);
            break;
          default:
            break;
        }
      }
    };
    exports2.ID3v24TagMapper = ID3v24TagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfTagMapper.js
var require_AsfTagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfTagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsfTagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    var asfTagMap = {
      Title: "title",
      Author: "artist",
      "WM/AlbumArtist": "albumartist",
      "WM/AlbumTitle": "album",
      "WM/Year": "date",
      "WM/OriginalReleaseTime": "originaldate",
      "WM/OriginalReleaseYear": "originalyear",
      Description: "comment",
      "WM/TrackNumber": "track",
      "WM/PartOfSet": "disk",
      "WM/Genre": "genre",
      "WM/Composer": "composer",
      "WM/Lyrics": "lyrics",
      "WM/AlbumSortOrder": "albumsort",
      "WM/TitleSortOrder": "titlesort",
      "WM/ArtistSortOrder": "artistsort",
      "WM/AlbumArtistSortOrder": "albumartistsort",
      "WM/ComposerSortOrder": "composersort",
      "WM/Writer": "lyricist",
      "WM/Conductor": "conductor",
      "WM/ModifiedBy": "remixer",
      "WM/Engineer": "engineer",
      "WM/Producer": "producer",
      "WM/DJMixer": "djmixer",
      "WM/Mixer": "mixer",
      "WM/Publisher": "label",
      "WM/ContentGroupDescription": "grouping",
      "WM/SubTitle": "subtitle",
      "WM/SetSubTitle": "discsubtitle",
      // 'WM/PartOfSet': 'totaldiscs',
      "WM/IsCompilation": "compilation",
      "WM/SharedUserRating": "rating",
      "WM/BeatsPerMinute": "bpm",
      "WM/Mood": "mood",
      "WM/Media": "media",
      "WM/CatalogNo": "catalognumber",
      "MusicBrainz/Album Status": "releasestatus",
      "MusicBrainz/Album Type": "releasetype",
      "MusicBrainz/Album Release Country": "releasecountry",
      "WM/Script": "script",
      "WM/Language": "language",
      Copyright: "copyright",
      LICENSE: "license",
      "WM/EncodedBy": "encodedby",
      "WM/EncodingSettings": "encodersettings",
      "WM/Barcode": "barcode",
      "WM/ISRC": "isrc",
      "MusicBrainz/Track Id": "musicbrainz_recordingid",
      "MusicBrainz/Release Track Id": "musicbrainz_trackid",
      "MusicBrainz/Album Id": "musicbrainz_albumid",
      "MusicBrainz/Artist Id": "musicbrainz_artistid",
      "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
      "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
      "MusicBrainz/Work Id": "musicbrainz_workid",
      "MusicBrainz/TRM Id": "musicbrainz_trmid",
      "MusicBrainz/Disc Id": "musicbrainz_discid",
      "Acoustid/Id": "acoustid_id",
      "Acoustid/Fingerprint": "acoustid_fingerprint",
      "MusicIP/PUID": "musicip_puid",
      "WM/ARTISTS": "artists",
      "WM/InitialKey": "key",
      ASIN: "asin",
      "WM/Work": "work",
      "WM/AuthorURL": "website",
      "WM/Picture": "picture"
    };
    var AsfTagMapper = class _AsfTagMapper extends GenericTagMapper_1.CommonTagMapper {
      static toRating(rating) {
        return {
          rating: parseFloat(rating + 1) / 5
        };
      }
      constructor() {
        super(["asf"], asfTagMap);
      }
      postMap(tag) {
        switch (tag.id) {
          case "WM/SharedUserRating":
            const keys = tag.id.split(":");
            tag.value = _AsfTagMapper.toRating(tag.value);
            tag.id = keys[0];
            break;
        }
      }
    };
    exports2.AsfTagMapper = AsfTagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js
var require_ID3v22TagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ID3v22TagMapper = exports2.id3v22TagMap = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap();
    exports2.id3v22TagMap = {
      TT2: "title",
      TP1: "artist",
      TP2: "albumartist",
      TAL: "album",
      TYE: "year",
      COM: "comment",
      TRK: "track",
      TPA: "disk",
      TCO: "genre",
      PIC: "picture",
      TCM: "composer",
      TOR: "originaldate",
      TOT: "originalalbum",
      TXT: "lyricist",
      TP3: "conductor",
      TPB: "label",
      TT1: "grouping",
      TT3: "subtitle",
      TLA: "language",
      TCR: "copyright",
      WCP: "license",
      TEN: "encodedby",
      TSS: "encodersettings",
      WAR: "website",
      "COM:iTunPGAP": "gapless",
      PCS: "podcast",
      TCP: "compilation",
      TDR: "date",
      TS2: "albumartistsort",
      TSA: "albumsort",
      TSC: "composersort",
      TSP: "artistsort",
      TST: "titlesort",
      WFD: "podcasturl",
      TBP: "bpm"
    };
    var ID3v22TagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super(["ID3v2.2"], exports2.id3v22TagMap);
      }
    };
    exports2.ID3v22TagMapper = ID3v22TagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/apev2/APEv2TagMapper.js
var require_APEv2TagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/apev2/APEv2TagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APEv2TagMapper = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap();
    var apev2TagMap = {
      Title: "title",
      Artist: "artist",
      Artists: "artists",
      "Album Artist": "albumartist",
      Album: "album",
      Year: "date",
      Originalyear: "originalyear",
      Originaldate: "originaldate",
      Comment: "comment",
      Track: "track",
      Disc: "disk",
      DISCNUMBER: "disk",
      Genre: "genre",
      "Cover Art (Front)": "picture",
      "Cover Art (Back)": "picture",
      Composer: "composer",
      Lyrics: "lyrics",
      ALBUMSORT: "albumsort",
      TITLESORT: "titlesort",
      WORK: "work",
      ARTISTSORT: "artistsort",
      ALBUMARTISTSORT: "albumartistsort",
      COMPOSERSORT: "composersort",
      Lyricist: "lyricist",
      Writer: "writer",
      Conductor: "conductor",
      // 'Performer=artist(instrument)': 'performer:instrument',
      MixArtist: "remixer",
      Arranger: "arranger",
      Engineer: "engineer",
      Producer: "producer",
      DJMixer: "djmixer",
      Mixer: "mixer",
      Label: "label",
      Grouping: "grouping",
      Subtitle: "subtitle",
      DiscSubtitle: "discsubtitle",
      Compilation: "compilation",
      BPM: "bpm",
      Mood: "mood",
      Media: "media",
      CatalogNumber: "catalognumber",
      MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
      MUSICBRAINZ_ALBUMTYPE: "releasetype",
      RELEASECOUNTRY: "releasecountry",
      Script: "script",
      Language: "language",
      Copyright: "copyright",
      LICENSE: "license",
      EncodedBy: "encodedby",
      EncoderSettings: "encodersettings",
      Barcode: "barcode",
      ISRC: "isrc",
      ASIN: "asin",
      musicbrainz_trackid: "musicbrainz_recordingid",
      musicbrainz_releasetrackid: "musicbrainz_trackid",
      MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
      MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
      MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
      MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
      MUSICBRAINZ_WORKID: "musicbrainz_workid",
      MUSICBRAINZ_TRMID: "musicbrainz_trmid",
      MUSICBRAINZ_DISCID: "musicbrainz_discid",
      Acoustid_Id: "acoustid_id",
      ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
      MUSICIP_PUID: "musicip_puid",
      Weblink: "website",
      REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
      REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
      MP3GAIN_MINMAX: "replaygain_track_minmax",
      MP3GAIN_UNDO: "replaygain_undo"
    };
    var APEv2TagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super(["APEv2"], apev2TagMap);
      }
    };
    exports2.APEv2TagMapper = APEv2TagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/MP4TagMapper.js
var require_MP4TagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/MP4TagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MP4TagMapper = exports2.tagType = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap();
    var mp4TagMap = {
      "\xA9nam": "title",
      "\xA9ART": "artist",
      aART: "albumartist",
      /**
       * ToDo: Album artist seems to be stored here while Picard documentation says: aART
       */
      "----:com.apple.iTunes:Band": "albumartist",
      "\xA9alb": "album",
      "\xA9day": "date",
      "\xA9cmt": "comment",
      "\xA9com": "comment",
      trkn: "track",
      disk: "disk",
      "\xA9gen": "genre",
      covr: "picture",
      "\xA9wrt": "composer",
      "\xA9lyr": "lyrics",
      soal: "albumsort",
      sonm: "titlesort",
      soar: "artistsort",
      soaa: "albumartistsort",
      soco: "composersort",
      "----:com.apple.iTunes:LYRICIST": "lyricist",
      "----:com.apple.iTunes:CONDUCTOR": "conductor",
      "----:com.apple.iTunes:REMIXER": "remixer",
      "----:com.apple.iTunes:ENGINEER": "engineer",
      "----:com.apple.iTunes:PRODUCER": "producer",
      "----:com.apple.iTunes:DJMIXER": "djmixer",
      "----:com.apple.iTunes:MIXER": "mixer",
      "----:com.apple.iTunes:LABEL": "label",
      "\xA9grp": "grouping",
      "----:com.apple.iTunes:SUBTITLE": "subtitle",
      "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
      cpil: "compilation",
      tmpo: "bpm",
      "----:com.apple.iTunes:MOOD": "mood",
      "----:com.apple.iTunes:MEDIA": "media",
      "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
      tvsh: "tvShow",
      tvsn: "tvSeason",
      tves: "tvEpisode",
      sosn: "tvShowSort",
      tven: "tvEpisodeId",
      tvnn: "tvNetwork",
      pcst: "podcast",
      purl: "podcasturl",
      "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
      "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
      "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
      "----:com.apple.iTunes:SCRIPT": "script",
      "----:com.apple.iTunes:LANGUAGE": "language",
      cprt: "copyright",
      "\xA9cpy": "copyright",
      "----:com.apple.iTunes:LICENSE": "license",
      "\xA9too": "encodedby",
      pgap: "gapless",
      "----:com.apple.iTunes:BARCODE": "barcode",
      "----:com.apple.iTunes:ISRC": "isrc",
      "----:com.apple.iTunes:ASIN": "asin",
      "----:com.apple.iTunes:NOTES": "comment",
      "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
      "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
      "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
      "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
      "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
      "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
      "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
      "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
      "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
      "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
      "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
      "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
      "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
      "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
      "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
      "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
      "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
      "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
      "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
      "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
      // Additional mappings:
      gnre: "genre",
      "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
      "----:com.apple.iTunes:ARTISTS": "artists",
      "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
      "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
      // '----:com.apple.iTunes:PERFORMER': 'performer'
      desc: "description",
      ldes: "longDescription",
      "\xA9mvn": "movement",
      "\xA9mvi": "movementIndex",
      "\xA9mvc": "movementTotal",
      "\xA9wrk": "work",
      catg: "category",
      egid: "podcastId",
      hdvd: "hdVideo",
      keyw: "keywords",
      shwm: "showMovement",
      stik: "stik"
    };
    exports2.tagType = "iTunes";
    var MP4TagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super([exports2.tagType], mp4TagMap);
      }
    };
    exports2.MP4TagMapper = MP4TagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js
var require_VorbisTagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VorbisTagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    var vorbisTagMap = {
      TITLE: "title",
      ARTIST: "artist",
      ARTISTS: "artists",
      ALBUMARTIST: "albumartist",
      "ALBUM ARTIST": "albumartist",
      ALBUM: "album",
      DATE: "date",
      ORIGINALDATE: "originaldate",
      ORIGINALYEAR: "originalyear",
      COMMENT: "comment",
      TRACKNUMBER: "track",
      DISCNUMBER: "disk",
      GENRE: "genre",
      METADATA_BLOCK_PICTURE: "picture",
      COMPOSER: "composer",
      LYRICS: "lyrics",
      ALBUMSORT: "albumsort",
      TITLESORT: "titlesort",
      WORK: "work",
      ARTISTSORT: "artistsort",
      ALBUMARTISTSORT: "albumartistsort",
      COMPOSERSORT: "composersort",
      LYRICIST: "lyricist",
      WRITER: "writer",
      CONDUCTOR: "conductor",
      // 'PERFORMER=artist(instrument)': 'performer:instrument', // ToDo
      REMIXER: "remixer",
      ARRANGER: "arranger",
      ENGINEER: "engineer",
      PRODUCER: "producer",
      DJMIXER: "djmixer",
      MIXER: "mixer",
      LABEL: "label",
      GROUPING: "grouping",
      SUBTITLE: "subtitle",
      DISCSUBTITLE: "discsubtitle",
      TRACKTOTAL: "totaltracks",
      DISCTOTAL: "totaldiscs",
      COMPILATION: "compilation",
      RATING: "rating",
      BPM: "bpm",
      KEY: "key",
      MOOD: "mood",
      MEDIA: "media",
      CATALOGNUMBER: "catalognumber",
      RELEASESTATUS: "releasestatus",
      RELEASETYPE: "releasetype",
      RELEASECOUNTRY: "releasecountry",
      SCRIPT: "script",
      LANGUAGE: "language",
      COPYRIGHT: "copyright",
      LICENSE: "license",
      ENCODEDBY: "encodedby",
      ENCODERSETTINGS: "encodersettings",
      BARCODE: "barcode",
      ISRC: "isrc",
      ASIN: "asin",
      MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
      MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
      MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
      MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
      MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
      MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
      MUSICBRAINZ_WORKID: "musicbrainz_workid",
      MUSICBRAINZ_TRMID: "musicbrainz_trmid",
      MUSICBRAINZ_DISCID: "musicbrainz_discid",
      ACOUSTID_ID: "acoustid_id",
      ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
      MUSICIP_PUID: "musicip_puid",
      // 'FINGERPRINT=MusicMagic Fingerprint{fingerprint}': 'musicip_fingerprint', // ToDo
      WEBSITE: "website",
      NOTES: "notes",
      TOTALTRACKS: "totaltracks",
      TOTALDISCS: "totaldiscs",
      // Discogs
      DISCOGS_ARTIST_ID: "discogs_artist_id",
      DISCOGS_ARTISTS: "artists",
      DISCOGS_ARTIST_NAME: "artists",
      DISCOGS_ALBUM_ARTISTS: "albumartist",
      DISCOGS_CATALOG: "catalognumber",
      DISCOGS_COUNTRY: "releasecountry",
      DISCOGS_DATE: "originaldate",
      DISCOGS_LABEL: "label",
      DISCOGS_LABEL_ID: "discogs_label_id",
      DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
      DISCOGS_RATING: "discogs_rating",
      DISCOGS_RELEASED: "date",
      DISCOGS_RELEASE_ID: "discogs_release_id",
      DISCOGS_VOTES: "discogs_votes",
      CATALOGID: "catalognumber",
      STYLE: "genre",
      //
      REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
      REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
      REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
      REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
      // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
      REPLAYGAIN_MINMAX: "replaygain_track_minmax",
      REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
      REPLAYGAIN_UNDO: "replaygain_undo"
    };
    var VorbisTagMapper = class _VorbisTagMapper extends GenericTagMapper_1.CommonTagMapper {
      static toRating(email, rating) {
        return {
          source: email ? email.toLowerCase() : email,
          rating: parseFloat(rating) * GenericTagMapper_1.CommonTagMapper.maxRatingScore
        };
      }
      constructor() {
        super(["vorbis"], vorbisTagMap);
      }
      postMap(tag) {
        if (tag.id.indexOf("RATING:") === 0) {
          const keys = tag.id.split(":");
          tag.value = _VorbisTagMapper.toRating(keys[1], tag.value);
          tag.id = keys[0];
        }
      }
    };
    exports2.VorbisTagMapper = VorbisTagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/riff/RiffInfoTagMap.js
var require_RiffInfoTagMap = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/riff/RiffInfoTagMap.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RiffInfoTagMapper = exports2.riffInfoTagMap = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    exports2.riffInfoTagMap = {
      IART: "artist",
      ICRD: "date",
      INAM: "title",
      TITL: "title",
      IPRD: "album",
      ITRK: "track",
      IPRT: "track",
      COMM: "comment",
      ICMT: "comment",
      ICNT: "releasecountry",
      GNRE: "genre",
      IWRI: "writer",
      RATE: "rating",
      YEAR: "year",
      ISFT: "encodedby",
      CODE: "encodedby",
      TURL: "website",
      IGNR: "genre",
      IENG: "engineer",
      ITCH: "technician",
      IMED: "media",
      IRPD: "album"
      // Product, where the file was intended for
    };
    var RiffInfoTagMapper = class extends GenericTagMapper_1.CommonTagMapper {
      constructor() {
        super(["exif"], exports2.riffInfoTagMap);
      }
    };
    exports2.RiffInfoTagMapper = RiffInfoTagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js
var require_MatroskaTagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MatroskaTagMapper = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap();
    var ebmlTagMap = {
      "segment:title": "title",
      "album:ARTIST": "albumartist",
      "album:ARTISTSORT": "albumartistsort",
      "album:TITLE": "album",
      "album:DATE_RECORDED": "originaldate",
      "album:PART_NUMBER": "disk",
      "album:TOTAL_PARTS": "totaltracks",
      "track:ARTIST": "artist",
      "track:ARTISTSORT": "artistsort",
      "track:TITLE": "title",
      "track:PART_NUMBER": "track",
      "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
      "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
      "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
      "track:PUBLISHER": "label",
      "track:GENRE": "genre",
      "track:ENCODER": "encodedby",
      "track:ENCODER_OPTIONS": "encodersettings",
      "edition:TOTAL_PARTS": "totaldiscs",
      picture: "picture"
    };
    var MatroskaTagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super(["matroska"], ebmlTagMap);
      }
    };
    exports2.MatroskaTagMapper = MatroskaTagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/aiff/AiffTagMap.js
var require_AiffTagMap = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/aiff/AiffTagMap.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AiffTagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    var tagMap = {
      NAME: "title",
      AUTH: "artist",
      "(c) ": "copyright",
      ANNO: "comment"
    };
    var AiffTagMapper = class extends GenericTagMapper_1.CommonTagMapper {
      constructor() {
        super(["AIFF"], tagMap);
      }
    };
    exports2.AiffTagMapper = AiffTagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/CombinedTagMapper.js
var require_CombinedTagMapper = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/CombinedTagMapper.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CombinedTagMapper = void 0;
    var ID3v1TagMap_1 = require_ID3v1TagMap();
    var ID3v24TagMapper_1 = require_ID3v24TagMapper();
    var AsfTagMapper_1 = require_AsfTagMapper();
    var ID3v22TagMapper_1 = require_ID3v22TagMapper();
    var APEv2TagMapper_1 = require_APEv2TagMapper();
    var MP4TagMapper_1 = require_MP4TagMapper();
    var VorbisTagMapper_1 = require_VorbisTagMapper();
    var RiffInfoTagMap_1 = require_RiffInfoTagMap();
    var MatroskaTagMapper_1 = require_MatroskaTagMapper();
    var AiffTagMap_1 = require_AiffTagMap();
    var CombinedTagMapper = class {
      constructor() {
        this.tagMappers = {};
        [
          new ID3v1TagMap_1.ID3v1TagMapper(),
          new ID3v22TagMapper_1.ID3v22TagMapper(),
          new ID3v24TagMapper_1.ID3v24TagMapper(),
          new MP4TagMapper_1.MP4TagMapper(),
          new MP4TagMapper_1.MP4TagMapper(),
          new VorbisTagMapper_1.VorbisTagMapper(),
          new APEv2TagMapper_1.APEv2TagMapper(),
          new AsfTagMapper_1.AsfTagMapper(),
          new RiffInfoTagMap_1.RiffInfoTagMapper(),
          new MatroskaTagMapper_1.MatroskaTagMapper(),
          new AiffTagMap_1.AiffTagMapper()
        ].forEach((mapper) => {
          this.registerTagMapper(mapper);
        });
      }
      /**
       * Convert native to generic (common) tags
       * @param tagType Originating tag format
       * @param tag     Native tag to map to a generic tag id
       * @param warnings
       * @return Generic tag result (output of this function)
       */
      mapTag(tagType, tag, warnings) {
        const tagMapper = this.tagMappers[tagType];
        if (tagMapper) {
          return this.tagMappers[tagType].mapGenericTag(tag, warnings);
        }
        throw new Error("No generic tag mapper defined for tag-format: " + tagType);
      }
      registerTagMapper(genericTagMapper) {
        for (const tagType of genericTagMapper.tagTypes) {
          this.tagMappers[tagType] = genericTagMapper;
        }
      }
    };
    exports2.CombinedTagMapper = CombinedTagMapper;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/MetadataCollector.js
var require_MetadataCollector = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/MetadataCollector.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinArtists = exports2.MetadataCollector = void 0;
    var type_1 = require_type();
    var debug_1 = require_browser();
    var GenericTagTypes_1 = require_GenericTagTypes();
    var CombinedTagMapper_1 = require_CombinedTagMapper();
    var GenericTagMapper_1 = require_GenericTagMapper();
    var Util_1 = require_Util();
    var FileType = require_core2();
    var debug = (0, debug_1.default)("music-metadata:collector");
    var TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
    var MetadataCollector = class {
      constructor(opts) {
        this.opts = opts;
        this.format = {
          tagTypes: [],
          trackInfo: []
        };
        this.native = {};
        this.common = {
          track: { no: null, of: null },
          disk: { no: null, of: null },
          movementIndex: {}
        };
        this.quality = {
          warnings: []
        };
        this.commonOrigin = {};
        this.originPriority = {};
        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();
        let priority = 1;
        for (const tagType of TagPriority) {
          this.originPriority[tagType] = priority++;
        }
        this.originPriority.artificial = 500;
        this.originPriority.id3v1 = 600;
      }
      /**
       * @returns {boolean} true if one or more tags have been found
       */
      hasAny() {
        return Object.keys(this.native).length > 0;
      }
      addStreamInfo(streamInfo) {
        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);
        this.format.trackInfo.push(streamInfo);
      }
      setFormat(key, value) {
        debug(`format: ${key} = ${value}`);
        this.format[key] = value;
        if (this.opts.observer) {
          this.opts.observer({ metadata: this, tag: { type: "format", id: key, value } });
        }
      }
      addTag(tagType, tagId, value) {
        debug(`tag ${tagType}.${tagId} = ${value}`);
        if (!this.native[tagType]) {
          this.format.tagTypes.push(tagType);
          this.native[tagType] = [];
        }
        this.native[tagType].push({ id: tagId, value });
        this.toCommon(tagType, tagId, value);
      }
      addWarning(warning) {
        this.quality.warnings.push({ message: warning });
      }
      postMap(tagType, tag) {
        switch (tag.id) {
          case "artist":
            if (this.commonOrigin.artist === this.originPriority[tagType]) {
              return this.postMap("artificial", { id: "artists", value: tag.value });
            }
            if (!this.common.artists) {
              this.setGenericTag("artificial", { id: "artists", value: tag.value });
            }
            break;
          case "artists":
            if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
              if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {
                const artists = (this.common.artists || []).concat([tag.value]);
                const value = joinArtists(artists);
                const artistTag = { id: "artist", value };
                this.setGenericTag("artificial", artistTag);
              }
            }
            break;
          case "picture":
            this.postFixPicture(tag.value).then((picture) => {
              if (picture !== null) {
                tag.value = picture;
                this.setGenericTag(tagType, tag);
              }
            });
            return;
          case "totaltracks":
            this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
            return;
          case "totaldiscs":
            this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
            return;
          case "movementTotal":
            this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
            return;
          case "track":
          case "disk":
          case "movementIndex":
            const of = this.common[tag.id].of;
            this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);
            this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
            return;
          case "bpm":
          case "year":
          case "originalyear":
            tag.value = parseInt(tag.value, 10);
            break;
          case "date":
            const year = parseInt(tag.value.substr(0, 4), 10);
            if (!isNaN(year)) {
              this.common.year = year;
            }
            break;
          case "discogs_label_id":
          case "discogs_release_id":
          case "discogs_master_release_id":
          case "discogs_artist_id":
          case "discogs_votes":
            tag.value = typeof tag.value === "string" ? parseInt(tag.value, 10) : tag.value;
            break;
          case "replaygain_track_gain":
          case "replaygain_track_peak":
          case "replaygain_album_gain":
          case "replaygain_album_peak":
            tag.value = (0, Util_1.toRatio)(tag.value);
            break;
          case "replaygain_track_minmax":
            tag.value = tag.value.split(",").map((v) => parseInt(v, 10));
            break;
          case "replaygain_undo":
            const minMix = tag.value.split(",").map((v) => parseInt(v, 10));
            tag.value = {
              leftChannel: minMix[0],
              rightChannel: minMix[1]
            };
            break;
          case "gapless":
          case "compilation":
          case "podcast":
          case "showMovement":
            tag.value = tag.value === "1" || tag.value === 1;
            break;
          case "isrc":
            if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)
              return;
            break;
          default:
        }
        if (tag.value !== null) {
          this.setGenericTag(tagType, tag);
        }
      }
      /**
       * Convert native tags to common tags
       * @returns {IAudioMetadata} Native + common tags
       */
      toCommonMetadata() {
        return {
          format: this.format,
          native: this.native,
          quality: this.quality,
          common: this.common
        };
      }
      /**
       * Fix some common issues with picture object
       * @param picture Picture
       */
      async postFixPicture(picture) {
        if (picture.data && picture.data.length > 0) {
          if (!picture.format) {
            const fileType2 = await FileType.fromBuffer(picture.data);
            if (fileType2) {
              picture.format = fileType2.mime;
            } else {
              return null;
            }
          }
          picture.format = picture.format.toLocaleLowerCase();
          switch (picture.format) {
            case "image/jpg":
              picture.format = "image/jpeg";
          }
          return picture;
        }
        this.addWarning(`Empty picture tag found`);
        return null;
      }
      /**
       * Convert native tag to common tags
       */
      toCommon(tagType, tagId, value) {
        const tag = { id: tagId, value };
        const genericTag = this.tagMapper.mapTag(tagType, tag, this);
        if (genericTag) {
          this.postMap(tagType, genericTag);
        }
      }
      /**
       * Set generic tag
       */
      setGenericTag(tagType, tag) {
        debug(`common.${tag.id} = ${tag.value}`);
        const prio0 = this.commonOrigin[tag.id] || 1e3;
        const prio1 = this.originPriority[tagType];
        if ((0, GenericTagTypes_1.isSingleton)(tag.id)) {
          if (prio1 <= prio0) {
            this.common[tag.id] = tag.value;
            this.commonOrigin[tag.id] = prio1;
          } else {
            return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);
          }
        } else {
          if (prio1 === prio0) {
            if (!(0, GenericTagTypes_1.isUnique)(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {
              this.common[tag.id].push(tag.value);
            } else {
              debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);
            }
          } else if (prio1 < prio0) {
            this.common[tag.id] = [tag.value];
            this.commonOrigin[tag.id] = prio1;
          } else {
            return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);
          }
        }
        if (this.opts.observer) {
          this.opts.observer({ metadata: this, tag: { type: "common", id: tag.id, value: tag.value } });
        }
      }
    };
    exports2.MetadataCollector = MetadataCollector;
    function joinArtists(artists) {
      if (artists.length > 2) {
        return artists.slice(0, artists.length - 1).join(", ") + " & " + artists[artists.length - 1];
      }
      return artists.join(" & ");
    }
    exports2.joinArtists = joinArtists;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v2Token.js
var require_ID3v2Token = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v2Token.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextEncodingToken = exports2.ExtendedHeader = exports2.ID3v2Header = exports2.UINT32SYNCSAFE = exports2.AttachedPictureType = void 0;
    var Token2 = require_lib2();
    var util = require_Util();
    var AttachedPictureType;
    (function(AttachedPictureType2) {
      AttachedPictureType2[AttachedPictureType2["Other"] = 0] = "Other";
      AttachedPictureType2[AttachedPictureType2["32x32 pixels 'file icon' (PNG only)"] = 1] = "32x32 pixels 'file icon' (PNG only)";
      AttachedPictureType2[AttachedPictureType2["Other file icon"] = 2] = "Other file icon";
      AttachedPictureType2[AttachedPictureType2["Cover (front)"] = 3] = "Cover (front)";
      AttachedPictureType2[AttachedPictureType2["Cover (back)"] = 4] = "Cover (back)";
      AttachedPictureType2[AttachedPictureType2["Leaflet page"] = 5] = "Leaflet page";
      AttachedPictureType2[AttachedPictureType2["Media (e.g. label side of CD)"] = 6] = "Media (e.g. label side of CD)";
      AttachedPictureType2[AttachedPictureType2["Lead artist/lead performer/soloist"] = 7] = "Lead artist/lead performer/soloist";
      AttachedPictureType2[AttachedPictureType2["Artist/performer"] = 8] = "Artist/performer";
      AttachedPictureType2[AttachedPictureType2["Conductor"] = 9] = "Conductor";
      AttachedPictureType2[AttachedPictureType2["Band/Orchestra"] = 10] = "Band/Orchestra";
      AttachedPictureType2[AttachedPictureType2["Composer"] = 11] = "Composer";
      AttachedPictureType2[AttachedPictureType2["Lyricist/text writer"] = 12] = "Lyricist/text writer";
      AttachedPictureType2[AttachedPictureType2["Recording Location"] = 13] = "Recording Location";
      AttachedPictureType2[AttachedPictureType2["During recording"] = 14] = "During recording";
      AttachedPictureType2[AttachedPictureType2["During performance"] = 15] = "During performance";
      AttachedPictureType2[AttachedPictureType2["Movie/video screen capture"] = 16] = "Movie/video screen capture";
      AttachedPictureType2[AttachedPictureType2["A bright coloured fish"] = 17] = "A bright coloured fish";
      AttachedPictureType2[AttachedPictureType2["Illustration"] = 18] = "Illustration";
      AttachedPictureType2[AttachedPictureType2["Band/artist logotype"] = 19] = "Band/artist logotype";
      AttachedPictureType2[AttachedPictureType2["Publisher/Studio logotype"] = 20] = "Publisher/Studio logotype";
    })(AttachedPictureType = exports2.AttachedPictureType || (exports2.AttachedPictureType = {}));
    exports2.UINT32SYNCSAFE = {
      get: (buf, off) => {
        return buf[off + 3] & 127 | buf[off + 2] << 7 | buf[off + 1] << 14 | buf[off] << 21;
      },
      len: 4
    };
    exports2.ID3v2Header = {
      len: 10,
      get: (buf, off) => {
        return {
          // ID3v2/file identifier   "ID3"
          fileIdentifier: new Token2.StringType(3, "ascii").get(buf, off),
          // ID3v2 versionIndex
          version: {
            major: Token2.INT8.get(buf, off + 3),
            revision: Token2.INT8.get(buf, off + 4)
          },
          // ID3v2 flags
          flags: {
            // Unsynchronisation
            unsynchronisation: util.getBit(buf, off + 5, 7),
            // Extended header
            isExtendedHeader: util.getBit(buf, off + 5, 6),
            // Experimental indicator
            expIndicator: util.getBit(buf, off + 5, 5),
            footer: util.getBit(buf, off + 5, 4)
          },
          size: exports2.UINT32SYNCSAFE.get(buf, off + 6)
        };
      }
    };
    exports2.ExtendedHeader = {
      len: 10,
      get: (buf, off) => {
        return {
          // Extended header size
          size: Token2.UINT32_BE.get(buf, off),
          // Extended Flags
          extendedFlags: Token2.UINT16_BE.get(buf, off + 4),
          // Size of padding
          sizeOfPadding: Token2.UINT32_BE.get(buf, off + 6),
          // CRC data present
          crcDataPresent: util.getBit(buf, off + 4, 31)
        };
      }
    };
    exports2.TextEncodingToken = {
      len: 1,
      get: (uint8Array, off) => {
        switch (uint8Array[off]) {
          case 0:
            return { encoding: "latin1" };
          case 1:
            return { encoding: "utf16le", bom: true };
          case 2:
            return { encoding: "utf16le", bom: false };
          case 3:
            return { encoding: "utf8", bom: false };
          default:
            return { encoding: "utf8", bom: false };
        }
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/BasicParser.js
var require_BasicParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/BasicParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicParser = void 0;
    var BasicParser = class {
      /**
       * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
       * @param {INativeMetadataCollector} metadata Output
       * @param {ITokenizer} tokenizer Input
       * @param {IOptions} options Parsing options
       */
      init(metadata, tokenizer, options) {
        this.metadata = metadata;
        this.tokenizer = tokenizer;
        this.options = options;
        return this;
      }
    };
    exports2.BasicParser = BasicParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/FourCC.js
var require_FourCC = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/FourCC.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FourCcToken = void 0;
    var util = require_Util();
    var validFourCC = /^[\x21-\x7e][\x20-\x7e\x00()]{3}/;
    exports2.FourCcToken = {
      len: 4,
      get: (buf, off) => {
        const id = buf.toString("binary", off, off + exports2.FourCcToken.len);
        if (!id.match(validFourCC)) {
          throw new Error(`FourCC contains invalid characters: ${util.a2hex(id)} "${id}"`);
        }
        return id;
      },
      put: (buffer, offset, id) => {
        const str = Buffer.from(id, "binary");
        if (str.length !== 4)
          throw new Error("Invalid length");
        return str.copy(buffer, offset);
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/apev2/APEv2Token.js
var require_APEv2Token = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/apev2/APEv2Token.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBitSet = exports2.parseTagFlags = exports2.TagField = exports2.TagItemHeader = exports2.TagFooter = exports2.Header = exports2.DescriptorParser = exports2.DataType = void 0;
    var Token2 = require_lib2();
    var FourCC_1 = require_FourCC();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["text_utf8"] = 0] = "text_utf8";
      DataType2[DataType2["binary"] = 1] = "binary";
      DataType2[DataType2["external_info"] = 2] = "external_info";
      DataType2[DataType2["reserved"] = 3] = "reserved";
    })(DataType = exports2.DataType || (exports2.DataType = {}));
    exports2.DescriptorParser = {
      len: 52,
      get: (buf, off) => {
        return {
          // should equal 'MAC '
          ID: FourCC_1.FourCcToken.get(buf, off),
          // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
          version: Token2.UINT32_LE.get(buf, off + 4) / 1e3,
          // the number of descriptor bytes (allows later expansion of this header)
          descriptorBytes: Token2.UINT32_LE.get(buf, off + 8),
          // the number of header APE_HEADER bytes
          headerBytes: Token2.UINT32_LE.get(buf, off + 12),
          // the number of header APE_HEADER bytes
          seekTableBytes: Token2.UINT32_LE.get(buf, off + 16),
          // the number of header data bytes (from original file)
          headerDataBytes: Token2.UINT32_LE.get(buf, off + 20),
          // the number of bytes of APE frame data
          apeFrameDataBytes: Token2.UINT32_LE.get(buf, off + 24),
          // the high order number of APE frame data bytes
          apeFrameDataBytesHigh: Token2.UINT32_LE.get(buf, off + 28),
          // the terminating data of the file (not including tag data)
          terminatingDataBytes: Token2.UINT32_LE.get(buf, off + 32),
          // the MD5 hash of the file (see notes for usage... it's a little tricky)
          fileMD5: new Token2.Uint8ArrayType(16).get(buf, off + 36)
        };
      }
    };
    exports2.Header = {
      len: 24,
      get: (buf, off) => {
        return {
          // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
          compressionLevel: Token2.UINT16_LE.get(buf, off),
          // any format flags (for future use)
          formatFlags: Token2.UINT16_LE.get(buf, off + 2),
          // the number of audio blocks in one frame
          blocksPerFrame: Token2.UINT32_LE.get(buf, off + 4),
          // the number of audio blocks in the final frame
          finalFrameBlocks: Token2.UINT32_LE.get(buf, off + 8),
          // the total number of frames
          totalFrames: Token2.UINT32_LE.get(buf, off + 12),
          // the bits per sample (typically 16)
          bitsPerSample: Token2.UINT16_LE.get(buf, off + 16),
          // the number of channels (1 or 2)
          channel: Token2.UINT16_LE.get(buf, off + 18),
          // the sample rate (typically 44100)
          sampleRate: Token2.UINT32_LE.get(buf, off + 20)
        };
      }
    };
    exports2.TagFooter = {
      len: 32,
      get: (buf, off) => {
        return {
          // should equal 'APETAGEX'
          ID: new Token2.StringType(8, "ascii").get(buf, off),
          // equals CURRENT_APE_TAG_VERSION
          version: Token2.UINT32_LE.get(buf, off + 8),
          // the complete size of the tag, including this footer (excludes header)
          size: Token2.UINT32_LE.get(buf, off + 12),
          // the number of fields in the tag
          fields: Token2.UINT32_LE.get(buf, off + 16),
          // reserved for later use (must be zero),
          flags: parseTagFlags(Token2.UINT32_LE.get(buf, off + 20))
        };
      }
    };
    exports2.TagItemHeader = {
      len: 8,
      get: (buf, off) => {
        return {
          // Length of assigned value in bytes
          size: Token2.UINT32_LE.get(buf, off),
          // reserved for later use (must be zero),
          flags: parseTagFlags(Token2.UINT32_LE.get(buf, off + 4))
        };
      }
    };
    var TagField = (footer) => {
      return new Token2.Uint8ArrayType(footer.size - exports2.TagFooter.len);
    };
    exports2.TagField = TagField;
    function parseTagFlags(flags2) {
      return {
        containsHeader: isBitSet(flags2, 31),
        containsFooter: isBitSet(flags2, 30),
        isHeader: isBitSet(flags2, 31),
        readOnly: isBitSet(flags2, 0),
        dataType: (flags2 & 6) >> 1
      };
    }
    exports2.parseTagFlags = parseTagFlags;
    function isBitSet(num, bit) {
      return (num & 1 << bit) !== 0;
    }
    exports2.isBitSet = isBitSet;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/apev2/APEv2Parser.js
var require_APEv2Parser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/apev2/APEv2Parser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APEv2Parser = void 0;
    var debug_1 = require_browser();
    var strtok32 = require_core();
    var token_types_1 = require_lib2();
    var util = require_Util();
    var BasicParser_1 = require_BasicParser();
    var APEv2Token_1 = require_APEv2Token();
    var debug = (0, debug_1.default)("music-metadata:parser:APEv2");
    var tagFormat = "APEv2";
    var preamble = "APETAGEX";
    var APEv2Parser = class _APEv2Parser extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments);
        this.ape = {};
      }
      static tryParseApeHeader(metadata, tokenizer, options) {
        const apeParser = new _APEv2Parser();
        apeParser.init(metadata, tokenizer, options);
        return apeParser.tryParseApeHeader();
      }
      /**
       * Calculate the media file duration
       * @param ah ApeHeader
       * @return {number} duration in seconds
       */
      static calculateDuration(ah) {
        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
        duration += ah.finalFrameBlocks;
        return duration / ah.sampleRate;
      }
      /**
       * Calculates the APEv1 / APEv2 first field offset
       * @param reader
       * @param offset
       */
      static async findApeFooterOffset(reader, offset) {
        const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);
        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);
        const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);
        if (tagFooter.ID === "APETAGEX") {
          debug(`APE footer header at offset=${offset}`);
          return { footer: tagFooter, offset: offset - tagFooter.size };
        }
      }
      static parseTagFooter(metadata, buffer, options) {
        const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);
        if (footer.ID !== preamble)
          throw new Error("Unexpected APEv2 Footer ID preamble value.");
        strtok32.fromBuffer(buffer);
        const apeParser = new _APEv2Parser();
        apeParser.init(metadata, strtok32.fromBuffer(buffer), options);
        return apeParser.parseTags(footer);
      }
      /**
       * Parse APEv1 / APEv2 header if header signature found
       */
      async tryParseApeHeader() {
        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {
          debug(`No APEv2 header found, end-of-file reached`);
          return;
        }
        const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);
        if (footer.ID === preamble) {
          await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);
          return this.parseTags(footer);
        } else {
          debug(`APEv2 header not found at offset=${this.tokenizer.position}`);
          if (this.tokenizer.fileInfo.size) {
            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
            const buffer = Buffer.alloc(remaining);
            await this.tokenizer.readBuffer(buffer);
            return _APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);
          }
        }
      }
      async parse() {
        const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);
        if (descriptor.ID !== "MAC ")
          throw new Error("Unexpected descriptor ID");
        this.ape.descriptor = descriptor;
        const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;
        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());
        await this.tokenizer.ignore(header.forwardBytes);
        return this.tryParseApeHeader();
      }
      async parseTags(footer) {
        const keyBuffer = Buffer.alloc(256);
        let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;
        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);
        for (let i = 0; i < footer.fields; i++) {
          if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {
            this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);
            break;
          }
          const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);
          bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;
          await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });
          let zero = util.findZero(keyBuffer, 0, keyBuffer.length);
          const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, "ascii"));
          await this.tokenizer.ignore(1);
          bytesRemaining -= key.length + 1;
          switch (tagItemHeader.flags.dataType) {
            case APEv2Token_1.DataType.text_utf8: {
              const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, "utf8"));
              const values = value.split(/\x00/g);
              for (const val of values) {
                this.metadata.addTag(tagFormat, key, val);
              }
              break;
            }
            case APEv2Token_1.DataType.binary:
              if (this.options.skipCovers) {
                await this.tokenizer.ignore(tagItemHeader.size);
              } else {
                const picData = Buffer.alloc(tagItemHeader.size);
                await this.tokenizer.readBuffer(picData);
                zero = util.findZero(picData, 0, picData.length);
                const description = picData.toString("utf8", 0, zero);
                const data = Buffer.from(picData.slice(zero + 1));
                this.metadata.addTag(tagFormat, key, {
                  description,
                  data
                });
              }
              break;
            case APEv2Token_1.DataType.external_info:
              debug(`Ignore external info ${key}`);
              await this.tokenizer.ignore(tagItemHeader.size);
              break;
            case APEv2Token_1.DataType.reserved:
              debug(`Ignore external info ${key}`);
              this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${key}"`);
              await this.tokenizer.ignore(tagItemHeader.size);
              break;
          }
        }
      }
      async parseDescriptorExpansion(lenExp) {
        await this.tokenizer.ignore(lenExp);
        return this.parseHeader();
      }
      async parseHeader() {
        const header = await this.tokenizer.readToken(APEv2Token_1.Header);
        this.metadata.setFormat("lossless", true);
        this.metadata.setFormat("container", "Monkey's Audio");
        this.metadata.setFormat("bitsPerSample", header.bitsPerSample);
        this.metadata.setFormat("sampleRate", header.sampleRate);
        this.metadata.setFormat("numberOfChannels", header.channel);
        this.metadata.setFormat("duration", _APEv2Parser.calculateDuration(header));
        return {
          forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
        };
      }
    };
    exports2.APEv2Parser = APEv2Parser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v1/ID3v1Parser.js
var require_ID3v1Parser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v1/ID3v1Parser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasID3v1Header = exports2.ID3v1Parser = exports2.Genres = void 0;
    var debug_1 = require_browser();
    var token_types_1 = require_lib2();
    var util = require_Util();
    var BasicParser_1 = require_BasicParser();
    var APEv2Parser_1 = require_APEv2Parser();
    var debug = (0, debug_1.default)("music-metadata:parser:ID3v1");
    exports2.Genres = [
      "Blues",
      "Classic Rock",
      "Country",
      "Dance",
      "Disco",
      "Funk",
      "Grunge",
      "Hip-Hop",
      "Jazz",
      "Metal",
      "New Age",
      "Oldies",
      "Other",
      "Pop",
      "R&B",
      "Rap",
      "Reggae",
      "Rock",
      "Techno",
      "Industrial",
      "Alternative",
      "Ska",
      "Death Metal",
      "Pranks",
      "Soundtrack",
      "Euro-Techno",
      "Ambient",
      "Trip-Hop",
      "Vocal",
      "Jazz+Funk",
      "Fusion",
      "Trance",
      "Classical",
      "Instrumental",
      "Acid",
      "House",
      "Game",
      "Sound Clip",
      "Gospel",
      "Noise",
      "Alt. Rock",
      "Bass",
      "Soul",
      "Punk",
      "Space",
      "Meditative",
      "Instrumental Pop",
      "Instrumental Rock",
      "Ethnic",
      "Gothic",
      "Darkwave",
      "Techno-Industrial",
      "Electronic",
      "Pop-Folk",
      "Eurodance",
      "Dream",
      "Southern Rock",
      "Comedy",
      "Cult",
      "Gangsta Rap",
      "Top 40",
      "Christian Rap",
      "Pop/Funk",
      "Jungle",
      "Native American",
      "Cabaret",
      "New Wave",
      "Psychedelic",
      "Rave",
      "Showtunes",
      "Trailer",
      "Lo-Fi",
      "Tribal",
      "Acid Punk",
      "Acid Jazz",
      "Polka",
      "Retro",
      "Musical",
      "Rock & Roll",
      "Hard Rock",
      "Folk",
      "Folk/Rock",
      "National Folk",
      "Swing",
      "Fast-Fusion",
      "Bebob",
      "Latin",
      "Revival",
      "Celtic",
      "Bluegrass",
      "Avantgarde",
      "Gothic Rock",
      "Progressive Rock",
      "Psychedelic Rock",
      "Symphonic Rock",
      "Slow Rock",
      "Big Band",
      "Chorus",
      "Easy Listening",
      "Acoustic",
      "Humour",
      "Speech",
      "Chanson",
      "Opera",
      "Chamber Music",
      "Sonata",
      "Symphony",
      "Booty Bass",
      "Primus",
      "Porn Groove",
      "Satire",
      "Slow Jam",
      "Club",
      "Tango",
      "Samba",
      "Folklore",
      "Ballad",
      "Power Ballad",
      "Rhythmic Soul",
      "Freestyle",
      "Duet",
      "Punk Rock",
      "Drum Solo",
      "A Cappella",
      "Euro-House",
      "Dance Hall",
      "Goa",
      "Drum & Bass",
      "Club-House",
      "Hardcore",
      "Terror",
      "Indie",
      "BritPop",
      "Negerpunk",
      "Polsk Punk",
      "Beat",
      "Christian Gangsta Rap",
      "Heavy Metal",
      "Black Metal",
      "Crossover",
      "Contemporary Christian",
      "Christian Rock",
      "Merengue",
      "Salsa",
      "Thrash Metal",
      "Anime",
      "JPop",
      "Synthpop",
      "Abstract",
      "Art Rock",
      "Baroque",
      "Bhangra",
      "Big Beat",
      "Breakbeat",
      "Chillout",
      "Downtempo",
      "Dub",
      "EBM",
      "Eclectic",
      "Electro",
      "Electroclash",
      "Emo",
      "Experimental",
      "Garage",
      "Global",
      "IDM",
      "Illbient",
      "Industro-Goth",
      "Jam Band",
      "Krautrock",
      "Leftfield",
      "Lounge",
      "Math Rock",
      "New Romantic",
      "Nu-Breakz",
      "Post-Punk",
      "Post-Rock",
      "Psytrance",
      "Shoegaze",
      "Space Rock",
      "Trop Rock",
      "World Music",
      "Neoclassical",
      "Audiobook",
      "Audio Theatre",
      "Neue Deutsche Welle",
      "Podcast",
      "Indie Rock",
      "G-Funk",
      "Dubstep",
      "Garage Rock",
      "Psybient"
    ];
    var Iid3v1Token = {
      len: 128,
      /**
       * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
       * @param off Offset in buffer in bytes
       * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
       */
      get: (buf, off) => {
        const header = new Id3v1StringType(3).get(buf, off);
        return header === "TAG" ? {
          header,
          title: new Id3v1StringType(30).get(buf, off + 3),
          artist: new Id3v1StringType(30).get(buf, off + 33),
          album: new Id3v1StringType(30).get(buf, off + 63),
          year: new Id3v1StringType(4).get(buf, off + 93),
          comment: new Id3v1StringType(28).get(buf, off + 97),
          // ID3v1.1 separator for track
          zeroByte: token_types_1.UINT8.get(buf, off + 127),
          // track: ID3v1.1 field added by Michael Mutschler
          track: token_types_1.UINT8.get(buf, off + 126),
          genre: token_types_1.UINT8.get(buf, off + 127)
        } : null;
      }
    };
    var Id3v1StringType = class extends token_types_1.StringType {
      constructor(len) {
        super(len, "binary");
      }
      get(buf, off) {
        let value = super.get(buf, off);
        value = util.trimRightNull(value);
        value = value.trim();
        return value.length > 0 ? value : void 0;
      }
    };
    var ID3v1Parser = class _ID3v1Parser extends BasicParser_1.BasicParser {
      static getGenre(genreIndex) {
        if (genreIndex < exports2.Genres.length) {
          return exports2.Genres[genreIndex];
        }
        return void 0;
      }
      async parse() {
        if (!this.tokenizer.fileInfo.size) {
          debug("Skip checking for ID3v1 because the file-size is unknown");
          return;
        }
        if (this.options.apeHeader) {
          this.tokenizer.ignore(this.options.apeHeader.offset - this.tokenizer.position);
          const apeParser = new APEv2Parser_1.APEv2Parser();
          apeParser.init(this.metadata, this.tokenizer, this.options);
          await apeParser.parseTags(this.options.apeHeader.footer);
        }
        const offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;
        if (this.tokenizer.position > offset) {
          debug("Already consumed the last 128 bytes");
          return;
        }
        const header = await this.tokenizer.readToken(Iid3v1Token, offset);
        if (header) {
          debug("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
          for (const id of ["title", "artist", "album", "comment", "track", "year"]) {
            if (header[id] && header[id] !== "")
              this.addTag(id, header[id]);
          }
          const genre = _ID3v1Parser.getGenre(header.genre);
          if (genre)
            this.addTag("genre", genre);
        } else {
          debug("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
        }
      }
      addTag(id, value) {
        this.metadata.addTag("ID3v1", id, value);
      }
    };
    exports2.ID3v1Parser = ID3v1Parser;
    async function hasID3v1Header(reader) {
      if (reader.fileSize >= 128) {
        const tag = Buffer.alloc(3);
        await reader.randomRead(tag, 0, tag.length, reader.fileSize - 128);
        return tag.toString("binary") === "TAG";
      }
      return false;
    }
    exports2.hasID3v1Header = hasID3v1Header;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/FrameParser.js
var require_FrameParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/FrameParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FrameParser = exports2.parseGenre = void 0;
    var debug_1 = require_browser();
    var Token2 = require_lib2();
    var util = require_Util();
    var ID3v2Token_1 = require_ID3v2Token();
    var ID3v1Parser_1 = require_ID3v1Parser();
    var debug = (0, debug_1.default)("music-metadata:id3v2:frame-parser");
    var defaultEnc = "latin1";
    function parseGenre(origVal) {
      const genres = [];
      let code;
      let word = "";
      for (const c of origVal) {
        if (typeof code === "string") {
          if (c === "(" && code === "") {
            word += "(";
            code = void 0;
          } else if (c === ")") {
            if (word !== "") {
              genres.push(word);
              word = "";
            }
            const genre = parseGenreCode(code);
            if (genre) {
              genres.push(genre);
            }
            code = void 0;
          } else
            code += c;
        } else if (c === "(") {
          code = "";
        } else {
          word += c;
        }
      }
      if (word) {
        if (genres.length === 0 && word.match(/^\d*$/)) {
          word = ID3v1Parser_1.Genres[word];
        }
        genres.push(word);
      }
      return genres;
    }
    exports2.parseGenre = parseGenre;
    function parseGenreCode(code) {
      if (code === "RX")
        return "Remix";
      if (code === "CR")
        return "Cover";
      if (code.match(/^\d*$/)) {
        return ID3v1Parser_1.Genres[code];
      }
    }
    var FrameParser = class _FrameParser {
      /**
       * Create id3v2 frame parser
       * @param major - Major version, e.g. (4) for  id3v2.4
       * @param warningCollector - Used to collect decode issue
       */
      constructor(major, warningCollector) {
        this.major = major;
        this.warningCollector = warningCollector;
      }
      readData(uint8Array, type, includeCovers) {
        if (uint8Array.length === 0) {
          this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);
          return;
        }
        const { encoding, bom } = ID3v2Token_1.TextEncodingToken.get(uint8Array, 0);
        const length = uint8Array.length;
        let offset = 0;
        let output = [];
        const nullTerminatorLength = _FrameParser.getNullTerminatorLength(encoding);
        let fzero;
        const out = {};
        debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);
        switch (type !== "TXXX" && type[0] === "T" ? "T*" : type) {
          case "T*":
          case "IPLS":
          case "MVIN":
          case "MVNM":
          case "PCS":
          case "PCST":
            let text;
            try {
              text = util.decodeString(uint8Array.slice(1), encoding).replace(/\x00+$/, "");
            } catch (error) {
              this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);
            }
            switch (type) {
              case "TMCL":
              case "TIPL":
              case "IPLS":
                output = this.splitValue(type, text);
                output = _FrameParser.functionList(output);
                break;
              case "TRK":
              case "TRCK":
              case "TPOS":
                output = text;
                break;
              case "TCOM":
              case "TEXT":
              case "TOLY":
              case "TOPE":
              case "TPE1":
              case "TSRC":
                output = this.splitValue(type, text);
                break;
              case "TCO":
              case "TCON":
                output = this.splitValue(type, text).map((v) => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);
                break;
              case "PCS":
              case "PCST":
                output = this.major >= 4 ? this.splitValue(type, text) : [text];
                output = Array.isArray(output) && output[0] === "" ? 1 : 0;
                break;
              default:
                output = this.major >= 4 ? this.splitValue(type, text) : [text];
            }
            break;
          case "TXXX":
            output = _FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);
            output = {
              description: output.id,
              text: this.splitValue(type, util.decodeString(output.data, encoding).replace(/\x00+$/, ""))
            };
            break;
          case "PIC":
          case "APIC":
            if (includeCovers) {
              const pic = {};
              offset += 1;
              switch (this.major) {
                case 2:
                  pic.format = util.decodeString(uint8Array.slice(offset, offset + 3), "latin1");
                  offset += 3;
                  break;
                case 3:
                case 4:
                  fzero = util.findZero(uint8Array, offset, length, defaultEnc);
                  pic.format = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
                  offset = fzero + 1;
                  break;
                default:
                  throw new Error("Warning: unexpected major versionIndex: " + this.major);
              }
              pic.format = _FrameParser.fixPictureMimeType(pic.format);
              pic.type = ID3v2Token_1.AttachedPictureType[uint8Array[offset]];
              offset += 1;
              fzero = util.findZero(uint8Array, offset, length, encoding);
              pic.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);
              offset = fzero + nullTerminatorLength;
              pic.data = Buffer.from(uint8Array.slice(offset, length));
              output = pic;
            }
            break;
          case "CNT":
          case "PCNT":
            output = Token2.UINT32_BE.get(uint8Array, 0);
            break;
          case "SYLT":
            offset += 7;
            output = [];
            while (offset < length) {
              const txt = uint8Array.slice(offset, offset = util.findZero(uint8Array, offset, length, encoding));
              offset += 5;
              output.push(util.decodeString(txt, encoding));
            }
            break;
          case "ULT":
          case "USLT":
          case "COM":
          case "COMM":
            offset += 1;
            out.language = util.decodeString(uint8Array.slice(offset, offset + 3), defaultEnc);
            offset += 3;
            fzero = util.findZero(uint8Array, offset, length, encoding);
            out.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);
            offset = fzero + nullTerminatorLength;
            out.text = util.decodeString(uint8Array.slice(offset, length), encoding).replace(/\x00+$/, "");
            output = [out];
            break;
          case "UFID":
            output = _FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
            output = { owner_identifier: output.id, identifier: output.data };
            break;
          case "PRIV":
            output = _FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
            output = { owner_identifier: output.id, data: output.data };
            break;
          case "POPM":
            fzero = util.findZero(uint8Array, offset, length, defaultEnc);
            const email = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            offset = fzero + 1;
            const dataLen = length - offset;
            output = {
              email,
              rating: Token2.UINT8.get(uint8Array, offset),
              counter: dataLen >= 5 ? Token2.UINT32_BE.get(uint8Array, offset + 1) : void 0
            };
            break;
          case "GEOB": {
            fzero = util.findZero(uint8Array, offset + 1, length, encoding);
            const mimeType2 = util.decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);
            offset = fzero + 1;
            fzero = util.findZero(uint8Array, offset, length - offset, encoding);
            const filename = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            offset = fzero + 1;
            fzero = util.findZero(uint8Array, offset, length - offset, encoding);
            const description = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            output = {
              type: mimeType2,
              filename,
              description,
              data: uint8Array.slice(offset + 1, length)
            };
            break;
          }
          case "WCOM":
          case "WCOP":
          case "WOAF":
          case "WOAR":
          case "WOAS":
          case "WORS":
          case "WPAY":
          case "WPUB":
            output = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            break;
          case "WXXX": {
            fzero = util.findZero(uint8Array, offset + 1, length, encoding);
            const description = util.decodeString(uint8Array.slice(offset + 1, fzero), encoding);
            offset = fzero + (encoding === "utf16le" ? 2 : 1);
            output = { description, url: util.decodeString(uint8Array.slice(offset, length), defaultEnc) };
            break;
          }
          case "WFD":
          case "WFED":
            output = util.decodeString(uint8Array.slice(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);
            break;
          case "MCDI": {
            output = uint8Array.slice(0, length);
            break;
          }
          default:
            debug("Warning: unsupported id3v2-tag-type: " + type);
            break;
        }
        return output;
      }
      static fixPictureMimeType(pictureType) {
        pictureType = pictureType.toLocaleLowerCase();
        switch (pictureType) {
          case "jpg":
            return "image/jpeg";
          case "png":
            return "image/png";
        }
        return pictureType;
      }
      /**
       * Converts TMCL (Musician credits list) or TIPL (Involved people list)
       * @param entries
       */
      static functionList(entries) {
        const res = {};
        for (let i = 0; i + 1 < entries.length; i += 2) {
          const names = entries[i + 1].split(",");
          res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;
        }
        return res;
      }
      /**
       * id3v2.4 defines that multiple T* values are separated by 0x00
       * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
       * @param tag - Tag name
       * @param text - Concatenated tag value
       * @returns Split tag value
       */
      splitValue(tag, text) {
        let values;
        if (this.major < 4) {
          values = text.split(/\x00/g);
          if (values.length > 1) {
            this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);
          } else {
            values = text.split(/\//g);
          }
        } else {
          values = text.split(/\x00/g);
        }
        return _FrameParser.trimArray(values);
      }
      static trimArray(values) {
        return values.map((value) => value.replace(/\x00+$/, "").trim());
      }
      static readIdentifierAndData(uint8Array, offset, length, encoding) {
        const fzero = util.findZero(uint8Array, offset, length, encoding);
        const id = util.decodeString(uint8Array.slice(offset, fzero), encoding);
        offset = fzero + _FrameParser.getNullTerminatorLength(encoding);
        return { id, data: uint8Array.slice(offset, length) };
      }
      static getNullTerminatorLength(enc) {
        return enc === "utf16le" ? 2 : 1;
      }
    };
    exports2.FrameParser = FrameParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v2Parser.js
var require_ID3v2Parser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/ID3v2Parser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ID3v2Parser = void 0;
    var Token2 = require_lib2();
    var util = require_Util();
    var FrameParser_1 = require_FrameParser();
    var ID3v2Token_1 = require_ID3v2Token();
    var ID3v2Parser = class _ID3v2Parser {
      static removeUnsyncBytes(buffer) {
        let readI = 0;
        let writeI = 0;
        while (readI < buffer.length - 1) {
          if (readI !== writeI) {
            buffer[writeI] = buffer[readI];
          }
          readI += buffer[readI] === 255 && buffer[readI + 1] === 0 ? 2 : 1;
          writeI++;
        }
        if (readI < buffer.length) {
          buffer[writeI++] = buffer[readI];
        }
        return buffer.slice(0, writeI);
      }
      static getFrameHeaderLength(majorVer) {
        switch (majorVer) {
          case 2:
            return 6;
          case 3:
          case 4:
            return 10;
          default:
            throw new Error("header versionIndex is incorrect");
        }
      }
      static readFrameFlags(b) {
        return {
          status: {
            tag_alter_preservation: util.getBit(b, 0, 6),
            file_alter_preservation: util.getBit(b, 0, 5),
            read_only: util.getBit(b, 0, 4)
          },
          format: {
            grouping_identity: util.getBit(b, 1, 7),
            compression: util.getBit(b, 1, 3),
            encryption: util.getBit(b, 1, 2),
            unsynchronisation: util.getBit(b, 1, 1),
            data_length_indicator: util.getBit(b, 1, 0)
          }
        };
      }
      static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
        const frameParser = new FrameParser_1.FrameParser(majorVer, warningCollector);
        switch (majorVer) {
          case 2:
            return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
          case 3:
          case 4:
            if (frameHeader.flags.format.unsynchronisation) {
              uint8Array = _ID3v2Parser.removeUnsyncBytes(uint8Array);
            }
            if (frameHeader.flags.format.data_length_indicator) {
              uint8Array = uint8Array.slice(4, uint8Array.length);
            }
            return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
          default:
            throw new Error("Unexpected majorVer: " + majorVer);
        }
      }
      /**
       * Create a combined tag key, of tag & description
       * @param tag e.g.: COM
       * @param description e.g. iTunPGAP
       * @returns string e.g. COM:iTunPGAP
       */
      static makeDescriptionTagName(tag, description) {
        return tag + (description ? ":" + description : "");
      }
      async parse(metadata, tokenizer, options) {
        this.tokenizer = tokenizer;
        this.metadata = metadata;
        this.options = options;
        const id3Header = await this.tokenizer.readToken(ID3v2Token_1.ID3v2Header);
        if (id3Header.fileIdentifier !== "ID3") {
          throw new Error("expected ID3-header file-identifier 'ID3' was not found");
        }
        this.id3Header = id3Header;
        this.headerType = "ID3v2." + id3Header.version.major;
        return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);
      }
      async parseExtendedHeader() {
        const extendedHeader = await this.tokenizer.readToken(ID3v2Token_1.ExtendedHeader);
        const dataRemaining = extendedHeader.size - ID3v2Token_1.ExtendedHeader.len;
        return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);
      }
      async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
        await this.tokenizer.ignore(dataRemaining);
        return this.parseId3Data(this.id3Header.size - extendedHeaderSize);
      }
      async parseId3Data(dataLen) {
        const uint8Array = await this.tokenizer.readToken(new Token2.Uint8ArrayType(dataLen));
        for (const tag of this.parseMetadata(uint8Array)) {
          if (tag.id === "TXXX") {
            if (tag.value) {
              for (const text of tag.value.text) {
                this.addTag(_ID3v2Parser.makeDescriptionTagName(tag.id, tag.value.description), text);
              }
            }
          } else if (tag.id === "COM") {
            for (const value of tag.value) {
              this.addTag(_ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value.text);
            }
          } else if (tag.id === "COMM") {
            for (const value of tag.value) {
              this.addTag(_ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value);
            }
          } else if (Array.isArray(tag.value)) {
            for (const value of tag.value) {
              this.addTag(tag.id, value);
            }
          } else {
            this.addTag(tag.id, tag.value);
          }
        }
      }
      addTag(id, value) {
        this.metadata.addTag(this.headerType, id, value);
      }
      parseMetadata(data) {
        let offset = 0;
        const tags = [];
        while (true) {
          if (offset === data.length)
            break;
          const frameHeaderLength = _ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
          if (offset + frameHeaderLength > data.length) {
            this.metadata.addWarning("Illegal ID3v2 tag length");
            break;
          }
          const frameHeaderBytes = data.slice(offset, offset += frameHeaderLength);
          const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
          const frameDataBytes = data.slice(offset, offset += frameHeader.length);
          const values = _ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
          if (values) {
            tags.push({ id: frameHeader.id, value: values });
          }
        }
        return tags;
      }
      readFrameHeader(uint8Array, majorVer) {
        let header;
        switch (majorVer) {
          case 2:
            header = {
              id: Buffer.from(uint8Array.slice(0, 3)).toString("ascii"),
              length: Token2.UINT24_BE.get(uint8Array, 3)
            };
            if (!header.id.match(/[A-Z0-9]{3}/g)) {
              this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
            }
            break;
          case 3:
          case 4:
            header = {
              id: Buffer.from(uint8Array.slice(0, 4)).toString("ascii"),
              length: (majorVer === 4 ? ID3v2Token_1.UINT32SYNCSAFE : Token2.UINT32_BE).get(uint8Array, 4),
              flags: _ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))
            };
            if (!header.id.match(/[A-Z0-9]{4}/g)) {
              this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
            }
            break;
          default:
            throw new Error("Unexpected majorVer: " + majorVer);
        }
        return header;
      }
    };
    exports2.ID3v2Parser = ID3v2Parser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/aiff/AiffToken.js
var require_AiffToken = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/aiff/AiffToken.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Common = void 0;
    var Token2 = require_lib2();
    var FourCC_1 = require_FourCC();
    var Common = class {
      constructor(header, isAifc) {
        this.isAifc = isAifc;
        const minimumChunkSize = isAifc ? 22 : 18;
        if (header.chunkSize < minimumChunkSize)
          throw new Error(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);
        this.len = header.chunkSize;
      }
      get(buf, off) {
        const shift = buf.readUInt16BE(off + 8) - 16398;
        const baseSampleRate = buf.readUInt16BE(off + 8 + 2);
        const res = {
          numChannels: buf.readUInt16BE(off),
          numSampleFrames: buf.readUInt32BE(off + 2),
          sampleSize: buf.readUInt16BE(off + 6),
          sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
        };
        if (this.isAifc) {
          res.compressionType = FourCC_1.FourCcToken.get(buf, off + 18);
          if (this.len > 22) {
            const strLen = buf.readInt8(off + 22);
            if (strLen > 0) {
              const padding = (strLen + 1) % 2;
              if (23 + strLen + padding === this.len) {
                res.compressionName = new Token2.StringType(strLen, "binary").get(buf, off + 23);
              } else {
                throw new Error("Illegal pstring length");
              }
            } else {
              res.compressionName = void 0;
            }
          }
        } else {
          res.compressionName = "PCM";
        }
        return res;
      }
    };
    exports2.Common = Common;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/iff/index.js
var require_iff = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/iff/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Header = void 0;
    var Token2 = require_lib2();
    var FourCC_1 = require_FourCC();
    exports2.Header = {
      len: 8,
      get: (buf, off) => {
        return {
          // Chunk type ID
          chunkID: FourCC_1.FourCcToken.get(buf, off),
          // Chunk size
          chunkSize: Number(BigInt(Token2.UINT32_BE.get(buf, off + 4)))
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/aiff/AiffParser.js
var require_AiffParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/aiff/AiffParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AIFFParser = void 0;
    var Token2 = require_lib2();
    var debug_1 = require_browser();
    var strtok32 = require_core();
    var ID3v2Parser_1 = require_ID3v2Parser();
    var FourCC_1 = require_FourCC();
    var BasicParser_1 = require_BasicParser();
    var AiffToken = require_AiffToken();
    var iff = require_iff();
    var debug = (0, debug_1.default)("music-metadata:parser:aiff");
    var compressionTypes = {
      NONE: "not compressed	PCM	Apple Computer",
      sowt: "PCM (byte swapped)",
      fl32: "32-bit floating point IEEE 32-bit float",
      fl64: "64-bit floating point IEEE 64-bit float	Apple Computer",
      alaw: "ALaw 2:1	8-bit ITU-T G.711 A-law",
      ulaw: "\xB5Law 2:1	8-bit ITU-T G.711 \xB5-law	Apple Computer",
      ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 \xB5-law",
      ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
      FL32: "Float 32	IEEE 32-bit float "
    };
    var AIFFParser = class extends BasicParser_1.BasicParser {
      async parse() {
        const header = await this.tokenizer.readToken(iff.Header);
        if (header.chunkID !== "FORM")
          throw new Error("Invalid Chunk-ID, expected 'FORM'");
        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);
        switch (type) {
          case "AIFF":
            this.metadata.setFormat("container", type);
            this.isCompressed = false;
            break;
          case "AIFC":
            this.metadata.setFormat("container", "AIFF-C");
            this.isCompressed = true;
            break;
          default:
            throw Error("Unsupported AIFF type: " + type);
        }
        this.metadata.setFormat("lossless", !this.isCompressed);
        try {
          while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {
            debug("Reading AIFF chunk at offset=" + this.tokenizer.position);
            const chunkHeader = await this.tokenizer.readToken(iff.Header);
            const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
            const bytesRead = await this.readData(chunkHeader);
            await this.tokenizer.ignore(nextChunk - bytesRead);
          }
        } catch (err) {
          if (err instanceof strtok32.EndOfStreamError) {
            debug(`End-of-stream`);
          } else {
            throw err;
          }
        }
      }
      async readData(header) {
        var _a;
        switch (header.chunkID) {
          case "COMM":
            const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));
            this.metadata.setFormat("bitsPerSample", common.sampleSize);
            this.metadata.setFormat("sampleRate", common.sampleRate);
            this.metadata.setFormat("numberOfChannels", common.numChannels);
            this.metadata.setFormat("numberOfSamples", common.numSampleFrames);
            this.metadata.setFormat("duration", common.numSampleFrames / common.sampleRate);
            this.metadata.setFormat("codec", (_a = common.compressionName) !== null && _a !== void 0 ? _a : compressionTypes[common.compressionType]);
            return header.chunkSize;
          case "ID3 ":
            const id3_data = await this.tokenizer.readToken(new Token2.Uint8ArrayType(header.chunkSize));
            const rst = strtok32.fromBuffer(id3_data);
            await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
            return header.chunkSize;
          case "SSND":
            if (this.metadata.format.duration) {
              this.metadata.setFormat("bitrate", 8 * header.chunkSize / this.metadata.format.duration);
            }
            return 0;
          case "NAME":
          case "AUTH":
          case "(c) ":
          case "ANNO":
            return this.readTextChunk(header);
          default:
            debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);
            return 0;
        }
      }
      async readTextChunk(header) {
        const value = await this.tokenizer.readToken(new Token2.StringType(header.chunkSize, "ascii"));
        value.split("\0").map((v) => v.trim()).filter((v) => v && v.length > 0).forEach((v) => {
          this.metadata.addTag("AIFF", header.chunkID, v.trim());
        });
        return header.chunkSize;
      }
    };
    exports2.AIFFParser = AIFFParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/GUID.js
var require_GUID = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/GUID.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GUID = class _GUID {
      static fromBin(bin, offset = 0) {
        return new _GUID(this.decode(bin, offset));
      }
      /**
       * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
       * @param objectId Binary GUID
       * @param offset Read offset in bytes, default 0
       * @returns GUID as dashed hexadecimal representation
       */
      static decode(objectId, offset = 0) {
        const guid = objectId.readUInt32LE(offset).toString(16) + "-" + objectId.readUInt16LE(offset + 4).toString(16) + "-" + objectId.readUInt16LE(offset + 6).toString(16) + "-" + objectId.readUInt16BE(offset + 8).toString(16) + "-" + objectId.slice(offset + 10, offset + 16).toString("hex");
        return guid.toUpperCase();
      }
      /**
       * Decode stream type
       * @param mediaType Media type GUID
       * @returns Media type
       */
      static decodeMediaType(mediaType) {
        switch (mediaType.str) {
          case _GUID.AudioMedia.str:
            return "audio";
          case _GUID.VideoMedia.str:
            return "video";
          case _GUID.CommandMedia.str:
            return "command";
          case _GUID.Degradable_JPEG_Media.str:
            return "degradable-jpeg";
          case _GUID.FileTransferMedia.str:
            return "file-transfer";
          case _GUID.BinaryMedia.str:
            return "binary";
        }
      }
      /**
       * Encode GUID
       * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
       * @returns Encoded Binary GUID
       */
      static encode(str) {
        const bin = Buffer.alloc(16);
        bin.writeUInt32LE(parseInt(str.slice(0, 8), 16), 0);
        bin.writeUInt16LE(parseInt(str.slice(9, 13), 16), 4);
        bin.writeUInt16LE(parseInt(str.slice(14, 18), 16), 6);
        Buffer.from(str.slice(19, 23), "hex").copy(bin, 8);
        Buffer.from(str.slice(24), "hex").copy(bin, 10);
        return bin;
      }
      constructor(str) {
        this.str = str;
      }
      equals(guid) {
        return this.str === guid.str;
      }
      toBin() {
        return _GUID.encode(this.str);
      }
    };
    GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
    GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
    GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
    GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
    GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
    GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
    GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
    GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
    GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
    GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
    GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
    GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
    GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
    GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
    GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
    GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
    GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
    GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
    GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
    GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
    GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
    GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
    GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
    GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
    GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
    GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
    GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
    GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
    GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
    GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
    GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
    GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
    GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
    GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
    GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
    GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
    GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
    GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
    GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
    GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
    GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
    GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
    GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
    exports2.default = GUID;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfUtil.js
var require_AsfUtil = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfUtil.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsfUtil = void 0;
    var Token2 = require_lib2();
    var util = require_Util();
    var AsfUtil = class _AsfUtil {
      static getParserForAttr(i) {
        return _AsfUtil.attributeParsers[i];
      }
      static parseUnicodeAttr(uint8Array) {
        return util.stripNulls(util.decodeString(uint8Array, "utf16le"));
      }
      static parseByteArrayAttr(buf) {
        return Buffer.from(buf);
      }
      static parseBoolAttr(buf, offset = 0) {
        return _AsfUtil.parseWordAttr(buf, offset) === 1;
      }
      static parseDWordAttr(buf, offset = 0) {
        return buf.readUInt32LE(offset);
      }
      static parseQWordAttr(buf, offset = 0) {
        return Token2.UINT64_LE.get(buf, offset);
      }
      static parseWordAttr(buf, offset = 0) {
        return buf.readUInt16LE(offset);
      }
    };
    AsfUtil.attributeParsers = [
      AsfUtil.parseUnicodeAttr,
      AsfUtil.parseByteArrayAttr,
      AsfUtil.parseBoolAttr,
      AsfUtil.parseDWordAttr,
      AsfUtil.parseQWordAttr,
      AsfUtil.parseWordAttr,
      AsfUtil.parseByteArrayAttr
    ];
    exports2.AsfUtil = AsfUtil;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfObject.js
var require_AsfObject = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfObject.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WmPictureToken = exports2.MetadataLibraryObjectState = exports2.MetadataObjectState = exports2.ExtendedStreamPropertiesObjectState = exports2.ExtendedContentDescriptionObjectState = exports2.ContentDescriptionObjectState = exports2.readCodecEntries = exports2.HeaderExtensionObject = exports2.StreamPropertiesObject = exports2.FilePropertiesObject = exports2.IgnoreObjectState = exports2.State = exports2.HeaderObjectToken = exports2.TopLevelHeaderObjectToken = exports2.DataType = void 0;
    var util = require_Util();
    var Token2 = require_lib2();
    var GUID_1 = require_GUID();
    var AsfUtil_1 = require_AsfUtil();
    var ID3v2Token_1 = require_ID3v2Token();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["UnicodeString"] = 0] = "UnicodeString";
      DataType2[DataType2["ByteArray"] = 1] = "ByteArray";
      DataType2[DataType2["Bool"] = 2] = "Bool";
      DataType2[DataType2["DWord"] = 3] = "DWord";
      DataType2[DataType2["QWord"] = 4] = "QWord";
      DataType2[DataType2["Word"] = 5] = "Word";
    })(DataType = exports2.DataType || (exports2.DataType = {}));
    exports2.TopLevelHeaderObjectToken = {
      len: 30,
      get: (buf, off) => {
        return {
          objectId: GUID_1.default.fromBin(new Token2.BufferType(16).get(buf, off)),
          objectSize: Number(Token2.UINT64_LE.get(buf, off + 16)),
          numberOfHeaderObjects: Token2.UINT32_LE.get(buf, off + 24)
          // Reserved: 2 bytes
        };
      }
    };
    exports2.HeaderObjectToken = {
      len: 24,
      get: (buf, off) => {
        return {
          objectId: GUID_1.default.fromBin(new Token2.BufferType(16).get(buf, off)),
          objectSize: Number(Token2.UINT64_LE.get(buf, off + 16))
        };
      }
    };
    var State = class {
      constructor(header) {
        this.len = Number(header.objectSize) - exports2.HeaderObjectToken.len;
      }
      postProcessTag(tags, name, valueType, data) {
        if (name === "WM/Picture") {
          tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });
        } else {
          const parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(valueType);
          if (!parseAttr) {
            throw new Error("unexpected value headerType: " + valueType);
          }
          tags.push({ id: name, value: parseAttr(data) });
        }
      }
    };
    exports2.State = State;
    var IgnoreObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return null;
      }
    };
    exports2.IgnoreObjectState = IgnoreObjectState;
    var FilePropertiesObject = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return {
          fileId: GUID_1.default.fromBin(buf, off),
          fileSize: Token2.UINT64_LE.get(buf, off + 16),
          creationDate: Token2.UINT64_LE.get(buf, off + 24),
          dataPacketsCount: Token2.UINT64_LE.get(buf, off + 32),
          playDuration: Token2.UINT64_LE.get(buf, off + 40),
          sendDuration: Token2.UINT64_LE.get(buf, off + 48),
          preroll: Token2.UINT64_LE.get(buf, off + 56),
          flags: {
            broadcast: util.getBit(buf, off + 64, 24),
            seekable: util.getBit(buf, off + 64, 25)
          },
          // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
          minimumDataPacketSize: Token2.UINT32_LE.get(buf, off + 68),
          maximumDataPacketSize: Token2.UINT32_LE.get(buf, off + 72),
          maximumBitrate: Token2.UINT32_LE.get(buf, off + 76)
        };
      }
    };
    FilePropertiesObject.guid = GUID_1.default.FilePropertiesObject;
    exports2.FilePropertiesObject = FilePropertiesObject;
    var StreamPropertiesObject = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return {
          streamType: GUID_1.default.decodeMediaType(GUID_1.default.fromBin(buf, off)),
          errorCorrectionType: GUID_1.default.fromBin(buf, off + 8)
          // ToDo
        };
      }
    };
    StreamPropertiesObject.guid = GUID_1.default.StreamPropertiesObject;
    exports2.StreamPropertiesObject = StreamPropertiesObject;
    var HeaderExtensionObject = class {
      constructor() {
        this.len = 22;
      }
      get(buf, off) {
        return {
          reserved1: GUID_1.default.fromBin(buf, off),
          reserved2: buf.readUInt16LE(off + 16),
          extensionDataSize: buf.readUInt32LE(off + 18)
        };
      }
    };
    HeaderExtensionObject.guid = GUID_1.default.HeaderExtensionObject;
    exports2.HeaderExtensionObject = HeaderExtensionObject;
    var CodecListObjectHeader = {
      len: 20,
      get: (buf, off) => {
        return {
          entryCount: buf.readUInt16LE(off + 16)
        };
      }
    };
    async function readString(tokenizer) {
      const length = await tokenizer.readNumber(Token2.UINT16_LE);
      return (await tokenizer.readToken(new Token2.StringType(length * 2, "utf16le"))).replace("\0", "");
    }
    async function readCodecEntries(tokenizer) {
      const codecHeader = await tokenizer.readToken(CodecListObjectHeader);
      const entries = [];
      for (let i = 0; i < codecHeader.entryCount; ++i) {
        entries.push(await readCodecEntry(tokenizer));
      }
      return entries;
    }
    exports2.readCodecEntries = readCodecEntries;
    async function readInformation(tokenizer) {
      const length = await tokenizer.readNumber(Token2.UINT16_LE);
      const buf = Buffer.alloc(length);
      await tokenizer.readBuffer(buf);
      return buf;
    }
    async function readCodecEntry(tokenizer) {
      const type = await tokenizer.readNumber(Token2.UINT16_LE);
      return {
        type: {
          videoCodec: (type & 1) === 1,
          audioCodec: (type & 2) === 2
        },
        codecName: await readString(tokenizer),
        description: await readString(tokenizer),
        information: await readInformation(tokenizer)
      };
    }
    var ContentDescriptionObjectState = class _ContentDescriptionObjectState extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        const tags = [];
        let pos = off + 10;
        for (let i = 0; i < _ContentDescriptionObjectState.contentDescTags.length; ++i) {
          const length = buf.readUInt16LE(off + i * 2);
          if (length > 0) {
            const tagName = _ContentDescriptionObjectState.contentDescTags[i];
            const end = pos + length;
            tags.push({ id: tagName, value: AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, end)) });
            pos = end;
          }
        }
        return tags;
      }
    };
    ContentDescriptionObjectState.guid = GUID_1.default.ContentDescriptionObject;
    ContentDescriptionObjectState.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"];
    exports2.ContentDescriptionObjectState = ContentDescriptionObjectState;
    var ExtendedContentDescriptionObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        const tags = [];
        const attrCount = buf.readUInt16LE(off);
        let pos = off + 2;
        for (let i = 0; i < attrCount; i += 1) {
          const nameLen = buf.readUInt16LE(pos);
          pos += 2;
          const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
          pos += nameLen;
          const valueType = buf.readUInt16LE(pos);
          pos += 2;
          const valueLen = buf.readUInt16LE(pos);
          pos += 2;
          const value = buf.slice(pos, pos + valueLen);
          pos += valueLen;
          this.postProcessTag(tags, name, valueType, value);
        }
        return tags;
      }
    };
    ExtendedContentDescriptionObjectState.guid = GUID_1.default.ExtendedContentDescriptionObject;
    exports2.ExtendedContentDescriptionObjectState = ExtendedContentDescriptionObjectState;
    var ExtendedStreamPropertiesObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return {
          startTime: Token2.UINT64_LE.get(buf, off),
          endTime: Token2.UINT64_LE.get(buf, off + 8),
          dataBitrate: buf.readInt32LE(off + 12),
          bufferSize: buf.readInt32LE(off + 16),
          initialBufferFullness: buf.readInt32LE(off + 20),
          alternateDataBitrate: buf.readInt32LE(off + 24),
          alternateBufferSize: buf.readInt32LE(off + 28),
          alternateInitialBufferFullness: buf.readInt32LE(off + 32),
          maximumObjectSize: buf.readInt32LE(off + 36),
          flags: {
            reliableFlag: util.getBit(buf, off + 40, 0),
            seekableFlag: util.getBit(buf, off + 40, 1),
            resendLiveCleanpointsFlag: util.getBit(buf, off + 40, 2)
          },
          // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
          streamNumber: buf.readInt16LE(off + 42),
          streamLanguageId: buf.readInt16LE(off + 44),
          averageTimePerFrame: buf.readInt32LE(off + 52),
          streamNameCount: buf.readInt32LE(off + 54),
          payloadExtensionSystems: buf.readInt32LE(off + 56),
          streamNames: [],
          streamPropertiesObject: null
        };
      }
    };
    ExtendedStreamPropertiesObjectState.guid = GUID_1.default.ExtendedStreamPropertiesObject;
    exports2.ExtendedStreamPropertiesObjectState = ExtendedStreamPropertiesObjectState;
    var MetadataObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(uint8Array, off) {
        const tags = [];
        const buf = Buffer.from(uint8Array);
        const descriptionRecordsCount = buf.readUInt16LE(off);
        let pos = off + 2;
        for (let i = 0; i < descriptionRecordsCount; i += 1) {
          pos += 4;
          const nameLen = buf.readUInt16LE(pos);
          pos += 2;
          const dataType = buf.readUInt16LE(pos);
          pos += 2;
          const dataLen = buf.readUInt32LE(pos);
          pos += 4;
          const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
          pos += nameLen;
          const data = buf.slice(pos, pos + dataLen);
          pos += dataLen;
          this.postProcessTag(tags, name, dataType, data);
        }
        return tags;
      }
    };
    MetadataObjectState.guid = GUID_1.default.MetadataObject;
    exports2.MetadataObjectState = MetadataObjectState;
    var MetadataLibraryObjectState = class extends MetadataObjectState {
      constructor(header) {
        super(header);
      }
    };
    MetadataLibraryObjectState.guid = GUID_1.default.MetadataLibraryObject;
    exports2.MetadataLibraryObjectState = MetadataLibraryObjectState;
    var WmPictureToken = class _WmPictureToken {
      static fromBase64(base64str) {
        return this.fromBuffer(Buffer.from(base64str, "base64"));
      }
      static fromBuffer(buffer) {
        const pic = new _WmPictureToken(buffer.length);
        return pic.get(buffer, 0);
      }
      constructor(len) {
        this.len = len;
      }
      get(buffer, offset) {
        const typeId = buffer.readUInt8(offset++);
        const size = buffer.readInt32LE(offset);
        let index = 5;
        while (buffer.readUInt16BE(index) !== 0) {
          index += 2;
        }
        const format = buffer.slice(5, index).toString("utf16le");
        while (buffer.readUInt16BE(index) !== 0) {
          index += 2;
        }
        const description = buffer.slice(5, index).toString("utf16le");
        return {
          type: ID3v2Token_1.AttachedPictureType[typeId],
          format,
          description,
          size,
          data: buffer.slice(index + 4)
        };
      }
    };
    exports2.WmPictureToken = WmPictureToken;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfParser.js
var require_AsfParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/asf/AsfParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsfParser = void 0;
    var debug_1 = require_browser();
    var type_1 = require_type();
    var GUID_1 = require_GUID();
    var AsfObject = require_AsfObject();
    var BasicParser_1 = require_BasicParser();
    var debug = (0, debug_1.default)("music-metadata:parser:ASF");
    var headerType = "asf";
    var AsfParser = class extends BasicParser_1.BasicParser {
      async parse() {
        const header = await this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);
        if (!header.objectId.equals(GUID_1.default.HeaderObject)) {
          throw new Error("expected asf header; but was not found; got: " + header.objectId.str);
        }
        try {
          await this.parseObjectHeader(header.numberOfHeaderObjects);
        } catch (err) {
          debug("Error while parsing ASF: %s", err);
        }
      }
      async parseObjectHeader(numberOfObjectHeaders) {
        let tags;
        do {
          const header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);
          debug("header GUID=%s", header.objectId.str);
          switch (header.objectId.str) {
            case AsfObject.FilePropertiesObject.guid.str:
              const fpo = await this.tokenizer.readToken(new AsfObject.FilePropertiesObject(header));
              this.metadata.setFormat("duration", Number(fpo.playDuration / BigInt(1e3)) / 1e4 - Number(fpo.preroll) / 1e3);
              this.metadata.setFormat("bitrate", fpo.maximumBitrate);
              break;
            case AsfObject.StreamPropertiesObject.guid.str:
              const spo = await this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(header));
              this.metadata.setFormat("container", "ASF/" + spo.streamType);
              break;
            case AsfObject.HeaderExtensionObject.guid.str:
              const extHeader = await this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());
              await this.parseExtensionObject(extHeader.extensionDataSize);
              break;
            case AsfObject.ContentDescriptionObjectState.guid.str:
              tags = await this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(header));
              this.addTags(tags);
              break;
            case AsfObject.ExtendedContentDescriptionObjectState.guid.str:
              tags = await this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(header));
              this.addTags(tags);
              break;
            case GUID_1.default.CodecListObject.str:
              const codecs = await AsfObject.readCodecEntries(this.tokenizer);
              codecs.forEach((codec) => {
                this.metadata.addStreamInfo({
                  type: codec.type.videoCodec ? type_1.TrackType.video : type_1.TrackType.audio,
                  codecName: codec.codecName
                });
              });
              const audioCodecs = codecs.filter((codec) => codec.type.audioCodec).map((codec) => codec.codecName).join("/");
              this.metadata.setFormat("codec", audioCodecs);
              break;
            case GUID_1.default.StreamBitratePropertiesObject.str:
              await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
              break;
            case GUID_1.default.PaddingObject.str:
              debug("Padding: %s bytes", header.objectSize - AsfObject.HeaderObjectToken.len);
              await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
              break;
            default:
              this.metadata.addWarning("Ignore ASF-Object-GUID: " + header.objectId.str);
              debug("Ignore ASF-Object-GUID: %s", header.objectId.str);
              await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
          }
        } while (--numberOfObjectHeaders);
      }
      addTags(tags) {
        tags.forEach((tag) => {
          this.metadata.addTag(headerType, tag.id, tag.value);
        });
      }
      async parseExtensionObject(extensionSize) {
        do {
          const header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);
          const remaining = header.objectSize - AsfObject.HeaderObjectToken.len;
          switch (header.objectId.str) {
            case AsfObject.ExtendedStreamPropertiesObjectState.guid.str:
              await this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(header));
              break;
            case AsfObject.MetadataObjectState.guid.str:
              const moTags = await this.tokenizer.readToken(new AsfObject.MetadataObjectState(header));
              this.addTags(moTags);
              break;
            case AsfObject.MetadataLibraryObjectState.guid.str:
              const mlTags = await this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(header));
              this.addTags(mlTags);
              break;
            case GUID_1.default.PaddingObject.str:
              await this.tokenizer.ignore(remaining);
              break;
            case GUID_1.default.CompatibilityObject.str:
              this.tokenizer.ignore(remaining);
              break;
            case GUID_1.default.ASF_Index_Placeholder_Object.str:
              await this.tokenizer.ignore(remaining);
              break;
            default:
              this.metadata.addWarning("Ignore ASF-Object-GUID: " + header.objectId.str);
              await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
              break;
          }
          extensionSize -= header.objectSize;
        } while (extensionSize > 0);
      }
    };
    exports2.AsfParser = AsfParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js
var require_Vorbis = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdentificationHeader = exports2.CommonHeader = exports2.VorbisPictureToken = void 0;
    var Token2 = require_lib2();
    var ID3v2Token_1 = require_ID3v2Token();
    var VorbisPictureToken = class _VorbisPictureToken {
      static fromBase64(base64str) {
        return this.fromBuffer(Buffer.from(base64str, "base64"));
      }
      static fromBuffer(buffer) {
        const pic = new _VorbisPictureToken(buffer.length);
        return pic.get(buffer, 0);
      }
      constructor(len) {
        this.len = len;
      }
      get(buffer, offset) {
        const type = ID3v2Token_1.AttachedPictureType[Token2.UINT32_BE.get(buffer, offset)];
        const mimeLen = Token2.UINT32_BE.get(buffer, offset += 4);
        const format = buffer.toString("utf-8", offset += 4, offset + mimeLen);
        const descLen = Token2.UINT32_BE.get(buffer, offset += mimeLen);
        const description = buffer.toString("utf-8", offset += 4, offset + descLen);
        const width = Token2.UINT32_BE.get(buffer, offset += descLen);
        const height = Token2.UINT32_BE.get(buffer, offset += 4);
        const colour_depth = Token2.UINT32_BE.get(buffer, offset += 4);
        const indexed_color = Token2.UINT32_BE.get(buffer, offset += 4);
        const picDataLen = Token2.UINT32_BE.get(buffer, offset += 4);
        const data = Buffer.from(buffer.slice(offset += 4, offset + picDataLen));
        return {
          type,
          format,
          description,
          width,
          height,
          colour_depth,
          indexed_color,
          data
        };
      }
    };
    exports2.VorbisPictureToken = VorbisPictureToken;
    exports2.CommonHeader = {
      len: 7,
      get: (buf, off) => {
        return {
          packetType: buf.readUInt8(off),
          vorbis: new Token2.StringType(6, "ascii").get(buf, off + 1)
        };
      }
    };
    exports2.IdentificationHeader = {
      len: 23,
      get: (uint8Array, off) => {
        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset);
        return {
          version: dataView.getUint32(off + 0, true),
          channelMode: dataView.getUint8(off + 4),
          sampleRate: dataView.getUint32(off + 5, true),
          bitrateMax: dataView.getUint32(off + 9, true),
          bitrateNominal: dataView.getUint32(off + 13, true),
          bitrateMin: dataView.getUint32(off + 17, true)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js
var require_AbstractID3Parser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractID3Parser = void 0;
    var core_1 = require_core();
    var debug_1 = require_browser();
    var ID3v2Token_1 = require_ID3v2Token();
    var ID3v2Parser_1 = require_ID3v2Parser();
    var ID3v1Parser_1 = require_ID3v1Parser();
    var BasicParser_1 = require_BasicParser();
    var debug = (0, debug_1.default)("music-metadata:parser:ID3");
    var AbstractID3Parser = class extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments);
        this.id3parser = new ID3v2Parser_1.ID3v2Parser();
      }
      static async startsWithID3v2Header(tokenizer) {
        return (await tokenizer.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === "ID3";
      }
      async parse() {
        try {
          await this.parseID3v2();
        } catch (err) {
          if (err instanceof core_1.EndOfStreamError) {
            debug(`End-of-stream`);
          } else {
            throw err;
          }
        }
      }
      finalize() {
        return;
      }
      async parseID3v2() {
        await this.tryReadId3v2Headers();
        debug("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position);
        await this.postId3v2Parse();
        if (this.options.skipPostHeaders && this.metadata.hasAny()) {
          this.finalize();
        } else {
          const id3v1parser = new ID3v1Parser_1.ID3v1Parser();
          await id3v1parser.init(this.metadata, this.tokenizer, this.options).parse();
          this.finalize();
        }
      }
      async tryReadId3v2Headers() {
        const id3Header = await this.tokenizer.peekToken(ID3v2Token_1.ID3v2Header);
        if (id3Header.fileIdentifier === "ID3") {
          debug("Found ID3v2 header, pos=%s", this.tokenizer.position);
          await this.id3parser.parse(this.metadata, this.tokenizer, this.options);
          return this.tryReadId3v2Headers();
        }
      }
    };
    exports2.AbstractID3Parser = AbstractID3Parser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js
var require_VorbisDecoder = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VorbisDecoder = void 0;
    var Token2 = require_lib2();
    var VorbisDecoder = class {
      constructor(data, offset) {
        this.data = data;
        this.offset = offset;
      }
      readInt32() {
        const value = Token2.UINT32_LE.get(this.data, this.offset);
        this.offset += 4;
        return value;
      }
      readStringUtf8() {
        const len = this.readInt32();
        const value = Buffer.from(this.data).toString("utf-8", this.offset, this.offset + len);
        this.offset += len;
        return value;
      }
      parseUserComment() {
        const offset0 = this.offset;
        const v = this.readStringUtf8();
        const idx = v.indexOf("=");
        return {
          key: v.slice(0, idx).toUpperCase(),
          value: v.slice(idx + 1),
          len: this.offset - offset0
        };
      }
    };
    exports2.VorbisDecoder = VorbisDecoder;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js
var require_VorbisParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VorbisParser = void 0;
    var Token2 = require_lib2();
    var debug_1 = require_browser();
    var VorbisDecoder_1 = require_VorbisDecoder();
    var Vorbis_1 = require_Vorbis();
    var debug = (0, debug_1.default)("music-metadata:parser:ogg:vorbis1");
    var VorbisParser = class {
      constructor(metadata, options) {
        this.metadata = metadata;
        this.options = options;
        this.pageSegments = [];
      }
      /**
       * Vorbis 1 parser
       * @param header Ogg Page Header
       * @param pageData Page data
       */
      parsePage(header, pageData) {
        if (header.headerType.firstPage) {
          this.parseFirstPage(header, pageData);
        } else {
          if (header.headerType.continued) {
            if (this.pageSegments.length === 0) {
              throw new Error("Cannot continue on previous page");
            }
            this.pageSegments.push(pageData);
          }
          if (header.headerType.lastPage || !header.headerType.continued) {
            if (this.pageSegments.length > 0) {
              const fullPage = Buffer.concat(this.pageSegments);
              this.parseFullPage(fullPage);
            }
            this.pageSegments = header.headerType.lastPage ? [] : [pageData];
          }
        }
        if (header.headerType.lastPage) {
          this.calculateDuration(header);
        }
      }
      flush() {
        this.parseFullPage(Buffer.concat(this.pageSegments));
      }
      parseUserComment(pageData, offset) {
        const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);
        const tag = decoder.parseUserComment();
        this.addTag(tag.key, tag.value);
        return tag.len;
      }
      addTag(id, value) {
        if (id === "METADATA_BLOCK_PICTURE" && typeof value === "string") {
          if (this.options.skipCovers) {
            debug(`Ignore picture`);
            return;
          }
          value = Vorbis_1.VorbisPictureToken.fromBase64(value);
          debug(`Push picture: id=${id}, format=${value.format}`);
        } else {
          debug(`Push tag: id=${id}, value=${value}`);
        }
        this.metadata.addTag("vorbis", id, value);
      }
      calculateDuration(header) {
        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
          this.metadata.setFormat("numberOfSamples", header.absoluteGranulePosition);
          this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
        }
      }
      /**
       * Parse first Ogg/Vorbis page
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        this.metadata.setFormat("codec", "Vorbis I");
        debug("Parse first page");
        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);
        if (commonHeader.vorbis !== "vorbis")
          throw new Error("Metadata does not look like Vorbis");
        if (commonHeader.packetType === 1) {
          const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);
          this.metadata.setFormat("sampleRate", idHeader.sampleRate);
          this.metadata.setFormat("bitrate", idHeader.bitrateNominal);
          this.metadata.setFormat("numberOfChannels", idHeader.channelMode);
          debug("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
        } else
          throw new Error("First Ogg page should be type 1: the identification header");
      }
      parseFullPage(pageData) {
        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);
        debug("Parse full page: type=%s, byteLength=%s", commonHeader.packetType, pageData.byteLength);
        switch (commonHeader.packetType) {
          case 3:
            return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);
          case 1:
          case 5:
            break;
        }
      }
      /**
       * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
       */
      parseUserCommentList(pageData, offset) {
        const strLen = Token2.UINT32_LE.get(pageData, offset);
        offset += 4;
        offset += strLen;
        let userCommentListLength = Token2.UINT32_LE.get(pageData, offset);
        offset += 4;
        while (userCommentListLength-- > 0) {
          offset += this.parseUserComment(pageData, offset);
        }
      }
    };
    exports2.VorbisParser = VorbisParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/flac/FlacParser.js
var require_FlacParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/flac/FlacParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FlacParser = void 0;
    var token_types_1 = require_lib2();
    var debug_1 = require_browser();
    var util = require_Util();
    var Vorbis_1 = require_Vorbis();
    var AbstractID3Parser_1 = require_AbstractID3Parser();
    var FourCC_1 = require_FourCC();
    var VorbisParser_1 = require_VorbisParser();
    var VorbisDecoder_1 = require_VorbisDecoder();
    var debug = (0, debug_1.default)("music-metadata:parser:FLAC");
    var BlockType;
    (function(BlockType2) {
      BlockType2[BlockType2["STREAMINFO"] = 0] = "STREAMINFO";
      BlockType2[BlockType2["PADDING"] = 1] = "PADDING";
      BlockType2[BlockType2["APPLICATION"] = 2] = "APPLICATION";
      BlockType2[BlockType2["SEEKTABLE"] = 3] = "SEEKTABLE";
      BlockType2[BlockType2["VORBIS_COMMENT"] = 4] = "VORBIS_COMMENT";
      BlockType2[BlockType2["CUESHEET"] = 5] = "CUESHEET";
      BlockType2[BlockType2["PICTURE"] = 6] = "PICTURE";
    })(BlockType || (BlockType = {}));
    var FlacParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      constructor() {
        super(...arguments);
        this.padding = 0;
      }
      /**
       * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
       * @param {INativeMetadataCollector} metadata Output
       * @param {ITokenizer} tokenizer Input
       * @param {IOptions} options Parsing options
       */
      init(metadata, tokenizer, options) {
        super.init(metadata, tokenizer, options);
        this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);
        return this;
      }
      async postId3v2Parse() {
        const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);
        if (fourCC.toString() !== "fLaC") {
          throw new Error("Invalid FLAC preamble");
        }
        let blockHeader;
        do {
          blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);
          await this.parseDataBlock(blockHeader);
        } while (!blockHeader.lastBlock);
        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
          const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;
          this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
        }
      }
      parseDataBlock(blockHeader) {
        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);
        switch (blockHeader.type) {
          case BlockType.STREAMINFO:
            return this.parseBlockStreamInfo(blockHeader.length);
          case BlockType.PADDING:
            this.padding += blockHeader.length;
            break;
          case BlockType.APPLICATION:
            break;
          case BlockType.SEEKTABLE:
            break;
          case BlockType.VORBIS_COMMENT:
            return this.parseComment(blockHeader.length);
          case BlockType.CUESHEET:
            break;
          case BlockType.PICTURE:
            return this.parsePicture(blockHeader.length).then();
          default:
            this.metadata.addWarning("Unknown block type: " + blockHeader.type);
        }
        return this.tokenizer.ignore(blockHeader.length).then();
      }
      /**
       * Parse STREAMINFO
       */
      async parseBlockStreamInfo(dataLen) {
        if (dataLen !== Metadata.BlockStreamInfo.len)
          throw new Error("Unexpected block-stream-info length");
        const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);
        this.metadata.setFormat("container", "FLAC");
        this.metadata.setFormat("codec", "FLAC");
        this.metadata.setFormat("lossless", true);
        this.metadata.setFormat("numberOfChannels", streamInfo.channels);
        this.metadata.setFormat("bitsPerSample", streamInfo.bitsPerSample);
        this.metadata.setFormat("sampleRate", streamInfo.sampleRate);
        if (streamInfo.totalSamples > 0) {
          this.metadata.setFormat("duration", streamInfo.totalSamples / streamInfo.sampleRate);
        }
      }
      /**
       * Parse VORBIS_COMMENT
       * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
       */
      async parseComment(dataLen) {
        const data = await this.tokenizer.readToken(new token_types_1.Uint8ArrayType(dataLen));
        const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);
        decoder.readStringUtf8();
        const commentListLength = decoder.readInt32();
        for (let i = 0; i < commentListLength; i++) {
          const tag = decoder.parseUserComment();
          this.vorbisParser.addTag(tag.key, tag.value);
        }
      }
      async parsePicture(dataLen) {
        if (this.options.skipCovers) {
          return this.tokenizer.ignore(dataLen);
        } else {
          const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));
          this.vorbisParser.addTag("METADATA_BLOCK_PICTURE", picture);
        }
      }
    };
    exports2.FlacParser = FlacParser;
    var Metadata = class {
    };
    Metadata.BlockHeader = {
      len: 4,
      get: (buf, off) => {
        return {
          lastBlock: util.getBit(buf, off, 7),
          type: util.getBitAllignedNumber(buf, off, 1, 7),
          length: token_types_1.UINT24_BE.get(buf, off + 1)
        };
      }
    };
    Metadata.BlockStreamInfo = {
      len: 34,
      get: (buf, off) => {
        return {
          // The minimum block size (in samples) used in the stream.
          minimumBlockSize: token_types_1.UINT16_BE.get(buf, off),
          // The maximum block size (in samples) used in the stream.
          // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
          maximumBlockSize: token_types_1.UINT16_BE.get(buf, off + 2) / 1e3,
          // The minimum frame size (in bytes) used in the stream.
          // May be 0 to imply the value is not known.
          minimumFrameSize: token_types_1.UINT24_BE.get(buf, off + 4),
          // The maximum frame size (in bytes) used in the stream.
          // May be 0 to imply the value is not known.
          maximumFrameSize: token_types_1.UINT24_BE.get(buf, off + 7),
          // Sample rate in Hz. Though 20 bits are available,
          // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
          // Also, a value of 0 is invalid.
          sampleRate: token_types_1.UINT24_BE.get(buf, off + 10) >> 4,
          // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
          // (number of channels)-1. FLAC supports from 1 to 8 channels
          channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,
          // bits per sample)-1.
          // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
          bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,
          // Total samples in stream.
          // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
          // A value of zero here means the number of total samples is unknown.
          totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),
          // the MD5 hash of the file (see notes for usage... it's a littly tricky)
          fileMD5: new token_types_1.Uint8ArrayType(16).get(buf, off + 18)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/AtomToken.js
var require_AtomToken = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/AtomToken.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChapterText = exports2.StcoAtom = exports2.StszAtom = exports2.StscAtom = exports2.SampleToChunkToken = exports2.SttsAtom = exports2.TimeToSampleToken = exports2.SoundSampleDescriptionV0 = exports2.SoundSampleDescriptionVersion = exports2.StsdAtom = exports2.TrackHeaderAtom = exports2.NameAtom = exports2.DataAtom = exports2.MvhdAtom = exports2.MdhdAtom = exports2.FixedLengthAtom = exports2.mhdr = exports2.tkhd = exports2.ftyp = exports2.ExtendedSize = exports2.Header = void 0;
    var Token2 = require_lib2();
    var debug_1 = require_browser();
    var FourCC_1 = require_FourCC();
    var debug = (0, debug_1.default)("music-metadata:parser:MP4:atom");
    exports2.Header = {
      len: 8,
      get: (buf, off) => {
        const length = Token2.UINT32_BE.get(buf, off);
        if (length < 0)
          throw new Error("Invalid atom header length");
        return {
          length: BigInt(length),
          name: new Token2.StringType(4, "binary").get(buf, off + 4)
        };
      },
      put: (buf, off, hdr) => {
        Token2.UINT32_BE.put(buf, off, Number(hdr.length));
        return FourCC_1.FourCcToken.put(buf, off + 4, hdr.name);
      }
    };
    exports2.ExtendedSize = Token2.UINT64_BE;
    exports2.ftyp = {
      len: 4,
      get: (buf, off) => {
        return {
          type: new Token2.StringType(4, "ascii").get(buf, off)
        };
      }
    };
    exports2.tkhd = {
      len: 4,
      get: (buf, off) => {
        return {
          type: new Token2.StringType(4, "ascii").get(buf, off)
        };
      }
    };
    exports2.mhdr = {
      len: 8,
      get: (buf, off) => {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          nextItemID: Token2.UINT32_BE.get(buf, off + 4)
        };
      }
    };
    var FixedLengthAtom = class {
      /**
       *
       * @param {number} len Length as specified in the size field
       * @param {number} expLen Total length of sum of specified fields in the standard
       */
      constructor(len, expLen, atomId) {
        this.len = len;
        if (len < expLen) {
          throw new Error(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
        } else if (len > expLen) {
          debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
        }
      }
    };
    exports2.FixedLengthAtom = FixedLengthAtom;
    var SecondsSinceMacEpoch = {
      len: 4,
      get: (buf, off) => {
        const secondsSinceUnixEpoch = Token2.UINT32_BE.get(buf, off) - 2082844800;
        return new Date(secondsSinceUnixEpoch * 1e3);
      }
    };
    var MdhdAtom = class extends FixedLengthAtom {
      constructor(len) {
        super(len, 24, "mdhd");
        this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off + 0),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
          modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
          timeScale: Token2.UINT32_BE.get(buf, off + 12),
          duration: Token2.UINT32_BE.get(buf, off + 16),
          language: Token2.UINT16_BE.get(buf, off + 20),
          quality: Token2.UINT16_BE.get(buf, off + 22)
        };
      }
    };
    exports2.MdhdAtom = MdhdAtom;
    var MvhdAtom = class extends FixedLengthAtom {
      constructor(len) {
        super(len, 100, "mvhd");
        this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
          modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
          timeScale: Token2.UINT32_BE.get(buf, off + 12),
          duration: Token2.UINT32_BE.get(buf, off + 16),
          preferredRate: Token2.UINT32_BE.get(buf, off + 20),
          preferredVolume: Token2.UINT16_BE.get(buf, off + 24),
          // ignore reserver: 10 bytes
          // ignore matrix structure: 36 bytes
          previewTime: Token2.UINT32_BE.get(buf, off + 72),
          previewDuration: Token2.UINT32_BE.get(buf, off + 76),
          posterTime: Token2.UINT32_BE.get(buf, off + 80),
          selectionTime: Token2.UINT32_BE.get(buf, off + 84),
          selectionDuration: Token2.UINT32_BE.get(buf, off + 88),
          currentTime: Token2.UINT32_BE.get(buf, off + 92),
          nextTrackID: Token2.UINT32_BE.get(buf, off + 96)
        };
      }
    };
    exports2.MvhdAtom = MvhdAtom;
    var DataAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          type: {
            set: Token2.UINT8.get(buf, off + 0),
            type: Token2.UINT24_BE.get(buf, off + 1)
          },
          locale: Token2.UINT24_BE.get(buf, off + 4),
          value: Buffer.from(new Token2.Uint8ArrayType(this.len - 8).get(buf, off + 8))
        };
      }
    };
    exports2.DataAtom = DataAtom;
    var NameAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          name: new Token2.StringType(this.len - 4, "utf-8").get(buf, off + 4)
        };
      }
    };
    exports2.NameAtom = NameAtom;
    var TrackHeaderAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
          modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
          trackId: Token2.UINT32_BE.get(buf, off + 12),
          // reserved 4 bytes
          duration: Token2.UINT32_BE.get(buf, off + 20),
          layer: Token2.UINT16_BE.get(buf, off + 24),
          alternateGroup: Token2.UINT16_BE.get(buf, off + 26),
          volume: Token2.UINT16_BE.get(buf, off + 28)
          // ToDo: fixed point
          // ToDo: add remaining fields
        };
      }
    };
    exports2.TrackHeaderAtom = TrackHeaderAtom;
    var stsdHeader = {
      len: 8,
      get: (buf, off) => {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          numberOfEntries: Token2.UINT32_BE.get(buf, off + 4)
        };
      }
    };
    var SampleDescriptionTable = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          dataFormat: FourCC_1.FourCcToken.get(buf, off),
          dataReferenceIndex: Token2.UINT16_BE.get(buf, off + 10),
          description: new Token2.Uint8ArrayType(this.len - 12).get(buf, off + 12)
        };
      }
    };
    var StsdAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        const header = stsdHeader.get(buf, off);
        off += stsdHeader.len;
        const table = [];
        for (let n = 0; n < header.numberOfEntries; ++n) {
          const size = Token2.UINT32_BE.get(buf, off);
          off += Token2.UINT32_BE.len;
          table.push(new SampleDescriptionTable(size).get(buf, off));
          off += size;
        }
        return {
          header,
          table
        };
      }
    };
    exports2.StsdAtom = StsdAtom;
    exports2.SoundSampleDescriptionVersion = {
      len: 8,
      get(buf, off) {
        return {
          version: Token2.INT16_BE.get(buf, off),
          revision: Token2.INT16_BE.get(buf, off + 2),
          vendor: Token2.INT32_BE.get(buf, off + 4)
        };
      }
    };
    exports2.SoundSampleDescriptionV0 = {
      len: 12,
      get(buf, off) {
        return {
          numAudioChannels: Token2.INT16_BE.get(buf, off + 0),
          sampleSize: Token2.INT16_BE.get(buf, off + 2),
          compressionId: Token2.INT16_BE.get(buf, off + 4),
          packetSize: Token2.INT16_BE.get(buf, off + 6),
          sampleRate: Token2.UINT16_BE.get(buf, off + 8) + Token2.UINT16_BE.get(buf, off + 10) / 1e4
        };
      }
    };
    var SimpleTableAtom = class {
      constructor(len, token) {
        this.len = len;
        this.token = token;
      }
      get(buf, off) {
        const nrOfEntries = Token2.INT32_BE.get(buf, off + 4);
        return {
          version: Token2.INT8.get(buf, off + 0),
          flags: Token2.INT24_BE.get(buf, off + 1),
          numberOfEntries: nrOfEntries,
          entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
        };
      }
    };
    exports2.TimeToSampleToken = {
      len: 8,
      get(buf, off) {
        return {
          count: Token2.INT32_BE.get(buf, off + 0),
          duration: Token2.INT32_BE.get(buf, off + 4)
        };
      }
    };
    var SttsAtom = class extends SimpleTableAtom {
      constructor(len) {
        super(len, exports2.TimeToSampleToken);
        this.len = len;
      }
    };
    exports2.SttsAtom = SttsAtom;
    exports2.SampleToChunkToken = {
      len: 12,
      get(buf, off) {
        return {
          firstChunk: Token2.INT32_BE.get(buf, off),
          samplesPerChunk: Token2.INT32_BE.get(buf, off + 4),
          sampleDescriptionId: Token2.INT32_BE.get(buf, off + 8)
        };
      }
    };
    var StscAtom = class extends SimpleTableAtom {
      constructor(len) {
        super(len, exports2.SampleToChunkToken);
        this.len = len;
      }
    };
    exports2.StscAtom = StscAtom;
    var StszAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        const nrOfEntries = Token2.INT32_BE.get(buf, off + 8);
        return {
          version: Token2.INT8.get(buf, off),
          flags: Token2.INT24_BE.get(buf, off + 1),
          sampleSize: Token2.INT32_BE.get(buf, off + 4),
          numberOfEntries: nrOfEntries,
          entries: readTokenTable(buf, Token2.INT32_BE, off + 12, this.len - 12, nrOfEntries)
        };
      }
    };
    exports2.StszAtom = StszAtom;
    var StcoAtom = class extends SimpleTableAtom {
      constructor(len) {
        super(len, Token2.INT32_BE);
        this.len = len;
      }
    };
    exports2.StcoAtom = StcoAtom;
    var ChapterText = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        const titleLen = Token2.INT16_BE.get(buf, off + 0);
        const str = new Token2.StringType(titleLen, "utf-8");
        return str.get(buf, off + 2);
      }
    };
    exports2.ChapterText = ChapterText;
    function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
      debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);
      if (remainingLen === 0)
        return [];
      if (remainingLen !== numberOfEntries * token.len)
        throw new Error("mismatch number-of-entries with remaining atom-length");
      const entries = [];
      for (let n = 0; n < numberOfEntries; ++n) {
        entries.push(token.get(buf, off));
        off += token.len;
      }
      return entries;
    }
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/Atom.js
var require_Atom = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/Atom.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Atom = void 0;
    var debug_1 = require_browser();
    var AtomToken = require_AtomToken();
    var debug = (0, debug_1.default)("music-metadata:parser:MP4:Atom");
    var Atom = class _Atom {
      static async readAtom(tokenizer, dataHandler, parent, remaining) {
        const offset = tokenizer.position;
        const header = await tokenizer.readToken(AtomToken.Header);
        const extended = header.length === BigInt(1);
        if (extended) {
          header.length = await tokenizer.readToken(AtomToken.ExtendedSize);
        }
        const atomBean = new _Atom(header, header.length === BigInt(1), parent);
        const payloadLength = atomBean.getPayloadLength(remaining);
        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`);
        await atomBean.readData(tokenizer, dataHandler, payloadLength);
        return atomBean;
      }
      constructor(header, extended, parent) {
        this.header = header;
        this.extended = extended;
        this.parent = parent;
        this.children = [];
        this.atomPath = (this.parent ? this.parent.atomPath + "." : "") + this.header.name;
      }
      getHeaderLength() {
        return this.extended ? 16 : 8;
      }
      getPayloadLength(remaining) {
        return (this.header.length === BigInt(0) ? remaining : Number(this.header.length)) - this.getHeaderLength();
      }
      async readAtoms(tokenizer, dataHandler, size) {
        while (size > 0) {
          const atomBean = await _Atom.readAtom(tokenizer, dataHandler, this, size);
          this.children.push(atomBean);
          size -= atomBean.header.length === BigInt(0) ? size : Number(atomBean.header.length);
        }
      }
      async readData(tokenizer, dataHandler, remaining) {
        switch (this.header.name) {
          case "moov":
          case "udta":
          case "trak":
          case "mdia":
          case "minf":
          case "stbl":
          case "<id>":
          case "ilst":
          case "tref":
            return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));
          case "meta":
            const peekHeader = await tokenizer.peekToken(AtomToken.Header);
            const paddingLength = peekHeader.name === "hdlr" ? 0 : 4;
            await tokenizer.ignore(paddingLength);
            return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);
          case "mdhd":
          case "mvhd":
          case "tkhd":
          case "stsz":
          case "mdat":
          default:
            return dataHandler(this, remaining);
        }
      }
    };
    exports2.Atom = Atom;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/MP4Parser.js
var require_MP4Parser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mp4/MP4Parser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MP4Parser = void 0;
    var debug_1 = require_browser();
    var Token2 = require_lib2();
    var BasicParser_1 = require_BasicParser();
    var ID3v1Parser_1 = require_ID3v1Parser();
    var type_1 = require_type();
    var Atom_1 = require_Atom();
    var AtomToken = require_AtomToken();
    var debug = (0, debug_1.default)("music-metadata:parser:MP4");
    var tagFormat = "iTunes";
    var encoderDict = {
      raw: {
        lossy: false,
        format: "raw"
      },
      MAC3: {
        lossy: true,
        format: "MACE 3:1"
      },
      MAC6: {
        lossy: true,
        format: "MACE 6:1"
      },
      ima4: {
        lossy: true,
        format: "IMA 4:1"
      },
      ulaw: {
        lossy: true,
        format: "uLaw 2:1"
      },
      alaw: {
        lossy: true,
        format: "uLaw 2:1"
      },
      Qclp: {
        lossy: true,
        format: "QUALCOMM PureVoice"
      },
      ".mp3": {
        lossy: true,
        format: "MPEG-1 layer 3"
      },
      alac: {
        lossy: false,
        format: "ALAC"
      },
      "ac-3": {
        lossy: true,
        format: "AC-3"
      },
      mp4a: {
        lossy: true,
        format: "MPEG-4/AAC"
      },
      mp4s: {
        lossy: true,
        format: "MP4S"
      },
      // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
      c608: {
        lossy: true,
        format: "CEA-608"
      },
      c708: {
        lossy: true,
        format: "CEA-708"
      }
    };
    function distinct(value, index, self2) {
      return self2.indexOf(value) === index;
    }
    var MP4Parser = class _MP4Parser extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments);
        this.atomParsers = {
          /**
           * Parse movie header (mvhd) atom
           * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
           */
          mvhd: async (len) => {
            const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));
            this.metadata.setFormat("creationTime", mvhd.creationTime);
            this.metadata.setFormat("modificationTime", mvhd.modificationTime);
          },
          /**
           * Parse media header (mdhd) atom
           * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615
           */
          mdhd: async (len) => {
            const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));
            const td = this.getTrackDescription();
            td.creationTime = mdhd_data.creationTime;
            td.modificationTime = mdhd_data.modificationTime;
            td.timeScale = mdhd_data.timeScale;
            td.duration = mdhd_data.duration;
          },
          chap: async (len) => {
            const td = this.getTrackDescription();
            const trackIds = [];
            while (len >= Token2.UINT32_BE.len) {
              trackIds.push(await this.tokenizer.readNumber(Token2.UINT32_BE));
              len -= Token2.UINT32_BE.len;
            }
            td.chapterList = trackIds;
          },
          tkhd: async (len) => {
            const track = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));
            this.tracks.push(track);
          },
          /**
           * Parse mdat atom.
           * Will scan for chapters
           */
          mdat: async (len) => {
            this.audioLengthInBytes = len;
            this.calculateBitRate();
            if (this.options.includeChapters) {
              const trackWithChapters = this.tracks.filter((track) => track.chapterList);
              if (trackWithChapters.length === 1) {
                const chapterTrackIds = trackWithChapters[0].chapterList;
                const chapterTracks = this.tracks.filter((track) => chapterTrackIds.indexOf(track.trackId) !== -1);
                if (chapterTracks.length === 1) {
                  return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);
                }
              }
            }
            await this.tokenizer.ignore(len);
          },
          ftyp: async (len) => {
            const types = [];
            while (len > 0) {
              const ftype = await this.tokenizer.readToken(AtomToken.ftyp);
              len -= AtomToken.ftyp.len;
              const value = ftype.type.replace(/\W/g, "");
              if (value.length > 0) {
                types.push(value);
              }
            }
            debug(`ftyp: ${types.join("/")}`);
            const x = types.filter(distinct).join("/");
            this.metadata.setFormat("container", x);
          },
          /**
           * Parse sample description atom
           */
          stsd: async (len) => {
            const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));
            const trackDescription = this.getTrackDescription();
            trackDescription.soundSampleDescription = stsd.table.map((dfEntry) => this.parseSoundSampleDescription(dfEntry));
          },
          /**
           * sample-to-Chunk Atoms
           */
          stsc: async (len) => {
            const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));
            this.getTrackDescription().sampleToChunkTable = stsc.entries;
          },
          /**
           * time to sample
           */
          stts: async (len) => {
            const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));
            this.getTrackDescription().timeToSampleTable = stts.entries;
          },
          /**
           * Parse sample-sizes atom ('stsz')
           */
          stsz: async (len) => {
            const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));
            const td = this.getTrackDescription();
            td.sampleSize = stsz.sampleSize;
            td.sampleSizeTable = stsz.entries;
          },
          /**
           * Parse chunk-offset atom ('stco')
           */
          stco: async (len) => {
            const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));
            this.getTrackDescription().chunkOffsetTable = stco.entries;
          },
          date: async (len) => {
            const date = await this.tokenizer.readToken(new Token2.StringType(len, "utf-8"));
            this.addTag("date", date);
          }
        };
      }
      static read_BE_Integer(array, signed) {
        const integerType = (signed ? "INT" : "UINT") + array.length * 8 + (array.length > 1 ? "_BE" : "");
        const token = Token2[integerType];
        if (!token) {
          throw new Error('Token for integer type not found: "' + integerType + '"');
        }
        return Number(token.get(array, 0));
      }
      async parse() {
        this.tracks = [];
        let remainingFileSize = this.tokenizer.fileInfo.size;
        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {
          try {
            const token = await this.tokenizer.peekToken(AtomToken.Header);
            if (token.name === "\0\0\0\0") {
              const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;
              debug(errMsg);
              this.addWarning(errMsg);
              break;
            }
          } catch (error) {
            const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;
            debug(errMsg);
            this.addWarning(errMsg);
            break;
          }
          const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);
          remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
        }
        const formatList = [];
        this.tracks.forEach((track) => {
          const trackFormats = [];
          track.soundSampleDescription.forEach((ssd) => {
            const streamInfo = {};
            const encoderInfo = encoderDict[ssd.dataFormat];
            if (encoderInfo) {
              trackFormats.push(encoderInfo.format);
              streamInfo.codecName = encoderInfo.format;
            } else {
              streamInfo.codecName = `<${ssd.dataFormat}>`;
            }
            if (ssd.description) {
              const { description } = ssd;
              if (description.sampleRate > 0) {
                streamInfo.type = type_1.TrackType.audio;
                streamInfo.audio = {
                  samplingFrequency: description.sampleRate,
                  bitDepth: description.sampleSize,
                  channels: description.numAudioChannels
                };
              }
            }
            this.metadata.addStreamInfo(streamInfo);
          });
          if (trackFormats.length >= 1) {
            formatList.push(trackFormats.join("/"));
          }
        });
        if (formatList.length > 0) {
          this.metadata.setFormat("codec", formatList.filter(distinct).join("+"));
        }
        const audioTracks = this.tracks.filter((track) => {
          return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;
        });
        if (audioTracks.length >= 1) {
          const audioTrack = audioTracks[0];
          const duration = audioTrack.duration / audioTrack.timeScale;
          this.metadata.setFormat("duration", duration);
          const ssd = audioTrack.soundSampleDescription[0];
          if (ssd.description) {
            this.metadata.setFormat("sampleRate", ssd.description.sampleRate);
            this.metadata.setFormat("bitsPerSample", ssd.description.sampleSize);
            this.metadata.setFormat("numberOfChannels", ssd.description.numAudioChannels);
          }
          const encoderInfo = encoderDict[ssd.dataFormat];
          if (encoderInfo) {
            this.metadata.setFormat("lossless", !encoderInfo.lossy);
          }
          this.calculateBitRate();
        }
      }
      async handleAtom(atom, remaining) {
        if (atom.parent) {
          switch (atom.parent.header.name) {
            case "ilst":
            case "<id>":
              return this.parseMetadataItemData(atom);
          }
        }
        if (this.atomParsers[atom.header.name]) {
          return this.atomParsers[atom.header.name](remaining);
        } else {
          debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);
          await this.tokenizer.ignore(remaining);
        }
      }
      getTrackDescription() {
        return this.tracks[this.tracks.length - 1];
      }
      calculateBitRate() {
        if (this.audioLengthInBytes && this.metadata.format.duration) {
          this.metadata.setFormat("bitrate", 8 * this.audioLengthInBytes / this.metadata.format.duration);
        }
      }
      addTag(id, value) {
        this.metadata.addTag(tagFormat, id, value);
      }
      addWarning(message) {
        debug("Warning: " + message);
        this.metadata.addWarning(message);
      }
      /**
       * Parse data of Meta-item-list-atom (item of 'ilst' atom)
       * @param metaAtom
       * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
       */
      parseMetadataItemData(metaAtom) {
        let tagKey = metaAtom.header.name;
        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {
          const payLoadLength = child.getPayloadLength(remaining);
          switch (child.header.name) {
            case "data":
              return this.parseValueAtom(tagKey, child);
            case "name":
              const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));
              tagKey += ":" + name.name;
              break;
            case "mean":
              const mean = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));
              tagKey += ":" + mean.name;
              break;
            default:
              const dataAtom = await this.tokenizer.readToken(new Token2.BufferType(payLoadLength));
              this.addWarning("Unsupported meta-item: " + tagKey + "[" + child.header.name + "] => value=" + dataAtom.toString("hex") + " ascii=" + dataAtom.toString("ascii"));
          }
        }, metaAtom.getPayloadLength(0));
      }
      async parseValueAtom(tagKey, metaAtom) {
        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));
        if (dataAtom.type.set !== 0) {
          throw new Error("Unsupported type-set != 0: " + dataAtom.type.set);
        }
        switch (dataAtom.type.type) {
          case 0:
            switch (tagKey) {
              case "trkn":
              case "disk":
                const num = Token2.UINT8.get(dataAtom.value, 3);
                const of = Token2.UINT8.get(dataAtom.value, 5);
                this.addTag(tagKey, num + "/" + of);
                break;
              case "gnre":
                const genreInt = Token2.UINT8.get(dataAtom.value, 1);
                const genreStr = ID3v1Parser_1.Genres[genreInt - 1];
                this.addTag(tagKey, genreStr);
                break;
              default:
            }
            break;
          case 1:
          case 18:
            this.addTag(tagKey, dataAtom.value.toString("utf-8"));
            break;
          case 13:
            if (this.options.skipCovers)
              break;
            this.addTag(tagKey, {
              format: "image/jpeg",
              data: Buffer.from(dataAtom.value)
            });
            break;
          case 14:
            if (this.options.skipCovers)
              break;
            this.addTag(tagKey, {
              format: "image/png",
              data: Buffer.from(dataAtom.value)
            });
            break;
          case 21:
            this.addTag(tagKey, _MP4Parser.read_BE_Integer(dataAtom.value, true));
            break;
          case 22:
            this.addTag(tagKey, _MP4Parser.read_BE_Integer(dataAtom.value, false));
            break;
          case 65:
            this.addTag(tagKey, dataAtom.value.readInt8(0));
            break;
          case 66:
            this.addTag(tagKey, dataAtom.value.readInt16BE(0));
            break;
          case 67:
            this.addTag(tagKey, dataAtom.value.readInt32BE(0));
            break;
          default:
            this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
        }
      }
      /**
       * @param sampleDescription
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
       */
      parseSoundSampleDescription(sampleDescription) {
        const ssd = {
          dataFormat: sampleDescription.dataFormat,
          dataReferenceIndex: sampleDescription.dataReferenceIndex
        };
        let offset = 0;
        const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
        offset += AtomToken.SoundSampleDescriptionVersion.len;
        if (version.version === 0 || version.version === 1) {
          ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);
        } else {
          debug(`Warning: sound-sample-description ${version} not implemented`);
        }
        return ssd;
      }
      async parseChapterTrack(chapterTrack, track, len) {
        if (!chapterTrack.sampleSize) {
          if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)
            throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
        }
        const chapters = [];
        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {
          const chunkOffset = chapterTrack.chunkOffsetTable[i];
          const nextChunkLen = chunkOffset - this.tokenizer.position;
          const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
          len -= nextChunkLen + sampleSize;
          if (len < 0)
            throw new Error("Chapter chunk exceeding token length");
          await this.tokenizer.ignore(nextChunkLen);
          const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));
          debug(`Chapter ${i + 1}: ${title}`);
          const chapter = {
            title,
            sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
          };
          debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);
          chapters.push(chapter);
        }
        this.metadata.setFormat("chapters", chapters);
        await this.tokenizer.ignore(len);
      }
      findSampleOffset(track, chapterOffset) {
        let totalDuration = 0;
        track.timeToSampleTable.forEach((e) => {
          totalDuration += e.count * e.duration;
        });
        debug(`Total duration=${totalDuration}`);
        let chunkIndex = 0;
        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {
          ++chunkIndex;
        }
        return this.getChunkDuration(chunkIndex + 1, track);
      }
      getChunkDuration(chunkId, track) {
        let ttsi = 0;
        let ttsc = track.timeToSampleTable[ttsi].count;
        let ttsd = track.timeToSampleTable[ttsi].duration;
        let curChunkId = 1;
        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
        let totalDuration = 0;
        while (curChunkId < chunkId) {
          const nrOfSamples = Math.min(ttsc, samplesPerChunk);
          totalDuration += nrOfSamples * ttsd;
          ttsc -= nrOfSamples;
          samplesPerChunk -= nrOfSamples;
          if (samplesPerChunk === 0) {
            ++curChunkId;
            samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
          } else {
            ++ttsi;
            ttsc = track.timeToSampleTable[ttsi].count;
            ttsd = track.timeToSampleTable[ttsi].duration;
          }
        }
        return totalDuration;
      }
      getSamplesPerChunk(chunkId, stcTable) {
        for (let i = 0; i < stcTable.length - 1; ++i) {
          if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {
            return stcTable[i].samplesPerChunk;
          }
        }
        return stcTable[stcTable.length - 1].samplesPerChunk;
      }
    };
    exports2.MP4Parser = MP4Parser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js
var require_ReplayGainDataFormat = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReplayGain = void 0;
    var common = require_Util();
    var NameCode;
    (function(NameCode2) {
      NameCode2[NameCode2["not_set"] = 0] = "not_set";
      NameCode2[NameCode2["radio"] = 1] = "radio";
      NameCode2[NameCode2["audiophile"] = 2] = "audiophile";
    })(NameCode || (NameCode = {}));
    var ReplayGainOriginator;
    (function(ReplayGainOriginator2) {
      ReplayGainOriginator2[ReplayGainOriginator2["unspecified"] = 0] = "unspecified";
      ReplayGainOriginator2[ReplayGainOriginator2["engineer"] = 1] = "engineer";
      ReplayGainOriginator2[ReplayGainOriginator2["user"] = 2] = "user";
      ReplayGainOriginator2[ReplayGainOriginator2["automatic"] = 3] = "automatic";
      ReplayGainOriginator2[ReplayGainOriginator2["rms_average"] = 4] = "rms_average";
    })(ReplayGainOriginator || (ReplayGainOriginator = {}));
    exports2.ReplayGain = {
      len: 2,
      get: (buf, off) => {
        const gain_type = common.getBitAllignedNumber(buf, off, 0, 3);
        const sign = common.getBitAllignedNumber(buf, off, 6, 1);
        const gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10;
        if (gain_type > 0) {
          return {
            type: common.getBitAllignedNumber(buf, off, 0, 3),
            origin: common.getBitAllignedNumber(buf, off, 3, 3),
            adjustment: sign ? -gain_adj : gain_adj
          };
        }
        return void 0;
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js
var require_ExtendedLameHeader = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtendedLameHeader = void 0;
    var Token2 = require_lib2();
    var common = require_Util();
    var ReplayGainDataFormat_1 = require_ReplayGainDataFormat();
    exports2.ExtendedLameHeader = {
      len: 27,
      get: (buf, off) => {
        const track_peak = Token2.UINT32_BE.get(buf, off + 2);
        return {
          revision: common.getBitAllignedNumber(buf, off, 0, 4),
          vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),
          lowpass_filter: 100 * Token2.UINT8.get(buf, off + 1),
          track_peak: track_peak === 0 ? void 0 : track_peak / Math.pow(2, 23),
          track_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 6),
          album_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 8),
          music_length: Token2.UINT32_BE.get(buf, off + 20),
          music_crc: Token2.UINT8.get(buf, off + 24),
          header_crc: Token2.UINT16_BE.get(buf, off + 24)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/XingTag.js
var require_XingTag = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/XingTag.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readXingHeader = exports2.XingHeaderFlags = exports2.LameEncoderVersion = exports2.InfoTagHeaderTag = void 0;
    var Token2 = require_lib2();
    var util = require_Util();
    var ExtendedLameHeader_1 = require_ExtendedLameHeader();
    exports2.InfoTagHeaderTag = new Token2.StringType(4, "ascii");
    exports2.LameEncoderVersion = new Token2.StringType(6, "ascii");
    exports2.XingHeaderFlags = {
      len: 4,
      get: (buf, off) => {
        return {
          frames: util.isBitSet(buf, off, 31),
          bytes: util.isBitSet(buf, off, 30),
          toc: util.isBitSet(buf, off, 29),
          vbrScale: util.isBitSet(buf, off, 28)
        };
      }
    };
    async function readXingHeader(tokenizer) {
      const flags2 = await tokenizer.readToken(exports2.XingHeaderFlags);
      const xingInfoTag = {};
      if (flags2.frames) {
        xingInfoTag.numFrames = await tokenizer.readToken(Token2.UINT32_BE);
      }
      if (flags2.bytes) {
        xingInfoTag.streamSize = await tokenizer.readToken(Token2.UINT32_BE);
      }
      if (flags2.toc) {
        xingInfoTag.toc = Buffer.alloc(100);
        await tokenizer.readBuffer(xingInfoTag.toc);
      }
      if (flags2.vbrScale) {
        xingInfoTag.vbrScale = await tokenizer.readToken(Token2.UINT32_BE);
      }
      const lameTag = await tokenizer.peekToken(new Token2.StringType(4, "ascii"));
      if (lameTag === "LAME") {
        await tokenizer.ignore(4);
        xingInfoTag.lame = {
          version: await tokenizer.readToken(new Token2.StringType(5, "ascii"))
        };
        const match = xingInfoTag.lame.version.match(/\d+.\d+/g);
        if (match) {
          const majorMinorVersion = xingInfoTag.lame.version.match(/\d+.\d+/g)[0];
          const version = majorMinorVersion.split(".").map((n) => parseInt(n, 10));
          if (version[0] >= 3 && version[1] >= 90) {
            xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader);
          }
        }
      }
      return xingInfoTag;
    }
    exports2.readXingHeader = readXingHeader;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/MpegParser.js
var require_MpegParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/mpeg/MpegParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MpegParser = void 0;
    var Token2 = require_lib2();
    var core_1 = require_core();
    var debug_1 = require_browser();
    var common = require_Util();
    var AbstractID3Parser_1 = require_AbstractID3Parser();
    var XingTag_1 = require_XingTag();
    var debug = (0, debug_1.default)("music-metadata:parser:mpeg");
    var maxPeekLen = 1024;
    var MPEG4 = {
      /**
       * Audio Object Types
       */
      AudioObjectTypes: [
        "AAC Main",
        "AAC LC",
        "AAC SSR",
        "AAC LTP"
        // Long Term Prediction
      ],
      /**
       * Sampling Frequencies
       * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
       */
      SamplingFrequencies: [
        96e3,
        88200,
        64e3,
        48e3,
        44100,
        32e3,
        24e3,
        22050,
        16e3,
        12e3,
        11025,
        8e3,
        7350,
        void 0,
        void 0,
        -1
      ]
      /**
       * Channel Configurations
       */
    };
    var MPEG4_ChannelConfigurations = [
      void 0,
      ["front-center"],
      ["front-left", "front-right"],
      ["front-center", "front-left", "front-right"],
      ["front-center", "front-left", "front-right", "back-center"],
      ["front-center", "front-left", "front-right", "back-left", "back-right"],
      ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
      ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
    ];
    var MpegFrameHeader = class _MpegFrameHeader {
      constructor(buf, off) {
        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);
        this.layer = _MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];
        if (this.versionIndex > 1 && this.layer === 0) {
          this.parseAdtsHeader(buf, off);
        } else {
          this.parseMpegHeader(buf, off);
        }
        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);
      }
      calcDuration(numFrames) {
        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;
      }
      calcSamplesPerFrame() {
        return _MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
      }
      calculateSideInfoLength() {
        if (this.layer !== 3)
          return 2;
        if (this.channelModeIndex === 3) {
          if (this.version === 1) {
            return 17;
          } else if (this.version === 2 || this.version === 2.5) {
            return 9;
          }
        } else {
          if (this.version === 1) {
            return 32;
          } else if (this.version === 2 || this.version === 2.5) {
            return 17;
          }
        }
      }
      calcSlotSize() {
        return [null, 4, 1, 1][this.layer];
      }
      parseMpegHeader(buf, off) {
        this.container = "MPEG";
        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);
        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);
        this.padding = common.isBitSet(buf, off + 2, 6);
        this.privateBit = common.isBitSet(buf, off + 2, 7);
        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);
        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);
        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);
        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);
        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);
        this.version = _MpegFrameHeader.VersionID[this.versionIndex];
        this.channelMode = _MpegFrameHeader.ChannelMode[this.channelModeIndex];
        this.codec = `MPEG ${this.version} Layer ${this.layer}`;
        const bitrateInKbps = this.calcBitrate();
        if (!bitrateInKbps) {
          throw new Error("Cannot determine bit-rate");
        }
        this.bitrate = bitrateInKbps * 1e3;
        this.samplingRate = this.calcSamplingRate();
        if (this.samplingRate == null) {
          throw new Error("Cannot determine sampling-rate");
        }
      }
      parseAdtsHeader(buf, off) {
        debug(`layer=0 => ADTS`);
        this.version = this.versionIndex === 2 ? 4 : 2;
        this.container = "ADTS/MPEG-" + this.version;
        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);
        this.codec = "AAC";
        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
        debug(`MPEG-4 audio-codec=${this.codec}`);
        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);
        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
        debug(`sampling-rate=${this.samplingRate}`);
        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);
        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
        debug(`channel-config=${this.mp4ChannelConfig.join("+")}`);
        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;
      }
      calcBitrate() {
        if (this.bitrateIndex === 0 || // free
        this.bitrateIndex === 15) {
          return;
        }
        const codecIndex = `${Math.floor(this.version)}${this.layer}`;
        return _MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
      }
      calcSamplingRate() {
        if (this.sampRateFreqIndex === 3)
          return null;
        return _MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
      }
    };
    MpegFrameHeader.SyncByte1 = 255;
    MpegFrameHeader.SyncByte2 = 224;
    MpegFrameHeader.VersionID = [2.5, null, 2, 1];
    MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
    MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
    MpegFrameHeader.bitrate_index = {
      1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
      2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
      3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
      4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
      5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
      6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
      7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
      8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
      9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
      10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
      11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
      12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
      13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
      14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
    };
    MpegFrameHeader.sampling_rate_freq_index = {
      1: { 0: 44100, 1: 48e3, 2: 32e3 },
      2: { 0: 22050, 1: 24e3, 2: 16e3 },
      2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
    };
    MpegFrameHeader.samplesInFrameTable = [
      /* Layer   I    II   III */
      [0, 384, 1152, 1152],
      [0, 384, 1152, 576]
      // MPEG-2(.5
    ];
    var FrameHeader = {
      len: 4,
      get: (buf, off) => {
        return new MpegFrameHeader(buf, off);
      }
    };
    function getVbrCodecProfile(vbrScale) {
      return "V" + Math.floor((100 - vbrScale) / 10);
    }
    var MpegParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      constructor() {
        super(...arguments);
        this.frameCount = 0;
        this.syncFrameCount = -1;
        this.countSkipFrameData = 0;
        this.totalDataLength = 0;
        this.bitrates = [];
        this.calculateEofDuration = false;
        this.buf_frame_header = Buffer.alloc(4);
        this.syncPeek = {
          buf: Buffer.alloc(maxPeekLen),
          len: 0
        };
      }
      /**
       * Called after ID3 headers have been parsed
       */
      async postId3v2Parse() {
        this.metadata.setFormat("lossless", false);
        try {
          let quit = false;
          while (!quit) {
            await this.sync();
            quit = await this.parseCommonMpegHeader();
          }
        } catch (err) {
          if (err instanceof core_1.EndOfStreamError) {
            debug(`End-of-stream`);
            if (this.calculateEofDuration) {
              const numberOfSamples = this.frameCount * this.samplesPerFrame;
              this.metadata.setFormat("numberOfSamples", numberOfSamples);
              const duration = numberOfSamples / this.metadata.format.sampleRate;
              debug(`Calculate duration at EOF: ${duration} sec.`, duration);
              this.metadata.setFormat("duration", duration);
            }
          } else {
            throw err;
          }
        }
      }
      /**
       * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
       */
      finalize() {
        const format = this.metadata.format;
        const hasID3v1 = this.metadata.native.hasOwnProperty("ID3v1");
        if (format.duration && this.tokenizer.fileInfo.size) {
          const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
          if (format.codecProfile && format.codecProfile[0] === "V") {
            this.metadata.setFormat("bitrate", mpegSize * 8 / format.duration);
          }
        } else if (this.tokenizer.fileInfo.size && format.codecProfile === "CBR") {
          const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
          const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
          this.metadata.setFormat("numberOfSamples", numberOfSamples);
          const duration = numberOfSamples / format.sampleRate;
          debug("Calculate CBR duration based on file size: %s", duration);
          this.metadata.setFormat("duration", duration);
        }
      }
      async sync() {
        let gotFirstSync = false;
        while (true) {
          let bo = 0;
          this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });
          if (this.syncPeek.len <= 163) {
            throw new core_1.EndOfStreamError();
          }
          while (true) {
            if (gotFirstSync && (this.syncPeek.buf[bo] & 224) === 224) {
              this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
              this.buf_frame_header[1] = this.syncPeek.buf[bo];
              await this.tokenizer.ignore(bo);
              debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);
              if (this.syncFrameCount === this.frameCount) {
                debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);
                this.frameCount = 0;
                this.frame_size = 0;
              }
              this.syncFrameCount = this.frameCount;
              return;
            } else {
              gotFirstSync = false;
              bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
              if (bo === -1) {
                if (this.syncPeek.len < this.syncPeek.buf.length) {
                  throw new core_1.EndOfStreamError();
                }
                await this.tokenizer.ignore(this.syncPeek.len);
                break;
              } else {
                ++bo;
                gotFirstSync = true;
              }
            }
          }
        }
      }
      /**
       * Combined ADTS & MPEG (MP2 & MP3) header handling
       * @return {Promise<boolean>} true if parser should quit
       */
      async parseCommonMpegHeader() {
        if (this.frameCount === 0) {
          this.mpegOffset = this.tokenizer.position - 1;
        }
        await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });
        let header;
        try {
          header = FrameHeader.get(this.buf_frame_header, 0);
        } catch (err) {
          await this.tokenizer.ignore(1);
          this.metadata.addWarning("Parse error: " + err.message);
          return false;
        }
        await this.tokenizer.ignore(3);
        this.metadata.setFormat("container", header.container);
        this.metadata.setFormat("codec", header.codec);
        this.metadata.setFormat("lossless", false);
        this.metadata.setFormat("sampleRate", header.samplingRate);
        this.frameCount++;
        return header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);
      }
      /**
       * @return {Promise<boolean>} true if parser should quit
       */
      async parseAudioFrameHeader(header) {
        this.metadata.setFormat("numberOfChannels", header.channelMode === "mono" ? 1 : 2);
        this.metadata.setFormat("bitrate", header.bitrate);
        if (this.frameCount < 20 * 1e4) {
          debug("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
        }
        const slot_size = header.calcSlotSize();
        if (slot_size === null) {
          throw new Error("invalid slot_size");
        }
        const samples_per_frame = header.calcSamplesPerFrame();
        debug(`samples_per_frame=${samples_per_frame}`);
        const bps = samples_per_frame / 8;
        const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
        this.frame_size = Math.floor(fsize);
        this.audioFrameHeader = header;
        this.bitrates.push(header.bitrate);
        if (this.frameCount === 1) {
          this.offset = FrameHeader.len;
          await this.skipSideInformation();
          return false;
        }
        if (this.frameCount === 3) {
          if (this.areAllSame(this.bitrates)) {
            this.samplesPerFrame = samples_per_frame;
            this.metadata.setFormat("codecProfile", "CBR");
            if (this.tokenizer.fileInfo.size)
              return true;
          } else if (this.metadata.format.duration) {
            return true;
          }
          if (!this.options.duration) {
            return true;
          }
        }
        if (this.options.duration && this.frameCount === 4) {
          this.samplesPerFrame = samples_per_frame;
          this.calculateEofDuration = true;
        }
        this.offset = 4;
        if (header.isProtectedByCRC) {
          await this.parseCrc();
          return false;
        } else {
          await this.skipSideInformation();
          return false;
        }
      }
      async parseAdts(header) {
        const buf = Buffer.alloc(3);
        await this.tokenizer.readBuffer(buf);
        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);
        this.totalDataLength += header.frameLength;
        this.samplesPerFrame = 1024;
        const framesPerSec = header.samplingRate / this.samplesPerFrame;
        const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;
        const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
        this.metadata.setFormat("bitrate", bitrate);
        debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);
        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);
        if (this.frameCount === 3) {
          this.metadata.setFormat("codecProfile", header.codecProfile);
          if (header.mp4ChannelConfig) {
            this.metadata.setFormat("numberOfChannels", header.mp4ChannelConfig.length);
          }
          if (this.options.duration) {
            this.calculateEofDuration = true;
          } else {
            return true;
          }
        }
        return false;
      }
      async parseCrc() {
        this.crc = await this.tokenizer.readNumber(Token2.INT16_BE);
        this.offset += 2;
        return this.skipSideInformation();
      }
      async skipSideInformation() {
        const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
        await this.tokenizer.readToken(new Token2.Uint8ArrayType(sideinfo_length));
        this.offset += sideinfo_length;
        await this.readXtraInfoHeader();
        return;
      }
      async readXtraInfoHeader() {
        const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);
        this.offset += XingTag_1.InfoTagHeaderTag.len;
        switch (headerTag) {
          case "Info":
            this.metadata.setFormat("codecProfile", "CBR");
            return this.readXingInfoHeader();
          case "Xing":
            const infoTag = await this.readXingInfoHeader();
            const codecProfile = getVbrCodecProfile(infoTag.vbrScale);
            this.metadata.setFormat("codecProfile", codecProfile);
            return null;
          case "Xtra":
            break;
          case "LAME":
            const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);
            if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {
              this.offset += XingTag_1.LameEncoderVersion.len;
              this.metadata.setFormat("tool", "LAME " + version);
              await this.skipFrameData(this.frame_size - this.offset);
              return null;
            } else {
              this.metadata.addWarning("Corrupt LAME header");
              break;
            }
        }
        const frameDataLeft = this.frame_size - this.offset;
        if (frameDataLeft < 0) {
          this.metadata.addWarning("Frame " + this.frameCount + "corrupt: negative frameDataLeft");
        } else {
          await this.skipFrameData(frameDataLeft);
        }
        return null;
      }
      /**
       * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
       * @returns {Promise<string>}
       */
      async readXingInfoHeader() {
        const offset = this.tokenizer.position;
        const infoTag = await (0, XingTag_1.readXingHeader)(this.tokenizer);
        this.offset += this.tokenizer.position - offset;
        if (infoTag.lame) {
          this.metadata.setFormat("tool", "LAME " + common.stripNulls(infoTag.lame.version));
          if (infoTag.lame.extended) {
            this.metadata.setFormat("trackPeakLevel", infoTag.lame.extended.track_peak);
            if (infoTag.lame.extended.track_gain) {
              this.metadata.setFormat("trackGain", infoTag.lame.extended.track_gain.adjustment);
            }
            if (infoTag.lame.extended.album_gain) {
              this.metadata.setFormat("albumGain", infoTag.lame.extended.album_gain.adjustment);
            }
            this.metadata.setFormat("duration", infoTag.lame.extended.music_length / 1e3);
          }
        }
        if (infoTag.streamSize) {
          const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
          this.metadata.setFormat("duration", duration);
          debug("Get duration from Xing header: %s", this.metadata.format.duration);
          return infoTag;
        }
        const frameDataLeft = this.frame_size - this.offset;
        await this.skipFrameData(frameDataLeft);
        return infoTag;
      }
      async skipFrameData(frameDataLeft) {
        if (frameDataLeft < 0)
          throw new Error("frame-data-left cannot be negative");
        await this.tokenizer.ignore(frameDataLeft);
        this.countSkipFrameData += frameDataLeft;
      }
      areAllSame(array) {
        const first = array[0];
        return array.every((element) => {
          return element === first;
        });
      }
    };
    exports2.MpegParser = MpegParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js
var require_StreamVersion8 = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = void 0;
    var Token2 = require_lib2();
    var debug_1 = require_browser();
    var util = require_Util();
    var debug = (0, debug_1.default)("music-metadata:parser:musepack:sv8");
    var PacketKey = new Token2.StringType(2, "binary");
    var SH_part1 = {
      len: 5,
      get: (buf, off) => {
        return {
          crc: Token2.UINT32_LE.get(buf, off),
          streamVersion: Token2.UINT8.get(buf, off + 4)
        };
      }
    };
    var SH_part3 = {
      len: 2,
      get: (buf, off) => {
        return {
          sampleFrequency: [44100, 48e3, 37800, 32e3][util.getBitAllignedNumber(buf, off, 0, 3)],
          maxUsedBands: util.getBitAllignedNumber(buf, off, 3, 5),
          channelCount: util.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,
          msUsed: util.isBitSet(buf, off + 1, 4),
          audioBlockFrames: util.getBitAllignedNumber(buf, off + 1, 5, 3)
        };
      }
    };
    var StreamReader = class {
      constructor(tokenizer) {
        this.tokenizer = tokenizer;
      }
      async readPacketHeader() {
        const key = await this.tokenizer.readToken(PacketKey);
        const size = await this.readVariableSizeField();
        return {
          key,
          payloadLength: size.value - 2 - size.len
        };
      }
      async readStreamHeader(size) {
        const streamHeader = {};
        debug(`Reading SH at offset=${this.tokenizer.position}`);
        const part1 = await this.tokenizer.readToken(SH_part1);
        size -= SH_part1.len;
        Object.assign(streamHeader, part1);
        debug(`SH.streamVersion = ${part1.streamVersion}`);
        const sampleCount = await this.readVariableSizeField();
        size -= sampleCount.len;
        streamHeader.sampleCount = sampleCount.value;
        const bs = await this.readVariableSizeField();
        size -= bs.len;
        streamHeader.beginningOfSilence = bs.value;
        const part3 = await this.tokenizer.readToken(SH_part3);
        size -= SH_part3.len;
        Object.assign(streamHeader, part3);
        await this.tokenizer.ignore(size);
        return streamHeader;
      }
      async readVariableSizeField(len = 1, hb = 0) {
        let n = await this.tokenizer.readNumber(Token2.UINT8);
        if ((n & 128) === 0) {
          return { len, value: hb + n };
        }
        n &= 127;
        n += hb;
        return this.readVariableSizeField(len + 1, n << 7);
      }
    };
    exports2.StreamReader = StreamReader;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js
var require_MpcSv8Parser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MpcSv8Parser = void 0;
    var debug_1 = require_browser();
    var BasicParser_1 = require_BasicParser();
    var APEv2Parser_1 = require_APEv2Parser();
    var FourCC_1 = require_FourCC();
    var SV8 = require_StreamVersion8();
    var debug = (0, debug_1.default)("music-metadata:parser:musepack");
    var MpcSv8Parser = class extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments);
        this.audioLength = 0;
      }
      async parse() {
        const signature = await this.tokenizer.readToken(FourCC_1.FourCcToken);
        if (signature !== "MPCK")
          throw new Error("Invalid Magic number");
        this.metadata.setFormat("container", "Musepack, SV8");
        return this.parsePacket();
      }
      async parsePacket() {
        const sv8reader = new SV8.StreamReader(this.tokenizer);
        do {
          const header = await sv8reader.readPacketHeader();
          debug(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);
          switch (header.key) {
            case "SH":
              const sh = await sv8reader.readStreamHeader(header.payloadLength);
              this.metadata.setFormat("numberOfSamples", sh.sampleCount);
              this.metadata.setFormat("sampleRate", sh.sampleFrequency);
              this.metadata.setFormat("duration", sh.sampleCount / sh.sampleFrequency);
              this.metadata.setFormat("numberOfChannels", sh.channelCount);
              break;
            case "AP":
              this.audioLength += header.payloadLength;
              await this.tokenizer.ignore(header.payloadLength);
              break;
            case "RG":
            case "EI":
            case "SO":
            case "ST":
            case "CT":
              await this.tokenizer.ignore(header.payloadLength);
              break;
            case "SE":
              this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration);
              return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
            default:
              throw new Error(`Unexpected header: ${header.key}`);
          }
        } while (true);
      }
    };
    exports2.MpcSv8Parser = MpcSv8Parser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv7/BitReader.js
var require_BitReader = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv7/BitReader.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BitReader = void 0;
    var Token2 = require_lib2();
    var BitReader = class {
      constructor(tokenizer) {
        this.tokenizer = tokenizer;
        this.pos = 0;
        this.dword = void 0;
      }
      /**
       *
       * @param bits 1..30 bits
       */
      async read(bits) {
        while (this.dword === void 0) {
          this.dword = await this.tokenizer.readToken(Token2.UINT32_LE);
        }
        let out = this.dword;
        this.pos += bits;
        if (this.pos < 32) {
          out >>>= 32 - this.pos;
          return out & (1 << bits) - 1;
        } else {
          this.pos -= 32;
          if (this.pos === 0) {
            this.dword = void 0;
            return out & (1 << bits) - 1;
          } else {
            this.dword = await this.tokenizer.readToken(Token2.UINT32_LE);
            if (this.pos) {
              out <<= this.pos;
              out |= this.dword >>> 32 - this.pos;
            }
            return out & (1 << bits) - 1;
          }
        }
      }
      async ignore(bits) {
        if (this.pos > 0) {
          const remaining = 32 - this.pos;
          this.dword = void 0;
          bits -= remaining;
          this.pos = 0;
        }
        const remainder = bits % 32;
        const numOfWords = (bits - remainder) / 32;
        await this.tokenizer.ignore(numOfWords * 4);
        return this.read(remainder);
      }
    };
    exports2.BitReader = BitReader;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js
var require_StreamVersion7 = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Header = void 0;
    var Token2 = require_lib2();
    var util = require_Util();
    exports2.Header = {
      len: 6 * 4,
      get: (buf, off) => {
        const header = {
          // word 0
          signature: Buffer.from(buf).toString("latin1", off, off + 3),
          // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
          streamMinorVersion: util.getBitAllignedNumber(buf, off + 3, 0, 4),
          streamMajorVersion: util.getBitAllignedNumber(buf, off + 3, 4, 4),
          // word 1
          frameCount: Token2.UINT32_LE.get(buf, off + 4),
          // word 2
          maxLevel: Token2.UINT16_LE.get(buf, off + 8),
          sampleFrequency: [44100, 48e3, 37800, 32e3][util.getBitAllignedNumber(buf, off + 10, 0, 2)],
          link: util.getBitAllignedNumber(buf, off + 10, 2, 2),
          profile: util.getBitAllignedNumber(buf, off + 10, 4, 4),
          maxBand: util.getBitAllignedNumber(buf, off + 11, 0, 6),
          intensityStereo: util.isBitSet(buf, off + 11, 6),
          midSideStereo: util.isBitSet(buf, off + 11, 7),
          // word 3
          titlePeak: Token2.UINT16_LE.get(buf, off + 12),
          titleGain: Token2.UINT16_LE.get(buf, off + 14),
          // word 4
          albumPeak: Token2.UINT16_LE.get(buf, off + 16),
          albumGain: Token2.UINT16_LE.get(buf, off + 18),
          // word
          lastFrameLength: Token2.UINT32_LE.get(buf, off + 20) >>> 20 & 2047,
          trueGapless: util.isBitSet(buf, off + 23, 0)
        };
        header.lastFrameLength = header.trueGapless ? Token2.UINT32_LE.get(buf, 20) >>> 20 & 2047 : 0;
        return header;
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js
var require_MpcSv7Parser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MpcSv7Parser = void 0;
    var debug_1 = require_browser();
    var BasicParser_1 = require_BasicParser();
    var APEv2Parser_1 = require_APEv2Parser();
    var BitReader_1 = require_BitReader();
    var SV7 = require_StreamVersion7();
    var debug = (0, debug_1.default)("music-metadata:parser:musepack");
    var MpcSv7Parser = class extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments);
        this.audioLength = 0;
      }
      async parse() {
        const header = await this.tokenizer.readToken(SV7.Header);
        if (header.signature !== "MP+")
          throw new Error("Unexpected magic number");
        debug(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);
        this.metadata.setFormat("container", "Musepack, SV7");
        this.metadata.setFormat("sampleRate", header.sampleFrequency);
        const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
        this.metadata.setFormat("numberOfSamples", numberOfSamples);
        this.duration = numberOfSamples / header.sampleFrequency;
        this.metadata.setFormat("duration", this.duration);
        this.bitreader = new BitReader_1.BitReader(this.tokenizer);
        this.metadata.setFormat("numberOfChannels", header.midSideStereo || header.intensityStereo ? 2 : 1);
        const version = await this.bitreader.read(8);
        this.metadata.setFormat("codec", (version / 100).toFixed(2));
        await this.skipAudioData(header.frameCount);
        debug(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);
        return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
      }
      async skipAudioData(frameCount) {
        while (frameCount-- > 0) {
          const frameLength = await this.bitreader.read(20);
          this.audioLength += 20 + frameLength;
          await this.bitreader.ignore(frameLength);
        }
        const lastFrameLength = await this.bitreader.read(11);
        this.audioLength += lastFrameLength;
        this.metadata.setFormat("bitrate", this.audioLength / this.duration);
      }
    };
    exports2.MpcSv7Parser = MpcSv7Parser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/index.js
var require_musepack = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/musepack/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = require_browser();
    var Token2 = require_lib2();
    var AbstractID3Parser_1 = require_AbstractID3Parser();
    var MpcSv8Parser_1 = require_MpcSv8Parser();
    var MpcSv7Parser_1 = require_MpcSv7Parser();
    var debug = (0, debug_1.default)("music-metadata:parser:musepack");
    var MusepackParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      async postId3v2Parse() {
        const signature = await this.tokenizer.peekToken(new Token2.StringType(3, "binary"));
        let mpcParser;
        switch (signature) {
          case "MP+": {
            debug("Musepack stream-version 7");
            mpcParser = new MpcSv7Parser_1.MpcSv7Parser();
            break;
          }
          case "MPC": {
            debug("Musepack stream-version 8");
            mpcParser = new MpcSv8Parser_1.MpcSv8Parser();
            break;
          }
          default: {
            throw new Error("Invalid Musepack signature prefix");
          }
        }
        mpcParser.init(this.metadata, this.tokenizer, this.options);
        return mpcParser.parse();
      }
    };
    exports2.default = MusepackParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/opus/Opus.js
var require_Opus = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/opus/Opus.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdHeader = void 0;
    var Token2 = require_lib2();
    var IdHeader = class {
      constructor(len) {
        this.len = len;
        if (len < 19) {
          throw new Error("ID-header-page 0 should be at least 19 bytes long");
        }
      }
      get(buf, off) {
        return {
          magicSignature: new Token2.StringType(8, "ascii").get(buf, off + 0),
          version: buf.readUInt8(off + 8),
          channelCount: buf.readUInt8(off + 9),
          preSkip: buf.readInt16LE(off + 10),
          inputSampleRate: buf.readInt32LE(off + 12),
          outputGain: buf.readInt16LE(off + 16),
          channelMapping: buf.readUInt8(off + 18)
        };
      }
    };
    exports2.IdHeader = IdHeader;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/opus/OpusParser.js
var require_OpusParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/opus/OpusParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OpusParser = void 0;
    var Token2 = require_lib2();
    var VorbisParser_1 = require_VorbisParser();
    var Opus = require_Opus();
    var OpusParser = class extends VorbisParser_1.VorbisParser {
      constructor(metadata, options, tokenizer) {
        super(metadata, options);
        this.tokenizer = tokenizer;
        this.lastPos = -1;
      }
      /**
       * Parse first Opus Ogg page
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        this.metadata.setFormat("codec", "Opus");
        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);
        if (this.idHeader.magicSignature !== "OpusHead")
          throw new Error("Illegal ogg/Opus magic-signature");
        this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate);
        this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
      }
      parseFullPage(pageData) {
        const magicSignature = new Token2.StringType(8, "ascii").get(pageData, 0);
        switch (magicSignature) {
          case "OpusTags":
            this.parseUserCommentList(pageData, 8);
            this.lastPos = this.tokenizer.position - pageData.length;
            break;
          default:
            break;
        }
      }
      calculateDuration(header) {
        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
          const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;
          this.metadata.setFormat("numberOfSamples", pos_48bit);
          this.metadata.setFormat("duration", pos_48bit / 48e3);
          if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
            const dataSize = this.tokenizer.fileInfo.size - this.lastPos;
            this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
          }
        }
      }
    };
    exports2.OpusParser = OpusParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/speex/Speex.js
var require_Speex = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/speex/Speex.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Header = void 0;
    var Token2 = require_lib2();
    var util = require_Util();
    exports2.Header = {
      len: 80,
      get: (buf, off) => {
        return {
          speex: new Token2.StringType(8, "ascii").get(buf, off + 0),
          version: util.trimRightNull(new Token2.StringType(20, "ascii").get(buf, off + 8)),
          version_id: buf.readInt32LE(off + 28),
          header_size: buf.readInt32LE(off + 32),
          rate: buf.readInt32LE(off + 36),
          mode: buf.readInt32LE(off + 40),
          mode_bitstream_version: buf.readInt32LE(off + 44),
          nb_channels: buf.readInt32LE(off + 48),
          bitrate: buf.readInt32LE(off + 52),
          frame_size: buf.readInt32LE(off + 56),
          vbr: buf.readInt32LE(off + 60),
          frames_per_packet: buf.readInt32LE(off + 64),
          extra_headers: buf.readInt32LE(off + 68),
          reserved1: buf.readInt32LE(off + 72),
          reserved2: buf.readInt32LE(off + 76)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/speex/SpeexParser.js
var require_SpeexParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/speex/SpeexParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpeexParser = void 0;
    var debug_1 = require_browser();
    var VorbisParser_1 = require_VorbisParser();
    var Speex = require_Speex();
    var debug = (0, debug_1.default)("music-metadata:parser:ogg:speex");
    var SpeexParser = class extends VorbisParser_1.VorbisParser {
      constructor(metadata, options, tokenizer) {
        super(metadata, options);
        this.tokenizer = tokenizer;
      }
      /**
       * Parse first Speex Ogg page
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        debug("First Ogg/Speex page");
        const speexHeader = Speex.Header.get(pageData, 0);
        this.metadata.setFormat("codec", `Speex ${speexHeader.version}`);
        this.metadata.setFormat("numberOfChannels", speexHeader.nb_channels);
        this.metadata.setFormat("sampleRate", speexHeader.rate);
        if (speexHeader.bitrate !== -1) {
          this.metadata.setFormat("bitrate", speexHeader.bitrate);
        }
      }
    };
    exports2.SpeexParser = SpeexParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/theora/Theora.js
var require_Theora = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/theora/Theora.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdentificationHeader = void 0;
    var Token2 = require_lib2();
    exports2.IdentificationHeader = {
      len: 42,
      get: (buf, off) => {
        return {
          id: new Token2.StringType(7, "ascii").get(buf, off),
          vmaj: buf.readUInt8(off + 7),
          vmin: buf.readUInt8(off + 8),
          vrev: buf.readUInt8(off + 9),
          vmbw: buf.readUInt16BE(off + 10),
          vmbh: buf.readUInt16BE(off + 17),
          nombr: Token2.UINT24_BE.get(buf, off + 37),
          nqual: buf.readUInt8(off + 40)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/theora/TheoraParser.js
var require_TheoraParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/theora/TheoraParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TheoraParser = void 0;
    var debug_1 = require_browser();
    var Theora_1 = require_Theora();
    var debug = (0, debug_1.default)("music-metadata:parser:ogg:theora");
    var TheoraParser = class {
      constructor(metadata, options, tokenizer) {
        this.metadata = metadata;
        this.tokenizer = tokenizer;
      }
      /**
       * Vorbis 1 parser
       * @param header Ogg Page Header
       * @param pageData Page data
       */
      parsePage(header, pageData) {
        if (header.headerType.firstPage) {
          this.parseFirstPage(header, pageData);
        }
      }
      flush() {
        debug("flush");
      }
      calculateDuration(header) {
        debug("duration calculation not implemented");
      }
      /**
       * Parse first Theora Ogg page. the initial identification header packet
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        debug("First Ogg/Theora page");
        this.metadata.setFormat("codec", "Theora");
        const idHeader = Theora_1.IdentificationHeader.get(pageData, 0);
        this.metadata.setFormat("bitrate", idHeader.nombr);
      }
    };
    exports2.TheoraParser = TheoraParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/OggParser.js
var require_OggParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ogg/OggParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OggParser = exports2.SegmentTable = void 0;
    var Token2 = require_lib2();
    var core_1 = require_core();
    var debug_1 = require_browser();
    var util = require_Util();
    var FourCC_1 = require_FourCC();
    var BasicParser_1 = require_BasicParser();
    var VorbisParser_1 = require_VorbisParser();
    var OpusParser_1 = require_OpusParser();
    var SpeexParser_1 = require_SpeexParser();
    var TheoraParser_1 = require_TheoraParser();
    var debug = (0, debug_1.default)("music-metadata:parser:ogg");
    var SegmentTable = class _SegmentTable {
      static sum(buf, off, len) {
        let s = 0;
        for (let i = off; i < off + len; ++i) {
          s += buf[i];
        }
        return s;
      }
      constructor(header) {
        this.len = header.page_segments;
      }
      get(buf, off) {
        return {
          totalPageSize: _SegmentTable.sum(buf, off, this.len)
        };
      }
    };
    exports2.SegmentTable = SegmentTable;
    var OggParser = class _OggParser extends BasicParser_1.BasicParser {
      /**
       * Parse page
       * @returns {Promise<void>}
       */
      async parse() {
        debug("pos=%s, parsePage()", this.tokenizer.position);
        try {
          let header;
          do {
            header = await this.tokenizer.readToken(_OggParser.Header);
            if (header.capturePattern !== "OggS")
              throw new Error("Invalid Ogg capture pattern");
            this.metadata.setFormat("container", "Ogg");
            this.header = header;
            this.pageNumber = header.pageSequenceNo;
            debug("page#=%s, Ogg.id=%s", header.pageSequenceNo, header.capturePattern);
            const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));
            debug("totalPageSize=%s", segmentTable.totalPageSize);
            const pageData = await this.tokenizer.readToken(new Token2.Uint8ArrayType(segmentTable.totalPageSize));
            debug("firstPage=%s, lastPage=%s, continued=%s", header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
            if (header.headerType.firstPage) {
              const id = new Token2.StringType(7, "ascii").get(Buffer.from(pageData), 0);
              switch (id) {
                case "vorbis":
                  debug("Set page consumer to Ogg/Vorbis");
                  this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);
                  break;
                case "OpusHea":
                  debug("Set page consumer to Ogg/Opus");
                  this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);
                  break;
                case "Speex  ":
                  debug("Set page consumer to Ogg/Speex");
                  this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);
                  break;
                case "fishead":
                case "\0theora":
                  debug("Set page consumer to Ogg/Theora");
                  this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);
                  break;
                default:
                  throw new Error("gg audio-codec not recognized (id=" + id + ")");
              }
            }
            this.pageConsumer.parsePage(header, pageData);
          } while (!header.headerType.lastPage);
        } catch (err) {
          if (err instanceof core_1.EndOfStreamError) {
            this.metadata.addWarning("Last OGG-page is not marked with last-page flag");
            debug(`End-of-stream`);
            this.metadata.addWarning("Last OGG-page is not marked with last-page flag");
            if (this.header) {
              this.pageConsumer.calculateDuration(this.header);
            }
          } else if (err.message.startsWith("FourCC")) {
            if (this.pageNumber > 0) {
              this.metadata.addWarning("Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag");
              this.pageConsumer.flush();
            }
          } else {
            throw err;
          }
        }
      }
    };
    OggParser.Header = {
      len: 27,
      get: (buf, off) => {
        return {
          capturePattern: FourCC_1.FourCcToken.get(buf, off),
          version: Token2.UINT8.get(buf, off + 4),
          headerType: {
            continued: util.getBit(buf, off + 5, 0),
            firstPage: util.getBit(buf, off + 5, 1),
            lastPage: util.getBit(buf, off + 5, 2)
          },
          // packet_flag: buf.readUInt8(off + 5),
          absoluteGranulePosition: Number(Token2.UINT64_LE.get(buf, off + 6)),
          streamSerialNumber: Token2.UINT32_LE.get(buf, off + 14),
          pageSequenceNo: Token2.UINT32_LE.get(buf, off + 18),
          pageChecksum: Token2.UINT32_LE.get(buf, off + 22),
          page_segments: Token2.UINT8.get(buf, off + 26)
        };
      }
    };
    exports2.OggParser = OggParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/riff/RiffChunk.js
var require_RiffChunk = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/riff/RiffChunk.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListInfoTagValue = exports2.Header = void 0;
    var Token2 = require_lib2();
    exports2.Header = {
      len: 8,
      get: (buf, off) => {
        return {
          // Group-ID
          chunkID: buf.toString("binary", off, off + 4),
          // Size
          chunkSize: Token2.UINT32_LE.get(buf, 4)
        };
      }
    };
    var ListInfoTagValue = class {
      constructor(tagHeader) {
        this.tagHeader = tagHeader;
        this.len = tagHeader.chunkSize;
        this.len += this.len & 1;
      }
      get(buf, off) {
        return new Token2.StringType(this.tagHeader.chunkSize, "ascii").get(buf, off);
      }
    };
    exports2.ListInfoTagValue = ListInfoTagValue;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/wav/WaveChunk.js
var require_WaveChunk = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/wav/WaveChunk.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FactChunk = exports2.Format = exports2.WaveFormat = void 0;
    var WaveFormat;
    (function(WaveFormat2) {
      WaveFormat2[WaveFormat2["PCM"] = 1] = "PCM";
      WaveFormat2[WaveFormat2["ADPCM"] = 2] = "ADPCM";
      WaveFormat2[WaveFormat2["IEEE_FLOAT"] = 3] = "IEEE_FLOAT";
      WaveFormat2[WaveFormat2["MPEG_ADTS_AAC"] = 5632] = "MPEG_ADTS_AAC";
      WaveFormat2[WaveFormat2["MPEG_LOAS"] = 5634] = "MPEG_LOAS";
      WaveFormat2[WaveFormat2["RAW_AAC1"] = 255] = "RAW_AAC1";
      WaveFormat2[WaveFormat2["DOLBY_AC3_SPDIF"] = 146] = "DOLBY_AC3_SPDIF";
      WaveFormat2[WaveFormat2["DVM"] = 8192] = "DVM";
      WaveFormat2[WaveFormat2["RAW_SPORT"] = 576] = "RAW_SPORT";
      WaveFormat2[WaveFormat2["ESST_AC3"] = 577] = "ESST_AC3";
      WaveFormat2[WaveFormat2["DRM"] = 9] = "DRM";
      WaveFormat2[WaveFormat2["DTS2"] = 8193] = "DTS2";
      WaveFormat2[WaveFormat2["MPEG"] = 80] = "MPEG";
    })(WaveFormat = exports2.WaveFormat || (exports2.WaveFormat = {}));
    var Format = class {
      constructor(header) {
        if (header.chunkSize < 16)
          throw new Error("Invalid chunk size");
        this.len = header.chunkSize;
      }
      get(buf, off) {
        return {
          wFormatTag: buf.readUInt16LE(off),
          nChannels: buf.readUInt16LE(off + 2),
          nSamplesPerSec: buf.readUInt32LE(off + 4),
          nAvgBytesPerSec: buf.readUInt32LE(off + 8),
          nBlockAlign: buf.readUInt16LE(off + 12),
          wBitsPerSample: buf.readUInt16LE(off + 14)
        };
      }
    };
    exports2.Format = Format;
    var FactChunk = class {
      constructor(header) {
        if (header.chunkSize < 4) {
          throw new Error("Invalid fact chunk size.");
        }
        this.len = header.chunkSize;
      }
      get(buf, off) {
        return {
          dwSampleLength: buf.readUInt32LE(off)
        };
      }
    };
    exports2.FactChunk = FactChunk;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/wav/BwfChunk.js
var require_BwfChunk = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/wav/BwfChunk.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BroadcastAudioExtensionChunk = void 0;
    var Token2 = require_lib2();
    var Util_1 = require_Util();
    exports2.BroadcastAudioExtensionChunk = {
      len: 420,
      get: (uint8array, off) => {
        return {
          description: (0, Util_1.stripNulls)(new Token2.StringType(256, "ascii").get(uint8array, off)).trim(),
          originator: (0, Util_1.stripNulls)(new Token2.StringType(32, "ascii").get(uint8array, off + 256)).trim(),
          originatorReference: (0, Util_1.stripNulls)(new Token2.StringType(32, "ascii").get(uint8array, off + 288)).trim(),
          originationDate: (0, Util_1.stripNulls)(new Token2.StringType(10, "ascii").get(uint8array, off + 320)).trim(),
          originationTime: (0, Util_1.stripNulls)(new Token2.StringType(8, "ascii").get(uint8array, off + 330)).trim(),
          timeReferenceLow: Token2.UINT32_LE.get(uint8array, off + 338),
          timeReferenceHigh: Token2.UINT32_LE.get(uint8array, off + 342),
          version: Token2.UINT16_LE.get(uint8array, off + 346),
          umid: new Token2.Uint8ArrayType(64).get(uint8array, off + 348),
          loudnessValue: Token2.UINT16_LE.get(uint8array, off + 412),
          maxTruePeakLevel: Token2.UINT16_LE.get(uint8array, off + 414),
          maxMomentaryLoudness: Token2.UINT16_LE.get(uint8array, off + 416),
          maxShortTermLoudness: Token2.UINT16_LE.get(uint8array, off + 418)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/wav/WaveParser.js
var require_WaveParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/wav/WaveParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WaveParser = void 0;
    var strtok32 = require_core();
    var Token2 = require_lib2();
    var debug_1 = require_browser();
    var riff = require_RiffChunk();
    var WaveChunk = require_WaveChunk();
    var ID3v2Parser_1 = require_ID3v2Parser();
    var util = require_Util();
    var FourCC_1 = require_FourCC();
    var BasicParser_1 = require_BasicParser();
    var BwfChunk_1 = require_BwfChunk();
    var debug = (0, debug_1.default)("music-metadata:parser:RIFF");
    var WaveParser = class extends BasicParser_1.BasicParser {
      async parse() {
        const riffHeader = await this.tokenizer.readToken(riff.Header);
        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);
        if (riffHeader.chunkID !== "RIFF")
          return;
        return this.parseRiffChunk(riffHeader.chunkSize).catch((err) => {
          if (!(err instanceof strtok32.EndOfStreamError)) {
            throw err;
          }
        });
      }
      async parseRiffChunk(chunkSize) {
        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);
        this.metadata.setFormat("container", type);
        switch (type) {
          case "WAVE":
            return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);
          default:
            throw new Error(`Unsupported RIFF format: RIFF/${type}`);
        }
      }
      async readWaveChunk(remaining) {
        while (remaining >= riff.Header.len) {
          const header = await this.tokenizer.readToken(riff.Header);
          remaining -= riff.Header.len + header.chunkSize;
          if (header.chunkSize > remaining) {
            this.metadata.addWarning("Data chunk size exceeds file size");
          }
          this.header = header;
          debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);
          switch (header.chunkID) {
            case "LIST":
              await this.parseListTag(header);
              break;
            case "fact":
              this.metadata.setFormat("lossless", false);
              this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));
              break;
            case "fmt ":
              const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));
              let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];
              if (!subFormat) {
                debug("WAVE/non-PCM format=" + fmt.wFormatTag);
                subFormat = "non-PCM (" + fmt.wFormatTag + ")";
              }
              this.metadata.setFormat("codec", subFormat);
              this.metadata.setFormat("bitsPerSample", fmt.wBitsPerSample);
              this.metadata.setFormat("sampleRate", fmt.nSamplesPerSec);
              this.metadata.setFormat("numberOfChannels", fmt.nChannels);
              this.metadata.setFormat("bitrate", fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
              this.blockAlign = fmt.nBlockAlign;
              break;
            case "id3 ":
            case "ID3 ":
              const id3_data = await this.tokenizer.readToken(new Token2.Uint8ArrayType(header.chunkSize));
              const rst = strtok32.fromBuffer(id3_data);
              await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
              break;
            case "data":
              if (this.metadata.format.lossless !== false) {
                this.metadata.setFormat("lossless", true);
              }
              let chunkSize = header.chunkSize;
              if (this.tokenizer.fileInfo.size) {
                const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
                if (calcRemaining < chunkSize) {
                  this.metadata.addWarning("data chunk length exceeding file length");
                  chunkSize = calcRemaining;
                }
              }
              const numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 4294967295 ? void 0 : chunkSize / this.blockAlign;
              if (numberOfSamples) {
                this.metadata.setFormat("numberOfSamples", numberOfSamples);
                this.metadata.setFormat("duration", numberOfSamples / this.metadata.format.sampleRate);
              }
              if (this.metadata.format.codec === "ADPCM") {
                this.metadata.setFormat("bitrate", 352e3);
              } else {
                this.metadata.setFormat("bitrate", this.blockAlign * this.metadata.format.sampleRate * 8);
              }
              await this.tokenizer.ignore(header.chunkSize);
              break;
            case "bext":
              const bext = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);
              Object.keys(bext).forEach((key) => {
                this.metadata.addTag("exif", "bext." + key, bext[key]);
              });
              const bextRemaining = header.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;
              await this.tokenizer.ignore(bextRemaining);
              break;
            case "\0\0\0\0":
              debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
              this.metadata.addWarning("Ignore chunk: RIFF/" + header.chunkID);
              await this.tokenizer.ignore(header.chunkSize);
              break;
            default:
              debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
              this.metadata.addWarning("Ignore chunk: RIFF/" + header.chunkID);
              await this.tokenizer.ignore(header.chunkSize);
          }
          if (this.header.chunkSize % 2 === 1) {
            debug("Read odd padding byte");
            await this.tokenizer.ignore(1);
          }
        }
      }
      async parseListTag(listHeader) {
        const listType = await this.tokenizer.readToken(new Token2.StringType(4, "binary"));
        debug("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, listType);
        switch (listType) {
          case "INFO":
            return this.parseRiffInfoTags(listHeader.chunkSize - 4);
          case "adtl":
          default:
            this.metadata.addWarning("Ignore chunk: RIFF/WAVE/LIST/" + listType);
            debug("Ignoring chunkID=RIFF/WAVE/LIST/" + listType);
            return this.tokenizer.ignore(listHeader.chunkSize - 4).then();
        }
      }
      async parseRiffInfoTags(chunkSize) {
        while (chunkSize >= 8) {
          const header = await this.tokenizer.readToken(riff.Header);
          const valueToken = new riff.ListInfoTagValue(header);
          const value = await this.tokenizer.readToken(valueToken);
          this.addTag(header.chunkID, util.stripNulls(value));
          chunkSize -= 8 + valueToken.len;
        }
        if (chunkSize !== 0) {
          throw Error("Illegal remaining size: " + chunkSize);
        }
      }
      addTag(id, value) {
        this.metadata.addTag("exif", id, value);
      }
    };
    exports2.WaveParser = WaveParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/wavpack/WavPackToken.js
var require_WavPackToken = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/wavpack/WavPackToken.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WavPack = void 0;
    var Token2 = require_lib2();
    var FourCC_1 = require_FourCC();
    var SampleRates = [
      6e3,
      8e3,
      9600,
      11025,
      12e3,
      16e3,
      22050,
      24e3,
      32e3,
      44100,
      48e3,
      64e3,
      88200,
      96e3,
      192e3,
      -1
    ];
    var WavPack = class _WavPack {
      static isBitSet(flags2, bitOffset) {
        return _WavPack.getBitAllignedNumber(flags2, bitOffset, 1) === 1;
      }
      static getBitAllignedNumber(flags2, bitOffset, len) {
        return flags2 >>> bitOffset & 4294967295 >>> 32 - len;
      }
    };
    WavPack.BlockHeaderToken = {
      len: 32,
      get: (buf, off) => {
        const flags2 = Token2.UINT32_LE.get(buf, off + 24);
        const res = {
          // should equal 'wvpk'
          BlockID: FourCC_1.FourCcToken.get(buf, off),
          //  0x402 to 0x410 are valid for decode
          blockSize: Token2.UINT32_LE.get(buf, off + 4),
          //  0x402 (1026) to 0x410 are valid for decode
          version: Token2.UINT16_LE.get(buf, off + 8),
          //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
          totalSamples: (
            /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */
            Token2.UINT32_LE.get(buf, off + 12)
          ),
          // 40-bit block_index
          blockIndex: (
            /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */
            Token2.UINT32_LE.get(buf, off + 16)
          ),
          // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
          blockSamples: Token2.UINT32_LE.get(buf, off + 20),
          // various flags for id and decoding
          flags: {
            bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags2, 0, 2)) * 8,
            isMono: WavPack.isBitSet(flags2, 2),
            isHybrid: WavPack.isBitSet(flags2, 3),
            isJointStereo: WavPack.isBitSet(flags2, 4),
            crossChannel: WavPack.isBitSet(flags2, 5),
            hybridNoiseShaping: WavPack.isBitSet(flags2, 6),
            floatingPoint: WavPack.isBitSet(flags2, 7),
            samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags2, 23, 4)],
            isDSD: WavPack.isBitSet(flags2, 31)
          },
          // crc for actual decoded data
          crc: new Token2.Uint8ArrayType(4).get(buf, off + 28)
        };
        if (res.flags.isDSD) {
          res.totalSamples *= 8;
        }
        return res;
      }
    };
    WavPack.MetadataIdToken = {
      len: 1,
      get: (buf, off) => {
        return {
          functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),
          isOptional: WavPack.isBitSet(buf[off], 5),
          isOddSize: WavPack.isBitSet(buf[off], 6),
          largeBlock: WavPack.isBitSet(buf[off], 7)
        };
      }
    };
    exports2.WavPack = WavPack;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/wavpack/WavPackParser.js
var require_WavPackParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/wavpack/WavPackParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WavPackParser = void 0;
    var Token2 = require_lib2();
    var APEv2Parser_1 = require_APEv2Parser();
    var FourCC_1 = require_FourCC();
    var BasicParser_1 = require_BasicParser();
    var WavPackToken_1 = require_WavPackToken();
    var debug_1 = require_browser();
    var debug = (0, debug_1.default)("music-metadata:parser:WavPack");
    var WavPackParser = class extends BasicParser_1.BasicParser {
      async parse() {
        this.audioDataSize = 0;
        await this.parseWavPackBlocks();
        return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
      }
      async parseWavPackBlocks() {
        do {
          const blockId = await this.tokenizer.peekToken(FourCC_1.FourCcToken);
          if (blockId !== "wvpk")
            break;
          const header = await this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);
          if (header.BlockID !== "wvpk")
            throw new Error("Invalid WavPack Block-ID");
          debug(`WavPack header blockIndex=${header.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`);
          if (header.blockIndex === 0 && !this.metadata.format.container) {
            this.metadata.setFormat("container", "WavPack");
            this.metadata.setFormat("lossless", !header.flags.isHybrid);
            this.metadata.setFormat("bitsPerSample", header.flags.bitsPerSample);
            if (!header.flags.isDSD) {
              this.metadata.setFormat("sampleRate", header.flags.samplingRate);
              this.metadata.setFormat("duration", header.totalSamples / header.flags.samplingRate);
            }
            this.metadata.setFormat("numberOfChannels", header.flags.isMono ? 1 : 2);
            this.metadata.setFormat("numberOfSamples", header.totalSamples);
            this.metadata.setFormat("codec", header.flags.isDSD ? "DSD" : "PCM");
          }
          const ignoreBytes = header.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);
          await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes));
          if (header.blockSamples > 0) {
            this.audioDataSize += header.blockSize;
          }
        } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);
        this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
      }
      /**
       * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
       * @param remainingLength
       */
      async parseMetadataSubBlock(header, remainingLength) {
        while (remainingLength > WavPackToken_1.WavPack.MetadataIdToken.len) {
          const id = await this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken);
          const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? Token2.UINT24_LE : Token2.UINT8);
          const data = Buffer.alloc(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
          await this.tokenizer.readBuffer(data);
          debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);
          switch (id.functionId) {
            case 0:
              break;
            case 14:
              debug("ID_DSD_BLOCK");
              const mp = 1 << data.readUInt8(0);
              const samplingRate = header.flags.samplingRate * mp * 8;
              if (!header.flags.isDSD)
                throw new Error("Only expect DSD block if DSD-flag is set");
              this.metadata.setFormat("sampleRate", samplingRate);
              this.metadata.setFormat("duration", header.totalSamples / samplingRate);
              break;
            case 36:
              debug("ID_ALT_TRAILER: trailer for non-wav files");
              break;
            case 38:
              this.metadata.setFormat("audioMD5", data);
              break;
            case 47:
              debug(`ID_BLOCK_CHECKSUM: checksum=${data.toString("hex")}`);
              break;
            default:
              debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);
              break;
          }
          remainingLength -= WavPackToken_1.WavPack.MetadataIdToken.len + (id.largeBlock ? Token2.UINT24_LE.len : Token2.UINT8.len) + dataSizeInWords * 2;
          debug(`remainingLength=${remainingLength}`);
          if (id.isOddSize)
            this.tokenizer.ignore(1);
        }
        if (remainingLength !== 0)
          throw new Error("metadata-sub-block should fit it remaining length");
      }
    };
    exports2.WavPackParser = WavPackParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsf/DsfChunk.js
var require_DsfChunk = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsf/DsfChunk.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormatChunk = exports2.ChannelType = exports2.DsdChunk = exports2.ChunkHeader = void 0;
    var Token2 = require_lib2();
    var FourCC_1 = require_FourCC();
    exports2.ChunkHeader = {
      len: 12,
      get: (buf, off) => {
        return { id: FourCC_1.FourCcToken.get(buf, off), size: Token2.UINT64_LE.get(buf, off + 4) };
      }
    };
    exports2.DsdChunk = {
      len: 16,
      get: (buf, off) => {
        return {
          fileSize: Token2.INT64_LE.get(buf, off),
          metadataPointer: Token2.INT64_LE.get(buf, off + 8)
        };
      }
    };
    var ChannelType;
    (function(ChannelType2) {
      ChannelType2[ChannelType2["mono"] = 1] = "mono";
      ChannelType2[ChannelType2["stereo"] = 2] = "stereo";
      ChannelType2[ChannelType2["channels"] = 3] = "channels";
      ChannelType2[ChannelType2["quad"] = 4] = "quad";
      ChannelType2[ChannelType2["4 channels"] = 5] = "4 channels";
      ChannelType2[ChannelType2["5 channels"] = 6] = "5 channels";
      ChannelType2[ChannelType2["5.1 channels"] = 7] = "5.1 channels";
    })(ChannelType = exports2.ChannelType || (exports2.ChannelType = {}));
    exports2.FormatChunk = {
      len: 40,
      get: (buf, off) => {
        return {
          formatVersion: Token2.INT32_LE.get(buf, off),
          formatID: Token2.INT32_LE.get(buf, off + 4),
          channelType: Token2.INT32_LE.get(buf, off + 8),
          channelNum: Token2.INT32_LE.get(buf, off + 12),
          samplingFrequency: Token2.INT32_LE.get(buf, off + 16),
          bitsPerSample: Token2.INT32_LE.get(buf, off + 20),
          sampleCount: Token2.INT64_LE.get(buf, off + 24),
          blockSizePerChannel: Token2.INT32_LE.get(buf, off + 32)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsf/DsfParser.js
var require_DsfParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsf/DsfParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DsfParser = void 0;
    var debug_1 = require_browser();
    var AbstractID3Parser_1 = require_AbstractID3Parser();
    var DsfChunk_1 = require_DsfChunk();
    var ID3v2Parser_1 = require_ID3v2Parser();
    var debug = (0, debug_1.default)("music-metadata:parser:DSF");
    var DsfParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      async postId3v2Parse() {
        const p0 = this.tokenizer.position;
        const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
        if (chunkHeader.id !== "DSD ")
          throw new Error("Invalid chunk signature");
        this.metadata.setFormat("container", "DSF");
        this.metadata.setFormat("lossless", true);
        const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);
        if (dsdChunk.metadataPointer === BigInt(0)) {
          debug(`No ID3v2 tag present`);
        } else {
          debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);
          await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
          await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);
          return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
        }
      }
      async parseChunks(bytesRemaining) {
        while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {
          const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
          debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);
          switch (chunkHeader.id) {
            case "fmt ":
              const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);
              this.metadata.setFormat("numberOfChannels", formatChunk.channelNum);
              this.metadata.setFormat("sampleRate", formatChunk.samplingFrequency);
              this.metadata.setFormat("bitsPerSample", formatChunk.bitsPerSample);
              this.metadata.setFormat("numberOfSamples", formatChunk.sampleCount);
              this.metadata.setFormat("duration", Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
              const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
              this.metadata.setFormat("bitrate", bitrate);
              return;
            default:
              this.tokenizer.ignore(Number(chunkHeader.size) - DsfChunk_1.ChunkHeader.len);
              break;
          }
          bytesRemaining -= chunkHeader.size;
        }
      }
    };
    exports2.DsfParser = DsfParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsdiff/DsdiffToken.js
var require_DsdiffToken = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsdiff/DsdiffToken.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChunkHeader64 = void 0;
    var Token2 = require_lib2();
    var FourCC_1 = require_FourCC();
    exports2.ChunkHeader64 = {
      len: 12,
      get: (buf, off) => {
        return {
          // Group-ID
          chunkID: FourCC_1.FourCcToken.get(buf, off),
          // Size
          chunkSize: Token2.INT64_BE.get(buf, off + 4)
        };
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsdiff/DsdiffParser.js
var require_DsdiffParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DsdiffParser = void 0;
    var Token2 = require_lib2();
    var debug_1 = require_browser();
    var strtok32 = require_core();
    var FourCC_1 = require_FourCC();
    var BasicParser_1 = require_BasicParser();
    var ID3v2Parser_1 = require_ID3v2Parser();
    var DsdiffToken_1 = require_DsdiffToken();
    var debug = (0, debug_1.default)("music-metadata:parser:aiff");
    var DsdiffParser = class extends BasicParser_1.BasicParser {
      async parse() {
        const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
        if (header.chunkID !== "FRM8")
          throw new Error("Unexpected chunk-ID");
        const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();
        switch (type) {
          case "DSD":
            this.metadata.setFormat("container", `DSDIFF/${type}`);
            this.metadata.setFormat("lossless", true);
            return this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));
          default:
            throw Error(`Unsupported DSDIFF type: ${type}`);
        }
      }
      async readFmt8Chunks(remainingSize) {
        while (remainingSize >= DsdiffToken_1.ChunkHeader64.len) {
          const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
          debug(`Chunk id=${chunkHeader.chunkID}`);
          await this.readData(chunkHeader);
          remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize;
        }
      }
      async readData(header) {
        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
        const p0 = this.tokenizer.position;
        switch (header.chunkID.trim()) {
          case "FVER":
            const version = await this.tokenizer.readToken(Token2.UINT32_LE);
            debug(`DSDIFF version=${version}`);
            break;
          case "PROP":
            const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);
            if (propType !== "SND ")
              throw new Error("Unexpected PROP-chunk ID");
            await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));
            break;
          case "ID3":
            const id3_data = await this.tokenizer.readToken(new Token2.Uint8ArrayType(Number(header.chunkSize)));
            const rst = strtok32.fromBuffer(id3_data);
            await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
            break;
          default:
            debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
            break;
          case "DSD":
            this.metadata.setFormat("numberOfSamples", Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));
            this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
            break;
        }
        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);
        if (remaining > 0) {
          debug(`After Parsing chunk, remaining ${remaining} bytes`);
          await this.tokenizer.ignore(Number(remaining));
        }
      }
      async handleSoundPropertyChunks(remainingSize) {
        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
        while (remainingSize > 0) {
          const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
          debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
          const p0 = this.tokenizer.position;
          switch (sndPropHeader.chunkID.trim()) {
            case "FS":
              const sampleRate = await this.tokenizer.readToken(Token2.UINT32_BE);
              this.metadata.setFormat("sampleRate", sampleRate);
              break;
            case "CHNL":
              const numChannels = await this.tokenizer.readToken(Token2.UINT16_BE);
              this.metadata.setFormat("numberOfChannels", numChannels);
              await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token2.UINT16_BE.len));
              break;
            case "CMPR":
              const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();
              const count = await this.tokenizer.readToken(Token2.UINT8);
              const compressionName = await this.tokenizer.readToken(new Token2.StringType(count, "ascii"));
              if (compressionIdCode === "DSD") {
                this.metadata.setFormat("lossless", true);
                this.metadata.setFormat("bitsPerSample", 1);
              }
              this.metadata.setFormat("codec", `${compressionIdCode} (${compressionName})`);
              break;
            case "ABSS":
              const hours = await this.tokenizer.readToken(Token2.UINT16_BE);
              const minutes = await this.tokenizer.readToken(Token2.UINT8);
              const seconds = await this.tokenizer.readToken(Token2.UINT8);
              const samples = await this.tokenizer.readToken(Token2.UINT32_BE);
              debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);
              break;
            case "LSCO":
              const lsConfig = await this.tokenizer.readToken(Token2.UINT16_BE);
              debug(`LSCO lsConfig=${lsConfig}`);
              break;
            case "COMT":
            default:
              debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
              await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));
          }
          const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);
          if (remaining > 0) {
            debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);
            await this.tokenizer.ignore(Number(remaining));
          }
          remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;
          debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
        }
        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
          const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
          this.metadata.setFormat("bitrate", bitrate);
        }
      }
      async handleChannelChunks(remainingSize) {
        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);
        const channels = [];
        while (remainingSize >= FourCC_1.FourCcToken.len) {
          const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);
          debug(`Channel[ID=${channelId}]`);
          channels.push(channelId);
          remainingSize -= BigInt(FourCC_1.FourCcToken.len);
        }
        debug(`Channels: ${channels.join(", ")}`);
        return channels;
      }
    };
    exports2.DsdiffParser = DsdiffParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/MatroskaDtd.js
var require_MatroskaDtd = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/MatroskaDtd.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.elements = void 0;
    var types_1 = require_types();
    exports2.elements = {
      440786851: {
        name: "ebml",
        container: {
          17030: { name: "ebmlVersion", value: types_1.DataType.uint },
          17143: { name: "ebmlReadVersion", value: types_1.DataType.uint },
          17138: { name: "ebmlMaxIDWidth", value: types_1.DataType.uint },
          17139: { name: "ebmlMaxSizeWidth", value: types_1.DataType.uint },
          17026: { name: "docType", value: types_1.DataType.string },
          17031: { name: "docTypeVersion", value: types_1.DataType.uint },
          17029: { name: "docTypeReadVersion", value: types_1.DataType.uint }
          // 5.1.7
        }
      },
      // Matroska segments
      408125543: {
        name: "segment",
        container: {
          // Meta Seek Information
          290298740: {
            name: "seekHead",
            container: {
              19899: {
                name: "seek",
                container: {
                  21419: { name: "seekId", value: types_1.DataType.binary },
                  21420: { name: "seekPosition", value: types_1.DataType.uint }
                }
              }
            }
          },
          // Segment Information
          357149030: {
            name: "info",
            container: {
              29604: { name: "uid", value: types_1.DataType.uid },
              29572: { name: "filename", value: types_1.DataType.string },
              3979555: { name: "prevUID", value: types_1.DataType.uid },
              3965867: { name: "prevFilename", value: types_1.DataType.string },
              4110627: { name: "nextUID", value: types_1.DataType.uid },
              4096955: { name: "nextFilename", value: types_1.DataType.string },
              2807729: { name: "timecodeScale", value: types_1.DataType.uint },
              17545: { name: "duration", value: types_1.DataType.float },
              17505: { name: "dateUTC", value: types_1.DataType.uint },
              31657: { name: "title", value: types_1.DataType.string },
              19840: { name: "muxingApp", value: types_1.DataType.string },
              22337: { name: "writingApp", value: types_1.DataType.string }
            }
          },
          // Cluster
          524531317: {
            name: "cluster",
            multiple: true,
            container: {
              231: { name: "timecode", value: types_1.DataType.uid },
              163: { name: "unknown", value: types_1.DataType.binary },
              167: { name: "position", value: types_1.DataType.uid },
              171: { name: "prevSize", value: types_1.DataType.uid }
            }
          },
          // Track
          374648427: {
            name: "tracks",
            container: {
              174: {
                name: "entries",
                multiple: true,
                container: {
                  215: { name: "trackNumber", value: types_1.DataType.uint },
                  29637: { name: "uid", value: types_1.DataType.uid },
                  131: { name: "trackType", value: types_1.DataType.uint },
                  185: { name: "flagEnabled", value: types_1.DataType.bool },
                  136: { name: "flagDefault", value: types_1.DataType.bool },
                  21930: { name: "flagForced", value: types_1.DataType.bool },
                  156: { name: "flagLacing", value: types_1.DataType.bool },
                  28135: { name: "minCache", value: types_1.DataType.uint },
                  28136: { name: "maxCache", value: types_1.DataType.uint },
                  2352003: { name: "defaultDuration", value: types_1.DataType.uint },
                  2306383: { name: "timecodeScale", value: types_1.DataType.float },
                  21358: { name: "name", value: types_1.DataType.string },
                  2274716: { name: "language", value: types_1.DataType.string },
                  134: { name: "codecID", value: types_1.DataType.string },
                  25506: { name: "codecPrivate", value: types_1.DataType.binary },
                  2459272: { name: "codecName", value: types_1.DataType.string },
                  3839639: { name: "codecSettings", value: types_1.DataType.string },
                  3883072: { name: "codecInfoUrl", value: types_1.DataType.string },
                  2536e3: { name: "codecDownloadUrl", value: types_1.DataType.string },
                  170: { name: "codecDecodeAll", value: types_1.DataType.bool },
                  28587: { name: "trackOverlay", value: types_1.DataType.uint },
                  // Video
                  224: {
                    name: "video",
                    container: {
                      154: { name: "flagInterlaced", value: types_1.DataType.bool },
                      21432: { name: "stereoMode", value: types_1.DataType.uint },
                      176: { name: "pixelWidth", value: types_1.DataType.uint },
                      186: { name: "pixelHeight", value: types_1.DataType.uint },
                      21680: { name: "displayWidth", value: types_1.DataType.uint },
                      21690: { name: "displayHeight", value: types_1.DataType.uint },
                      21683: { name: "aspectRatioType", value: types_1.DataType.uint },
                      3061028: { name: "colourSpace", value: types_1.DataType.uint },
                      3126563: { name: "gammaValue", value: types_1.DataType.float }
                    }
                  },
                  // Audio
                  225: {
                    name: "audio",
                    container: {
                      181: { name: "samplingFrequency", value: types_1.DataType.float },
                      30901: { name: "outputSamplingFrequency", value: types_1.DataType.float },
                      159: { name: "channels", value: types_1.DataType.uint },
                      148: { name: "channels", value: types_1.DataType.uint },
                      32123: { name: "channelPositions", value: types_1.DataType.binary },
                      25188: { name: "bitDepth", value: types_1.DataType.uint }
                    }
                  },
                  // Content Encoding
                  28032: {
                    name: "contentEncodings",
                    container: {
                      25152: {
                        name: "contentEncoding",
                        container: {
                          20529: { name: "order", value: types_1.DataType.uint },
                          20530: { name: "scope", value: types_1.DataType.bool },
                          20531: { name: "type", value: types_1.DataType.uint },
                          20532: {
                            name: "contentEncoding",
                            container: {
                              16980: { name: "contentCompAlgo", value: types_1.DataType.uint },
                              16981: { name: "contentCompSettings", value: types_1.DataType.binary }
                            }
                          },
                          20533: {
                            name: "contentEncoding",
                            container: {
                              18401: { name: "contentEncAlgo", value: types_1.DataType.uint },
                              18402: { name: "contentEncKeyID", value: types_1.DataType.binary },
                              18403: { name: "contentSignature ", value: types_1.DataType.binary },
                              18404: { name: "ContentSigKeyID  ", value: types_1.DataType.binary },
                              18405: { name: "contentSigAlgo ", value: types_1.DataType.uint },
                              18406: { name: "contentSigHashAlgo ", value: types_1.DataType.uint }
                            }
                          },
                          25188: { name: "bitDepth", value: types_1.DataType.uint }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          // Cueing Data
          475249515: {
            name: "cues",
            container: {
              187: {
                name: "cuePoint",
                container: {
                  179: { name: "cueTime", value: types_1.DataType.uid },
                  183: {
                    name: "positions",
                    container: {
                      247: { name: "track", value: types_1.DataType.uint },
                      241: { name: "clusterPosition", value: types_1.DataType.uint },
                      21368: { name: "blockNumber", value: types_1.DataType.uint },
                      234: { name: "codecState", value: types_1.DataType.uint },
                      219: {
                        name: "reference",
                        container: {
                          150: { name: "time", value: types_1.DataType.uint },
                          151: { name: "cluster", value: types_1.DataType.uint },
                          21343: { name: "number", value: types_1.DataType.uint },
                          235: { name: "codecState", value: types_1.DataType.uint }
                        }
                      },
                      240: { name: "relativePosition", value: types_1.DataType.uint }
                      // extended
                    }
                  }
                }
              }
            }
          },
          // Attachment
          423732329: {
            name: "attachments",
            container: {
              24999: {
                name: "attachedFiles",
                multiple: true,
                container: {
                  18046: { name: "description", value: types_1.DataType.string },
                  18030: { name: "name", value: types_1.DataType.string },
                  18016: { name: "mimeType", value: types_1.DataType.string },
                  18012: { name: "data", value: types_1.DataType.binary },
                  18094: { name: "uid", value: types_1.DataType.uid }
                }
              }
            }
          },
          // Chapters
          272869232: {
            name: "chapters",
            container: {
              17849: {
                name: "editionEntry",
                container: {
                  182: {
                    name: "chapterAtom",
                    container: {
                      29636: { name: "uid", value: types_1.DataType.uid },
                      145: { name: "timeStart", value: types_1.DataType.uint },
                      146: { name: "timeEnd", value: types_1.DataType.uid },
                      152: { name: "hidden", value: types_1.DataType.bool },
                      17816: { name: "enabled", value: types_1.DataType.uid },
                      143: {
                        name: "track",
                        container: {
                          137: { name: "trackNumber", value: types_1.DataType.uid },
                          128: {
                            name: "display",
                            container: {
                              133: { name: "string", value: types_1.DataType.string },
                              17276: { name: "language ", value: types_1.DataType.string },
                              17278: { name: "country ", value: types_1.DataType.string }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          // Tagging
          307544935: {
            name: "tags",
            container: {
              29555: {
                name: "tag",
                multiple: true,
                container: {
                  25536: {
                    name: "target",
                    container: {
                      25541: { name: "tagTrackUID", value: types_1.DataType.uid },
                      25540: { name: "tagChapterUID", value: types_1.DataType.uint },
                      25542: { name: "tagAttachmentUID", value: types_1.DataType.uid },
                      25546: { name: "targetType", value: types_1.DataType.string },
                      26826: { name: "targetTypeValue", value: types_1.DataType.uint },
                      25545: { name: "tagEditionUID", value: types_1.DataType.uid }
                      // extended
                    }
                  },
                  26568: {
                    name: "simpleTags",
                    multiple: true,
                    container: {
                      17827: { name: "name", value: types_1.DataType.string },
                      17543: { name: "string", value: types_1.DataType.string },
                      17541: { name: "binary", value: types_1.DataType.binary },
                      17530: { name: "language", value: types_1.DataType.string },
                      17531: { name: "languageIETF", value: types_1.DataType.string },
                      17540: { name: "default", value: types_1.DataType.bool }
                      // extended
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/MatroskaParser.js
var require_MatroskaParser = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/matroska/MatroskaParser.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MatroskaParser = void 0;
    var token_types_1 = require_lib2();
    var debug_1 = require_browser();
    var BasicParser_1 = require_BasicParser();
    var types_1 = require_types();
    var matroskaDtd = require_MatroskaDtd();
    var debug = (0, debug_1.default)("music-metadata:parser:matroska");
    var MatroskaParser = class extends BasicParser_1.BasicParser {
      constructor() {
        super();
        this.padding = 0;
        this.parserMap = /* @__PURE__ */ new Map();
        this.ebmlMaxIDLength = 4;
        this.ebmlMaxSizeLength = 8;
        this.parserMap.set(types_1.DataType.uint, (e) => this.readUint(e));
        this.parserMap.set(types_1.DataType.string, (e) => this.readString(e));
        this.parserMap.set(types_1.DataType.binary, (e) => this.readBuffer(e));
        this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1);
        this.parserMap.set(types_1.DataType.bool, (e) => this.readFlag(e));
        this.parserMap.set(types_1.DataType.float, (e) => this.readFloat(e));
      }
      /**
       * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
       * @param {INativeMetadataCollector} metadata Output
       * @param {ITokenizer} tokenizer Input
       * @param {IOptions} options Parsing options
       */
      init(metadata, tokenizer, options) {
        super.init(metadata, tokenizer, options);
        return this;
      }
      async parse() {
        const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);
        this.metadata.setFormat("container", `EBML/${matroska.ebml.docType}`);
        if (matroska.segment) {
          const info = matroska.segment.info;
          if (info) {
            const timecodeScale = info.timecodeScale ? info.timecodeScale : 1e6;
            if (typeof info.duration === "number") {
              const duration = info.duration * timecodeScale / 1e9;
              this.addTag("segment:title", info.title);
              this.metadata.setFormat("duration", duration);
            }
          }
          const audioTracks = matroska.segment.tracks;
          if (audioTracks && audioTracks.entries) {
            audioTracks.entries.forEach((entry) => {
              const stream2 = {
                codecName: entry.codecID.replace("A_", "").replace("V_", ""),
                codecSettings: entry.codecSettings,
                flagDefault: entry.flagDefault,
                flagLacing: entry.flagLacing,
                flagEnabled: entry.flagEnabled,
                language: entry.language,
                name: entry.name,
                type: entry.trackType,
                audio: entry.audio,
                video: entry.video
              };
              this.metadata.addStreamInfo(stream2);
            });
            const audioTrack = audioTracks.entries.filter((entry) => {
              return entry.trackType === types_1.TrackType.audio.valueOf();
            }).reduce((acc, cur) => {
              if (!acc) {
                return cur;
              }
              if (!acc.flagDefault && cur.flagDefault) {
                return cur;
              }
              if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {
                return cur;
              }
              return acc;
            }, null);
            if (audioTrack) {
              this.metadata.setFormat("codec", audioTrack.codecID.replace("A_", ""));
              this.metadata.setFormat("sampleRate", audioTrack.audio.samplingFrequency);
              this.metadata.setFormat("numberOfChannels", audioTrack.audio.channels);
            }
            if (matroska.segment.tags) {
              matroska.segment.tags.tag.forEach((tag) => {
                const target = tag.target;
                const targetType = (target === null || target === void 0 ? void 0 : target.targetTypeValue) ? types_1.TargetType[target.targetTypeValue] : (target === null || target === void 0 ? void 0 : target.targetType) ? target.targetType : "track";
                tag.simpleTags.forEach((simpleTag) => {
                  const value = simpleTag.string ? simpleTag.string : simpleTag.binary;
                  this.addTag(`${targetType}:${simpleTag.name}`, value);
                });
              });
            }
            if (matroska.segment.attachments) {
              matroska.segment.attachments.attachedFiles.filter((file) => file.mimeType.startsWith("image/")).map((file) => {
                return {
                  data: file.data,
                  format: file.mimeType,
                  description: file.description,
                  name: file.name
                };
              }).forEach((picture) => {
                this.addTag("picture", picture);
              });
            }
          }
        }
      }
      async parseContainer(container, posDone, path) {
        const tree = {};
        while (this.tokenizer.position < posDone) {
          let element;
          try {
            element = await this.readElement();
          } catch (error) {
            if (error.message === "End-Of-Stream") {
              break;
            }
            throw error;
          }
          const type = container[element.id];
          if (type) {
            debug(`Element: name=${type.name}, container=${!!type.container}`);
            if (type.container) {
              const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));
              if (type.multiple) {
                if (!tree[type.name]) {
                  tree[type.name] = [];
                }
                tree[type.name].push(res);
              } else {
                tree[type.name] = res;
              }
            } else {
              tree[type.name] = await this.parserMap.get(type.value)(element);
            }
          } else {
            switch (element.id) {
              case 236:
                this.padding += element.len;
                await this.tokenizer.ignore(element.len);
                break;
              default:
                debug(`parseEbml: path=${path.join("/")}, unknown element: id=${element.id.toString(16)}`);
                this.padding += element.len;
                await this.tokenizer.ignore(element.len);
            }
          }
        }
        return tree;
      }
      async readVintData(maxLength) {
        const msb = await this.tokenizer.peekNumber(token_types_1.UINT8);
        let mask = 128;
        let oc = 1;
        while ((msb & mask) === 0) {
          if (oc > maxLength) {
            throw new Error("VINT value exceeding maximum size");
          }
          ++oc;
          mask >>= 1;
        }
        const id = Buffer.alloc(oc);
        await this.tokenizer.readBuffer(id);
        return id;
      }
      async readElement() {
        const id = await this.readVintData(this.ebmlMaxIDLength);
        const lenField = await this.readVintData(this.ebmlMaxSizeLength);
        lenField[0] ^= 128 >> lenField.length - 1;
        const nrLen = Math.min(6, lenField.length);
        return {
          id: id.readUIntBE(0, id.length),
          len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
        };
      }
      isMaxValue(vintData) {
        if (vintData.length === this.ebmlMaxSizeLength) {
          for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {
            if (vintData[n] !== 255)
              return false;
          }
          return true;
        }
        return false;
      }
      async readFloat(e) {
        switch (e.len) {
          case 0:
            return 0;
          case 4:
            return this.tokenizer.readNumber(token_types_1.Float32_BE);
          case 8:
            return this.tokenizer.readNumber(token_types_1.Float64_BE);
          case 10:
            return this.tokenizer.readNumber(token_types_1.Float64_BE);
          default:
            throw new Error(`Invalid IEEE-754 float length: ${e.len}`);
        }
      }
      async readFlag(e) {
        return await this.readUint(e) === 1;
      }
      async readUint(e) {
        const buf = await this.readBuffer(e);
        const nrLen = Math.min(6, e.len);
        return buf.readUIntBE(e.len - nrLen, nrLen);
      }
      async readString(e) {
        const rawString = await this.tokenizer.readToken(new token_types_1.StringType(e.len, "utf-8"));
        return rawString.replace(/\00.*$/g, "");
      }
      async readBuffer(e) {
        const buf = Buffer.alloc(e.len);
        await this.tokenizer.readBuffer(buf);
        return buf;
      }
      addTag(tagId, value) {
        this.metadata.addTag("matroska", tagId, value);
      }
    };
    exports2.MatroskaParser = MatroskaParser;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/ParserFactory.js
var require_ParserFactory = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/ParserFactory.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParserFactory = exports2.parseHttpContentType = void 0;
    var FileType = require_core2();
    var ContentType = require_content_type();
    var MimeType = require_media_typer();
    var debug_1 = require_browser();
    var MetadataCollector_1 = require_MetadataCollector();
    var AiffParser_1 = require_AiffParser();
    var APEv2Parser_1 = require_APEv2Parser();
    var AsfParser_1 = require_AsfParser();
    var FlacParser_1 = require_FlacParser();
    var MP4Parser_1 = require_MP4Parser();
    var MpegParser_1 = require_MpegParser();
    var musepack_1 = require_musepack();
    var OggParser_1 = require_OggParser();
    var WaveParser_1 = require_WaveParser();
    var WavPackParser_1 = require_WavPackParser();
    var DsfParser_1 = require_DsfParser();
    var DsdiffParser_1 = require_DsdiffParser();
    var MatroskaParser_1 = require_MatroskaParser();
    var debug = (0, debug_1.default)("music-metadata:parser:factory");
    function parseHttpContentType(contentType) {
      const type = ContentType.parse(contentType);
      const mime = MimeType.parse(type.type);
      return {
        type: mime.type,
        subtype: mime.subtype,
        suffix: mime.suffix,
        parameters: type.parameters
      };
    }
    exports2.parseHttpContentType = parseHttpContentType;
    async function parse(tokenizer, parserId, opts = {}) {
      const parser = await ParserFactory.loadParser(parserId);
      const metadata = new MetadataCollector_1.MetadataCollector(opts);
      await parser.init(metadata, tokenizer, opts).parse();
      return metadata.toCommonMetadata();
    }
    var ParserFactory = class _ParserFactory {
      /**
       * Parse metadata from tokenizer
       * @param tokenizer - Tokenizer
       * @param opts - Options
       * @returns Native metadata
       */
      static async parseOnContentType(tokenizer, opts) {
        const { mimeType: mimeType2, path, url } = await tokenizer.fileInfo;
        const parserId = _ParserFactory.getParserIdForMimeType(mimeType2) || _ParserFactory.getParserIdForExtension(path) || _ParserFactory.getParserIdForExtension(url);
        if (!parserId) {
          debug("No parser found for MIME-type / extension: " + mimeType2);
        }
        return this.parse(tokenizer, parserId, opts);
      }
      static async parse(tokenizer, parserId, opts) {
        if (!parserId) {
          debug("Guess parser on content...");
          const buf = Buffer.alloc(4100);
          await tokenizer.peekBuffer(buf, { mayBeLess: true });
          if (tokenizer.fileInfo.path) {
            parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);
          }
          if (!parserId) {
            const guessedType = await FileType.fromBuffer(buf);
            if (!guessedType) {
              throw new Error("Failed to determine audio format");
            }
            debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);
            parserId = _ParserFactory.getParserIdForMimeType(guessedType.mime);
            if (!parserId) {
              throw new Error("Guessed MIME-type not supported: " + guessedType.mime);
            }
          }
        }
        return parse(tokenizer, parserId, opts);
      }
      /**
       * @param filePath - Path, filename or extension to audio file
       * @return Parser sub-module name
       */
      static getParserIdForExtension(filePath) {
        if (!filePath)
          return;
        const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;
        switch (extension) {
          case ".mp2":
          case ".mp3":
          case ".m2a":
          case ".aac":
            return "mpeg";
          case ".ape":
            return "apev2";
          case ".mp4":
          case ".m4a":
          case ".m4b":
          case ".m4pa":
          case ".m4v":
          case ".m4r":
          case ".3gp":
            return "mp4";
          case ".wma":
          case ".wmv":
          case ".asf":
            return "asf";
          case ".flac":
            return "flac";
          case ".ogg":
          case ".ogv":
          case ".oga":
          case ".ogm":
          case ".ogx":
          case ".opus":
          case ".spx":
            return "ogg";
          case ".aif":
          case ".aiff":
          case ".aifc":
            return "aiff";
          case ".wav":
          case ".bwf":
            return "riff";
          case ".wv":
          case ".wvp":
            return "wavpack";
          case ".mpc":
            return "musepack";
          case ".dsf":
            return "dsf";
          case ".dff":
            return "dsdiff";
          case ".mka":
          case ".mkv":
          case ".mk3d":
          case ".mks":
          case ".webm":
            return "matroska";
        }
      }
      static async loadParser(moduleName) {
        switch (moduleName) {
          case "aiff":
            return new AiffParser_1.AIFFParser();
          case "adts":
          case "mpeg":
            return new MpegParser_1.MpegParser();
          case "apev2":
            return new APEv2Parser_1.APEv2Parser();
          case "asf":
            return new AsfParser_1.AsfParser();
          case "dsf":
            return new DsfParser_1.DsfParser();
          case "dsdiff":
            return new DsdiffParser_1.DsdiffParser();
          case "flac":
            return new FlacParser_1.FlacParser();
          case "mp4":
            return new MP4Parser_1.MP4Parser();
          case "musepack":
            return new musepack_1.default();
          case "ogg":
            return new OggParser_1.OggParser();
          case "riff":
            return new WaveParser_1.WaveParser();
          case "wavpack":
            return new WavPackParser_1.WavPackParser();
          case "matroska":
            return new MatroskaParser_1.MatroskaParser();
          default:
            throw new Error(`Unknown parser type: ${moduleName}`);
        }
      }
      static getExtension(fname) {
        const i = fname.lastIndexOf(".");
        return i === -1 ? "" : fname.slice(i);
      }
      /**
       * @param httpContentType - HTTP Content-Type, extension, path or filename
       * @returns Parser sub-module name
       */
      static getParserIdForMimeType(httpContentType) {
        let mime;
        try {
          mime = parseHttpContentType(httpContentType);
        } catch (err) {
          debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);
          return;
        }
        const subType = mime.subtype.indexOf("x-") === 0 ? mime.subtype.substring(2) : mime.subtype;
        switch (mime.type) {
          case "audio":
            switch (subType) {
              case "mp3":
              case "mpeg":
                return "mpeg";
              case "aac":
              case "aacp":
                return "adts";
              case "flac":
                return "flac";
              case "ape":
              case "monkeys-audio":
                return "apev2";
              case "mp4":
              case "m4a":
                return "mp4";
              case "ogg":
              case "opus":
              case "speex":
                return "ogg";
              case "ms-wma":
              case "ms-wmv":
              case "ms-asf":
                return "asf";
              case "aiff":
              case "aif":
              case "aifc":
                return "aiff";
              case "vnd.wave":
              case "wav":
              case "wave":
                return "riff";
              case "wavpack":
                return "wavpack";
              case "musepack":
                return "musepack";
              case "matroska":
              case "webm":
                return "matroska";
              case "dsf":
                return "dsf";
            }
            break;
          case "video":
            switch (subType) {
              case "ms-asf":
              case "ms-wmv":
                return "asf";
              case "m4v":
              case "mp4":
                return "mp4";
              case "ogg":
                return "ogg";
              case "matroska":
              case "webm":
                return "matroska";
            }
            break;
          case "application":
            switch (subType) {
              case "vnd.ms-asf":
                return "asf";
              case "ogg":
                return "ogg";
            }
            break;
        }
      }
    };
    exports2.ParserFactory = ParserFactory;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js
var require_RandomUint8ArrayReader = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomUint8ArrayReader = void 0;
    var RandomUint8ArrayReader = class {
      constructor(uint8Array) {
        this.uint8Array = uint8Array;
        this.fileSize = uint8Array.length;
      }
      /**
       * Read from a given position of an abstracted file or buffer.
       * @param uint8Array - Uint8Array that the data will be written to.
       * @param offset - Offset in the buffer to start writing at.
       * @param length - Integer specifying the number of bytes to read.
       * @param position - Specifies where to begin reading from in the file.
       * @return Promise providing bytes read
       */
      async randomRead(uint8Array, offset, length, position) {
        uint8Array.set(this.uint8Array.subarray(position, position + length), offset);
        return length;
      }
    };
    exports2.RandomUint8ArrayReader = RandomUint8ArrayReader;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/lyrics3/Lyrics3.js
var require_Lyrics3 = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/lyrics3/Lyrics3.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLyricsHeaderLength = exports2.endTag2 = void 0;
    exports2.endTag2 = "LYRICS200";
    async function getLyricsHeaderLength(reader) {
      if (reader.fileSize >= 143) {
        const buf = Buffer.alloc(15);
        await reader.randomRead(buf, 0, buf.length, reader.fileSize - 143);
        const txt = buf.toString("binary");
        const tag = txt.substr(6);
        if (tag === exports2.endTag2) {
          return parseInt(txt.substr(0, 6), 10) + 15;
        }
      }
      return 0;
    }
    exports2.getLyricsHeaderLength = getLyricsHeaderLength;
  }
});

// node_modules/music-metadata-browser/node_modules/music-metadata/lib/core.js
var require_core3 = __commonJS({
  "node_modules/music-metadata-browser/node_modules/music-metadata/lib/core.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scanAppendingHeaders = exports2.selectCover = exports2.ratingToStars = exports2.orderTags = exports2.parseFromTokenizer = exports2.parseBuffer = exports2.parseStream = void 0;
    var strtok32 = require_core();
    var ParserFactory_1 = require_ParserFactory();
    var RandomUint8ArrayReader_1 = require_RandomUint8ArrayReader();
    var APEv2Parser_1 = require_APEv2Parser();
    var ID3v1Parser_1 = require_ID3v1Parser();
    var Lyrics3_1 = require_Lyrics3();
    function parseStream(stream2, fileInfo, options = {}) {
      return parseFromTokenizer2(strtok32.fromStream(stream2, typeof fileInfo === "string" ? { mimeType: fileInfo } : fileInfo), options);
    }
    exports2.parseStream = parseStream;
    async function parseBuffer(uint8Array, fileInfo, options = {}) {
      const bufferReader = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(uint8Array);
      await scanAppendingHeaders(bufferReader, options);
      const tokenizer = strtok32.fromBuffer(uint8Array, typeof fileInfo === "string" ? { mimeType: fileInfo } : fileInfo);
      return parseFromTokenizer2(tokenizer, options);
    }
    exports2.parseBuffer = parseBuffer;
    function parseFromTokenizer2(tokenizer, options) {
      return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);
    }
    exports2.parseFromTokenizer = parseFromTokenizer2;
    function orderTags(nativeTags) {
      const tags = {};
      for (const tag of nativeTags) {
        (tags[tag.id] = tags[tag.id] || []).push(tag.value);
      }
      return tags;
    }
    exports2.orderTags = orderTags;
    function ratingToStars(rating) {
      return rating === void 0 ? 0 : 1 + Math.round(rating * 4);
    }
    exports2.ratingToStars = ratingToStars;
    function selectCover(pictures) {
      return pictures ? pictures.reduce((acc, cur) => {
        if (cur.name && cur.name.toLowerCase() in ["front", "cover", "cover (front)"])
          return cur;
        return acc;
      }) : null;
    }
    exports2.selectCover = selectCover;
    async function scanAppendingHeaders(randomReader, options = {}) {
      let apeOffset = randomReader.fileSize;
      if (await (0, ID3v1Parser_1.hasID3v1Header)(randomReader)) {
        apeOffset -= 128;
        const lyricsLen = await (0, Lyrics3_1.getLyricsHeaderLength)(randomReader);
        apeOffset -= lyricsLen;
      }
      options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);
    }
    exports2.scanAppendingHeaders = scanAppendingHeaders;
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    init_node_shims();
    module2.exports = require_events().EventEmitter;
  }
});

// (disabled):node_modules/util/util.js
var require_util2 = __commonJS({
  "(disabled):node_modules/util/util.js"() {
    init_node_shims();
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util2();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream2, err) {
      var rState = stream2._readableState;
      var wState = stream2._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream2.destroy(err);
      else
        stream2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search2, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search2.length) === search2;
    }
    function endsWith(str, search2, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search2.length, this_len) === search2;
    }
    function includes(str, search2, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search2.length > str.length) {
        return false;
      } else {
        return str.indexOf(search2, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_node_shims();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    init_node_shims();
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream2, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream2, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream2, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream2, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream2._writev(chunk, state.onwrite);
      else
        stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        errorOrDestroy(stream2, er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        errorOrDestroy(stream2, er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream2.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream2, err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
          if (state.autoDestroy) {
            var rState = stream2._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream2.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_node_shims();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    init_node_shims();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function eos(stream2, opts, callback) {
      if (typeof opts === "function")
        return eos(stream2, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream2.readable;
      var writable = opts.writable || opts.writable !== false && stream2.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream2.writable)
          onfinish();
      };
      var writableEnded = stream2._writableState && stream2._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream2);
      };
      var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream2);
      };
      var onerror = function onerror2(err) {
        callback.call(stream2, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream2._readableState || !stream2._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
        if (writable && !writableEnded) {
          if (!stream2._writableState || !stream2._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
      };
      var onrequest = function onrequest2() {
        stream2.req.on("finish", onfinish);
      };
      if (isRequest(stream2)) {
        stream2.on("complete", onfinish);
        stream2.on("abort", onclose);
        if (stream2.req)
          onrequest();
        else
          stream2.on("request", onrequest);
      } else if (writable && !stream2._writableState) {
        stream2.on("end", onlegacyfinish);
        stream2.on("close", onlegacyfinish);
      }
      stream2.on("end", onend);
      stream2.on("finish", onfinish);
      if (opts.error !== false)
        stream2.on("error", onerror);
      stream2.on("close", onclose);
      return function() {
        stream2.removeListener("complete", onfinish);
        stream2.removeListener("abort", onclose);
        stream2.removeListener("request", onrequest);
        if (stream2.req)
          stream2.req.removeListener("finish", onfinish);
        stream2.removeListener("end", onlegacyfinish);
        stream2.removeListener("close", onlegacyfinish);
        stream2.removeListener("finish", onfinish);
        stream2.removeListener("end", onend);
        stream2.removeListener("error", onerror);
        stream2.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject2) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject2);
        }, reject2);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject2) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject2(_this[kError]);
              } else {
                resolve2(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject2) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject2(err);
            return;
          }
          resolve2(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream2,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream2._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject2) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject2;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream2, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject2 = iterator[kLastReject];
          if (reject2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject2(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream2.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    init_node_shims();
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util2();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream2, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream2, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream2, state, chunk, false);
              else
                maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream2, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream2.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream2);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream2);
        }
      }
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream2);
      }
    }
    function emitReadable_(stream2) {
      var state = stream2._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream2.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream2.read(0);
      }
      state.resumeScheduled = false;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading)
        stream2.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
        if (state.autoDestroy) {
          var wState = stream2._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream2.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs2 = this._readableState;
        if (ts.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream2._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream2.push(null);
    }
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function destroyer(stream2, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream2.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream2, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream2))
          return stream2.abort();
        if (typeof stream2.destroy === "function")
          return stream2.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream2, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream2, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-web-to-node-stream/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-web-to-node-stream/node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    init_node_shims();
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/readable-web-to-node-stream/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/readable-web-to-node-stream/lib/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableWebToNodeStream = void 0;
    var readable_stream_1 = require_readable_browser();
    var ReadableWebToNodeStream = class extends readable_stream_1.Readable {
      /**
       *
       * @param stream ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
       */
      constructor(stream2) {
        super();
        this.bytesRead = 0;
        this.released = false;
        this.reader = stream2.getReader();
      }
      /**
       * Implementation of readable._read(size).
       * When readable._read() is called, if data is available from the resource,
       * the implementation should begin pushing that data into the read queue
       * https://nodejs.org/api/stream.html#stream_readable_read_size_1
       */
      async _read() {
        if (this.released) {
          this.push(null);
          return;
        }
        this.pendingRead = this.reader.read();
        const data = await this.pendingRead;
        delete this.pendingRead;
        if (data.done || this.released) {
          this.push(null);
        } else {
          this.bytesRead += data.value.length;
          this.push(data.value);
        }
      }
      /**
       * If there is no unresolved read call to Web-API ReadableStream immediately returns;
       * otherwise will wait until the read is resolved.
       */
      async waitForReadToComplete() {
        if (this.pendingRead) {
          await this.pendingRead;
        }
      }
      /**
       * Close wrapper
       */
      async close() {
        await this.syncAndRelease();
      }
      async syncAndRelease() {
        this.released = true;
        await this.waitForReadToComplete();
        await this.reader.releaseLock();
      }
    };
    exports2.ReadableWebToNodeStream = ReadableWebToNodeStream;
  }
});

// node_modules/music-metadata-browser/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/music-metadata-browser/lib/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchFromUrl = exports2.parseBlob = exports2.parseReadableStream = exports2.parseNodeStream = exports2.selectCover = exports2.ratingToStars = exports2.orderTags = exports2.parseFromTokenizer = exports2.parseBuffer = void 0;
    var initDebug = require_browser();
    var mm = require_core3();
    var readable_web_to_node_stream_1 = require_lib3();
    var debug = initDebug("music-metadata-browser:main");
    var core_1 = require_core3();
    Object.defineProperty(exports2, "parseBuffer", { enumerable: true, get: function() {
      return core_1.parseBuffer;
    } });
    Object.defineProperty(exports2, "parseFromTokenizer", { enumerable: true, get: function() {
      return core_1.parseFromTokenizer;
    } });
    Object.defineProperty(exports2, "orderTags", { enumerable: true, get: function() {
      return core_1.orderTags;
    } });
    Object.defineProperty(exports2, "ratingToStars", { enumerable: true, get: function() {
      return core_1.ratingToStars;
    } });
    Object.defineProperty(exports2, "selectCover", { enumerable: true, get: function() {
      return core_1.selectCover;
    } });
    exports2.parseNodeStream = mm.parseStream;
    async function parseReadableStream(stream2, fileInfo, options) {
      const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream2);
      const res = await (0, exports2.parseNodeStream)(ns, typeof fileInfo === "string" ? { mimeType: fileInfo } : fileInfo, options);
      await ns.close();
      return res;
    }
    exports2.parseReadableStream = parseReadableStream;
    async function parseBlob(blob, options) {
      const fileInfo = { mimeType: blob.type, size: blob.size };
      if (blob instanceof File) {
        fileInfo.path = blob.name;
      }
      const stream2 = blob.stream ? blob.stream() : convertBlobToReadableStream(blob);
      return parseReadableStream(stream2, { mimeType: blob.type, size: blob.size }, options);
    }
    exports2.parseBlob = parseBlob;
    function convertBlobToReadableStream(blob) {
      const fileReader = new FileReader();
      return new ReadableStream({
        start(controller) {
          fileReader.onloadend = (event) => {
            let data = event.target.result;
            if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            controller.enqueue(data);
            controller.close();
          };
          fileReader.onerror = (error) => {
            controller.close();
          };
          fileReader.onabort = (error) => {
            controller.close();
          };
          fileReader.readAsArrayBuffer(blob);
        }
      });
    }
    async function fetchFromUrl(audioTrackUrl, options) {
      const response = await fetch(audioTrackUrl);
      const fileInfo = {
        size: parseInt(response.headers.get("Content-Length"), 10),
        mimeType: response.headers.get("Content-Type")
      };
      if (response.ok) {
        if (response.body) {
          const res = await parseReadableStream(response.body, fileInfo, options);
          debug("Closing HTTP-readable-stream...");
          if (!response.body.locked) {
            await response.body.cancel();
          }
          debug("HTTP-readable-stream closed.");
          return res;
        } else {
          return parseBlob(await response.blob(), options);
        }
      } else {
        throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);
      }
    }
    exports2.fetchFromUrl = fetchFromUrl;
  }
});

// node_modules/node-fetch/browser.js
var require_browser3 = __commonJS({
  "node_modules/node-fetch/browser.js"(exports2, module2) {
    "use strict";
    init_node_shims();
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module2.exports = exports2 = globalObject.fetch;
    if (globalObject.fetch) {
      exports2.default = globalObject.fetch.bind(globalObject);
    }
    exports2.Headers = globalObject.Headers;
    exports2.Request = globalObject.Request;
    exports2.Response = globalObject.Response;
  }
});

// node_modules/@tokenizer/range/lib/chunked-file-data.js
var require_chunked_file_data = __commonJS({
  "node_modules/@tokenizer/range/lib/chunked-file-data.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChunkedFileData = void 0;
    var NOT_FOUND = -1;
    var ChunkedFileData = class {
      constructor() {
        this._fileData = [];
      }
      /**
       * Adds data to the file storage at a specific offset.
       */
      addData(offset, data) {
        const offsetEnd = offset + data.byteLength - 1;
        const chunkRange = this._getChunkRange(offset, offsetEnd);
        if (chunkRange.startIx === NOT_FOUND) {
          this._fileData.splice(chunkRange.insertIx || 0, 0, {
            offset,
            data
          });
        } else {
          const firstChunk = this._fileData[chunkRange.startIx];
          const lastChunk = this._fileData[chunkRange.endIx];
          const needsPrepend = offset > firstChunk.offset;
          const needsAppend = offsetEnd < lastChunk.offset + lastChunk.data.byteLength - 1;
          const chunk = {
            offset: Math.min(offset, firstChunk.offset),
            data
          };
          if (needsPrepend) {
            const slicedData = firstChunk.data.slice(0, offset - firstChunk.offset);
            chunk.data = this._concatData(slicedData, data);
          }
          if (needsAppend) {
            const slicedData = chunk.data.slice(0, lastChunk.offset - chunk.offset);
            chunk.data = this._concatData(slicedData, lastChunk.data);
          }
          this._fileData.splice(chunkRange.startIx, chunkRange.endIx - chunkRange.startIx + 1, chunk);
        }
      }
      hasDataRange(offsetStart, offsetEnd) {
        for (let i = 0; i < this._fileData.length; i++) {
          const chunk = this._fileData[i];
          if (offsetEnd < chunk.offset) {
            return false;
          }
          if (offsetStart >= chunk.offset && offsetEnd < chunk.offset + chunk.data.byteLength) {
            return true;
          }
        }
        return false;
      }
      readToBuffer(buffer, offset, position, length) {
        const _pos_offset = position;
        let dataChunk;
        for (let i = 0; i < this._fileData.length; i++) {
          const dataChunkStart = this._fileData[i].offset;
          const dataChunkEnd = dataChunkStart + this._fileData[i].data.byteLength;
          if (_pos_offset >= dataChunkStart && _pos_offset < dataChunkEnd) {
            dataChunk = this._fileData[i];
            const chunkOffset = _pos_offset - dataChunkStart;
            let chunkLength = Math.min(length, dataChunk.data.byteLength - chunkOffset);
            Buffer.from(dataChunk.data).copy(buffer, offset, chunkOffset, chunkOffset + chunkLength);
            if (chunkLength < length) {
              chunkLength += this.readToBuffer(buffer, offset + chunkLength, position + chunkLength, length - chunkLength);
            }
            return chunkLength;
          }
        }
        return 0;
      }
      _concatData(buffer1, buffer2) {
        const tmp = Buffer.alloc(buffer1.byteLength + buffer2.byteLength);
        tmp.set(new Uint8Array(buffer1), 0);
        tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
        return tmp;
      }
      /**
       * Finds the chunk range that overlaps the [offsetStart-1,offsetEnd+1] range.
       * When a chunk is adjacent to the offset we still consider it part of the
       * range (this is the situation of offsetStart-1 or offsetEnd+1).
       * When no chunks are found `insertIx` denotes the index where the data
       * should be inserted in the data list (startIx == NOT_FOUND and endIX ==
       * NOT_FOUND).
       */
      _getChunkRange(offsetStart, offsetEnd) {
        let startChunkIx = NOT_FOUND;
        let endChunkIx = NOT_FOUND;
        let insertIx = 0;
        for (let i = 0; i < this._fileData.length; i++, insertIx = i) {
          const chunkOffsetStart = this._fileData[i].offset;
          const chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.byteLength;
          if (offsetEnd < chunkOffsetStart - 1) {
            break;
          }
          if (offsetStart <= chunkOffsetEnd + 1 && offsetEnd >= chunkOffsetStart - 1) {
            startChunkIx = i;
            break;
          }
        }
        if (startChunkIx === NOT_FOUND) {
          return {
            startIx: NOT_FOUND,
            endIx: NOT_FOUND,
            insertIx
          };
        }
        for (let i = startChunkIx; i < this._fileData.length; i++) {
          const chunkOffsetStart = this._fileData[i].offset;
          const chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.byteLength;
          if (offsetEnd >= chunkOffsetStart - 1) {
            endChunkIx = i;
          }
          if (offsetEnd <= chunkOffsetEnd + 1) {
            break;
          }
        }
        if (endChunkIx === NOT_FOUND) {
          endChunkIx = startChunkIx;
        }
        return {
          startIx: startChunkIx,
          endIx: endChunkIx
        };
      }
      getByteAt(offset) {
        const buf = Buffer.alloc(1);
        const bytesRead = this.readToBuffer(buf, 0, offset, 1);
        if (bytesRead < 1) {
          throw new Error("Offset " + offset + " hasn't been loaded yet.");
        }
        return buf[0];
      }
    };
    exports2.ChunkedFileData = ChunkedFileData;
  }
});

// node_modules/@tokenizer/range/lib/range-request-tokenizer.js
var require_range_request_tokenizer = __commonJS({
  "node_modules/@tokenizer/range/lib/range-request-tokenizer.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseContentRange = exports2.roundRange = exports2.RangeRequestTokenizer = void 0;
    var initDebug = require_browser();
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var chunked_file_data_1 = require_chunked_file_data();
    var debug = initDebug("range-request-reader");
    var RangeRequestTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(rangeRequestClient, fileInfo, minimumChunkSize) {
        super(fileInfo);
        this.rangeRequestClient = rangeRequestClient;
        this.minimumChunkSize = minimumChunkSize;
        if (isNaN(minimumChunkSize)) {
          throw new Error("minimumChunkSize must be a number");
        }
        this._fileData = new chunked_file_data_1.ChunkedFileData();
      }
      /**
       * Read portion from stream
       * @param buffer - Target buffer
       * @param options - Additional read options
       * @returns Promise with number of bytes read
       */
      async readBuffer(buffer, options) {
        if (options && options.position) {
          this.position = options.position;
        }
        const length = await this.peekBuffer(buffer, options);
        this.position += length;
        return length;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param buffer - Target buffer to fill with data peek from the tokenizer-stream
       * @param options - Additional read options
       * @returns Promise with number of bytes read
       */
      async peekBuffer(buffer, options) {
        let length = buffer.length;
        let offset = 0;
        let position = this.position;
        if (options) {
          if (options.position) {
            position = options.position;
          }
          if (Number.isInteger(options.offset)) {
            offset = options.offset;
          }
          if (options.length) {
            length = options.length;
          } else {
            length -= offset;
          }
        }
        if (length === 0) {
          return 0;
        }
        debug(`peekBuffer position=${position} length=${length}`);
        const lastPos = Math.min(this.fileInfo.size - 1, position + length - 1);
        return this.loadRange([position, lastPos]).then(() => {
          this._fileData.readToBuffer(buffer, offset, position, Math.min(this.fileInfo.size, length));
          return length;
        });
      }
      /**
       * Ignore number of bytes, advances the pointer in under tokenizer-stream.
       * @param length - Number of bytes to skip (ignore)
       * @return actual number of bytes ignored
       */
      async ignore(length) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length <= bytesLeft) {
          this.position += length;
          return length;
        }
        this.position += bytesLeft;
        return bytesLeft;
      }
      async loadRange(range) {
        if (range[0] > this.fileInfo.size - 1) {
          throw new Error("End-Of-File");
        }
        debug(`request range ${range[0]}..${range[1]}`);
        debug(`adjusted range ${range[0]}..${range[1]}`);
        if (this._fileData.hasDataRange(range[0], range[1])) {
          debug(`Read from cache`);
          return Promise.resolve();
        }
        range = roundRange(range, this.minimumChunkSize);
        range[1] = Math.min(this.fileInfo.size - 1, range[1]);
        debug(`blocked range: ${range[0]}..${range[1]}`);
        return this.rangeRequestClient.getResponse("GET", range).then((response) => {
          return response.arrayBuffer().then((data) => {
            this._fileData.addData(range[0], data);
          });
        });
      }
    };
    exports2.RangeRequestTokenizer = RangeRequestTokenizer;
    function roundRange(range, minimumChunkSize) {
      const length = range[1] - range[0] + 1;
      const newLength = Math.max(minimumChunkSize, length);
      return [range[0], range[0] + newLength - 1];
    }
    exports2.roundRange = roundRange;
    function parseContentRange(contentRange) {
      debug(`_parseContentRang response: contentRange=${contentRange}`);
      if (contentRange) {
        const parsedContentRange = contentRange.match(/bytes (\d+)-(\d+)\/(?:(\d+)|\*)/i);
        if (!parsedContentRange) {
          throw new Error("FIXME: Unknown Content-Range syntax: " + contentRange);
        }
        return {
          firstBytePosition: parseInt(parsedContentRange[1], 10),
          lastBytePosition: parseInt(parsedContentRange[2], 10),
          instanceLength: parsedContentRange[3] ? parseInt(parsedContentRange[3], 10) : null
        };
      }
    }
    exports2.parseContentRange = parseContentRange;
  }
});

// node_modules/@tokenizer/range/lib/range-request-factory.js
var require_range_request_factory = __commonJS({
  "node_modules/@tokenizer/range/lib/range-request-factory.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RangeRequestFactory = void 0;
    var range_request_tokenizer_1 = require_range_request_tokenizer();
    var initDebug = require_browser();
    var debug = initDebug("range-request-reader");
    var RangeRequestFactory = class {
      constructor(rangeRequestClient) {
        this.rangeRequestClient = rangeRequestClient;
        this.config = {
          avoidHeadRequests: false,
          initialChunkSize: 4 * 1024,
          minimumChunkSize: 1024
        };
      }
      async initTokenizer(config) {
        if (config) {
          this.config = Object.assign(Object.assign({}, this.config), config);
        }
        const headRequestInfo = await this.getHeadRequestInfo();
        return new range_request_tokenizer_1.RangeRequestTokenizer(this.rangeRequestClient, headRequestInfo, this.config.minimumChunkSize);
      }
      /**
       * Get file information, an HTTP-client may implement this doing a HEAD request
       * @return Promise with head-request-info, extending tokenizer file-info.
       */
      getHeadRequestInfo() {
        return this.config.avoidHeadRequests ? this.fetchFileInfoWithGetRequest() : this.fetchFileInfoWithHeadRequest();
      }
      async fetchFileInfoWithHeadRequest() {
        debug(`_fetchSizeWithHeadRequest()`);
        const info = await this.rangeRequestClient.getHeadInfo();
        if (info.size) {
          debug(`MIME-type=${info.mimeType}, content-length=${info.size}`);
          return info;
        }
        debug("Content-Length not provided by the server, fallback to GET requests");
        return this.fetchFileInfoWithGetRequest();
      }
      async fetchFileInfoWithGetRequest() {
        const range = (0, range_request_tokenizer_1.roundRange)([0, this.config.initialChunkSize], this.config.minimumChunkSize);
        const response = await this.rangeRequestClient.getResponse("GET", range);
        debug(`_fetchSizeWithGetRequest response: contentRange=${response.contentRange}`);
        if (!response.contentRange) {
          throw new Error("Failed to resolve content range (file size)");
        }
        return response;
      }
    };
    exports2.RangeRequestFactory = RangeRequestFactory;
  }
});

// node_modules/@tokenizer/range/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@tokenizer/range/lib/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenizer = exports2.parseContentRange = void 0;
    var range_request_factory_1 = require_range_request_factory();
    var range_request_tokenizer_1 = require_range_request_tokenizer();
    Object.defineProperty(exports2, "parseContentRange", { enumerable: true, get: function() {
      return range_request_tokenizer_1.parseContentRange;
    } });
    function tokenizer(rangeRequestClient, config) {
      const factory = new range_request_factory_1.RangeRequestFactory(rangeRequestClient);
      return factory.initTokenizer(config);
    }
    exports2.tokenizer = tokenizer;
  }
});

// node_modules/@tokenizer/http/lib/http-client.js
var require_http_client = __commonJS({
  "node_modules/@tokenizer/http/lib/http-client.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = void 0;
    var initDebug = require_browser();
    var _fetch = require_browser3();
    var range_1 = require_lib5();
    var debug = initDebug("streaming-http-token-reader:http-client");
    var DEFAULT_CONFIG = {
      resolveUrl: false
    };
    var HttpClient = class _HttpClient {
      constructor(url, config) {
        this.url = url;
        this.config = DEFAULT_CONFIG;
        Object.assign(this.config, config);
      }
      static getContentLength(headers) {
        const contentLength = headers.get("Content-Length");
        return contentLength ? parseInt(contentLength, 10) : void 0;
      }
      static parseContentRange(headers) {
        const contentRange = headers.get("Content-Range");
        return range_1.parseContentRange(contentRange);
      }
      static makeResponse(resp) {
        const contentRange = _HttpClient.parseContentRange(resp.headers);
        return {
          url: resp.url,
          size: contentRange ? contentRange.instanceLength : _HttpClient.getContentLength(resp.headers),
          mimeType: resp.headers.get("Content-Type"),
          contentRange,
          arrayBuffer: () => resp.arrayBuffer()
        };
      }
      async getHeadInfo() {
        const response = await _fetch(this.url, { method: "HEAD" });
        if (this.config.resolveUrl)
          this.resolvedUrl = response.url;
        return _HttpClient.makeResponse(response);
      }
      async getResponse(method, range) {
        if (range) {
          debug(`_getResponse ${method} ${range[0]}..${range[1]}`);
        } else {
          debug(`_getResponse ${method} (range not provided)`);
        }
        const headers = new _fetch.Headers();
        headers.set("Range", "bytes=" + range[0] + "-" + range[1]);
        const response = await _fetch(this.resolvedUrl || this.url, { method, headers });
        if (response.ok) {
          if (this.config.resolveUrl)
            this.resolvedUrl = response.url;
          return _HttpClient.makeResponse(response);
        } else {
          throw new Error(`Unexpected HTTP response status=${response.status}`);
        }
      }
    };
    exports2.HttpClient = HttpClient;
  }
});

// node_modules/@tokenizer/http/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@tokenizer/http/lib/index.js"(exports2) {
    "use strict";
    init_node_shims();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeTokenizer = void 0;
    var http_client_1 = require_http_client();
    var rangeTokenizer = require_lib5();
    function makeTokenizer2(url, tokenizerConfig, httpClientConfig) {
      const httpClient = new http_client_1.HttpClient(url, httpClientConfig);
      return rangeTokenizer.tokenizer(httpClient, tokenizerConfig);
    }
    exports2.makeTokenizer = makeTokenizer2;
  }
});

// build/js/brain.elm.js
var require_brain_elm = __commonJS({
  "build/js/brain.elm.js"(exports2) {
    init_node_shims();
    (function(scope) {
      "use strict";
      function F(arity, fun, wrapper) {
        wrapper.a = arity;
        wrapper.f = fun;
        return wrapper;
      }
      function F2(fun) {
        return F(2, fun, function(a) {
          return function(b) {
            return fun(a, b);
          };
        });
      }
      function F3(fun) {
        return F(3, fun, function(a) {
          return function(b) {
            return function(c) {
              return fun(a, b, c);
            };
          };
        });
      }
      function F4(fun) {
        return F(4, fun, function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return fun(a, b, c, d);
              };
            };
          };
        });
      }
      function F5(fun) {
        return F(5, fun, function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return fun(a, b, c, d, e);
                };
              };
            };
          };
        });
      }
      function F6(fun) {
        return F(6, fun, function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return function(f) {
                    return fun(a, b, c, d, e, f);
                  };
                };
              };
            };
          };
        });
      }
      function F7(fun) {
        return F(7, fun, function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return function(f) {
                    return function(g) {
                      return fun(a, b, c, d, e, f, g);
                    };
                  };
                };
              };
            };
          };
        });
      }
      function F8(fun) {
        return F(8, fun, function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return function(f) {
                    return function(g) {
                      return function(h) {
                        return fun(a, b, c, d, e, f, g, h);
                      };
                    };
                  };
                };
              };
            };
          };
        });
      }
      function F9(fun) {
        return F(9, fun, function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return function(f) {
                    return function(g) {
                      return function(h) {
                        return function(i) {
                          return fun(a, b, c, d, e, f, g, h, i);
                        };
                      };
                    };
                  };
                };
              };
            };
          };
        });
      }
      function A2(fun, a, b) {
        return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
      }
      function A3(fun, a, b, c) {
        return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
      }
      function A4(fun, a, b, c, d) {
        return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
      }
      function A5(fun, a, b, c, d, e) {
        return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
      }
      function A6(fun, a, b, c, d, e, f) {
        return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
      }
      function A7(fun, a, b, c, d, e, f, g) {
        return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
      }
      function A8(fun, a, b, c, d, e, f, g, h) {
        return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
      }
      function A9(fun, a, b, c, d, e, f, g, h, i) {
        return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
      }
      console.warn("Compiled in DEV mode. Follow the advice at https://elm-lang.org/0.19.1/optimize for better performance and smaller assets.");
      var _JsArray_empty = [];
      function _JsArray_singleton(value) {
        return [value];
      }
      function _JsArray_length(array) {
        return array.length;
      }
      var _JsArray_initialize = F3(function(size, offset, func) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
          result[i] = func(offset + i);
        }
        return result;
      });
      var _JsArray_initializeFromList = F2(function(max, ls) {
        var result = new Array(max);
        for (var i = 0; i < max && ls.b; i++) {
          result[i] = ls.a;
          ls = ls.b;
        }
        result.length = i;
        return _Utils_Tuple2(result, ls);
      });
      var _JsArray_unsafeGet = F2(function(index, array) {
        return array[index];
      });
      var _JsArray_unsafeSet = F3(function(index, value, array) {
        var length = array.length;
        var result = new Array(length);
        for (var i = 0; i < length; i++) {
          result[i] = array[i];
        }
        result[index] = value;
        return result;
      });
      var _JsArray_push = F2(function(value, array) {
        var length = array.length;
        var result = new Array(length + 1);
        for (var i = 0; i < length; i++) {
          result[i] = array[i];
        }
        result[length] = value;
        return result;
      });
      var _JsArray_foldl = F3(function(func, acc, array) {
        var length = array.length;
        for (var i = 0; i < length; i++) {
          acc = A2(func, array[i], acc);
        }
        return acc;
      });
      var _JsArray_foldr = F3(function(func, acc, array) {
        for (var i = array.length - 1; i >= 0; i--) {
          acc = A2(func, array[i], acc);
        }
        return acc;
      });
      var _JsArray_map = F2(function(func, array) {
        var length = array.length;
        var result = new Array(length);
        for (var i = 0; i < length; i++) {
          result[i] = func(array[i]);
        }
        return result;
      });
      var _JsArray_indexedMap = F3(function(func, offset, array) {
        var length = array.length;
        var result = new Array(length);
        for (var i = 0; i < length; i++) {
          result[i] = A2(func, offset + i, array[i]);
        }
        return result;
      });
      var _JsArray_slice = F3(function(from, to, array) {
        return array.slice(from, to);
      });
      var _JsArray_appendN = F3(function(n, dest, source) {
        var destLen = dest.length;
        var itemsToCopy = n - destLen;
        if (itemsToCopy > source.length) {
          itemsToCopy = source.length;
        }
        var size = destLen + itemsToCopy;
        var result = new Array(size);
        for (var i = 0; i < destLen; i++) {
          result[i] = dest[i];
        }
        for (var i = 0; i < itemsToCopy; i++) {
          result[i + destLen] = source[i];
        }
        return result;
      });
      var _Debug_log_UNUSED = F2(function(tag, value) {
        return value;
      });
      var _Debug_log = F2(function(tag, value) {
        console.log(tag + ": " + _Debug_toString(value));
        return value;
      });
      function _Debug_todo(moduleName, region) {
        return function(message) {
          _Debug_crash(8, moduleName, region, message);
        };
      }
      function _Debug_todoCase(moduleName, region, value) {
        return function(message) {
          _Debug_crash(9, moduleName, region, value, message);
        };
      }
      function _Debug_toString_UNUSED(value) {
        return "<internals>";
      }
      function _Debug_toString(value) {
        return _Debug_toAnsiString(false, value);
      }
      function _Debug_toAnsiString(ansi, value) {
        if (typeof value === "function") {
          return _Debug_internalColor(ansi, "<function>");
        }
        if (typeof value === "boolean") {
          return _Debug_ctorColor(ansi, value ? "True" : "False");
        }
        if (typeof value === "number") {
          return _Debug_numberColor(ansi, value + "");
        }
        if (value instanceof String) {
          return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
        }
        if (typeof value === "string") {
          return _Debug_stringColor(ansi, '"' + _Debug_addSlashes(value, false) + '"');
        }
        if (typeof value === "object" && "$" in value) {
          var tag = value.$;
          if (typeof tag === "number") {
            return _Debug_internalColor(ansi, "<internals>");
          }
          if (tag[0] === "#") {
            var output = [];
            for (var k in value) {
              if (k === "$")
                continue;
              output.push(_Debug_toAnsiString(ansi, value[k]));
            }
            return "(" + output.join(",") + ")";
          }
          if (tag === "Set_elm_builtin") {
            return _Debug_ctorColor(ansi, "Set") + _Debug_fadeColor(ansi, ".fromList") + " " + _Debug_toAnsiString(ansi, $elm$core$Set$toList(value));
          }
          if (tag === "RBNode_elm_builtin" || tag === "RBEmpty_elm_builtin") {
            return _Debug_ctorColor(ansi, "Dict") + _Debug_fadeColor(ansi, ".fromList") + " " + _Debug_toAnsiString(ansi, $elm$core$Dict$toList(value));
          }
          if (tag === "Array_elm_builtin") {
            return _Debug_ctorColor(ansi, "Array") + _Debug_fadeColor(ansi, ".fromList") + " " + _Debug_toAnsiString(ansi, $elm$core$Array$toList(value));
          }
          if (tag === "::" || tag === "[]") {
            var output = "[";
            value.b && (output += _Debug_toAnsiString(ansi, value.a), value = value.b);
            for (; value.b; value = value.b) {
              output += "," + _Debug_toAnsiString(ansi, value.a);
            }
            return output + "]";
          }
          var output = "";
          for (var i in value) {
            if (i === "$")
              continue;
            var str = _Debug_toAnsiString(ansi, value[i]);
            var c0 = str[0];
            var parenless = c0 === "{" || c0 === "(" || c0 === "[" || c0 === "<" || c0 === '"' || str.indexOf(" ") < 0;
            output += " " + (parenless ? str : "(" + str + ")");
          }
          return _Debug_ctorColor(ansi, tag) + output;
        }
        if (typeof DataView === "function" && value instanceof DataView) {
          return _Debug_stringColor(ansi, "<" + value.byteLength + " bytes>");
        }
        if (typeof File !== "undefined" && value instanceof File) {
          return _Debug_internalColor(ansi, "<" + value.name + ">");
        }
        if (typeof value === "object") {
          var output = [];
          for (var key in value) {
            var field = key[0] === "_" ? key.slice(1) : key;
            output.push(_Debug_fadeColor(ansi, field) + " = " + _Debug_toAnsiString(ansi, value[key]));
          }
          if (output.length === 0) {
            return "{}";
          }
          return "{ " + output.join(", ") + " }";
        }
        return _Debug_internalColor(ansi, "<internals>");
      }
      function _Debug_addSlashes(str, isChar) {
        var s = str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
        if (isChar) {
          return s.replace(/\'/g, "\\'");
        } else {
          return s.replace(/\"/g, '\\"');
        }
      }
      function _Debug_ctorColor(ansi, string) {
        return ansi ? "\x1B[96m" + string + "\x1B[0m" : string;
      }
      function _Debug_numberColor(ansi, string) {
        return ansi ? "\x1B[95m" + string + "\x1B[0m" : string;
      }
      function _Debug_stringColor(ansi, string) {
        return ansi ? "\x1B[93m" + string + "\x1B[0m" : string;
      }
      function _Debug_charColor(ansi, string) {
        return ansi ? "\x1B[92m" + string + "\x1B[0m" : string;
      }
      function _Debug_fadeColor(ansi, string) {
        return ansi ? "\x1B[37m" + string + "\x1B[0m" : string;
      }
      function _Debug_internalColor(ansi, string) {
        return ansi ? "\x1B[36m" + string + "\x1B[0m" : string;
      }
      function _Debug_toHexDigit(n) {
        return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
      }
      function _Debug_crash_UNUSED(identifier) {
        throw new Error("https://github.com/elm/core/blob/1.0.0/hints/" + identifier + ".md");
      }
      function _Debug_crash(identifier, fact1, fact2, fact3, fact4) {
        switch (identifier) {
          case 0:
            throw new Error('What node should I take over? In JavaScript I need something like:\n\n    Elm.Main.init({\n        node: document.getElementById("elm-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.');
          case 1:
            throw new Error("Browser.application programs cannot handle URLs like this:\n\n    " + document.location.href + "\n\nWhat is the root? The root of your file system? Try looking at this program with `elm reactor` or some other server.");
          case 2:
            var jsonErrorString = fact1;
            throw new Error("Problem with the flags given to your Elm program on initialization.\n\n" + jsonErrorString);
          case 3:
            var portName = fact1;
            throw new Error("There can only be one port named `" + portName + "`, but your program has multiple.");
          case 4:
            var portName = fact1;
            var problem = fact2;
            throw new Error("Trying to send an unexpected type of value through port `" + portName + "`:\n" + problem);
          case 5:
            throw new Error('Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Elm sense.\nRead more about this at https://package.elm-lang.org/packages/elm/core/latest/Basics#== which describes why it is this way and what the better version will look like.');
          case 6:
            var moduleName = fact1;
            throw new Error("Your page is loading multiple Elm scripts with a module named " + moduleName + ". Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!");
          case 8:
            var moduleName = fact1;
            var region = fact2;
            var message = fact3;
            throw new Error("TODO in module `" + moduleName + "` " + _Debug_regionToString(region) + "\n\n" + message);
          case 9:
            var moduleName = fact1;
            var region = fact2;
            var value = fact3;
            var message = fact4;
            throw new Error(
              "TODO in module `" + moduleName + "` from the `case` expression " + _Debug_regionToString(region) + "\n\nIt received the following value:\n\n    " + _Debug_toString(value).replace("\n", "\n    ") + "\n\nBut the branch that handles it says:\n\n    " + message.replace("\n", "\n    ")
            );
          case 10:
            throw new Error("Bug in https://github.com/elm/virtual-dom/issues");
          case 11:
            throw new Error("Cannot perform mod 0. Division by zero error.");
        }
      }
      function _Debug_regionToString(region) {
        if (region.start.line === region.end.line) {
          return "on line " + region.start.line;
        }
        return "on lines " + region.start.line + " through " + region.end.line;
      }
      function _Utils_eq(x, y) {
        for (var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack); isEqual && (pair = stack.pop()); isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)) {
        }
        return isEqual;
      }
      function _Utils_eqHelp(x, y, depth, stack) {
        if (x === y) {
          return true;
        }
        if (typeof x !== "object" || x === null || y === null) {
          typeof x === "function" && _Debug_crash(5);
          return false;
        }
        if (depth > 100) {
          stack.push(_Utils_Tuple2(x, y));
          return true;
        }
        if (x.$ === "Set_elm_builtin") {
          x = $elm$core$Set$toList(x);
          y = $elm$core$Set$toList(y);
        }
        if (x.$ === "RBNode_elm_builtin" || x.$ === "RBEmpty_elm_builtin") {
          x = $elm$core$Dict$toList(x);
          y = $elm$core$Dict$toList(y);
        }
        for (var key in x) {
          if (!_Utils_eqHelp(x[key], y[key], depth + 1, stack)) {
            return false;
          }
        }
        return true;
      }
      var _Utils_equal = F2(_Utils_eq);
      var _Utils_notEqual = F2(function(a, b) {
        return !_Utils_eq(a, b);
      });
      function _Utils_cmp(x, y, ord) {
        if (typeof x !== "object") {
          return x === y ? (
            /*EQ*/
            0
          ) : x < y ? (
            /*LT*/
            -1
          ) : (
            /*GT*/
            1
          );
        }
        if (x instanceof String) {
          var a = x.valueOf();
          var b = y.valueOf();
          return a === b ? 0 : a < b ? -1 : 1;
        }
        if (x.$[0] === "#") {
          return (ord = _Utils_cmp(x.a, y.a)) ? ord : (ord = _Utils_cmp(x.b, y.b)) ? ord : _Utils_cmp(x.c, y.c);
        }
        for (; x.b && y.b && !(ord = _Utils_cmp(x.a, y.a)); x = x.b, y = y.b) {
        }
        return ord || (x.b ? (
          /*GT*/
          1
        ) : y.b ? (
          /*LT*/
          -1
        ) : (
          /*EQ*/
          0
        ));
      }
      var _Utils_lt = F2(function(a, b) {
        return _Utils_cmp(a, b) < 0;
      });
      var _Utils_le = F2(function(a, b) {
        return _Utils_cmp(a, b) < 1;
      });
      var _Utils_gt = F2(function(a, b) {
        return _Utils_cmp(a, b) > 0;
      });
      var _Utils_ge = F2(function(a, b) {
        return _Utils_cmp(a, b) >= 0;
      });
      var _Utils_compare = F2(function(x, y) {
        var n = _Utils_cmp(x, y);
        return n < 0 ? $elm$core$Basics$LT : n ? $elm$core$Basics$GT : $elm$core$Basics$EQ;
      });
      var _Utils_Tuple0_UNUSED = 0;
      var _Utils_Tuple0 = { $: "#0" };
      function _Utils_Tuple2_UNUSED(a, b) {
        return { a, b };
      }
      function _Utils_Tuple2(a, b) {
        return { $: "#2", a, b };
      }
      function _Utils_Tuple3_UNUSED(a, b, c) {
        return { a, b, c };
      }
      function _Utils_Tuple3(a, b, c) {
        return { $: "#3", a, b, c };
      }
      function _Utils_chr_UNUSED(c) {
        return c;
      }
      function _Utils_chr(c) {
        return new String(c);
      }
      function _Utils_update(oldRecord, updatedFields) {
        var newRecord = {};
        for (var key in oldRecord) {
          newRecord[key] = oldRecord[key];
        }
        for (var key in updatedFields) {
          newRecord[key] = updatedFields[key];
        }
        return newRecord;
      }
      var _Utils_append = F2(_Utils_ap);
      function _Utils_ap(xs, ys) {
        if (typeof xs === "string") {
          return xs + ys;
        }
        if (!xs.b) {
          return ys;
        }
        var root = _List_Cons(xs.a, ys);
        xs = xs.b;
        for (var curr = root; xs.b; xs = xs.b) {
          curr = curr.b = _List_Cons(xs.a, ys);
        }
        return root;
      }
      var _List_Nil_UNUSED = { $: 0 };
      var _List_Nil = { $: "[]" };
      function _List_Cons_UNUSED(hd, tl) {
        return { $: 1, a: hd, b: tl };
      }
      function _List_Cons(hd, tl) {
        return { $: "::", a: hd, b: tl };
      }
      var _List_cons = F2(_List_Cons);
      function _List_fromArray(arr) {
        var out = _List_Nil;
        for (var i = arr.length; i--; ) {
          out = _List_Cons(arr[i], out);
        }
        return out;
      }
      function _List_toArray(xs) {
        for (var out = []; xs.b; xs = xs.b) {
          out.push(xs.a);
        }
        return out;
      }
      var _List_map2 = F3(function(f, xs, ys) {
        for (var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b) {
          arr.push(A2(f, xs.a, ys.a));
        }
        return _List_fromArray(arr);
      });
      var _List_map3 = F4(function(f, xs, ys, zs) {
        for (var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b) {
          arr.push(A3(f, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
      });
      var _List_map4 = F5(function(f, ws, xs, ys, zs) {
        for (var arr = []; ws.b && xs.b && ys.b && zs.b; ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) {
          arr.push(A4(f, ws.a, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
      });
      var _List_map5 = F6(function(f, vs, ws, xs, ys, zs) {
        for (var arr = []; vs.b && ws.b && xs.b && ys.b && zs.b; vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) {
          arr.push(A5(f, vs.a, ws.a, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
      });
      var _List_sortBy = F2(function(f, xs) {
        return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
          return _Utils_cmp(f(a), f(b));
        }));
      });
      var _List_sortWith = F2(function(f, xs) {
        return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
          var ord = A2(f, a, b);
          return ord === $elm$core$Basics$EQ ? 0 : ord === $elm$core$Basics$LT ? -1 : 1;
        }));
      });
      var _Basics_add = F2(function(a, b) {
        return a + b;
      });
      var _Basics_sub = F2(function(a, b) {
        return a - b;
      });
      var _Basics_mul = F2(function(a, b) {
        return a * b;
      });
      var _Basics_fdiv = F2(function(a, b) {
        return a / b;
      });
      var _Basics_idiv = F2(function(a, b) {
        return a / b | 0;
      });
      var _Basics_pow = F2(Math.pow);
      var _Basics_remainderBy = F2(function(b, a) {
        return a % b;
      });
      var _Basics_modBy = F2(function(modulus, x) {
        var answer = x % modulus;
        return modulus === 0 ? _Debug_crash(11) : answer > 0 && modulus < 0 || answer < 0 && modulus > 0 ? answer + modulus : answer;
      });
      var _Basics_pi = Math.PI;
      var _Basics_e = Math.E;
      var _Basics_cos = Math.cos;
      var _Basics_sin = Math.sin;
      var _Basics_tan = Math.tan;
      var _Basics_acos = Math.acos;
      var _Basics_asin = Math.asin;
      var _Basics_atan = Math.atan;
      var _Basics_atan2 = F2(Math.atan2);
      function _Basics_toFloat(x) {
        return x;
      }
      function _Basics_truncate(n) {
        return n | 0;
      }
      function _Basics_isInfinite(n) {
        return n === Infinity || n === -Infinity;
      }
      var _Basics_ceiling = Math.ceil;
      var _Basics_floor = Math.floor;
      var _Basics_round = Math.round;
      var _Basics_sqrt = Math.sqrt;
      var _Basics_log = Math.log;
      var _Basics_isNaN = isNaN;
      function _Basics_not(bool) {
        return !bool;
      }
      var _Basics_and = F2(function(a, b) {
        return a && b;
      });
      var _Basics_or = F2(function(a, b) {
        return a || b;
      });
      var _Basics_xor = F2(function(a, b) {
        return a !== b;
      });
      var _String_cons = F2(function(chr, str) {
        return chr + str;
      });
      function _String_uncons(string) {
        var word = string.charCodeAt(0);
        return !isNaN(word) ? $elm$core$Maybe$Just(
          55296 <= word && word <= 56319 ? _Utils_Tuple2(_Utils_chr(string[0] + string[1]), string.slice(2)) : _Utils_Tuple2(_Utils_chr(string[0]), string.slice(1))
        ) : $elm$core$Maybe$Nothing;
      }
      var _String_append = F2(function(a, b) {
        return a + b;
      });
      function _String_length(str) {
        return str.length;
      }
      var _String_map = F2(function(func, string) {
        var len = string.length;
        var array = new Array(len);
        var i = 0;
        while (i < len) {
          var word = string.charCodeAt(i);
          if (55296 <= word && word <= 56319) {
            array[i] = func(_Utils_chr(string[i] + string[i + 1]));
            i += 2;
            continue;
          }
          array[i] = func(_Utils_chr(string[i]));
          i++;
        }
        return array.join("");
      });
      var _String_filter = F2(function(isGood, str) {
        var arr = [];
        var len = str.length;
        var i = 0;
        while (i < len) {
          var char = str[i];
          var word = str.charCodeAt(i);
          i++;
          if (55296 <= word && word <= 56319) {
            char += str[i];
            i++;
          }
          if (isGood(_Utils_chr(char))) {
            arr.push(char);
          }
        }
        return arr.join("");
      });
      function _String_reverse(str) {
        var len = str.length;
        var arr = new Array(len);
        var i = 0;
        while (i < len) {
          var word = str.charCodeAt(i);
          if (55296 <= word && word <= 56319) {
            arr[len - i] = str[i + 1];
            i++;
            arr[len - i] = str[i - 1];
            i++;
          } else {
            arr[len - i] = str[i];
            i++;
          }
        }
        return arr.join("");
      }
      var _String_foldl = F3(function(func, state, string) {
        var len = string.length;
        var i = 0;
        while (i < len) {
          var char = string[i];
          var word = string.charCodeAt(i);
          i++;
          if (55296 <= word && word <= 56319) {
            char += string[i];
            i++;
          }
          state = A2(func, _Utils_chr(char), state);
        }
        return state;
      });
      var _String_foldr = F3(function(func, state, string) {
        var i = string.length;
        while (i--) {
          var char = string[i];
          var word = string.charCodeAt(i);
          if (56320 <= word && word <= 57343) {
            i--;
            char = string[i] + char;
          }
          state = A2(func, _Utils_chr(char), state);
        }
        return state;
      });
      var _String_split = F2(function(sep, str) {
        return str.split(sep);
      });
      var _String_join = F2(function(sep, strs) {
        return strs.join(sep);
      });
      var _String_slice = F3(function(start, end, str) {
        return str.slice(start, end);
      });
      function _String_trim(str) {
        return str.trim();
      }
      function _String_trimLeft(str) {
        return str.replace(/^\s+/, "");
      }
      function _String_trimRight(str) {
        return str.replace(/\s+$/, "");
      }
      function _String_words(str) {
        return _List_fromArray(str.trim().split(/\s+/g));
      }
      function _String_lines(str) {
        return _List_fromArray(str.split(/\r\n|\r|\n/g));
      }
      function _String_toUpper(str) {
        return str.toUpperCase();
      }
      function _String_toLower(str) {
        return str.toLowerCase();
      }
      var _String_any = F2(function(isGood, string) {
        var i = string.length;
        while (i--) {
          var char = string[i];
          var word = string.charCodeAt(i);
          if (56320 <= word && word <= 57343) {
            i--;
            char = string[i] + char;
          }
          if (isGood(_Utils_chr(char))) {
            return true;
          }
        }
        return false;
      });
      var _String_all = F2(function(isGood, string) {
        var i = string.length;
        while (i--) {
          var char = string[i];
          var word = string.charCodeAt(i);
          if (56320 <= word && word <= 57343) {
            i--;
            char = string[i] + char;
          }
          if (!isGood(_Utils_chr(char))) {
            return false;
          }
        }
        return true;
      });
      var _String_contains = F2(function(sub, str) {
        return str.indexOf(sub) > -1;
      });
      var _String_startsWith = F2(function(sub, str) {
        return str.indexOf(sub) === 0;
      });
      var _String_endsWith = F2(function(sub, str) {
        return str.length >= sub.length && str.lastIndexOf(sub) === str.length - sub.length;
      });
      var _String_indexes = F2(function(sub, str) {
        var subLen = sub.length;
        if (subLen < 1) {
          return _List_Nil;
        }
        var i = 0;
        var is = [];
        while ((i = str.indexOf(sub, i)) > -1) {
          is.push(i);
          i = i + subLen;
        }
        return _List_fromArray(is);
      });
      function _String_fromNumber(number) {
        return number + "";
      }
      function _String_toInt(str) {
        var total = 0;
        var code0 = str.charCodeAt(0);
        var start = code0 == 43 || code0 == 45 ? 1 : 0;
        for (var i = start; i < str.length; ++i) {
          var code = str.charCodeAt(i);
          if (code < 48 || 57 < code) {
            return $elm$core$Maybe$Nothing;
          }
          total = 10 * total + code - 48;
        }
        return i == start ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(code0 == 45 ? -total : total);
      }
      function _String_toFloat(s) {
        if (s.length === 0 || /[\sxbo]/.test(s)) {
          return $elm$core$Maybe$Nothing;
        }
        var n = +s;
        return n === n ? $elm$core$Maybe$Just(n) : $elm$core$Maybe$Nothing;
      }
      function _String_fromList(chars) {
        return _List_toArray(chars).join("");
      }
      function _Char_toCode(char) {
        var code = char.charCodeAt(0);
        if (55296 <= code && code <= 56319) {
          return (code - 55296) * 1024 + char.charCodeAt(1) - 56320 + 65536;
        }
        return code;
      }
      function _Char_fromCode(code) {
        return _Utils_chr(
          code < 0 || 1114111 < code ? "\uFFFD" : code <= 65535 ? String.fromCharCode(code) : (code -= 65536, String.fromCharCode(Math.floor(code / 1024) + 55296, code % 1024 + 56320))
        );
      }
      function _Char_toUpper(char) {
        return _Utils_chr(char.toUpperCase());
      }
      function _Char_toLower(char) {
        return _Utils_chr(char.toLowerCase());
      }
      function _Char_toLocaleUpper(char) {
        return _Utils_chr(char.toLocaleUpperCase());
      }
      function _Char_toLocaleLower(char) {
        return _Utils_chr(char.toLocaleLowerCase());
      }
      function _Json_errorToString(error) {
        return $elm$json$Json$Decode$errorToString(error);
      }
      function _Json_succeed(msg) {
        return {
          $: 0,
          a: msg
        };
      }
      function _Json_fail(msg) {
        return {
          $: 1,
          a: msg
        };
      }
      function _Json_decodePrim(decoder) {
        return { $: 2, b: decoder };
      }
      var _Json_decodeInt = _Json_decodePrim(function(value) {
        return typeof value !== "number" ? _Json_expecting("an INT", value) : -2147483647 < value && value < 2147483647 && (value | 0) === value ? $elm$core$Result$Ok(value) : isFinite(value) && !(value % 1) ? $elm$core$Result$Ok(value) : _Json_expecting("an INT", value);
      });
      var _Json_decodeBool = _Json_decodePrim(function(value) {
        return typeof value === "boolean" ? $elm$core$Result$Ok(value) : _Json_expecting("a BOOL", value);
      });
      var _Json_decodeFloat = _Json_decodePrim(function(value) {
        return typeof value === "number" ? $elm$core$Result$Ok(value) : _Json_expecting("a FLOAT", value);
      });
      var _Json_decodeValue = _Json_decodePrim(function(value) {
        return $elm$core$Result$Ok(_Json_wrap(value));
      });
      var _Json_decodeString = _Json_decodePrim(function(value) {
        return typeof value === "string" ? $elm$core$Result$Ok(value) : value instanceof String ? $elm$core$Result$Ok(value + "") : _Json_expecting("a STRING", value);
      });
      function _Json_decodeList(decoder) {
        return { $: 3, b: decoder };
      }
      function _Json_decodeArray(decoder) {
        return { $: 4, b: decoder };
      }
      function _Json_decodeNull(value) {
        return { $: 5, c: value };
      }
      var _Json_decodeField = F2(function(field, decoder) {
        return {
          $: 6,
          d: field,
          b: decoder
        };
      });
      var _Json_decodeIndex = F2(function(index, decoder) {
        return {
          $: 7,
          e: index,
          b: decoder
        };
      });
      function _Json_decodeKeyValuePairs(decoder) {
        return {
          $: 8,
          b: decoder
        };
      }
      function _Json_mapMany(f, decoders) {
        return {
          $: 9,
          f,
          g: decoders
        };
      }
      var _Json_andThen = F2(function(callback, decoder) {
        return {
          $: 10,
          b: decoder,
          h: callback
        };
      });
      function _Json_oneOf(decoders) {
        return {
          $: 11,
          g: decoders
        };
      }
      var _Json_map1 = F2(function(f, d1) {
        return _Json_mapMany(f, [d1]);
      });
      var _Json_map2 = F3(function(f, d1, d2) {
        return _Json_mapMany(f, [d1, d2]);
      });
      var _Json_map3 = F4(function(f, d1, d2, d3) {
        return _Json_mapMany(f, [d1, d2, d3]);
      });
      var _Json_map4 = F5(function(f, d1, d2, d3, d4) {
        return _Json_mapMany(f, [d1, d2, d3, d4]);
      });
      var _Json_map5 = F6(function(f, d1, d2, d3, d4, d5) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5]);
      });
      var _Json_map6 = F7(function(f, d1, d2, d3, d4, d5, d6) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6]);
      });
      var _Json_map7 = F8(function(f, d1, d2, d3, d4, d5, d6, d7) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
      });
      var _Json_map8 = F9(function(f, d1, d2, d3, d4, d5, d6, d7, d8) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
      });
      var _Json_runOnString = F2(function(decoder, string) {
        try {
          var value = JSON.parse(string);
          return _Json_runHelp(decoder, value);
        } catch (e) {
          return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, "This is not valid JSON! " + e.message, _Json_wrap(string)));
        }
      });
      var _Json_run = F2(function(decoder, value) {
        return _Json_runHelp(decoder, _Json_unwrap(value));
      });
      function _Json_runHelp(decoder, value) {
        switch (decoder.$) {
          case 2:
            return decoder.b(value);
          case 5:
            return value === null ? $elm$core$Result$Ok(decoder.c) : _Json_expecting("null", value);
          case 3:
            if (!_Json_isArray(value)) {
              return _Json_expecting("a LIST", value);
            }
            return _Json_runArrayDecoder(decoder.b, value, _List_fromArray);
          case 4:
            if (!_Json_isArray(value)) {
              return _Json_expecting("an ARRAY", value);
            }
            return _Json_runArrayDecoder(decoder.b, value, _Json_toElmArray);
          case 6:
            var field = decoder.d;
            if (typeof value !== "object" || value === null || !(field in value)) {
              return _Json_expecting("an OBJECT with a field named `" + field + "`", value);
            }
            var result = _Json_runHelp(decoder.b, value[field]);
            return $elm$core$Result$isOk(result) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, field, result.a));
          case 7:
            var index = decoder.e;
            if (!_Json_isArray(value)) {
              return _Json_expecting("an ARRAY", value);
            }
            if (index >= value.length) {
              return _Json_expecting("a LONGER array. Need index " + index + " but only see " + value.length + " entries", value);
            }
            var result = _Json_runHelp(decoder.b, value[index]);
            return $elm$core$Result$isOk(result) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, index, result.a));
          case 8:
            if (typeof value !== "object" || value === null || _Json_isArray(value)) {
              return _Json_expecting("an OBJECT", value);
            }
            var keyValuePairs = _List_Nil;
            for (var key in value) {
              if (value.hasOwnProperty(key)) {
                var result = _Json_runHelp(decoder.b, value[key]);
                if (!$elm$core$Result$isOk(result)) {
                  return $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, key, result.a));
                }
                keyValuePairs = _List_Cons(_Utils_Tuple2(key, result.a), keyValuePairs);
              }
            }
            return $elm$core$Result$Ok($elm$core$List$reverse(keyValuePairs));
          case 9:
            var answer = decoder.f;
            var decoders = decoder.g;
            for (var i = 0; i < decoders.length; i++) {
              var result = _Json_runHelp(decoders[i], value);
              if (!$elm$core$Result$isOk(result)) {
                return result;
              }
              answer = answer(result.a);
            }
            return $elm$core$Result$Ok(answer);
          case 10:
            var result = _Json_runHelp(decoder.b, value);
            return !$elm$core$Result$isOk(result) ? result : _Json_runHelp(decoder.h(result.a), value);
          case 11:
            var errors = _List_Nil;
            for (var temp = decoder.g; temp.b; temp = temp.b) {
              var result = _Json_runHelp(temp.a, value);
              if ($elm$core$Result$isOk(result)) {
                return result;
              }
              errors = _List_Cons(result.a, errors);
            }
            return $elm$core$Result$Err($elm$json$Json$Decode$OneOf($elm$core$List$reverse(errors)));
          case 1:
            return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, decoder.a, _Json_wrap(value)));
          case 0:
            return $elm$core$Result$Ok(decoder.a);
        }
      }
      function _Json_runArrayDecoder(decoder, value, toElmValue) {
        var len = value.length;
        var array = new Array(len);
        for (var i = 0; i < len; i++) {
          var result = _Json_runHelp(decoder, value[i]);
          if (!$elm$core$Result$isOk(result)) {
            return $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, i, result.a));
          }
          array[i] = result.a;
        }
        return $elm$core$Result$Ok(toElmValue(array));
      }
      function _Json_isArray(value) {
        return Array.isArray(value) || typeof FileList !== "undefined" && value instanceof FileList;
      }
      function _Json_toElmArray(array) {
        return A2($elm$core$Array$initialize, array.length, function(i) {
          return array[i];
        });
      }
      function _Json_expecting(type, value) {
        return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, "Expecting " + type, _Json_wrap(value)));
      }
      function _Json_equality(x, y) {
        if (x === y) {
          return true;
        }
        if (x.$ !== y.$) {
          return false;
        }
        switch (x.$) {
          case 0:
          case 1:
            return x.a === y.a;
          case 2:
            return x.b === y.b;
          case 5:
            return x.c === y.c;
          case 3:
          case 4:
          case 8:
            return _Json_equality(x.b, y.b);
          case 6:
            return x.d === y.d && _Json_equality(x.b, y.b);
          case 7:
            return x.e === y.e && _Json_equality(x.b, y.b);
          case 9:
            return x.f === y.f && _Json_listEquality(x.g, y.g);
          case 10:
            return x.h === y.h && _Json_equality(x.b, y.b);
          case 11:
            return _Json_listEquality(x.g, y.g);
        }
      }
      function _Json_listEquality(aDecoders, bDecoders) {
        var len = aDecoders.length;
        if (len !== bDecoders.length) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          if (!_Json_equality(aDecoders[i], bDecoders[i])) {
            return false;
          }
        }
        return true;
      }
      var _Json_encode = F2(function(indentLevel, value) {
        return JSON.stringify(_Json_unwrap(value), null, indentLevel) + "";
      });
      function _Json_wrap(value) {
        return { $: 0, a: value };
      }
      function _Json_unwrap(value) {
        return value.a;
      }
      function _Json_wrap_UNUSED(value) {
        return value;
      }
      function _Json_unwrap_UNUSED(value) {
        return value;
      }
      function _Json_emptyArray() {
        return [];
      }
      function _Json_emptyObject() {
        return {};
      }
      var _Json_addField = F3(function(key, value, object) {
        object[key] = _Json_unwrap(value);
        return object;
      });
      function _Json_addEntry(func) {
        return F2(function(entry, array) {
          array.push(_Json_unwrap(func(entry)));
          return array;
        });
      }
      var _Json_encodeNull = _Json_wrap(null);
      function _Scheduler_succeed(value) {
        return {
          $: 0,
          a: value
        };
      }
      function _Scheduler_fail(error) {
        return {
          $: 1,
          a: error
        };
      }
      function _Scheduler_binding(callback) {
        return {
          $: 2,
          b: callback,
          c: null
        };
      }
      var _Scheduler_andThen = F2(function(callback, task) {
        return {
          $: 3,
          b: callback,
          d: task
        };
      });
      var _Scheduler_onError = F2(function(callback, task) {
        return {
          $: 4,
          b: callback,
          d: task
        };
      });
      function _Scheduler_receive(callback) {
        return {
          $: 5,
          b: callback
        };
      }
      var _Scheduler_guid = 0;
      function _Scheduler_rawSpawn(task) {
        var proc = {
          $: 0,
          e: _Scheduler_guid++,
          f: task,
          g: null,
          h: []
        };
        _Scheduler_enqueue(proc);
        return proc;
      }
      function _Scheduler_spawn(task) {
        return _Scheduler_binding(function(callback) {
          callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
        });
      }
      function _Scheduler_rawSend(proc, msg) {
        proc.h.push(msg);
        _Scheduler_enqueue(proc);
      }
      var _Scheduler_send = F2(function(proc, msg) {
        return _Scheduler_binding(function(callback) {
          _Scheduler_rawSend(proc, msg);
          callback(_Scheduler_succeed(_Utils_Tuple0));
        });
      });
      function _Scheduler_kill(proc) {
        return _Scheduler_binding(function(callback) {
          var task = proc.f;
          if (task.$ === 2 && task.c) {
            task.c();
          }
          proc.f = null;
          callback(_Scheduler_succeed(_Utils_Tuple0));
        });
      }
      var _Scheduler_working = false;
      var _Scheduler_queue = [];
      function _Scheduler_enqueue(proc) {
        _Scheduler_queue.push(proc);
        if (_Scheduler_working) {
          return;
        }
        _Scheduler_working = true;
        while (proc = _Scheduler_queue.shift()) {
          _Scheduler_step(proc);
        }
        _Scheduler_working = false;
      }
      function _Scheduler_step(proc) {
        while (proc.f) {
          var rootTag = proc.f.$;
          if (rootTag === 0 || rootTag === 1) {
            while (proc.g && proc.g.$ !== rootTag) {
              proc.g = proc.g.i;
            }
            if (!proc.g) {
              return;
            }
            proc.f = proc.g.b(proc.f.a);
            proc.g = proc.g.i;
          } else if (rootTag === 2) {
            proc.f.c = proc.f.b(function(newRoot) {
              proc.f = newRoot;
              _Scheduler_enqueue(proc);
            });
            return;
          } else if (rootTag === 5) {
            if (proc.h.length === 0) {
              return;
            }
            proc.f = proc.f.b(proc.h.shift());
          } else {
            proc.g = {
              $: rootTag === 3 ? 0 : 1,
              b: proc.f.b,
              i: proc.g
            };
            proc.f = proc.f.d;
          }
        }
      }
      function _Process_sleep(time) {
        return _Scheduler_binding(function(callback) {
          var id = setTimeout(function() {
            callback(_Scheduler_succeed(_Utils_Tuple0));
          }, time);
          return function() {
            clearTimeout(id);
          };
        });
      }
      var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(
          flagDecoder,
          args,
          impl.init,
          impl.update,
          impl.subscriptions,
          function() {
            return function() {
            };
          }
        );
      });
      function _Platform_initialize(flagDecoder, args, init, update, subscriptions, stepperBuilder) {
        var result = A2(_Json_run, flagDecoder, _Json_wrap(args ? args["flags"] : void 0));
        $elm$core$Result$isOk(result) || _Debug_crash(
          2,
          _Json_errorToString(result.a)
          /**/
        );
        var managers = {};
        var initPair = init(result.a);
        var model = initPair.a;
        var stepper = stepperBuilder(sendToApp, model);
        var ports2 = _Platform_setupEffects(managers, sendToApp);
        function sendToApp(msg, viewMetadata) {
          var pair = A2(update, msg, model);
          stepper(model = pair.a, viewMetadata);
          _Platform_enqueueEffects(managers, pair.b, subscriptions(model));
        }
        _Platform_enqueueEffects(managers, initPair.b, subscriptions(model));
        return ports2 ? { ports: ports2 } : {};
      }
      var _Platform_preload;
      function _Platform_registerPreload(url) {
        _Platform_preload.add(url);
      }
      var _Platform_effectManagers = {};
      function _Platform_setupEffects(managers, sendToApp) {
        var ports2;
        for (var key in _Platform_effectManagers) {
          var manager = _Platform_effectManagers[key];
          if (manager.a) {
            ports2 = ports2 || {};
            ports2[key] = manager.a(key, sendToApp);
          }
          managers[key] = _Platform_instantiateManager(manager, sendToApp);
        }
        return ports2;
      }
      function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap) {
        return {
          b: init,
          c: onEffects,
          d: onSelfMsg,
          e: cmdMap,
          f: subMap
        };
      }
      function _Platform_instantiateManager(info, sendToApp) {
        var router = {
          g: sendToApp,
          h: void 0
        };
        var onEffects = info.c;
        var onSelfMsg = info.d;
        var cmdMap = info.e;
        var subMap = info.f;
        function loop(state) {
          return A2(_Scheduler_andThen, loop, _Scheduler_receive(function(msg) {
            var value = msg.a;
            if (msg.$ === 0) {
              return A3(onSelfMsg, router, value, state);
            }
            return cmdMap && subMap ? A4(onEffects, router, value.i, value.j, state) : A3(onEffects, router, cmdMap ? value.i : value.j, state);
          }));
        }
        return router.h = _Scheduler_rawSpawn(A2(_Scheduler_andThen, loop, info.b));
      }
      var _Platform_sendToApp = F2(function(router, msg) {
        return _Scheduler_binding(function(callback) {
          router.g(msg);
          callback(_Scheduler_succeed(_Utils_Tuple0));
        });
      });
      var _Platform_sendToSelf = F2(function(router, msg) {
        return A2(_Scheduler_send, router.h, {
          $: 0,
          a: msg
        });
      });
      function _Platform_leaf(home) {
        return function(value) {
          return {
            $: 1,
            k: home,
            l: value
          };
        };
      }
      function _Platform_batch(list) {
        return {
          $: 2,
          m: list
        };
      }
      var _Platform_map = F2(function(tagger, bag) {
        return {
          $: 3,
          n: tagger,
          o: bag
        };
      });
      var _Platform_effectsQueue = [];
      var _Platform_effectsActive = false;
      function _Platform_enqueueEffects(managers, cmdBag, subBag) {
        _Platform_effectsQueue.push({ p: managers, q: cmdBag, r: subBag });
        if (_Platform_effectsActive)
          return;
        _Platform_effectsActive = true;
        for (var fx; fx = _Platform_effectsQueue.shift(); ) {
          _Platform_dispatchEffects(fx.p, fx.q, fx.r);
        }
        _Platform_effectsActive = false;
      }
      function _Platform_dispatchEffects(managers, cmdBag, subBag) {
        var effectsDict = {};
        _Platform_gatherEffects(true, cmdBag, effectsDict, null);
        _Platform_gatherEffects(false, subBag, effectsDict, null);
        for (var home in managers) {
          _Scheduler_rawSend(managers[home], {
            $: "fx",
            a: effectsDict[home] || { i: _List_Nil, j: _List_Nil }
          });
        }
      }
      function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers) {
        switch (bag.$) {
          case 1:
            var home = bag.k;
            var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
            effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
            return;
          case 2:
            for (var list = bag.m; list.b; list = list.b) {
              _Platform_gatherEffects(isCmd, list.a, effectsDict, taggers);
            }
            return;
          case 3:
            _Platform_gatherEffects(isCmd, bag.o, effectsDict, {
              s: bag.n,
              t: taggers
            });
            return;
        }
      }
      function _Platform_toEffect(isCmd, home, taggers, value) {
        function applyTaggers(x) {
          for (var temp = taggers; temp; temp = temp.t) {
            x = temp.s(x);
          }
          return x;
        }
        var map = isCmd ? _Platform_effectManagers[home].e : _Platform_effectManagers[home].f;
        return A2(map, applyTaggers, value);
      }
      function _Platform_insert(isCmd, newEffect, effects) {
        effects = effects || { i: _List_Nil, j: _List_Nil };
        isCmd ? effects.i = _List_Cons(newEffect, effects.i) : effects.j = _List_Cons(newEffect, effects.j);
        return effects;
      }
      function _Platform_checkPortName(name) {
        if (_Platform_effectManagers[name]) {
          _Debug_crash(3, name);
        }
      }
      function _Platform_outgoingPort(name, converter) {
        _Platform_checkPortName(name);
        _Platform_effectManagers[name] = {
          e: _Platform_outgoingPortMap,
          u: converter,
          a: _Platform_setupOutgoingPort
        };
        return _Platform_leaf(name);
      }
      var _Platform_outgoingPortMap = F2(function(tagger, value) {
        return value;
      });
      function _Platform_setupOutgoingPort(name) {
        var subs = [];
        var converter = _Platform_effectManagers[name].u;
        var init = _Process_sleep(0);
        _Platform_effectManagers[name].b = init;
        _Platform_effectManagers[name].c = F3(function(router, cmdList, state) {
          for (; cmdList.b; cmdList = cmdList.b) {
            var currentSubs = subs;
            var value = _Json_unwrap(converter(cmdList.a));
            for (var i = 0; i < currentSubs.length; i++) {
              currentSubs[i](value);
            }
          }
          return init;
        });
        function subscribe(callback) {
          subs.push(callback);
        }
        function unsubscribe(callback) {
          subs = subs.slice();
          var index = subs.indexOf(callback);
          if (index >= 0) {
            subs.splice(index, 1);
          }
        }
        return {
          subscribe,
          unsubscribe
        };
      }
      function _Platform_incomingPort(name, converter) {
        _Platform_checkPortName(name);
        _Platform_effectManagers[name] = {
          f: _Platform_incomingPortMap,
          u: converter,
          a: _Platform_setupIncomingPort
        };
        return _Platform_leaf(name);
      }
      var _Platform_incomingPortMap = F2(function(tagger, finalTagger) {
        return function(value) {
          return tagger(finalTagger(value));
        };
      });
      function _Platform_setupIncomingPort(name, sendToApp) {
        var subs = _List_Nil;
        var converter = _Platform_effectManagers[name].u;
        var init = _Scheduler_succeed(null);
        _Platform_effectManagers[name].b = init;
        _Platform_effectManagers[name].c = F3(function(router, subList, state) {
          subs = subList;
          return init;
        });
        function send(incomingValue) {
          var result = A2(_Json_run, converter, _Json_wrap(incomingValue));
          $elm$core$Result$isOk(result) || _Debug_crash(4, name, result.a);
          var value = result.a;
          for (var temp = subs; temp.b; temp = temp.b) {
            sendToApp(temp.a(value));
          }
        }
        return { send };
      }
      function _Platform_export_UNUSED(exports3) {
        scope["Elm"] ? _Platform_mergeExportsProd(scope["Elm"], exports3) : scope["Elm"] = exports3;
      }
      function _Platform_mergeExportsProd(obj, exports3) {
        for (var name in exports3) {
          name in obj ? name == "init" ? _Debug_crash(6) : _Platform_mergeExportsProd(obj[name], exports3[name]) : obj[name] = exports3[name];
        }
      }
      function _Platform_export(exports3) {
        scope["Elm"] ? _Platform_mergeExportsDebug("Elm", scope["Elm"], exports3) : scope["Elm"] = exports3;
      }
      function _Platform_mergeExportsDebug(moduleName, obj, exports3) {
        for (var name in exports3) {
          name in obj ? name == "init" ? _Debug_crash(6, moduleName) : _Platform_mergeExportsDebug(moduleName + "." + name, obj[name], exports3[name]) : obj[name] = exports3[name];
        }
      }
      function _Url_percentEncode(string) {
        return encodeURIComponent(string);
      }
      function _Url_percentDecode(string) {
        try {
          return $elm$core$Maybe$Just(decodeURIComponent(string));
        } catch (e) {
          return $elm$core$Maybe$Nothing;
        }
      }
      var _Http_toTask = F3(function(router, toTask, request) {
        return _Scheduler_binding(function(callback) {
          function done(response) {
            callback(toTask(request.expect.a(response)));
          }
          var xhr = new XMLHttpRequest();
          xhr.addEventListener("error", function() {
            done($elm$http$Http$NetworkError_);
          });
          xhr.addEventListener("timeout", function() {
            done($elm$http$Http$Timeout_);
          });
          xhr.addEventListener("load", function() {
            done(_Http_toResponse(request.expect.b, xhr));
          });
          $elm$core$Maybe$isJust(request.tracker) && _Http_track(router, xhr, request.tracker.a);
          try {
            xhr.open(request.method, request.url, true);
          } catch (e) {
            return done($elm$http$Http$BadUrl_(request.url));
          }
          _Http_configureRequest(xhr, request);
          request.body.a && xhr.setRequestHeader("Content-Type", request.body.a);
          xhr.send(request.body.b);
          return function() {
            xhr.c = true;
            xhr.abort();
          };
        });
      });
      function _Http_configureRequest(xhr, request) {
        for (var headers = request.headers; headers.b; headers = headers.b) {
          xhr.setRequestHeader(headers.a.a, headers.a.b);
        }
        xhr.timeout = request.timeout.a || 0;
        xhr.responseType = request.expect.d;
        xhr.withCredentials = request.allowCookiesFromOtherDomains;
      }
      function _Http_toResponse(toBody, xhr) {
        return A2(
          200 <= xhr.status && xhr.status < 300 ? $elm$http$Http$GoodStatus_ : $elm$http$Http$BadStatus_,
          _Http_toMetadata(xhr),
          toBody(xhr.response)
        );
      }
      function _Http_toMetadata(xhr) {
        return {
          url: xhr.responseURL,
          statusCode: xhr.status,
          statusText: xhr.statusText,
          headers: _Http_parseHeaders(xhr.getAllResponseHeaders())
        };
      }
      function _Http_parseHeaders(rawHeaders) {
        if (!rawHeaders) {
          return $elm$core$Dict$empty;
        }
        var headers = $elm$core$Dict$empty;
        var headerPairs = rawHeaders.split("\r\n");
        for (var i = headerPairs.length; i--; ) {
          var headerPair = headerPairs[i];
          var index = headerPair.indexOf(": ");
          if (index > 0) {
            var key = headerPair.substring(0, index);
            var value = headerPair.substring(index + 2);
            headers = A3($elm$core$Dict$update, key, function(oldValue) {
              return $elm$core$Maybe$Just(
                $elm$core$Maybe$isJust(oldValue) ? value + ", " + oldValue.a : value
              );
            }, headers);
          }
        }
        return headers;
      }
      var _Http_expect = F3(function(type, toBody, toValue) {
        return {
          $: 0,
          d: type,
          b: toBody,
          a: toValue
        };
      });
      var _Http_mapExpect = F2(function(func, expect) {
        return {
          $: 0,
          d: expect.d,
          b: expect.b,
          a: function(x) {
            return func(expect.a(x));
          }
        };
      });
      function _Http_toDataView(arrayBuffer) {
        return new DataView(arrayBuffer);
      }
      var _Http_emptyBody = { $: 0 };
      var _Http_pair = F2(function(a, b) {
        return { $: 0, a, b };
      });
      function _Http_toFormData(parts) {
        for (var formData = new FormData(); parts.b; parts = parts.b) {
          var part = parts.a;
          formData.append(part.a, part.b);
        }
        return formData;
      }
      var _Http_bytesToBlob = F2(function(mime, bytes) {
        return new Blob([bytes], { type: mime });
      });
      function _Http_track(router, xhr, tracker) {
        xhr.upload.addEventListener("progress", function(event) {
          if (xhr.c) {
            return;
          }
          _Scheduler_rawSpawn(A2($elm$core$Platform$sendToSelf, router, _Utils_Tuple2(tracker, $elm$http$Http$Sending({
            sent: event.loaded,
            size: event.total
          }))));
        });
        xhr.addEventListener("progress", function(event) {
          if (xhr.c) {
            return;
          }
          _Scheduler_rawSpawn(A2($elm$core$Platform$sendToSelf, router, _Utils_Tuple2(tracker, $elm$http$Http$Receiving({
            received: event.loaded,
            size: event.lengthComputable ? $elm$core$Maybe$Just(event.total) : $elm$core$Maybe$Nothing
          }))));
        });
      }
      function _Time_now(millisToPosix) {
        return _Scheduler_binding(function(callback) {
          callback(_Scheduler_succeed(millisToPosix(Date.now())));
        });
      }
      var _Time_setInterval = F2(function(interval, task) {
        return _Scheduler_binding(function(callback) {
          var id = setInterval(function() {
            _Scheduler_rawSpawn(task);
          }, interval);
          return function() {
            clearInterval(id);
          };
        });
      });
      function _Time_here() {
        return _Scheduler_binding(function(callback) {
          callback(_Scheduler_succeed(
            A2($elm$time$Time$customZone, -(/* @__PURE__ */ new Date()).getTimezoneOffset(), _List_Nil)
          ));
        });
      }
      function _Time_getZoneName() {
        return _Scheduler_binding(function(callback) {
          try {
            var name = $elm$time$Time$Name(Intl.DateTimeFormat().resolvedOptions().timeZone);
          } catch (e) {
            var name = $elm$time$Time$Offset((/* @__PURE__ */ new Date()).getTimezoneOffset());
          }
          callback(_Scheduler_succeed(name));
        });
      }
      var _Regex_never = /.^/;
      var _Regex_fromStringWith = F2(function(options, string) {
        var flags2 = "g";
        if (options.multiline) {
          flags2 += "m";
        }
        if (options.caseInsensitive) {
          flags2 += "i";
        }
        try {
          return $elm$core$Maybe$Just(new RegExp(string, flags2));
        } catch (error) {
          return $elm$core$Maybe$Nothing;
        }
      });
      var _Regex_contains = F2(function(re, string) {
        return string.match(re) !== null;
      });
      var _Regex_findAtMost = F3(function(n, re, str) {
        var out = [];
        var number = 0;
        var string = str;
        var lastIndex = re.lastIndex;
        var prevLastIndex = -1;
        var result;
        while (number++ < n && (result = re.exec(string))) {
          if (prevLastIndex == re.lastIndex)
            break;
          var i = result.length - 1;
          var subs = new Array(i);
          while (i > 0) {
            var submatch = result[i];
            subs[--i] = submatch ? $elm$core$Maybe$Just(submatch) : $elm$core$Maybe$Nothing;
          }
          out.push(A4($elm$regex$Regex$Match, result[0], result.index, number, _List_fromArray(subs)));
          prevLastIndex = re.lastIndex;
        }
        re.lastIndex = lastIndex;
        return _List_fromArray(out);
      });
      var _Regex_replaceAtMost = F4(function(n, re, replacer, string) {
        var count = 0;
        function jsReplacer(match) {
          if (count++ >= n) {
            return match;
          }
          var i = arguments.length - 3;
          var submatches = new Array(i);
          while (i > 0) {
            var submatch = arguments[i];
            submatches[--i] = submatch ? $elm$core$Maybe$Just(submatch) : $elm$core$Maybe$Nothing;
          }
          return replacer(A4($elm$regex$Regex$Match, match, arguments[arguments.length - 2], count, _List_fromArray(submatches)));
        }
        return string.replace(re, jsReplacer);
      });
      var _Regex_splitAtMost = F3(function(n, re, str) {
        var string = str;
        var out = [];
        var start = re.lastIndex;
        var restoreLastIndex = re.lastIndex;
        while (n--) {
          var result = re.exec(string);
          if (!result)
            break;
          out.push(string.slice(start, result.index));
          start = re.lastIndex;
        }
        out.push(string.slice(start));
        re.lastIndex = restoreLastIndex;
        return _List_fromArray(out);
      });
      var _Regex_infinity = Infinity;
      var _Bitwise_and = F2(function(a, b) {
        return a & b;
      });
      var _Bitwise_or = F2(function(a, b) {
        return a | b;
      });
      var _Bitwise_xor = F2(function(a, b) {
        return a ^ b;
      });
      function _Bitwise_complement(a) {
        return ~a;
      }
      ;
      var _Bitwise_shiftLeftBy = F2(function(offset, a) {
        return a << offset;
      });
      var _Bitwise_shiftRightBy = F2(function(offset, a) {
        return a >> offset;
      });
      var _Bitwise_shiftRightZfBy = F2(function(offset, a) {
        return a >>> offset;
      });
      var _Parser_isSubString = F5(function(smallString, offset, row, col, bigString) {
        var smallLength = smallString.length;
        var isGood = offset + smallLength <= bigString.length;
        for (var i = 0; isGood && i < smallLength; ) {
          var code = bigString.charCodeAt(offset);
          isGood = smallString[i++] === bigString[offset++] && (code === 10 ? (row++, col = 1) : (col++, (code & 63488) === 55296 ? smallString[i++] === bigString[offset++] : 1));
        }
        return _Utils_Tuple3(isGood ? offset : -1, row, col);
      });
      var _Parser_isSubChar = F3(function(predicate, offset, string) {
        return string.length <= offset ? -1 : (string.charCodeAt(offset) & 63488) === 55296 ? predicate(_Utils_chr(string.substr(offset, 2))) ? offset + 2 : -1 : predicate(_Utils_chr(string[offset])) ? string[offset] === "\n" ? -2 : offset + 1 : -1;
      });
      var _Parser_isAsciiCode = F3(function(code, offset, string) {
        return string.charCodeAt(offset) === code;
      });
      var _Parser_chompBase10 = F2(function(offset, string) {
        for (; offset < string.length; offset++) {
          var code = string.charCodeAt(offset);
          if (code < 48 || 57 < code) {
            return offset;
          }
        }
        return offset;
      });
      var _Parser_consumeBase = F3(function(base, offset, string) {
        for (var total = 0; offset < string.length; offset++) {
          var digit = string.charCodeAt(offset) - 48;
          if (digit < 0 || base <= digit)
            break;
          total = base * total + digit;
        }
        return _Utils_Tuple2(offset, total);
      });
      var _Parser_consumeBase16 = F2(function(offset, string) {
        for (var total = 0; offset < string.length; offset++) {
          var code = string.charCodeAt(offset);
          if (48 <= code && code <= 57) {
            total = 16 * total + code - 48;
          } else if (65 <= code && code <= 70) {
            total = 16 * total + code - 55;
          } else if (97 <= code && code <= 102) {
            total = 16 * total + code - 87;
          } else {
            break;
          }
        }
        return _Utils_Tuple2(offset, total);
      });
      var _Parser_findSubString = F5(function(smallString, offset, row, col, bigString) {
        var newOffset = bigString.indexOf(smallString, offset);
        var target = newOffset < 0 ? bigString.length : newOffset + smallString.length;
        while (offset < target) {
          var code = bigString.charCodeAt(offset++);
          code === 10 ? (col = 1, row++) : (col++, (code & 63488) === 55296 && offset++);
        }
        return _Utils_Tuple3(newOffset, row, col);
      });
      var $elm$core$List$cons = _List_cons;
      var $elm$core$Elm$JsArray$foldr = _JsArray_foldr;
      var $elm$core$Array$foldr = F3(
        function(func, baseCase, _v0) {
          var tree = _v0.c;
          var tail = _v0.d;
          var helper = F2(
            function(node, acc) {
              if (node.$ === "SubTree") {
                var subTree = node.a;
                return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
              } else {
                var values = node.a;
                return A3($elm$core$Elm$JsArray$foldr, func, acc, values);
              }
            }
          );
          return A3(
            $elm$core$Elm$JsArray$foldr,
            helper,
            A3($elm$core$Elm$JsArray$foldr, func, baseCase, tail),
            tree
          );
        }
      );
      var $elm$core$Array$toList = function(array) {
        return A3($elm$core$Array$foldr, $elm$core$List$cons, _List_Nil, array);
      };
      var $elm$core$Dict$foldr = F3(
        function(func, acc, t) {
          foldr:
            while (true) {
              if (t.$ === "RBEmpty_elm_builtin") {
                return acc;
              } else {
                var key = t.b;
                var value = t.c;
                var left = t.d;
                var right = t.e;
                var $temp$func = func, $temp$acc = A3(
                  func,
                  key,
                  value,
                  A3($elm$core$Dict$foldr, func, acc, right)
                ), $temp$t = left;
                func = $temp$func;
                acc = $temp$acc;
                t = $temp$t;
                continue foldr;
              }
            }
        }
      );
      var $elm$core$Dict$toList = function(dict) {
        return A3(
          $elm$core$Dict$foldr,
          F3(
            function(key, value, list) {
              return A2(
                $elm$core$List$cons,
                _Utils_Tuple2(key, value),
                list
              );
            }
          ),
          _List_Nil,
          dict
        );
      };
      var $elm$core$Dict$keys = function(dict) {
        return A3(
          $elm$core$Dict$foldr,
          F3(
            function(key, value, keyList) {
              return A2($elm$core$List$cons, key, keyList);
            }
          ),
          _List_Nil,
          dict
        );
      };
      var $elm$core$Set$toList = function(_v0) {
        var dict = _v0.a;
        return $elm$core$Dict$keys(dict);
      };
      var $elm$core$Basics$EQ = { $: "EQ" };
      var $elm$core$Basics$GT = { $: "GT" };
      var $elm$core$Basics$LT = { $: "LT" };
      var $elm$core$Result$Err = function(a) {
        return { $: "Err", a };
      };
      var $elm$json$Json$Decode$Failure = F2(
        function(a, b) {
          return { $: "Failure", a, b };
        }
      );
      var $elm$json$Json$Decode$Field = F2(
        function(a, b) {
          return { $: "Field", a, b };
        }
      );
      var $elm$json$Json$Decode$Index = F2(
        function(a, b) {
          return { $: "Index", a, b };
        }
      );
      var $elm$core$Result$Ok = function(a) {
        return { $: "Ok", a };
      };
      var $elm$json$Json$Decode$OneOf = function(a) {
        return { $: "OneOf", a };
      };
      var $elm$core$Basics$False = { $: "False" };
      var $elm$core$Basics$add = _Basics_add;
      var $elm$core$Maybe$Just = function(a) {
        return { $: "Just", a };
      };
      var $elm$core$Maybe$Nothing = { $: "Nothing" };
      var $elm$core$String$all = _String_all;
      var $elm$core$Basics$and = _Basics_and;
      var $elm$core$Basics$append = _Utils_append;
      var $elm$json$Json$Encode$encode = _Json_encode;
      var $elm$core$String$fromInt = _String_fromNumber;
      var $elm$core$String$join = F2(
        function(sep, chunks) {
          return A2(
            _String_join,
            sep,
            _List_toArray(chunks)
          );
        }
      );
      var $elm$core$String$split = F2(
        function(sep, string) {
          return _List_fromArray(
            A2(_String_split, sep, string)
          );
        }
      );
      var $elm$json$Json$Decode$indent = function(str) {
        return A2(
          $elm$core$String$join,
          "\n    ",
          A2($elm$core$String$split, "\n", str)
        );
      };
      var $elm$core$List$foldl = F3(
        function(func, acc, list) {
          foldl:
            while (true) {
              if (!list.b) {
                return acc;
              } else {
                var x = list.a;
                var xs = list.b;
                var $temp$func = func, $temp$acc = A2(func, x, acc), $temp$list = xs;
                func = $temp$func;
                acc = $temp$acc;
                list = $temp$list;
                continue foldl;
              }
            }
        }
      );
      var $elm$core$List$length = function(xs) {
        return A3(
          $elm$core$List$foldl,
          F2(
            function(_v0, i) {
              return i + 1;
            }
          ),
          0,
          xs
        );
      };
      var $elm$core$List$map2 = _List_map2;
      var $elm$core$Basics$le = _Utils_le;
      var $elm$core$Basics$sub = _Basics_sub;
      var $elm$core$List$rangeHelp = F3(
        function(lo, hi, list) {
          rangeHelp:
            while (true) {
              if (_Utils_cmp(lo, hi) < 1) {
                var $temp$lo = lo, $temp$hi = hi - 1, $temp$list = A2($elm$core$List$cons, hi, list);
                lo = $temp$lo;
                hi = $temp$hi;
                list = $temp$list;
                continue rangeHelp;
              } else {
                return list;
              }
            }
        }
      );
      var $elm$core$List$range = F2(
        function(lo, hi) {
          return A3($elm$core$List$rangeHelp, lo, hi, _List_Nil);
        }
      );
      var $elm$core$List$indexedMap = F2(
        function(f, xs) {
          return A3(
            $elm$core$List$map2,
            f,
            A2(
              $elm$core$List$range,
              0,
              $elm$core$List$length(xs) - 1
            ),
            xs
          );
        }
      );
      var $elm$core$Char$toCode = _Char_toCode;
      var $elm$core$Char$isLower = function(_char) {
        var code = $elm$core$Char$toCode(_char);
        return 97 <= code && code <= 122;
      };
      var $elm$core$Char$isUpper = function(_char) {
        var code = $elm$core$Char$toCode(_char);
        return code <= 90 && 65 <= code;
      };
      var $elm$core$Basics$or = _Basics_or;
      var $elm$core$Char$isAlpha = function(_char) {
        return $elm$core$Char$isLower(_char) || $elm$core$Char$isUpper(_char);
      };
      var $elm$core$Char$isDigit = function(_char) {
        var code = $elm$core$Char$toCode(_char);
        return code <= 57 && 48 <= code;
      };
      var $elm$core$Char$isAlphaNum = function(_char) {
        return $elm$core$Char$isLower(_char) || ($elm$core$Char$isUpper(_char) || $elm$core$Char$isDigit(_char));
      };
      var $elm$core$List$reverse = function(list) {
        return A3($elm$core$List$foldl, $elm$core$List$cons, _List_Nil, list);
      };
      var $elm$core$String$uncons = _String_uncons;
      var $elm$json$Json$Decode$errorOneOf = F2(
        function(i, error) {
          return "\n\n(" + ($elm$core$String$fromInt(i + 1) + (") " + $elm$json$Json$Decode$indent(
            $elm$json$Json$Decode$errorToString(error)
          )));
        }
      );
      var $elm$json$Json$Decode$errorToString = function(error) {
        return A2($elm$json$Json$Decode$errorToStringHelp, error, _List_Nil);
      };
      var $elm$json$Json$Decode$errorToStringHelp = F2(
        function(error, context) {
          errorToStringHelp:
            while (true) {
              switch (error.$) {
                case "Field":
                  var f = error.a;
                  var err = error.b;
                  var isSimple = function() {
                    var _v1 = $elm$core$String$uncons(f);
                    if (_v1.$ === "Nothing") {
                      return false;
                    } else {
                      var _v2 = _v1.a;
                      var _char = _v2.a;
                      var rest = _v2.b;
                      return $elm$core$Char$isAlpha(_char) && A2($elm$core$String$all, $elm$core$Char$isAlphaNum, rest);
                    }
                  }();
                  var fieldName = isSimple ? "." + f : "['" + (f + "']");
                  var $temp$error = err, $temp$context = A2($elm$core$List$cons, fieldName, context);
                  error = $temp$error;
                  context = $temp$context;
                  continue errorToStringHelp;
                case "Index":
                  var i = error.a;
                  var err = error.b;
                  var indexName = "[" + ($elm$core$String$fromInt(i) + "]");
                  var $temp$error = err, $temp$context = A2($elm$core$List$cons, indexName, context);
                  error = $temp$error;
                  context = $temp$context;
                  continue errorToStringHelp;
                case "OneOf":
                  var errors = error.a;
                  if (!errors.b) {
                    return "Ran into a Json.Decode.oneOf with no possibilities" + function() {
                      if (!context.b) {
                        return "!";
                      } else {
                        return " at json" + A2(
                          $elm$core$String$join,
                          "",
                          $elm$core$List$reverse(context)
                        );
                      }
                    }();
                  } else {
                    if (!errors.b.b) {
                      var err = errors.a;
                      var $temp$error = err, $temp$context = context;
                      error = $temp$error;
                      context = $temp$context;
                      continue errorToStringHelp;
                    } else {
                      var starter = function() {
                        if (!context.b) {
                          return "Json.Decode.oneOf";
                        } else {
                          return "The Json.Decode.oneOf at json" + A2(
                            $elm$core$String$join,
                            "",
                            $elm$core$List$reverse(context)
                          );
                        }
                      }();
                      var introduction = starter + (" failed in the following " + ($elm$core$String$fromInt(
                        $elm$core$List$length(errors)
                      ) + " ways:"));
                      return A2(
                        $elm$core$String$join,
                        "\n\n",
                        A2(
                          $elm$core$List$cons,
                          introduction,
                          A2($elm$core$List$indexedMap, $elm$json$Json$Decode$errorOneOf, errors)
                        )
                      );
                    }
                  }
                default:
                  var msg = error.a;
                  var json = error.b;
                  var introduction = function() {
                    if (!context.b) {
                      return "Problem with the given value:\n\n";
                    } else {
                      return "Problem with the value at json" + (A2(
                        $elm$core$String$join,
                        "",
                        $elm$core$List$reverse(context)
                      ) + ":\n\n    ");
                    }
                  }();
                  return introduction + ($elm$json$Json$Decode$indent(
                    A2($elm$json$Json$Encode$encode, 4, json)
                  ) + ("\n\n" + msg));
              }
            }
        }
      );
      var $elm$core$Array$branchFactor = 32;
      var $elm$core$Array$Array_elm_builtin = F4(
        function(a, b, c, d) {
          return { $: "Array_elm_builtin", a, b, c, d };
        }
      );
      var $elm$core$Elm$JsArray$empty = _JsArray_empty;
      var $elm$core$Basics$ceiling = _Basics_ceiling;
      var $elm$core$Basics$fdiv = _Basics_fdiv;
      var $elm$core$Basics$logBase = F2(
        function(base, number) {
          return _Basics_log(number) / _Basics_log(base);
        }
      );
      var $elm$core$Basics$toFloat = _Basics_toFloat;
      var $elm$core$Array$shiftStep = $elm$core$Basics$ceiling(
        A2($elm$core$Basics$logBase, 2, $elm$core$Array$branchFactor)
      );
      var $elm$core$Array$empty = A4($elm$core$Array$Array_elm_builtin, 0, $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, $elm$core$Elm$JsArray$empty);
      var $elm$core$Elm$JsArray$initialize = _JsArray_initialize;
      var $elm$core$Array$Leaf = function(a) {
        return { $: "Leaf", a };
      };
      var $elm$core$Basics$apL = F2(
        function(f, x) {
          return f(x);
        }
      );
      var $elm$core$Basics$apR = F2(
        function(x, f) {
          return f(x);
        }
      );
      var $elm$core$Basics$eq = _Utils_equal;
      var $elm$core$Basics$floor = _Basics_floor;
      var $elm$core$Elm$JsArray$length = _JsArray_length;
      var $elm$core$Basics$gt = _Utils_gt;
      var $elm$core$Basics$max = F2(
        function(x, y) {
          return _Utils_cmp(x, y) > 0 ? x : y;
        }
      );
      var $elm$core$Basics$mul = _Basics_mul;
      var $elm$core$Array$SubTree = function(a) {
        return { $: "SubTree", a };
      };
      var $elm$core$Elm$JsArray$initializeFromList = _JsArray_initializeFromList;
      var $elm$core$Array$compressNodes = F2(
        function(nodes, acc) {
          compressNodes:
            while (true) {
              var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodes);
              var node = _v0.a;
              var remainingNodes = _v0.b;
              var newAcc = A2(
                $elm$core$List$cons,
                $elm$core$Array$SubTree(node),
                acc
              );
              if (!remainingNodes.b) {
                return $elm$core$List$reverse(newAcc);
              } else {
                var $temp$nodes = remainingNodes, $temp$acc = newAcc;
                nodes = $temp$nodes;
                acc = $temp$acc;
                continue compressNodes;
              }
            }
        }
      );
      var $elm$core$Tuple$first = function(_v0) {
        var x = _v0.a;
        return x;
      };
      var $elm$core$Array$treeFromBuilder = F2(
        function(nodeList, nodeListSize) {
          treeFromBuilder:
            while (true) {
              var newNodeSize = $elm$core$Basics$ceiling(nodeListSize / $elm$core$Array$branchFactor);
              if (newNodeSize === 1) {
                return A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodeList).a;
              } else {
                var $temp$nodeList = A2($elm$core$Array$compressNodes, nodeList, _List_Nil), $temp$nodeListSize = newNodeSize;
                nodeList = $temp$nodeList;
                nodeListSize = $temp$nodeListSize;
                continue treeFromBuilder;
              }
            }
        }
      );
      var $elm$core$Array$builderToArray = F2(
        function(reverseNodeList, builder) {
          if (!builder.nodeListSize) {
            return A4(
              $elm$core$Array$Array_elm_builtin,
              $elm$core$Elm$JsArray$length(builder.tail),
              $elm$core$Array$shiftStep,
              $elm$core$Elm$JsArray$empty,
              builder.tail
            );
          } else {
            var treeLen = builder.nodeListSize * $elm$core$Array$branchFactor;
            var depth = $elm$core$Basics$floor(
              A2($elm$core$Basics$logBase, $elm$core$Array$branchFactor, treeLen - 1)
            );
            var correctNodeList = reverseNodeList ? $elm$core$List$reverse(builder.nodeList) : builder.nodeList;
            var tree = A2($elm$core$Array$treeFromBuilder, correctNodeList, builder.nodeListSize);
            return A4(
              $elm$core$Array$Array_elm_builtin,
              $elm$core$Elm$JsArray$length(builder.tail) + treeLen,
              A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep),
              tree,
              builder.tail
            );
          }
        }
      );
      var $elm$core$Basics$idiv = _Basics_idiv;
      var $elm$core$Basics$lt = _Utils_lt;
      var $elm$core$Array$initializeHelp = F5(
        function(fn, fromIndex, len, nodeList, tail) {
          initializeHelp:
            while (true) {
              if (fromIndex < 0) {
                return A2(
                  $elm$core$Array$builderToArray,
                  false,
                  { nodeList, nodeListSize: len / $elm$core$Array$branchFactor | 0, tail }
                );
              } else {
                var leaf = $elm$core$Array$Leaf(
                  A3($elm$core$Elm$JsArray$initialize, $elm$core$Array$branchFactor, fromIndex, fn)
                );
                var $temp$fn = fn, $temp$fromIndex = fromIndex - $elm$core$Array$branchFactor, $temp$len = len, $temp$nodeList = A2($elm$core$List$cons, leaf, nodeList), $temp$tail = tail;
                fn = $temp$fn;
                fromIndex = $temp$fromIndex;
                len = $temp$len;
                nodeList = $temp$nodeList;
                tail = $temp$tail;
                continue initializeHelp;
              }
            }
        }
      );
      var $elm$core$Basics$remainderBy = _Basics_remainderBy;
      var $elm$core$Array$initialize = F2(
        function(len, fn) {
          if (len <= 0) {
            return $elm$core$Array$empty;
          } else {
            var tailLen = len % $elm$core$Array$branchFactor;
            var tail = A3($elm$core$Elm$JsArray$initialize, tailLen, len - tailLen, fn);
            var initialFromIndex = len - tailLen - $elm$core$Array$branchFactor;
            return A5($elm$core$Array$initializeHelp, fn, initialFromIndex, len, _List_Nil, tail);
          }
        }
      );
      var $elm$core$Basics$True = { $: "True" };
      var $elm$core$Result$isOk = function(result) {
        if (result.$ === "Ok") {
          return true;
        } else {
          return false;
        }
      };
      var $elm$json$Json$Decode$andThen = _Json_andThen;
      var $elm$json$Json$Decode$field = _Json_decodeField;
      var $elm$url$Url$Http = { $: "Http" };
      var $author$project$Sources$Processing$NotProcessing = { $: "NotProcessing" };
      var $author$project$Brain$Types$SetCurrentTime = function(a) {
        return { $: "SetCurrentTime", a };
      };
      var $elm$core$Basics$identity = function(x) {
        return x;
      };
      var $Gizra$elm_debouncer$Debouncer$Internal$Config = function(a) {
        return { $: "Config", a };
      };
      var $Gizra$elm_debouncer$Debouncer$Internal$accumulateWith = F2(
        function(accumulator, _v0) {
          var config = _v0.a;
          return $Gizra$elm_debouncer$Debouncer$Internal$Config(
            { accumulator, emitWhenUnsettled: config.emitWhenUnsettled, emitWhileUnsettled: config.emitWhileUnsettled, settleWhenQuietFor: config.settleWhenQuietFor }
          );
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Basic$accumulateWith = $Gizra$elm_debouncer$Debouncer$Internal$accumulateWith;
      var $elm$core$Maybe$withDefault = F2(
        function(_default, maybe) {
          if (maybe.$ === "Just") {
            var value = maybe.a;
            return value;
          } else {
            return _default;
          }
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Internal$allInputs = F2(
        function(i, o) {
          return $elm$core$Maybe$Just(
            A2(
              $elm$core$List$cons,
              i,
              A2($elm$core$Maybe$withDefault, _List_Nil, o)
            )
          );
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Basic$allInputs = $Gizra$elm_debouncer$Debouncer$Internal$allInputs;
      var $elm$core$Platform$Cmd$batch = _Platform_batch;
      var $Gizra$elm_debouncer$Debouncer$Internal$lastInput = F2(
        function(i, o) {
          return $elm$core$Maybe$Just(i);
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Internal$manual = $Gizra$elm_debouncer$Debouncer$Internal$Config(
        { accumulator: $Gizra$elm_debouncer$Debouncer$Internal$lastInput, emitWhenUnsettled: $elm$core$Maybe$Nothing, emitWhileUnsettled: $elm$core$Maybe$Nothing, settleWhenQuietFor: $elm$core$Maybe$Nothing }
      );
      var $Gizra$elm_debouncer$Debouncer$Basic$manual = $Gizra$elm_debouncer$Debouncer$Internal$manual;
      var $Gizra$elm_debouncer$Debouncer$Internal$settleWhenQuietFor = F2(
        function(time, _v0) {
          var config = _v0.a;
          return $Gizra$elm_debouncer$Debouncer$Internal$Config(
            _Utils_update(
              config,
              { settleWhenQuietFor: time }
            )
          );
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Basic$settleWhenQuietFor = $Gizra$elm_debouncer$Debouncer$Internal$settleWhenQuietFor;
      var $Gizra$elm_debouncer$Debouncer$Basic$debounce = function(interval) {
        return A2(
          $Gizra$elm_debouncer$Debouncer$Basic$settleWhenQuietFor,
          $elm$core$Maybe$Just(interval),
          $Gizra$elm_debouncer$Debouncer$Basic$manual
        );
      };
      var $elm$time$Time$Posix = function(a) {
        return { $: "Posix", a };
      };
      var $elm$time$Time$millisToPosix = $elm$time$Time$Posix;
      var $author$project$Time$Ext$default = $elm$time$Time$millisToPosix(0);
      var $elm$core$Dict$RBEmpty_elm_builtin = { $: "RBEmpty_elm_builtin" };
      var $elm$core$Dict$empty = $elm$core$Dict$RBEmpty_elm_builtin;
      var $author$project$User$Layer$emptyHypaethralData = { favourites: _List_Nil, modifiedAt: $elm$core$Maybe$Nothing, playlists: _List_Nil, progress: $elm$core$Dict$empty, settings: $elm$core$Maybe$Nothing, sources: _List_Nil, tracks: _List_Nil };
      var $elm$core$Basics$round = _Basics_round;
      var $Gizra$elm_debouncer$Debouncer$Internal$fromSeconds = function(s) {
        return $elm$core$Basics$round(s * 1e3);
      };
      var $Gizra$elm_debouncer$Debouncer$Basic$fromSeconds = $Gizra$elm_debouncer$Debouncer$Internal$fromSeconds;
      var $elm$url$Url$Https = { $: "Https" };
      var $elm$url$Url$Url = F6(
        function(protocol, host, port_, path, query, fragment) {
          return { fragment, host, path, port_, protocol, query };
        }
      );
      var $elm$core$String$contains = _String_contains;
      var $elm$core$String$length = _String_length;
      var $elm$core$String$slice = _String_slice;
      var $elm$core$String$dropLeft = F2(
        function(n, string) {
          return n < 1 ? string : A3(
            $elm$core$String$slice,
            n,
            $elm$core$String$length(string),
            string
          );
        }
      );
      var $elm$core$String$indexes = _String_indexes;
      var $elm$core$String$isEmpty = function(string) {
        return string === "";
      };
      var $elm$core$String$left = F2(
        function(n, string) {
          return n < 1 ? "" : A3($elm$core$String$slice, 0, n, string);
        }
      );
      var $elm$core$String$toInt = _String_toInt;
      var $elm$url$Url$chompBeforePath = F5(
        function(protocol, path, params, frag, str) {
          if ($elm$core$String$isEmpty(str) || A2($elm$core$String$contains, "@", str)) {
            return $elm$core$Maybe$Nothing;
          } else {
            var _v0 = A2($elm$core$String$indexes, ":", str);
            if (!_v0.b) {
              return $elm$core$Maybe$Just(
                A6($elm$url$Url$Url, protocol, str, $elm$core$Maybe$Nothing, path, params, frag)
              );
            } else {
              if (!_v0.b.b) {
                var i = _v0.a;
                var _v1 = $elm$core$String$toInt(
                  A2($elm$core$String$dropLeft, i + 1, str)
                );
                if (_v1.$ === "Nothing") {
                  return $elm$core$Maybe$Nothing;
                } else {
                  var port_ = _v1;
                  return $elm$core$Maybe$Just(
                    A6(
                      $elm$url$Url$Url,
                      protocol,
                      A2($elm$core$String$left, i, str),
                      port_,
                      path,
                      params,
                      frag
                    )
                  );
                }
              } else {
                return $elm$core$Maybe$Nothing;
              }
            }
          }
        }
      );
      var $elm$url$Url$chompBeforeQuery = F4(
        function(protocol, params, frag, str) {
          if ($elm$core$String$isEmpty(str)) {
            return $elm$core$Maybe$Nothing;
          } else {
            var _v0 = A2($elm$core$String$indexes, "/", str);
            if (!_v0.b) {
              return A5($elm$url$Url$chompBeforePath, protocol, "/", params, frag, str);
            } else {
              var i = _v0.a;
              return A5(
                $elm$url$Url$chompBeforePath,
                protocol,
                A2($elm$core$String$dropLeft, i, str),
                params,
                frag,
                A2($elm$core$String$left, i, str)
              );
            }
          }
        }
      );
      var $elm$url$Url$chompBeforeFragment = F3(
        function(protocol, frag, str) {
          if ($elm$core$String$isEmpty(str)) {
            return $elm$core$Maybe$Nothing;
          } else {
            var _v0 = A2($elm$core$String$indexes, "?", str);
            if (!_v0.b) {
              return A4($elm$url$Url$chompBeforeQuery, protocol, $elm$core$Maybe$Nothing, frag, str);
            } else {
              var i = _v0.a;
              return A4(
                $elm$url$Url$chompBeforeQuery,
                protocol,
                $elm$core$Maybe$Just(
                  A2($elm$core$String$dropLeft, i + 1, str)
                ),
                frag,
                A2($elm$core$String$left, i, str)
              );
            }
          }
        }
      );
      var $elm$url$Url$chompAfterProtocol = F2(
        function(protocol, str) {
          if ($elm$core$String$isEmpty(str)) {
            return $elm$core$Maybe$Nothing;
          } else {
            var _v0 = A2($elm$core$String$indexes, "#", str);
            if (!_v0.b) {
              return A3($elm$url$Url$chompBeforeFragment, protocol, $elm$core$Maybe$Nothing, str);
            } else {
              var i = _v0.a;
              return A3(
                $elm$url$Url$chompBeforeFragment,
                protocol,
                $elm$core$Maybe$Just(
                  A2($elm$core$String$dropLeft, i + 1, str)
                ),
                A2($elm$core$String$left, i, str)
              );
            }
          }
        }
      );
      var $elm$core$String$startsWith = _String_startsWith;
      var $elm$url$Url$fromString = function(str) {
        return A2($elm$core$String$startsWith, "http://", str) ? A2(
          $elm$url$Url$chompAfterProtocol,
          $elm$url$Url$Http,
          A2($elm$core$String$dropLeft, 7, str)
        ) : A2($elm$core$String$startsWith, "https://", str) ? A2(
          $elm$url$Url$chompAfterProtocol,
          $elm$url$Url$Https,
          A2($elm$core$String$dropLeft, 8, str)
        ) : $elm$core$Maybe$Nothing;
      };
      var $elm_community$maybe_extra$Maybe$Extra$join = function(mx) {
        if (mx.$ === "Just") {
          var x = mx.a;
          return x;
        } else {
          return $elm$core$Maybe$Nothing;
        }
      };
      var $elm$url$Url$Parser$State = F5(
        function(visited, unvisited, params, frag, value) {
          return { frag, params, unvisited, value, visited };
        }
      );
      var $elm$url$Url$Parser$getFirstMatch = function(states) {
        getFirstMatch:
          while (true) {
            if (!states.b) {
              return $elm$core$Maybe$Nothing;
            } else {
              var state = states.a;
              var rest = states.b;
              var _v1 = state.unvisited;
              if (!_v1.b) {
                return $elm$core$Maybe$Just(state.value);
              } else {
                if (_v1.a === "" && !_v1.b.b) {
                  return $elm$core$Maybe$Just(state.value);
                } else {
                  var $temp$states = rest;
                  states = $temp$states;
                  continue getFirstMatch;
                }
              }
            }
          }
      };
      var $elm$url$Url$Parser$removeFinalEmpty = function(segments) {
        if (!segments.b) {
          return _List_Nil;
        } else {
          if (segments.a === "" && !segments.b.b) {
            return _List_Nil;
          } else {
            var segment = segments.a;
            var rest = segments.b;
            return A2(
              $elm$core$List$cons,
              segment,
              $elm$url$Url$Parser$removeFinalEmpty(rest)
            );
          }
        }
      };
      var $elm$url$Url$Parser$preparePath = function(path) {
        var _v0 = A2($elm$core$String$split, "/", path);
        if (_v0.b && _v0.a === "") {
          var segments = _v0.b;
          return $elm$url$Url$Parser$removeFinalEmpty(segments);
        } else {
          var segments = _v0;
          return $elm$url$Url$Parser$removeFinalEmpty(segments);
        }
      };
      var $elm$url$Url$Parser$addToParametersHelp = F2(
        function(value, maybeList) {
          if (maybeList.$ === "Nothing") {
            return $elm$core$Maybe$Just(
              _List_fromArray(
                [value]
              )
            );
          } else {
            var list = maybeList.a;
            return $elm$core$Maybe$Just(
              A2($elm$core$List$cons, value, list)
            );
          }
        }
      );
      var $elm$url$Url$percentDecode = _Url_percentDecode;
      var $elm$core$Basics$compare = _Utils_compare;
      var $elm$core$Dict$get = F2(
        function(targetKey, dict) {
          get:
            while (true) {
              if (dict.$ === "RBEmpty_elm_builtin") {
                return $elm$core$Maybe$Nothing;
              } else {
                var key = dict.b;
                var value = dict.c;
                var left = dict.d;
                var right = dict.e;
                var _v1 = A2($elm$core$Basics$compare, targetKey, key);
                switch (_v1.$) {
                  case "LT":
                    var $temp$targetKey = targetKey, $temp$dict = left;
                    targetKey = $temp$targetKey;
                    dict = $temp$dict;
                    continue get;
                  case "EQ":
                    return $elm$core$Maybe$Just(value);
                  default:
                    var $temp$targetKey = targetKey, $temp$dict = right;
                    targetKey = $temp$targetKey;
                    dict = $temp$dict;
                    continue get;
                }
              }
            }
        }
      );
      var $elm$core$Dict$Black = { $: "Black" };
      var $elm$core$Dict$RBNode_elm_builtin = F5(
        function(a, b, c, d, e) {
          return { $: "RBNode_elm_builtin", a, b, c, d, e };
        }
      );
      var $elm$core$Dict$Red = { $: "Red" };
      var $elm$core$Dict$balance = F5(
        function(color, key, value, left, right) {
          if (right.$ === "RBNode_elm_builtin" && right.a.$ === "Red") {
            var _v1 = right.a;
            var rK = right.b;
            var rV = right.c;
            var rLeft = right.d;
            var rRight = right.e;
            if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Red") {
              var _v3 = left.a;
              var lK = left.b;
              var lV = left.c;
              var lLeft = left.d;
              var lRight = left.e;
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Red,
                key,
                value,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, lK, lV, lLeft, lRight),
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rLeft, rRight)
              );
            } else {
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                color,
                rK,
                rV,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, left, rLeft),
                rRight
              );
            }
          } else {
            if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Red" && left.d.$ === "RBNode_elm_builtin" && left.d.a.$ === "Red") {
              var _v5 = left.a;
              var lK = left.b;
              var lV = left.c;
              var _v6 = left.d;
              var _v7 = _v6.a;
              var llK = _v6.b;
              var llV = _v6.c;
              var llLeft = _v6.d;
              var llRight = _v6.e;
              var lRight = left.e;
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Red,
                lK,
                lV,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, lRight, right)
              );
            } else {
              return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, left, right);
            }
          }
        }
      );
      var $elm$core$Dict$insertHelp = F3(
        function(key, value, dict) {
          if (dict.$ === "RBEmpty_elm_builtin") {
            return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
          } else {
            var nColor = dict.a;
            var nKey = dict.b;
            var nValue = dict.c;
            var nLeft = dict.d;
            var nRight = dict.e;
            var _v1 = A2($elm$core$Basics$compare, key, nKey);
            switch (_v1.$) {
              case "LT":
                return A5(
                  $elm$core$Dict$balance,
                  nColor,
                  nKey,
                  nValue,
                  A3($elm$core$Dict$insertHelp, key, value, nLeft),
                  nRight
                );
              case "EQ":
                return A5($elm$core$Dict$RBNode_elm_builtin, nColor, nKey, value, nLeft, nRight);
              default:
                return A5(
                  $elm$core$Dict$balance,
                  nColor,
                  nKey,
                  nValue,
                  nLeft,
                  A3($elm$core$Dict$insertHelp, key, value, nRight)
                );
            }
          }
        }
      );
      var $elm$core$Dict$insert = F3(
        function(key, value, dict) {
          var _v0 = A3($elm$core$Dict$insertHelp, key, value, dict);
          if (_v0.$ === "RBNode_elm_builtin" && _v0.a.$ === "Red") {
            var _v1 = _v0.a;
            var k = _v0.b;
            var v = _v0.c;
            var l = _v0.d;
            var r = _v0.e;
            return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
          } else {
            var x = _v0;
            return x;
          }
        }
      );
      var $elm$core$Dict$getMin = function(dict) {
        getMin:
          while (true) {
            if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin") {
              var left = dict.d;
              var $temp$dict = left;
              dict = $temp$dict;
              continue getMin;
            } else {
              return dict;
            }
          }
      };
      var $elm$core$Dict$moveRedLeft = function(dict) {
        if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin" && dict.e.$ === "RBNode_elm_builtin") {
          if (dict.e.d.$ === "RBNode_elm_builtin" && dict.e.d.a.$ === "Red") {
            var clr = dict.a;
            var k = dict.b;
            var v = dict.c;
            var _v1 = dict.d;
            var lClr = _v1.a;
            var lK = _v1.b;
            var lV = _v1.c;
            var lLeft = _v1.d;
            var lRight = _v1.e;
            var _v2 = dict.e;
            var rClr = _v2.a;
            var rK = _v2.b;
            var rV = _v2.c;
            var rLeft = _v2.d;
            var _v3 = rLeft.a;
            var rlK = rLeft.b;
            var rlV = rLeft.c;
            var rlL = rLeft.d;
            var rlR = rLeft.e;
            var rRight = _v2.e;
            return A5(
              $elm$core$Dict$RBNode_elm_builtin,
              $elm$core$Dict$Red,
              rlK,
              rlV,
              A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Black,
                k,
                v,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
                rlL
              ),
              A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rlR, rRight)
            );
          } else {
            var clr = dict.a;
            var k = dict.b;
            var v = dict.c;
            var _v4 = dict.d;
            var lClr = _v4.a;
            var lK = _v4.b;
            var lV = _v4.c;
            var lLeft = _v4.d;
            var lRight = _v4.e;
            var _v5 = dict.e;
            var rClr = _v5.a;
            var rK = _v5.b;
            var rV = _v5.c;
            var rLeft = _v5.d;
            var rRight = _v5.e;
            if (clr.$ === "Black") {
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Black,
                k,
                v,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)
              );
            } else {
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Black,
                k,
                v,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)
              );
            }
          }
        } else {
          return dict;
        }
      };
      var $elm$core$Dict$moveRedRight = function(dict) {
        if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin" && dict.e.$ === "RBNode_elm_builtin") {
          if (dict.d.d.$ === "RBNode_elm_builtin" && dict.d.d.a.$ === "Red") {
            var clr = dict.a;
            var k = dict.b;
            var v = dict.c;
            var _v1 = dict.d;
            var lClr = _v1.a;
            var lK = _v1.b;
            var lV = _v1.c;
            var _v2 = _v1.d;
            var _v3 = _v2.a;
            var llK = _v2.b;
            var llV = _v2.c;
            var llLeft = _v2.d;
            var llRight = _v2.e;
            var lRight = _v1.e;
            var _v4 = dict.e;
            var rClr = _v4.a;
            var rK = _v4.b;
            var rV = _v4.c;
            var rLeft = _v4.d;
            var rRight = _v4.e;
            return A5(
              $elm$core$Dict$RBNode_elm_builtin,
              $elm$core$Dict$Red,
              lK,
              lV,
              A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
              A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Black,
                k,
                v,
                lRight,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)
              )
            );
          } else {
            var clr = dict.a;
            var k = dict.b;
            var v = dict.c;
            var _v5 = dict.d;
            var lClr = _v5.a;
            var lK = _v5.b;
            var lV = _v5.c;
            var lLeft = _v5.d;
            var lRight = _v5.e;
            var _v6 = dict.e;
            var rClr = _v6.a;
            var rK = _v6.b;
            var rV = _v6.c;
            var rLeft = _v6.d;
            var rRight = _v6.e;
            if (clr.$ === "Black") {
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Black,
                k,
                v,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)
              );
            } else {
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                $elm$core$Dict$Black,
                k,
                v,
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
                A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)
              );
            }
          }
        } else {
          return dict;
        }
      };
      var $elm$core$Dict$removeHelpPrepEQGT = F7(
        function(targetKey, dict, color, key, value, left, right) {
          if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Red") {
            var _v1 = left.a;
            var lK = left.b;
            var lV = left.c;
            var lLeft = left.d;
            var lRight = left.e;
            return A5(
              $elm$core$Dict$RBNode_elm_builtin,
              color,
              lK,
              lV,
              lLeft,
              A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, lRight, right)
            );
          } else {
            _v2$2:
              while (true) {
                if (right.$ === "RBNode_elm_builtin" && right.a.$ === "Black") {
                  if (right.d.$ === "RBNode_elm_builtin") {
                    if (right.d.a.$ === "Black") {
                      var _v3 = right.a;
                      var _v4 = right.d;
                      var _v5 = _v4.a;
                      return $elm$core$Dict$moveRedRight(dict);
                    } else {
                      break _v2$2;
                    }
                  } else {
                    var _v6 = right.a;
                    var _v7 = right.d;
                    return $elm$core$Dict$moveRedRight(dict);
                  }
                } else {
                  break _v2$2;
                }
              }
            return dict;
          }
        }
      );
      var $elm$core$Dict$removeMin = function(dict) {
        if (dict.$ === "RBNode_elm_builtin" && dict.d.$ === "RBNode_elm_builtin") {
          var color = dict.a;
          var key = dict.b;
          var value = dict.c;
          var left = dict.d;
          var lColor = left.a;
          var lLeft = left.d;
          var right = dict.e;
          if (lColor.$ === "Black") {
            if (lLeft.$ === "RBNode_elm_builtin" && lLeft.a.$ === "Red") {
              var _v3 = lLeft.a;
              return A5(
                $elm$core$Dict$RBNode_elm_builtin,
                color,
                key,
                value,
                $elm$core$Dict$removeMin(left),
                right
              );
            } else {
              var _v4 = $elm$core$Dict$moveRedLeft(dict);
              if (_v4.$ === "RBNode_elm_builtin") {
                var nColor = _v4.a;
                var nKey = _v4.b;
                var nValue = _v4.c;
                var nLeft = _v4.d;
                var nRight = _v4.e;
                return A5(
                  $elm$core$Dict$balance,
                  nColor,
                  nKey,
                  nValue,
                  $elm$core$Dict$removeMin(nLeft),
                  nRight
                );
              } else {
                return $elm$core$Dict$RBEmpty_elm_builtin;
              }
            }
          } else {
            return A5(
              $elm$core$Dict$RBNode_elm_builtin,
              color,
              key,
              value,
              $elm$core$Dict$removeMin(left),
              right
            );
          }
        } else {
          return $elm$core$Dict$RBEmpty_elm_builtin;
        }
      };
      var $elm$core$Dict$removeHelp = F2(
        function(targetKey, dict) {
          if (dict.$ === "RBEmpty_elm_builtin") {
            return $elm$core$Dict$RBEmpty_elm_builtin;
          } else {
            var color = dict.a;
            var key = dict.b;
            var value = dict.c;
            var left = dict.d;
            var right = dict.e;
            if (_Utils_cmp(targetKey, key) < 0) {
              if (left.$ === "RBNode_elm_builtin" && left.a.$ === "Black") {
                var _v4 = left.a;
                var lLeft = left.d;
                if (lLeft.$ === "RBNode_elm_builtin" && lLeft.a.$ === "Red") {
                  var _v6 = lLeft.a;
                  return A5(
                    $elm$core$Dict$RBNode_elm_builtin,
                    color,
                    key,
                    value,
                    A2($elm$core$Dict$removeHelp, targetKey, left),
                    right
                  );
                } else {
                  var _v7 = $elm$core$Dict$moveRedLeft(dict);
                  if (_v7.$ === "RBNode_elm_builtin") {
                    var nColor = _v7.a;
                    var nKey = _v7.b;
                    var nValue = _v7.c;
                    var nLeft = _v7.d;
                    var nRight = _v7.e;
                    return A5(
                      $elm$core$Dict$balance,
                      nColor,
                      nKey,
                      nValue,
                      A2($elm$core$Dict$removeHelp, targetKey, nLeft),
                      nRight
                    );
                  } else {
                    return $elm$core$Dict$RBEmpty_elm_builtin;
                  }
                }
              } else {
                return A5(
                  $elm$core$Dict$RBNode_elm_builtin,
                  color,
                  key,
                  value,
                  A2($elm$core$Dict$removeHelp, targetKey, left),
                  right
                );
              }
            } else {
              return A2(
                $elm$core$Dict$removeHelpEQGT,
                targetKey,
                A7($elm$core$Dict$removeHelpPrepEQGT, targetKey, dict, color, key, value, left, right)
              );
            }
          }
        }
      );
      var $elm$core$Dict$removeHelpEQGT = F2(
        function(targetKey, dict) {
          if (dict.$ === "RBNode_elm_builtin") {
            var color = dict.a;
            var key = dict.b;
            var value = dict.c;
            var left = dict.d;
            var right = dict.e;
            if (_Utils_eq(targetKey, key)) {
              var _v1 = $elm$core$Dict$getMin(right);
              if (_v1.$ === "RBNode_elm_builtin") {
                var minKey = _v1.b;
                var minValue = _v1.c;
                return A5(
                  $elm$core$Dict$balance,
                  color,
                  minKey,
                  minValue,
                  left,
                  $elm$core$Dict$removeMin(right)
                );
              } else {
                return $elm$core$Dict$RBEmpty_elm_builtin;
              }
            } else {
              return A5(
                $elm$core$Dict$balance,
                color,
                key,
                value,
                left,
                A2($elm$core$Dict$removeHelp, targetKey, right)
              );
            }
          } else {
            return $elm$core$Dict$RBEmpty_elm_builtin;
          }
        }
      );
      var $elm$core$Dict$remove = F2(
        function(key, dict) {
          var _v0 = A2($elm$core$Dict$removeHelp, key, dict);
          if (_v0.$ === "RBNode_elm_builtin" && _v0.a.$ === "Red") {
            var _v1 = _v0.a;
            var k = _v0.b;
            var v = _v0.c;
            var l = _v0.d;
            var r = _v0.e;
            return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
          } else {
            var x = _v0;
            return x;
          }
        }
      );
      var $elm$core$Dict$update = F3(
        function(targetKey, alter, dictionary) {
          var _v0 = alter(
            A2($elm$core$Dict$get, targetKey, dictionary)
          );
          if (_v0.$ === "Just") {
            var value = _v0.a;
            return A3($elm$core$Dict$insert, targetKey, value, dictionary);
          } else {
            return A2($elm$core$Dict$remove, targetKey, dictionary);
          }
        }
      );
      var $elm$url$Url$Parser$addParam = F2(
        function(segment, dict) {
          var _v0 = A2($elm$core$String$split, "=", segment);
          if (_v0.b && _v0.b.b && !_v0.b.b.b) {
            var rawKey = _v0.a;
            var _v1 = _v0.b;
            var rawValue = _v1.a;
            var _v2 = $elm$url$Url$percentDecode(rawKey);
            if (_v2.$ === "Nothing") {
              return dict;
            } else {
              var key = _v2.a;
              var _v3 = $elm$url$Url$percentDecode(rawValue);
              if (_v3.$ === "Nothing") {
                return dict;
              } else {
                var value = _v3.a;
                return A3(
                  $elm$core$Dict$update,
                  key,
                  $elm$url$Url$Parser$addToParametersHelp(value),
                  dict
                );
              }
            }
          } else {
            return dict;
          }
        }
      );
      var $elm$core$List$foldrHelper = F4(
        function(fn, acc, ctr, ls) {
          if (!ls.b) {
            return acc;
          } else {
            var a = ls.a;
            var r1 = ls.b;
            if (!r1.b) {
              return A2(fn, a, acc);
            } else {
              var b = r1.a;
              var r2 = r1.b;
              if (!r2.b) {
                return A2(
                  fn,
                  a,
                  A2(fn, b, acc)
                );
              } else {
                var c = r2.a;
                var r3 = r2.b;
                if (!r3.b) {
                  return A2(
                    fn,
                    a,
                    A2(
                      fn,
                      b,
                      A2(fn, c, acc)
                    )
                  );
                } else {
                  var d = r3.a;
                  var r4 = r3.b;
                  var res = ctr > 500 ? A3(
                    $elm$core$List$foldl,
                    fn,
                    acc,
                    $elm$core$List$reverse(r4)
                  ) : A4($elm$core$List$foldrHelper, fn, acc, ctr + 1, r4);
                  return A2(
                    fn,
                    a,
                    A2(
                      fn,
                      b,
                      A2(
                        fn,
                        c,
                        A2(fn, d, res)
                      )
                    )
                  );
                }
              }
            }
          }
        }
      );
      var $elm$core$List$foldr = F3(
        function(fn, acc, ls) {
          return A4($elm$core$List$foldrHelper, fn, acc, 0, ls);
        }
      );
      var $elm$url$Url$Parser$prepareQuery = function(maybeQuery) {
        if (maybeQuery.$ === "Nothing") {
          return $elm$core$Dict$empty;
        } else {
          var qry = maybeQuery.a;
          return A3(
            $elm$core$List$foldr,
            $elm$url$Url$Parser$addParam,
            $elm$core$Dict$empty,
            A2($elm$core$String$split, "&", qry)
          );
        }
      };
      var $elm$url$Url$Parser$parse = F2(
        function(_v0, url) {
          var parser = _v0.a;
          return $elm$url$Url$Parser$getFirstMatch(
            parser(
              A5(
                $elm$url$Url$Parser$State,
                _List_Nil,
                $elm$url$Url$Parser$preparePath(url.path),
                $elm$url$Url$Parser$prepareQuery(url.query),
                url.fragment,
                $elm$core$Basics$identity
              )
            )
          );
        }
      );
      var $elm$url$Url$Parser$Parser = function(a) {
        return { $: "Parser", a };
      };
      var $elm$url$Url$Parser$query = function(_v0) {
        var queryParser = _v0.a;
        return $elm$url$Url$Parser$Parser(
          function(_v1) {
            var visited = _v1.visited;
            var unvisited = _v1.unvisited;
            var params = _v1.params;
            var frag = _v1.frag;
            var value = _v1.value;
            return _List_fromArray(
              [
                A5(
                  $elm$url$Url$Parser$State,
                  visited,
                  unvisited,
                  params,
                  frag,
                  value(
                    queryParser(params)
                  )
                )
              ]
            );
          }
        );
      };
      var $elm$url$Url$Parser$Internal$Parser = function(a) {
        return { $: "Parser", a };
      };
      var $elm$url$Url$Parser$Query$custom = F2(
        function(key, func) {
          return $elm$url$Url$Parser$Internal$Parser(
            function(dict) {
              return func(
                A2(
                  $elm$core$Maybe$withDefault,
                  _List_Nil,
                  A2($elm$core$Dict$get, key, dict)
                )
              );
            }
          );
        }
      );
      var $elm$url$Url$Parser$Query$string = function(key) {
        return A2(
          $elm$url$Url$Parser$Query$custom,
          key,
          function(stringList) {
            if (stringList.b && !stringList.b.b) {
              var str = stringList.a;
              return $elm$core$Maybe$Just(str);
            } else {
              return $elm$core$Maybe$Nothing;
            }
          }
        );
      };
      var $author$project$Url$Ext$extractQueryParam = F2(
        function(key, url) {
          return $elm_community$maybe_extra$Maybe$Extra$join(
            A2(
              $elm$url$Url$Parser$parse,
              $elm$url$Url$Parser$query(
                $elm$url$Url$Parser$Query$string(key)
              ),
              _Utils_update(
                url,
                { path: "" }
              )
            )
          );
        }
      );
      var $elm$core$Maybe$map = F2(
        function(f, maybe) {
          if (maybe.$ === "Just") {
            var value = maybe.a;
            return $elm$core$Maybe$Just(
              f(value)
            );
          } else {
            return $elm$core$Maybe$Nothing;
          }
        }
      );
      var $author$project$Url$Ext$action = function(url) {
        return A2(
          $elm$core$Maybe$withDefault,
          _List_Nil,
          A2(
            $elm$core$Maybe$map,
            $elm$core$String$split("/"),
            A2($author$project$Url$Ext$extractQueryParam, "action", url)
          )
        );
      };
      var $author$project$Alien$EnclosedData = { $: "EnclosedData" };
      var $author$project$Alien$LoadEnclosedUserData = { $: "LoadEnclosedUserData" };
      var $elm$core$Task$Perform = function(a) {
        return { $: "Perform", a };
      };
      var $elm$core$Task$andThen = _Scheduler_andThen;
      var $elm$core$Task$succeed = _Scheduler_succeed;
      var $elm$core$Task$init = $elm$core$Task$succeed(_Utils_Tuple0);
      var $elm$core$List$map = F2(
        function(f, xs) {
          return A3(
            $elm$core$List$foldr,
            F2(
              function(x, acc) {
                return A2(
                  $elm$core$List$cons,
                  f(x),
                  acc
                );
              }
            ),
            _List_Nil,
            xs
          );
        }
      );
      var $elm$core$Task$map = F2(
        function(func, taskA) {
          return A2(
            $elm$core$Task$andThen,
            function(a) {
              return $elm$core$Task$succeed(
                func(a)
              );
            },
            taskA
          );
        }
      );
      var $elm$core$Task$map2 = F3(
        function(func, taskA, taskB) {
          return A2(
            $elm$core$Task$andThen,
            function(a) {
              return A2(
                $elm$core$Task$andThen,
                function(b) {
                  return $elm$core$Task$succeed(
                    A2(func, a, b)
                  );
                },
                taskB
              );
            },
            taskA
          );
        }
      );
      var $elm$core$Task$sequence = function(tasks) {
        return A3(
          $elm$core$List$foldr,
          $elm$core$Task$map2($elm$core$List$cons),
          $elm$core$Task$succeed(_List_Nil),
          tasks
        );
      };
      var $elm$core$Platform$sendToApp = _Platform_sendToApp;
      var $elm$core$Task$spawnCmd = F2(
        function(router, _v0) {
          var task = _v0.a;
          return _Scheduler_spawn(
            A2(
              $elm$core$Task$andThen,
              $elm$core$Platform$sendToApp(router),
              task
            )
          );
        }
      );
      var $elm$core$Task$onEffects = F3(
        function(router, commands, state) {
          return A2(
            $elm$core$Task$map,
            function(_v0) {
              return _Utils_Tuple0;
            },
            $elm$core$Task$sequence(
              A2(
                $elm$core$List$map,
                $elm$core$Task$spawnCmd(router),
                commands
              )
            )
          );
        }
      );
      var $elm$core$Task$onSelfMsg = F3(
        function(_v0, _v1, _v2) {
          return $elm$core$Task$succeed(_Utils_Tuple0);
        }
      );
      var $elm$core$Task$cmdMap = F2(
        function(tagger, _v0) {
          var task = _v0.a;
          return $elm$core$Task$Perform(
            A2($elm$core$Task$map, tagger, task)
          );
        }
      );
      _Platform_effectManagers["Task"] = _Platform_createManager($elm$core$Task$init, $elm$core$Task$onEffects, $elm$core$Task$onSelfMsg, $elm$core$Task$cmdMap);
      var $elm$core$Task$command = _Platform_leaf("Task");
      var $elm$core$Basics$composeL = F3(
        function(g, f, x) {
          return g(
            f(x)
          );
        }
      );
      var $elm$core$Task$onError = _Scheduler_onError;
      var $elm$core$Task$attempt = F2(
        function(resultToMessage, task) {
          return $elm$core$Task$command(
            $elm$core$Task$Perform(
              A2(
                $elm$core$Task$onError,
                A2(
                  $elm$core$Basics$composeL,
                  A2($elm$core$Basics$composeL, $elm$core$Task$succeed, resultToMessage),
                  $elm$core$Result$Err
                ),
                A2(
                  $elm$core$Task$andThen,
                  A2(
                    $elm$core$Basics$composeL,
                    A2($elm$core$Basics$composeL, $elm$core$Task$succeed, resultToMessage),
                    $elm$core$Result$Ok
                  ),
                  task
                )
              )
            )
          );
        }
      );
      var $elm$core$Basics$composeR = F3(
        function(f, g, x) {
          return g(
            f(x)
          );
        }
      );
      var $lobanov$elm_taskport$TaskPort$interopErrorToString = function(error) {
        switch (error.$) {
          case "NotInstalled":
            return "NotInstalled: TaskPort JS component is not installed.";
          case "NotFound":
            var msg = error.a;
            return "NotFound: " + msg;
          case "NotCompatible":
            var msg = error.a;
            return "NotCompatible: " + msg;
          case "CannotDecodeValue":
            var err = error.a;
            var value = error.b;
            return "CannotDecodeValue: unable to decode JavaScript function return value.\n" + ("Value:\n" + (value + ("\n\n" + ("Decoding error:\n" + $elm$json$Json$Decode$errorToString(err)))));
          default:
            var msg = error.a;
            return "RuntimeError: " + msg;
        }
      };
      var $lobanov$elm_taskport$TaskPort$jsErrorToString = function(error) {
        if (error.$ === "ErrorValue") {
          var v = error.a;
          return "JSON object:\n" + A2($elm$json$Json$Encode$encode, 4, v);
        } else {
          var name = error.a;
          var o = error.b;
          return name + (": " + (o.message + ("\n" + (A2($elm$core$String$join, "\n", o.stackLines) + A2(
            $elm$core$Maybe$withDefault,
            "",
            A2(
              $elm$core$Maybe$map,
              function(cause) {
                return "\nCaused by:\n" + $lobanov$elm_taskport$TaskPort$jsErrorToString(cause);
              },
              o.cause
            )
          )))));
        }
      };
      var $lobanov$elm_taskport$TaskPort$errorToString = function(error) {
        if (error.$ === "InteropError") {
          var e = error.a;
          return $lobanov$elm_taskport$TaskPort$interopErrorToString(e);
        } else {
          var e = error.a;
          return $lobanov$elm_taskport$TaskPort$jsErrorToString(e);
        }
      };
      var $author$project$TaskPort$Extra$errorToStringCustom = function(err) {
        if (err.$ === "JSError") {
          var jsErr = err.a;
          if (jsErr.$ === "ErrorObject") {
            var errRecord = jsErr.b;
            return errRecord.message;
          } else {
            return $lobanov$elm_taskport$TaskPort$errorToString(err);
          }
        } else {
          return $lobanov$elm_taskport$TaskPort$errorToString(err);
        }
      };
      var $elm$core$Result$mapError = F2(
        function(f, result) {
          if (result.$ === "Ok") {
            var v = result.a;
            return $elm$core$Result$Ok(v);
          } else {
            var e = result.a;
            return $elm$core$Result$Err(
              f(e)
            );
          }
        }
      );
      var $author$project$Alien$ReportError = { $: "ReportError" };
      var $author$project$Brain$Types$Cmd = function(a) {
        return { $: "Cmd", a };
      };
      var $elm$json$Json$Encode$null = _Json_encodeNull;
      var $author$project$Alien$AddTracks = { $: "AddTracks" };
      var $author$project$Alien$CollectFissionCapabilities = { $: "CollectFissionCapabilities" };
      var $author$project$Alien$DownloadTracks = { $: "DownloadTracks" };
      var $author$project$Alien$FinishedProcessingSource = { $: "FinishedProcessingSource" };
      var $author$project$Alien$FinishedProcessingSources = { $: "FinishedProcessingSources" };
      var $author$project$Alien$GotCachedCover = { $: "GotCachedCover" };
      var $author$project$Alien$HideLoadingScreen = { $: "HideLoadingScreen" };
      var $author$project$Alien$LoadHypaethralUserData = { $: "LoadHypaethralUserData" };
      var $author$project$Alien$ProcessSources = { $: "ProcessSources" };
      var $author$project$Alien$RefreshedAccessToken = { $: "RefreshedAccessToken" };
      var $author$project$Alien$ReloadTracks = { $: "ReloadTracks" };
      var $author$project$Alien$RemoveEncryptionKey = { $: "RemoveEncryptionKey" };
      var $author$project$Alien$RemoveTracksByPath = { $: "RemoveTracksByPath" };
      var $author$project$Alien$RemoveTracksBySourceId = { $: "RemoveTracksBySourceId" };
      var $author$project$Alien$RemoveTracksFromCache = { $: "RemoveTracksFromCache" };
      var $author$project$Alien$ReportProcessingError = { $: "ReportProcessingError" };
      var $author$project$Alien$ReportProcessingProgress = { $: "ReportProcessingProgress" };
      var $author$project$Alien$SaveEnclosedUserData = { $: "SaveEnclosedUserData" };
      var $author$project$Alien$SaveFavourites = { $: "SaveFavourites" };
      var $author$project$Alien$SavePlaylists = { $: "SavePlaylists" };
      var $author$project$Alien$SaveProgress = { $: "SaveProgress" };
      var $author$project$Alien$SaveSettings = { $: "SaveSettings" };
      var $author$project$Alien$SaveSources = { $: "SaveSources" };
      var $author$project$Alien$SaveTracks = { $: "SaveTracks" };
      var $author$project$Alien$SearchTracks = { $: "SearchTracks" };
      var $author$project$Alien$SecretKey = { $: "SecretKey" };
      var $author$project$Alien$SetSyncMethod = { $: "SetSyncMethod" };
      var $author$project$Alien$StartedSyncing = { $: "StartedSyncing" };
      var $author$project$Alien$StopProcessing = { $: "StopProcessing" };
      var $author$project$Alien$StoreTracksInCache = { $: "StoreTracksInCache" };
      var $author$project$Alien$SyncHypaethralData = { $: "SyncHypaethralData" };
      var $author$project$Alien$SyncLocal = { $: "SyncLocal" };
      var $author$project$Alien$SyncMethod = { $: "SyncMethod" };
      var $author$project$Alien$SyncTrackTags = { $: "SyncTrackTags" };
      var $author$project$Alien$ToCache = { $: "ToCache" };
      var $author$project$Alien$UnsetSyncMethod = { $: "UnsetSyncMethod" };
      var $author$project$Alien$UpdateEncryptionKey = { $: "UpdateEncryptionKey" };
      var $author$project$Alien$UpdateSourceData = { $: "UpdateSourceData" };
      var $elm$json$Json$Decode$fail = _Json_fail;
      var $elm$core$List$filter = F2(
        function(isGood, list) {
          return A3(
            $elm$core$List$foldr,
            F2(
              function(x, xs) {
                return isGood(x) ? A2($elm$core$List$cons, x, xs) : xs;
              }
            ),
            _List_Nil,
            list
          );
        }
      );
      var $elm$core$Dict$fromList = function(assocs) {
        return A3(
          $elm$core$List$foldl,
          F2(
            function(_v0, dict) {
              var key = _v0.a;
              var value = _v0.b;
              return A3($elm$core$Dict$insert, key, value, dict);
            }
          ),
          $elm$core$Dict$empty,
          assocs
        );
      };
      var $elm$core$List$head = function(list) {
        if (list.b) {
          var x = list.a;
          var xs = list.b;
          return $elm$core$Maybe$Just(x);
        } else {
          return $elm$core$Maybe$Nothing;
        }
      };
      var $elm$json$Json$Decode$string = _Json_decodeString;
      var $elm$json$Json$Encode$string = _Json_wrap;
      var $elm$json$Json$Decode$succeed = _Json_succeed;
      var $Herteby$enum$Enum$create = function(list) {
        var toString2 = function(a) {
          var _v1 = $elm$core$List$head(
            A2(
              $elm$core$List$filter,
              function(_v2) {
                var str2 = _v2.a;
                var b2 = _v2.b;
                return _Utils_eq(b2, a);
              },
              list
            )
          );
          if (_v1.$ === "Just") {
            var _v3 = _v1.a;
            var str = _v3.a;
            var b = _v3.b;
            return str;
          } else {
            return "Missing enum";
          }
        };
        var dict = $elm$core$Dict$fromList(list);
        var fromString2 = function(string) {
          return A2($elm$core$Dict$get, string, dict);
        };
        return {
          decoder: A2(
            $elm$json$Json$Decode$andThen,
            function(string) {
              var _v0 = A2($elm$core$Dict$get, string, dict);
              if (_v0.$ === "Just") {
                var a = _v0.a;
                return $elm$json$Json$Decode$succeed(a);
              } else {
                return $elm$json$Json$Decode$fail("Missing enum: " + string);
              }
            },
            $elm$json$Json$Decode$string
          ),
          encode: A2($elm$core$Basics$composeR, toString2, $elm$json$Json$Encode$string),
          fromString: fromString2,
          list,
          toString: toString2
        };
      };
      var $author$project$Alien$enum = $Herteby$enum$Enum$create(
        _List_fromArray(
          [
            _Utils_Tuple2("ENCLOSED_DATA", $author$project$Alien$EnclosedData),
            _Utils_Tuple2("SEARCH_TRACKS", $author$project$Alien$SearchTracks),
            _Utils_Tuple2("SECRET_KEY", $author$project$Alien$SecretKey),
            _Utils_Tuple2("SYNC_LOCAL", $author$project$Alien$SyncLocal),
            _Utils_Tuple2("SYNC_METHOD", $author$project$Alien$SyncMethod),
            _Utils_Tuple2("DOWNLOAD_TRACKS", $author$project$Alien$DownloadTracks),
            _Utils_Tuple2("PROCESS_SOURCES", $author$project$Alien$ProcessSources),
            _Utils_Tuple2("REFRESHED_ACCESS_TOKEN", $author$project$Alien$RefreshedAccessToken),
            _Utils_Tuple2("REMOVE_ENCRYPTION_KEY", $author$project$Alien$RemoveEncryptionKey),
            _Utils_Tuple2("REMOVE_TRACKS_BY_SOURCE_ID", $author$project$Alien$RemoveTracksBySourceId),
            _Utils_Tuple2("REMOVE_TRACKS_FROM_CACHE", $author$project$Alien$RemoveTracksFromCache),
            _Utils_Tuple2("SAVE_ENCLOSED_USER_DATA", $author$project$Alien$SaveEnclosedUserData),
            _Utils_Tuple2("SAVE_FAVOURITES", $author$project$Alien$SaveFavourites),
            _Utils_Tuple2("SAVE_PLAYLISTS", $author$project$Alien$SavePlaylists),
            _Utils_Tuple2("SAVE_PROGRESS", $author$project$Alien$SaveProgress),
            _Utils_Tuple2("SAVE_SETTINGS", $author$project$Alien$SaveSettings),
            _Utils_Tuple2("SAVE_SOURCES", $author$project$Alien$SaveSources),
            _Utils_Tuple2("SAVE_TRACKS", $author$project$Alien$SaveTracks),
            _Utils_Tuple2("SET_SYNC_METHOD", $author$project$Alien$SetSyncMethod),
            _Utils_Tuple2("STOP_PROCESSING", $author$project$Alien$StopProcessing),
            _Utils_Tuple2("STORE_TRACKS_IN_CACHE", $author$project$Alien$StoreTracksInCache),
            _Utils_Tuple2("SYNC_HYPAETHRAL_DATA", $author$project$Alien$SyncHypaethralData),
            _Utils_Tuple2("SYNC_TRACK_TAGS", $author$project$Alien$SyncTrackTags),
            _Utils_Tuple2("TO_CACHE", $author$project$Alien$ToCache),
            _Utils_Tuple2("UNSET_SYNC_METHOD", $author$project$Alien$UnsetSyncMethod),
            _Utils_Tuple2("UPDATE_ENCRYPTION_KEY", $author$project$Alien$UpdateEncryptionKey),
            _Utils_Tuple2("ADD_TRACKS", $author$project$Alien$AddTracks),
            _Utils_Tuple2("COLLECT_FISSION_CAPABILITIES", $author$project$Alien$CollectFissionCapabilities),
            _Utils_Tuple2("FINISHED_PROCESSING_SOURCE", $author$project$Alien$FinishedProcessingSource),
            _Utils_Tuple2("FINISHED_PROCESSING_SOURCES", $author$project$Alien$FinishedProcessingSources),
            _Utils_Tuple2("GOT_CACHED_COVER", $author$project$Alien$GotCachedCover),
            _Utils_Tuple2("HIDE_LOADING_SCREEN", $author$project$Alien$HideLoadingScreen),
            _Utils_Tuple2("LOAD_ENCLOSED_USER_DATA", $author$project$Alien$LoadEnclosedUserData),
            _Utils_Tuple2("LOAD_HYPAETHRAL_USER_DATA", $author$project$Alien$LoadHypaethralUserData),
            _Utils_Tuple2("RELOAD_TRACKS", $author$project$Alien$ReloadTracks),
            _Utils_Tuple2("REMOVE_TRACKS_BY_PATH", $author$project$Alien$RemoveTracksByPath),
            _Utils_Tuple2("REPORT_ERROR", $author$project$Alien$ReportError),
            _Utils_Tuple2("REPORT_PROCESSING_ERROR", $author$project$Alien$ReportProcessingError),
            _Utils_Tuple2("REPORT_PROCESSING_PROGRESS", $author$project$Alien$ReportProcessingProgress),
            _Utils_Tuple2("STARTED_SYNCING", $author$project$Alien$StartedSyncing),
            _Utils_Tuple2("UPDATE_SOURCE_DATA", $author$project$Alien$UpdateSourceData)
          ]
        )
      );
      var $author$project$Alien$tagToString = $author$project$Alien$enum.toString;
      var $author$project$Alien$report = F2(
        function(tag, error) {
          return {
            data: $elm$json$Json$Encode$null,
            error: $elm$core$Maybe$Just(error),
            tag: $author$project$Alien$tagToString(tag)
          };
        }
      );
      var $elm$core$Maybe$destruct = F3(
        function(_default, func, maybe) {
          if (maybe.$ === "Just") {
            var a = maybe.a;
            return func(a);
          } else {
            return _default;
          }
        }
      );
      var $elm$json$Json$Encode$object = function(pairs) {
        return _Json_wrap(
          A3(
            $elm$core$List$foldl,
            F2(
              function(_v0, obj) {
                var k = _v0.a;
                var v = _v0.b;
                return A3(_Json_addField, k, v, obj);
              }
            ),
            _Json_emptyObject(_Utils_Tuple0),
            pairs
          )
        );
      };
      var $author$project$Brain$Ports$toUI = _Platform_outgoingPort(
        "toUI",
        function($) {
          return $elm$json$Json$Encode$object(
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "data",
                  $elm$core$Basics$identity($.data)
                ),
                _Utils_Tuple2(
                  "error",
                  function($2) {
                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $2);
                  }($.error)
                ),
                _Utils_Tuple2(
                  "tag",
                  $elm$json$Json$Encode$string($.tag)
                )
              ]
            )
          );
        }
      );
      var $author$project$Brain$Common$State$reportUICmd = F2(
        function(tag, error) {
          return $author$project$Brain$Ports$toUI(
            A2($author$project$Alien$report, tag, error)
          );
        }
      );
      var $author$project$Brain$Common$State$reportUICmdMsg = F2(
        function(tag, error) {
          return $author$project$Brain$Types$Cmd(
            A2($author$project$Brain$Common$State$reportUICmd, tag, error)
          );
        }
      );
      var $author$project$Brain$Common$State$reportErrorToUI = F2(
        function(mapFn, result) {
          if (result.$ === "Ok") {
            var value = result.a;
            return mapFn(value);
          } else {
            var error = result.a;
            return A2($author$project$Brain$Common$State$reportUICmdMsg, $author$project$Alien$ReportError, error);
          }
        }
      );
      var $author$project$Brain$Common$State$reportPortErrorToUI = function(mapFn) {
        return A2(
          $elm$core$Basics$composeR,
          $elm$core$Result$mapError($author$project$TaskPort$Extra$errorToStringCustom),
          $author$project$Brain$Common$State$reportErrorToUI(mapFn)
        );
      };
      var $author$project$Brain$Common$State$attemptPortTask = function(mapFn) {
        return $elm$core$Task$attempt(
          $author$project$Brain$Common$State$reportPortErrorToUI(mapFn)
        );
      };
      var $lobanov$elm_taskport$TaskPort$DefaultNS = function(a) {
        return { $: "DefaultNS", a };
      };
      var $lobanov$elm_taskport$TaskPort$moduleVersion = "2.0.1";
      var $lobanov$elm_taskport$TaskPort$buildCallUrl = function(_function) {
        if (_function.$ === "DefaultNS") {
          var name = _function.a;
          return "elmtaskport:///" + (name + ("?v=" + $lobanov$elm_taskport$TaskPort$moduleVersion));
        } else {
          var ns = _function.a;
          var nsVersion = _function.b;
          var name = _function.c;
          return "elmtaskport://" + (ns + ("/" + (name + ("?v=" + ($lobanov$elm_taskport$TaskPort$moduleVersion + ("&nsv=" + nsVersion))))));
        }
      };
      var $elm$http$Http$BadStatus_ = F2(
        function(a, b) {
          return { $: "BadStatus_", a, b };
        }
      );
      var $elm$http$Http$BadUrl_ = function(a) {
        return { $: "BadUrl_", a };
      };
      var $elm$http$Http$GoodStatus_ = F2(
        function(a, b) {
          return { $: "GoodStatus_", a, b };
        }
      );
      var $elm$http$Http$NetworkError_ = { $: "NetworkError_" };
      var $elm$http$Http$Receiving = function(a) {
        return { $: "Receiving", a };
      };
      var $elm$http$Http$Sending = function(a) {
        return { $: "Sending", a };
      };
      var $elm$http$Http$Timeout_ = { $: "Timeout_" };
      var $elm$core$Maybe$isJust = function(maybe) {
        if (maybe.$ === "Just") {
          return true;
        } else {
          return false;
        }
      };
      var $elm$core$Platform$sendToSelf = _Platform_sendToSelf;
      var $elm$http$Http$jsonBody = function(value) {
        return A2(
          _Http_pair,
          "application/json",
          A2($elm$json$Json$Encode$encode, 0, value)
        );
      };
      var $lobanov$elm_taskport$TaskPort$CannotDecodeValue = F2(
        function(a, b) {
          return { $: "CannotDecodeValue", a, b };
        }
      );
      var $lobanov$elm_taskport$TaskPort$InteropError = function(a) {
        return { $: "InteropError", a };
      };
      var $lobanov$elm_taskport$TaskPort$JSError = function(a) {
        return { $: "JSError", a };
      };
      var $lobanov$elm_taskport$TaskPort$NotCompatible = function(a) {
        return { $: "NotCompatible", a };
      };
      var $lobanov$elm_taskport$TaskPort$NotFound = function(a) {
        return { $: "NotFound", a };
      };
      var $lobanov$elm_taskport$TaskPort$NotInstalled = { $: "NotInstalled" };
      var $lobanov$elm_taskport$TaskPort$RuntimeError = function(a) {
        return { $: "RuntimeError", a };
      };
      var $elm$json$Json$Decode$decodeString = _Json_runOnString;
      var $lobanov$elm_taskport$TaskPort$ErrorObject = F2(
        function(a, b) {
          return { $: "ErrorObject", a, b };
        }
      );
      var $lobanov$elm_taskport$TaskPort$ErrorValue = function(a) {
        return { $: "ErrorValue", a };
      };
      var $lobanov$elm_taskport$TaskPort$JSErrorRecord = F4(
        function(name, message, stackLines, cause) {
          return { cause, message, name, stackLines };
        }
      );
      var $elm$json$Json$Decode$lazy = function(thunk) {
        return A2(
          $elm$json$Json$Decode$andThen,
          thunk,
          $elm$json$Json$Decode$succeed(_Utils_Tuple0)
        );
      };
      var $elm$json$Json$Decode$list = _Json_decodeList;
      var $elm$json$Json$Decode$map = _Json_map1;
      var $elm$json$Json$Decode$map2 = _Json_map2;
      var $elm$json$Json$Decode$map4 = _Json_map4;
      var $elm$json$Json$Decode$null = _Json_decodeNull;
      var $elm$json$Json$Decode$oneOf = _Json_oneOf;
      var $elm$json$Json$Decode$value = _Json_decodeValue;
      function $lobanov$elm_taskport$TaskPort$cyclic$jsErrorDecoder() {
        return $elm$json$Json$Decode$oneOf(
          _List_fromArray(
            [
              A3(
                $elm$json$Json$Decode$map2,
                $lobanov$elm_taskport$TaskPort$ErrorObject,
                A2($elm$json$Json$Decode$field, "name", $elm$json$Json$Decode$string),
                $lobanov$elm_taskport$TaskPort$cyclic$jsErrorRecordDecoder()
              ),
              A2($elm$json$Json$Decode$map, $lobanov$elm_taskport$TaskPort$ErrorValue, $elm$json$Json$Decode$value)
            ]
          )
        );
      }
      function $lobanov$elm_taskport$TaskPort$cyclic$jsErrorRecordDecoder() {
        return A5(
          $elm$json$Json$Decode$map4,
          $lobanov$elm_taskport$TaskPort$JSErrorRecord,
          A2($elm$json$Json$Decode$field, "name", $elm$json$Json$Decode$string),
          A2($elm$json$Json$Decode$field, "message", $elm$json$Json$Decode$string),
          A2(
            $elm$json$Json$Decode$field,
            "stackLines",
            $elm$json$Json$Decode$list($elm$json$Json$Decode$string)
          ),
          A2(
            $elm$json$Json$Decode$field,
            "cause",
            $elm$json$Json$Decode$oneOf(
              _List_fromArray(
                [
                  $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                  A2(
                    $elm$json$Json$Decode$map,
                    $elm$core$Maybe$Just,
                    $elm$json$Json$Decode$lazy(
                      function(_v0) {
                        return $lobanov$elm_taskport$TaskPort$cyclic$jsErrorDecoder();
                      }
                    )
                  )
                ]
              )
            )
          )
        );
      }
      try {
        var $lobanov$elm_taskport$TaskPort$jsErrorDecoder = $lobanov$elm_taskport$TaskPort$cyclic$jsErrorDecoder();
        $lobanov$elm_taskport$TaskPort$cyclic$jsErrorDecoder = function() {
          return $lobanov$elm_taskport$TaskPort$jsErrorDecoder;
        };
        var $lobanov$elm_taskport$TaskPort$jsErrorRecordDecoder = $lobanov$elm_taskport$TaskPort$cyclic$jsErrorRecordDecoder();
        $lobanov$elm_taskport$TaskPort$cyclic$jsErrorRecordDecoder = function() {
          return $lobanov$elm_taskport$TaskPort$jsErrorRecordDecoder;
        };
      } catch ($) {
        throw "Some top-level definitions from `TaskPort` are causing infinite recursion:\n\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502    jsErrorDecoder\n  \u2502     \u2193\n  \u2502    jsErrorRecordDecoder\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!";
      }
      var $lobanov$elm_taskport$TaskPort$runtimeError = function(msg) {
        return $elm$core$Result$Err(
          $lobanov$elm_taskport$TaskPort$InteropError(
            $lobanov$elm_taskport$TaskPort$RuntimeError("Runtime error in JavaScript interop: " + (msg + ". JavaScript console may contain more information about the issue."))
          )
        );
      };
      var $lobanov$elm_taskport$TaskPort$resolveResponse = F2(
        function(valueDecoder, res) {
          switch (res.$) {
            case "BadUrl_":
              var url = res.a;
              return $lobanov$elm_taskport$TaskPort$runtimeError("bad url " + url);
            case "Timeout_":
              return $lobanov$elm_taskport$TaskPort$runtimeError("timeout");
            case "NetworkError_":
              return $elm$core$Result$Err(
                $lobanov$elm_taskport$TaskPort$InteropError($lobanov$elm_taskport$TaskPort$NotInstalled)
              );
            case "BadStatus_":
              var statusCode = res.a.statusCode;
              var body = res.b;
              if (statusCode === 400) {
                return $elm$core$Result$Err(
                  $lobanov$elm_taskport$TaskPort$InteropError(
                    $lobanov$elm_taskport$TaskPort$NotCompatible(body)
                  )
                );
              } else {
                if (statusCode === 404) {
                  return $elm$core$Result$Err(
                    $lobanov$elm_taskport$TaskPort$InteropError(
                      $lobanov$elm_taskport$TaskPort$NotFound(body)
                    )
                  );
                } else {
                  if (statusCode === 500) {
                    var _v1 = A2($elm$json$Json$Decode$decodeString, $lobanov$elm_taskport$TaskPort$jsErrorDecoder, body);
                    if (_v1.$ === "Ok") {
                      var errorValue = _v1.a;
                      return $elm$core$Result$Err(
                        $lobanov$elm_taskport$TaskPort$JSError(errorValue)
                      );
                    } else {
                      var decodeError = _v1.a;
                      return $elm$core$Result$Err(
                        $lobanov$elm_taskport$TaskPort$InteropError(
                          $lobanov$elm_taskport$TaskPort$RuntimeError(
                            $elm$json$Json$Decode$errorToString(decodeError)
                          )
                        )
                      );
                    }
                  } else {
                    return $lobanov$elm_taskport$TaskPort$runtimeError(
                      "unexpected status " + $elm$core$String$fromInt(statusCode)
                    );
                  }
                }
              }
            default:
              var body = res.b;
              var _v2 = A2($elm$json$Json$Decode$decodeString, valueDecoder, body);
              if (_v2.$ === "Ok") {
                var returnValue = _v2.a;
                return $elm$core$Result$Ok(returnValue);
              } else {
                var decodeError = _v2.a;
                return $elm$core$Result$Err(
                  $lobanov$elm_taskport$TaskPort$InteropError(
                    A2($lobanov$elm_taskport$TaskPort$CannotDecodeValue, decodeError, body)
                  )
                );
              }
          }
        }
      );
      var $elm$http$Http$stringResolver = A2(_Http_expect, "", $elm$core$Basics$identity);
      var $lobanov$elm_taskport$TaskPort$buildHttpCall = F3(
        function(_function, valueDecoder, args) {
          return {
            body: $elm$http$Http$jsonBody(args),
            headers: _List_Nil,
            method: "POST",
            resolver: $elm$http$Http$stringResolver(
              $lobanov$elm_taskport$TaskPort$resolveResponse(valueDecoder)
            ),
            timeout: $elm$core$Maybe$Nothing,
            url: $lobanov$elm_taskport$TaskPort$buildCallUrl(_function)
          };
        }
      );
      var $elm$core$Task$fail = _Scheduler_fail;
      var $elm$http$Http$resultToTask = function(result) {
        if (result.$ === "Ok") {
          var a = result.a;
          return $elm$core$Task$succeed(a);
        } else {
          var x = result.a;
          return $elm$core$Task$fail(x);
        }
      };
      var $elm$http$Http$task = function(r) {
        return A3(
          _Http_toTask,
          _Utils_Tuple0,
          $elm$http$Http$resultToTask,
          { allowCookiesFromOtherDomains: false, body: r.body, expect: r.resolver, headers: r.headers, method: r.method, timeout: r.timeout, tracker: $elm$core$Maybe$Nothing, url: r.url }
        );
      };
      var $lobanov$elm_taskport$TaskPort$callNS = F2(
        function(details, args) {
          return $elm$http$Http$task(
            A3(
              $lobanov$elm_taskport$TaskPort$buildHttpCall,
              details._function,
              details.valueDecoder,
              details.argsEncoder(args)
            )
          );
        }
      );
      var $lobanov$elm_taskport$TaskPort$call = F2(
        function(details, args) {
          return A2(
            $lobanov$elm_taskport$TaskPort$callNS,
            {
              argsEncoder: details.argsEncoder,
              _function: $lobanov$elm_taskport$TaskPort$DefaultNS(details._function),
              valueDecoder: details.valueDecoder
            },
            args
          );
        }
      );
      var $elm$json$Json$Decode$maybe = function(decoder) {
        return $elm$json$Json$Decode$oneOf(
          _List_fromArray(
            [
              A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, decoder),
              $elm$json$Json$Decode$succeed($elm$core$Maybe$Nothing)
            ]
          )
        );
      };
      var $author$project$Brain$Task$Ports$fromCache = F2(
        function(tag, decoder) {
          return A2(
            $lobanov$elm_taskport$TaskPort$call,
            {
              argsEncoder: $elm$json$Json$Encode$string,
              _function: "fromCache",
              valueDecoder: $elm$json$Json$Decode$maybe(decoder)
            },
            $author$project$Alien$tagToString(tag)
          );
        }
      );
      var $author$project$Alien$broadcast = F2(
        function(tag, data) {
          return {
            data,
            error: $elm$core$Maybe$Nothing,
            tag: $author$project$Alien$tagToString(tag)
          };
        }
      );
      var $author$project$Brain$Common$State$giveUICmd = F2(
        function(tag, data) {
          return $author$project$Brain$Ports$toUI(
            A2($author$project$Alien$broadcast, tag, data)
          );
        }
      );
      var $author$project$Brain$Common$State$giveUICmdMsg = F2(
        function(tag, data) {
          return $author$project$Brain$Types$Cmd(
            A2($author$project$Brain$Common$State$giveUICmd, tag, data)
          );
        }
      );
      var $author$project$Brain$User$State$loadEnclosedData = A2(
        $author$project$Brain$Common$State$attemptPortTask,
        $author$project$Brain$Common$State$giveUICmdMsg($author$project$Alien$LoadEnclosedUserData),
        A2(
          $elm$core$Task$map,
          $elm$core$Maybe$withDefault($elm$json$Json$Encode$null),
          A2($author$project$Brain$Task$Ports$fromCache, $author$project$Alien$EnclosedData, $elm$json$Json$Decode$value)
        )
      );
      var $author$project$Brain$User$Types$Commence = F3(
        function(a, b, c) {
          return { $: "Commence", a, b, c };
        }
      );
      var $author$project$Brain$Types$UserMsg = function(a) {
        return { $: "UserMsg", a };
      };
      var $author$project$Brain$Common$State$attemptTask = function(mapFn) {
        return $elm$core$Task$attempt(
          $author$project$Brain$Common$State$reportErrorToUI(mapFn)
        );
      };
      var $elm$json$Json$Decode$decodeValue = _Json_run;
      var $author$project$User$Layer$Favourites = { $: "Favourites" };
      var $author$project$User$Layer$ModifiedAt = { $: "ModifiedAt" };
      var $author$project$User$Layer$Playlists = { $: "Playlists" };
      var $author$project$User$Layer$Progress = { $: "Progress" };
      var $author$project$User$Layer$Settings = { $: "Settings" };
      var $author$project$User$Layer$Sources = { $: "Sources" };
      var $author$project$User$Layer$Tracks = { $: "Tracks" };
      var $author$project$Playlists$Playlist = F4(
        function(autoGenerated, name, _public, tracks) {
          return { autoGenerated, name, _public, tracks };
        }
      );
      var $elm$json$Json$Decode$bool = _Json_decodeBool;
      var $author$project$Json$Decode$Ext$optionalField = F3(
        function(field, decoder, defaultValue) {
          return A2(
            $elm$json$Json$Decode$map,
            $elm$core$Maybe$withDefault(defaultValue),
            $elm$json$Json$Decode$maybe(
              A2($elm$json$Json$Decode$field, field, decoder)
            )
          );
        }
      );
      var $author$project$Playlists$PlaylistTrack = F3(
        function(album, artist, title) {
          return { album, artist, title };
        }
      );
      var $elm$json$Json$Decode$map3 = _Json_map3;
      var $author$project$Playlists$Encoding$playlistTrackDecoder = A4(
        $elm$json$Json$Decode$map3,
        $author$project$Playlists$PlaylistTrack,
        A2($elm$json$Json$Decode$field, "album", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "artist", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "title", $elm$json$Json$Decode$string)
      );
      var $author$project$Playlists$Encoding$decoder = A5(
        $elm$json$Json$Decode$map4,
        $author$project$Playlists$Playlist,
        A2($elm$json$Json$Decode$field, "autoGenerated", $elm$json$Json$Decode$bool),
        A2($elm$json$Json$Decode$field, "name", $elm$json$Json$Decode$string),
        A3($author$project$Json$Decode$Ext$optionalField, "public", $elm$json$Json$Decode$bool, false),
        A2(
          $elm$json$Json$Decode$field,
          "tracks",
          $elm$json$Json$Decode$list($author$project$Playlists$Encoding$playlistTrackDecoder)
        )
      );
      var $author$project$Settings$Settings = F6(
        function(backgroundImage, coverSelectionReducesPool, hideDuplicates, lastFm, processAutomatically, rememberProgress) {
          return { backgroundImage, coverSelectionReducesPool, hideDuplicates, lastFm, processAutomatically, rememberProgress };
        }
      );
      var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$custom = $elm$json$Json$Decode$map2($elm$core$Basics$apR);
      var $elm$json$Json$Decode$at = F2(
        function(fields, decoder) {
          return A3($elm$core$List$foldr, $elm$json$Json$Decode$field, decoder, fields);
        }
      );
      var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optionalDecoder = F3(
        function(path, valDecoder, fallback) {
          var nullOr = function(decoder) {
            return $elm$json$Json$Decode$oneOf(
              _List_fromArray(
                [
                  decoder,
                  $elm$json$Json$Decode$null(fallback)
                ]
              )
            );
          };
          var handleResult = function(input) {
            var _v0 = A2(
              $elm$json$Json$Decode$decodeValue,
              A2($elm$json$Json$Decode$at, path, $elm$json$Json$Decode$value),
              input
            );
            if (_v0.$ === "Ok") {
              var rawValue = _v0.a;
              var _v1 = A2(
                $elm$json$Json$Decode$decodeValue,
                nullOr(valDecoder),
                rawValue
              );
              if (_v1.$ === "Ok") {
                var finalResult = _v1.a;
                return $elm$json$Json$Decode$succeed(finalResult);
              } else {
                return A2(
                  $elm$json$Json$Decode$at,
                  path,
                  nullOr(valDecoder)
                );
              }
            } else {
              return $elm$json$Json$Decode$succeed(fallback);
            }
          };
          return A2($elm$json$Json$Decode$andThen, handleResult, $elm$json$Json$Decode$value);
        }
      );
      var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional = F4(
        function(key, valDecoder, fallback, decoder) {
          return A2(
            $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$custom,
            A3(
              $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optionalDecoder,
              _List_fromArray(
                [key]
              ),
              valDecoder,
              fallback
            ),
            decoder
          );
        }
      );
      var $author$project$Settings$decoder = A4(
        $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
        "rememberProgress",
        $elm$json$Json$Decode$bool,
        true,
        A4(
          $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
          "processAutomatically",
          $elm$json$Json$Decode$bool,
          true,
          A4(
            $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
            "lastFm",
            $elm$json$Json$Decode$maybe($elm$json$Json$Decode$string),
            $elm$core$Maybe$Nothing,
            A4(
              $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
              "hideDuplicates",
              $elm$json$Json$Decode$bool,
              false,
              A4(
                $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
                "coverSelectionReducesPool",
                $elm$json$Json$Decode$bool,
                true,
                A4(
                  $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
                  "backgroundImage",
                  $elm$json$Json$Decode$maybe($elm$json$Json$Decode$string),
                  $elm$core$Maybe$Nothing,
                  $elm$json$Json$Decode$succeed($author$project$Settings$Settings)
                )
              )
            )
          )
        )
      );
      var $author$project$Sources$Source = F5(
        function(id, data, directoryPlaylists, enabled, service) {
          return { data, directoryPlaylists, enabled, id, service };
        }
      );
      var $elm$json$Json$Decode$keyValuePairs = _Json_decodeKeyValuePairs;
      var $elm$json$Json$Decode$dict = function(decoder) {
        return A2(
          $elm$json$Json$Decode$map,
          $elm$core$Dict$fromList,
          $elm$json$Json$Decode$keyValuePairs(decoder)
        );
      };
      var $elm$json$Json$Decode$map5 = _Json_map5;
      var $author$project$Sources$AmazonS3 = { $: "AmazonS3" };
      var $author$project$Sources$AzureBlob = { $: "AzureBlob" };
      var $author$project$Sources$AzureFile = { $: "AzureFile" };
      var $author$project$Sources$Btfs = { $: "Btfs" };
      var $author$project$Sources$Dropbox = { $: "Dropbox" };
      var $author$project$Sources$Google = { $: "Google" };
      var $author$project$Sources$Ipfs = { $: "Ipfs" };
      var $author$project$Sources$WebDav = { $: "WebDav" };
      var $author$project$Sources$Services$keyToType = function(str) {
        switch (str) {
          case "AmazonS3":
            return $elm$core$Maybe$Just($author$project$Sources$AmazonS3);
          case "AzureBlob":
            return $elm$core$Maybe$Just($author$project$Sources$AzureBlob);
          case "AzureFile":
            return $elm$core$Maybe$Just($author$project$Sources$AzureFile);
          case "Btfs":
            return $elm$core$Maybe$Just($author$project$Sources$Btfs);
          case "Dropbox":
            return $elm$core$Maybe$Just($author$project$Sources$Dropbox);
          case "Google":
            return $elm$core$Maybe$Just($author$project$Sources$Google);
          case "Ipfs":
            return $elm$core$Maybe$Just($author$project$Sources$Ipfs);
          case "WebDav":
            return $elm$core$Maybe$Just($author$project$Sources$WebDav);
          default:
            return $elm$core$Maybe$Nothing;
        }
      };
      var $author$project$Sources$Encoding$serviceDecoder = A2(
        $elm$json$Json$Decode$andThen,
        function(key) {
          var _v0 = $author$project$Sources$Services$keyToType(key);
          if (_v0.$ === "Just") {
            var service = _v0.a;
            return $elm$json$Json$Decode$succeed(service);
          } else {
            return $elm$json$Json$Decode$fail("Unrecognizable source service");
          }
        },
        $elm$json$Json$Decode$string
      );
      var $author$project$Sources$Encoding$decoder = A6(
        $elm$json$Json$Decode$map5,
        $author$project$Sources$Source,
        A2($elm$json$Json$Decode$field, "id", $elm$json$Json$Decode$string),
        A2(
          $elm$json$Json$Decode$field,
          "data",
          $elm$json$Json$Decode$dict($elm$json$Json$Decode$string)
        ),
        A2(
          $elm$json$Json$Decode$map,
          $elm$core$Maybe$withDefault(true),
          $elm$json$Json$Decode$maybe(
            A2($elm$json$Json$Decode$field, "directoryPlaylists", $elm$json$Json$Decode$bool)
          )
        ),
        A2(
          $elm$json$Json$Decode$map,
          $elm$core$Maybe$withDefault(true),
          $elm$json$Json$Decode$maybe(
            A2($elm$json$Json$Decode$field, "enabled", $elm$json$Json$Decode$bool)
          )
        ),
        A2($elm$json$Json$Decode$field, "service", $author$project$Sources$Encoding$serviceDecoder)
      );
      var $author$project$Tracks$Favourite = F2(
        function(artist, title) {
          return { artist, title };
        }
      );
      var $author$project$Tracks$Encoding$favouriteDecoder = A3(
        $elm$json$Json$Decode$map2,
        $author$project$Tracks$Favourite,
        A2($elm$json$Json$Decode$field, "artist", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "title", $elm$json$Json$Decode$string)
      );
      var $elm$core$List$maybeCons = F3(
        function(f, mx, xs) {
          var _v0 = f(mx);
          if (_v0.$ === "Just") {
            var x = _v0.a;
            return A2($elm$core$List$cons, x, xs);
          } else {
            return xs;
          }
        }
      );
      var $elm$core$List$filterMap = F2(
        function(f, xs) {
          return A3(
            $elm$core$List$foldr,
            $elm$core$List$maybeCons(f),
            _List_Nil,
            xs
          );
        }
      );
      var $elm$json$Json$Decode$float = _Json_decodeFloat;
      var $author$project$User$Layer$hypaethralBitKey = function(bit) {
        switch (bit.$) {
          case "Favourites":
            return "favourites";
          case "ModifiedAt":
            return "modified";
          case "Playlists":
            return "playlists";
          case "Progress":
            return "progress";
          case "Settings":
            return "settings";
          case "Sources":
            return "sources";
          default:
            return "tracks";
        }
      };
      var $elm$json$Json$Decode$int = _Json_decodeInt;
      var $elm_community$list_extra$List$Extra$last = function(items) {
        last:
          while (true) {
            if (!items.b) {
              return $elm$core$Maybe$Nothing;
            } else {
              if (!items.b.b) {
                var x = items.a;
                return $elm$core$Maybe$Just(x);
              } else {
                var rest = items.b;
                var $temp$items = rest;
                items = $temp$items;
                continue last;
              }
            }
          }
      };
      var $elm_community$maybe_extra$Maybe$Extra$cons = F2(
        function(item, list) {
          if (item.$ === "Just") {
            var v = item.a;
            return A2($elm$core$List$cons, v, list);
          } else {
            return list;
          }
        }
      );
      var $elm_community$maybe_extra$Maybe$Extra$values = A2($elm$core$List$foldr, $elm_community$maybe_extra$Maybe$Extra$cons, _List_Nil);
      var $author$project$Json$Decode$Ext$listIgnore = function(decoder) {
        return A2(
          $elm$json$Json$Decode$map,
          $elm_community$maybe_extra$Maybe$Extra$values,
          $elm$json$Json$Decode$list(
            $elm$json$Json$Decode$maybe(decoder)
          )
        );
      };
      var $author$project$Time$Ext$decoder = A2($elm$json$Json$Decode$map, $elm$time$Time$millisToPosix, $elm$json$Json$Decode$int);
      var $author$project$User$Layer$modifiedAtDecoder = function(decoder) {
        return A3(
          $elm$json$Json$Decode$map2,
          F2(
            function(d, m) {
              return { data: d, modifiedAt: m };
            }
          ),
          A2($elm$json$Json$Decode$field, "data", decoder),
          $elm$json$Json$Decode$maybe(
            A2($elm$json$Json$Decode$field, "modifiedAt", $author$project$Time$Ext$decoder)
          )
        );
      };
      var $author$project$User$Layer$noModifiedAt = $elm$json$Json$Decode$map(
        function(data) {
          return { data, modifiedAt: $elm$core$Maybe$Nothing };
        }
      );
      var $elm$time$Time$posixToMillis = function(_v0) {
        var millis = _v0.a;
        return millis;
      };
      var $elm$core$List$sortBy = _List_sortBy;
      var $elm$core$List$sort = function(xs) {
        return A2($elm$core$List$sortBy, $elm$core$Basics$identity, xs);
      };
      var $author$project$Tracks$Track = F5(
        function(id, insertedAt, path, sourceId, tags) {
          return { id, insertedAt, path, sourceId, tags };
        }
      );
      var $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required = F3(
        function(key, valDecoder, decoder) {
          return A2(
            $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$custom,
            A2($elm$json$Json$Decode$field, key, valDecoder),
            decoder
          );
        }
      );
      var $author$project$Tracks$Tags = F8(
        function(disc, nr, album, artist, title, genre, picture, year) {
          return { album, artist, disc, genre, nr, picture, title, year };
        }
      );
      var $elm$json$Json$Decode$map8 = _Json_map8;
      var $author$project$Tracks$Encoding$tagsDecoder = A9(
        $elm$json$Json$Decode$map8,
        $author$project$Tracks$Tags,
        A2($elm$json$Json$Decode$field, "disc", $elm$json$Json$Decode$int),
        A2($elm$json$Json$Decode$field, "nr", $elm$json$Json$Decode$int),
        A2($elm$json$Json$Decode$field, "album", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "artist", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "title", $elm$json$Json$Decode$string),
        $elm$json$Json$Decode$maybe(
          A2($elm$json$Json$Decode$field, "genre", $elm$json$Json$Decode$string)
        ),
        $elm$json$Json$Decode$maybe(
          A2($elm$json$Json$Decode$field, "picture", $elm$json$Json$Decode$string)
        ),
        $elm$json$Json$Decode$maybe(
          A2($elm$json$Json$Decode$field, "year", $elm$json$Json$Decode$int)
        )
      );
      var $author$project$Tracks$Encoding$trackDecoder = A3(
        $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required,
        "tags",
        $author$project$Tracks$Encoding$tagsDecoder,
        A3(
          $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required,
          "sourceId",
          $elm$json$Json$Decode$string,
          A3(
            $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required,
            "path",
            $elm$json$Json$Decode$string,
            A4(
              $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
              "insertedAt",
              $author$project$Time$Ext$decoder,
              $author$project$Time$Ext$default,
              A3(
                $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$required,
                "id",
                $elm$json$Json$Decode$string,
                $elm$json$Json$Decode$succeed($author$project$Tracks$Track)
              )
            )
          )
        )
      );
      var $author$project$User$Layer$hypaethralDataDecoder = function() {
        var optionalWithPossiblyData = F4(
          function(key, dec, def, a) {
            return A4(
              $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
              $author$project$User$Layer$hypaethralBitKey(key),
              $elm$json$Json$Decode$oneOf(
                _List_fromArray(
                  [
                    $author$project$User$Layer$modifiedAtDecoder(dec),
                    $author$project$User$Layer$noModifiedAt(dec)
                  ]
                )
              ),
              { data: def, modifiedAt: $elm$core$Maybe$Nothing },
              a
            );
          }
        );
        return A4(
          $NoRedInk$elm_json_decode_pipeline$Json$Decode$Pipeline$optional,
          $author$project$User$Layer$hypaethralBitKey($author$project$User$Layer$ModifiedAt),
          $elm$json$Json$Decode$maybe($elm$json$Json$Decode$int),
          $elm$core$Maybe$Nothing,
          A4(
            optionalWithPossiblyData,
            $author$project$User$Layer$Tracks,
            $author$project$Json$Decode$Ext$listIgnore($author$project$Tracks$Encoding$trackDecoder),
            _List_Nil,
            A4(
              optionalWithPossiblyData,
              $author$project$User$Layer$Sources,
              $author$project$Json$Decode$Ext$listIgnore($author$project$Sources$Encoding$decoder),
              _List_Nil,
              A4(
                optionalWithPossiblyData,
                $author$project$User$Layer$Settings,
                $elm$json$Json$Decode$maybe($author$project$Settings$decoder),
                $elm$core$Maybe$Nothing,
                A4(
                  optionalWithPossiblyData,
                  $author$project$User$Layer$Progress,
                  $elm$json$Json$Decode$dict($elm$json$Json$Decode$float),
                  $elm$core$Dict$empty,
                  A4(
                    optionalWithPossiblyData,
                    $author$project$User$Layer$Playlists,
                    $author$project$Json$Decode$Ext$listIgnore($author$project$Playlists$Encoding$decoder),
                    _List_Nil,
                    A4(
                      optionalWithPossiblyData,
                      $author$project$User$Layer$Favourites,
                      $author$project$Json$Decode$Ext$listIgnore($author$project$Tracks$Encoding$favouriteDecoder),
                      _List_Nil,
                      $elm$json$Json$Decode$succeed(
                        F7(
                          function(fav, pla, pro, set, sor, tra, mod) {
                            return {
                              favourites: fav.data,
                              modifiedAt: function() {
                                if (mod.$ === "Just") {
                                  var m = mod.a;
                                  return $elm$core$Maybe$Just(
                                    $elm$time$Time$millisToPosix(m)
                                  );
                                } else {
                                  return A2(
                                    $elm$core$Maybe$map,
                                    $elm$time$Time$millisToPosix,
                                    $elm_community$list_extra$List$Extra$last(
                                      $elm$core$List$sort(
                                        A2(
                                          $elm$core$List$filterMap,
                                          $elm$core$Maybe$map($elm$time$Time$posixToMillis),
                                          _List_fromArray(
                                            [fav.modifiedAt, pla.modifiedAt, pro.modifiedAt, set.modifiedAt, sor.modifiedAt, tra.modifiedAt]
                                          )
                                        )
                                      )
                                    )
                                  );
                                }
                              }(),
                              playlists: pla.data,
                              progress: pro.data,
                              settings: set.data,
                              sources: sor.data,
                              tracks: tra.data
                            };
                          }
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }();
      var $author$project$User$Layer$decodeHypaethralData = $elm$json$Json$Decode$decodeValue($author$project$User$Layer$hypaethralDataDecoder);
      var $author$project$User$Layer$allHypaethralBits = _List_fromArray(
        [$author$project$User$Layer$Favourites, $author$project$User$Layer$Playlists, $author$project$User$Layer$Progress, $author$project$User$Layer$Settings, $author$project$User$Layer$Sources, $author$project$User$Layer$Tracks]
      );
      var $elm$core$Dict$foldl = F3(
        function(func, acc, dict) {
          foldl:
            while (true) {
              if (dict.$ === "RBEmpty_elm_builtin") {
                return acc;
              } else {
                var key = dict.b;
                var value = dict.c;
                var left = dict.d;
                var right = dict.e;
                var $temp$func = func, $temp$acc = A3(
                  func,
                  key,
                  value,
                  A3($elm$core$Dict$foldl, func, acc, left)
                ), $temp$dict = right;
                func = $temp$func;
                acc = $temp$acc;
                dict = $temp$dict;
                continue foldl;
              }
            }
        }
      );
      var $elm$json$Json$Encode$dict = F3(
        function(toKey, toValue, dictionary) {
          return _Json_wrap(
            A3(
              $elm$core$Dict$foldl,
              F3(
                function(key, value, obj) {
                  return A3(
                    _Json_addField,
                    toKey(key),
                    toValue(value),
                    obj
                  );
                }
              ),
              _Json_emptyObject(_Utils_Tuple0),
              dictionary
            )
          );
        }
      );
      var $elm$json$Json$Encode$bool = _Json_wrap;
      var $author$project$Playlists$Encoding$encodePlaylistTrack = function(playlistTrack) {
        return $elm$json$Json$Encode$object(
          _List_fromArray(
            [
              _Utils_Tuple2(
                "album",
                $elm$json$Json$Encode$string(playlistTrack.album)
              ),
              _Utils_Tuple2(
                "artist",
                $elm$json$Json$Encode$string(playlistTrack.artist)
              ),
              _Utils_Tuple2(
                "title",
                $elm$json$Json$Encode$string(playlistTrack.title)
              )
            ]
          )
        );
      };
      var $elm$json$Json$Encode$list = F2(
        function(func, entries) {
          return _Json_wrap(
            A3(
              $elm$core$List$foldl,
              _Json_addEntry(func),
              _Json_emptyArray(_Utils_Tuple0),
              entries
            )
          );
        }
      );
      var $author$project$Playlists$Encoding$encode = function(playlist) {
        return $elm$json$Json$Encode$object(
          _List_fromArray(
            [
              _Utils_Tuple2(
                "autoGenerated",
                $elm$json$Json$Encode$bool(playlist.autoGenerated)
              ),
              _Utils_Tuple2(
                "name",
                $elm$json$Json$Encode$string(playlist.name)
              ),
              _Utils_Tuple2(
                "public",
                $elm$json$Json$Encode$bool(playlist._public)
              ),
              _Utils_Tuple2(
                "tracks",
                A2($elm$json$Json$Encode$list, $author$project$Playlists$Encoding$encodePlaylistTrack, playlist.tracks)
              )
            ]
          )
        );
      };
      var $elm_community$maybe_extra$Maybe$Extra$unwrap = F3(
        function(_default, f, m) {
          if (m.$ === "Nothing") {
            return _default;
          } else {
            var a = m.a;
            return f(a);
          }
        }
      );
      var $author$project$Settings$encode = function(settings) {
        return $elm$json$Json$Encode$object(
          _List_fromArray(
            [
              _Utils_Tuple2(
                "backgroundImage",
                A3($elm_community$maybe_extra$Maybe$Extra$unwrap, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, settings.backgroundImage)
              ),
              _Utils_Tuple2(
                "coverSelectionReducesPool",
                $elm$json$Json$Encode$bool(settings.coverSelectionReducesPool)
              ),
              _Utils_Tuple2(
                "hideDuplicates",
                $elm$json$Json$Encode$bool(settings.hideDuplicates)
              ),
              _Utils_Tuple2(
                "lastFm",
                A3($elm_community$maybe_extra$Maybe$Extra$unwrap, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, settings.lastFm)
              ),
              _Utils_Tuple2(
                "processAutomatically",
                $elm$json$Json$Encode$bool(settings.processAutomatically)
              ),
              _Utils_Tuple2(
                "rememberProgress",
                $elm$json$Json$Encode$bool(settings.rememberProgress)
              )
            ]
          )
        );
      };
      var $elm$core$Tuple$mapSecond = F2(
        function(func, _v0) {
          var x = _v0.a;
          var y = _v0.b;
          return _Utils_Tuple2(
            x,
            func(y)
          );
        }
      );
      var $author$project$Sources$Encoding$encodeData = function(data) {
        return $elm$json$Json$Encode$object(
          A2(
            $elm$core$List$map,
            $elm$core$Tuple$mapSecond($elm$json$Json$Encode$string),
            $elm$core$Dict$toList(data)
          )
        );
      };
      var $author$project$Sources$Services$typeToKey = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return "AmazonS3";
          case "AzureBlob":
            return "AzureBlob";
          case "AzureFile":
            return "AzureFile";
          case "Btfs":
            return "Btfs";
          case "Dropbox":
            return "Dropbox";
          case "Google":
            return "Google";
          case "Ipfs":
            return "Ipfs";
          default:
            return "WebDav";
        }
      };
      var $author$project$Sources$Encoding$encode = function(source) {
        return $elm$json$Json$Encode$object(
          _List_fromArray(
            [
              _Utils_Tuple2(
                "id",
                $elm$json$Json$Encode$string(source.id)
              ),
              _Utils_Tuple2(
                "data",
                $author$project$Sources$Encoding$encodeData(source.data)
              ),
              _Utils_Tuple2(
                "directoryPlaylists",
                $elm$json$Json$Encode$bool(source.directoryPlaylists)
              ),
              _Utils_Tuple2(
                "enabled",
                $elm$json$Json$Encode$bool(source.enabled)
              ),
              _Utils_Tuple2(
                "service",
                $elm$json$Json$Encode$string(
                  $author$project$Sources$Services$typeToKey(source.service)
                )
              )
            ]
          )
        );
      };
      var $elm$json$Json$Encode$int = _Json_wrap;
      var $author$project$Time$Ext$encode = function(time) {
        return $elm$json$Json$Encode$int(
          $elm$time$Time$posixToMillis(time)
        );
      };
      var $author$project$Tracks$Encoding$encodeFavourite = function(fav) {
        return $elm$json$Json$Encode$object(
          _List_fromArray(
            [
              _Utils_Tuple2(
                "artist",
                $elm$json$Json$Encode$string(fav.artist)
              ),
              _Utils_Tuple2(
                "title",
                $elm$json$Json$Encode$string(fav.title)
              )
            ]
          )
        );
      };
      var $author$project$Tracks$Encoding$encodeMaybe = F2(
        function(maybe, encoder) {
          return A2(
            $elm$core$Maybe$withDefault,
            $elm$json$Json$Encode$null,
            A2($elm$core$Maybe$map, encoder, maybe)
          );
        }
      );
      var $author$project$Tracks$Encoding$encodeTags = function(tags) {
        return $elm$json$Json$Encode$object(
          _List_fromArray(
            [
              _Utils_Tuple2(
                "disc",
                $elm$json$Json$Encode$int(tags.disc)
              ),
              _Utils_Tuple2(
                "nr",
                $elm$json$Json$Encode$int(tags.nr)
              ),
              _Utils_Tuple2(
                "album",
                $elm$json$Json$Encode$string(tags.album)
              ),
              _Utils_Tuple2(
                "artist",
                $elm$json$Json$Encode$string(tags.artist)
              ),
              _Utils_Tuple2(
                "title",
                $elm$json$Json$Encode$string(tags.title)
              ),
              _Utils_Tuple2(
                "genre",
                A2($author$project$Tracks$Encoding$encodeMaybe, tags.genre, $elm$json$Json$Encode$string)
              ),
              _Utils_Tuple2(
                "picture",
                A2($author$project$Tracks$Encoding$encodeMaybe, tags.picture, $elm$json$Json$Encode$string)
              ),
              _Utils_Tuple2(
                "year",
                A2($author$project$Tracks$Encoding$encodeMaybe, tags.year, $elm$json$Json$Encode$int)
              )
            ]
          )
        );
      };
      var $author$project$Tracks$Encoding$encodeTrack = function(track) {
        return $elm$json$Json$Encode$object(
          _List_fromArray(
            [
              _Utils_Tuple2(
                "id",
                $elm$json$Json$Encode$string(track.id)
              ),
              _Utils_Tuple2(
                "insertedAt",
                $author$project$Time$Ext$encode(track.insertedAt)
              ),
              _Utils_Tuple2(
                "path",
                $elm$json$Json$Encode$string(track.path)
              ),
              _Utils_Tuple2(
                "sourceId",
                $elm$json$Json$Encode$string(track.sourceId)
              ),
              _Utils_Tuple2(
                "tags",
                $author$project$Tracks$Encoding$encodeTags(track.tags)
              )
            ]
          )
        );
      };
      var $elm$json$Json$Encode$float = _Json_wrap;
      var $author$project$User$Layer$encodeHypaethralBit = F2(
        function(bit, _v0) {
          var favourites = _v0.favourites;
          var playlists = _v0.playlists;
          var progress = _v0.progress;
          var settings = _v0.settings;
          var sources = _v0.sources;
          var tracks = _v0.tracks;
          var modifiedAt = _v0.modifiedAt;
          if (bit.$ === "ModifiedAt") {
            return A3($elm_community$maybe_extra$Maybe$Extra$unwrap, $elm$json$Json$Encode$null, $author$project$Time$Ext$encode, modifiedAt);
          } else {
            return $elm$json$Json$Encode$object(
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "data",
                    function() {
                      switch (bit.$) {
                        case "Favourites":
                          return A2($elm$json$Json$Encode$list, $author$project$Tracks$Encoding$encodeFavourite, favourites);
                        case "ModifiedAt":
                          return A3($elm_community$maybe_extra$Maybe$Extra$unwrap, $elm$json$Json$Encode$null, $author$project$Time$Ext$encode, modifiedAt);
                        case "Playlists":
                          return A2($elm$json$Json$Encode$list, $author$project$Playlists$Encoding$encode, playlists);
                        case "Progress":
                          return A3($elm$json$Json$Encode$dict, $elm$core$Basics$identity, $elm$json$Json$Encode$float, progress);
                        case "Settings":
                          return A3($elm_community$maybe_extra$Maybe$Extra$unwrap, $elm$json$Json$Encode$null, $author$project$Settings$encode, settings);
                        case "Sources":
                          return A2($elm$json$Json$Encode$list, $author$project$Sources$Encoding$encode, sources);
                        default:
                          return A2($elm$json$Json$Encode$list, $author$project$Tracks$Encoding$encodeTrack, tracks);
                      }
                    }()
                  ),
                  _Utils_Tuple2(
                    "modifiedAt",
                    A3($elm_community$maybe_extra$Maybe$Extra$unwrap, $elm$json$Json$Encode$null, $author$project$Time$Ext$encode, modifiedAt)
                  )
                ]
              )
            );
          }
        }
      );
      var $author$project$User$Layer$encodedHypaethralDataList = function(data) {
        return A2(
          $elm$core$List$map,
          function(bit) {
            return _Utils_Tuple2(
              bit,
              A2($author$project$User$Layer$encodeHypaethralBit, bit, data)
            );
          },
          $author$project$User$Layer$allHypaethralBits
        );
      };
      var $elm$core$Tuple$mapFirst = F2(
        function(func, _v0) {
          var x = _v0.a;
          var y = _v0.b;
          return _Utils_Tuple2(
            func(x),
            y
          );
        }
      );
      var $author$project$User$Layer$encodeHypaethralData = function(data) {
        return $elm$json$Json$Encode$object(
          A2(
            $elm$core$List$map,
            $elm$core$Tuple$mapFirst($author$project$User$Layer$hypaethralBitKey),
            $author$project$User$Layer$encodedHypaethralDataList(data)
          )
        );
      };
      var $elm$core$Result$map = F2(
        function(func, ra) {
          if (ra.$ === "Ok") {
            var a = ra.a;
            return $elm$core$Result$Ok(
              func(a)
            );
          } else {
            var e = ra.a;
            return $elm$core$Result$Err(e);
          }
        }
      );
      var $elm$core$Tuple$pair = F2(
        function(a, b) {
          return _Utils_Tuple2(a, b);
        }
      );
      var $author$project$User$Layer$hypaethralBit = $Herteby$enum$Enum$create(
        A2(
          $elm$core$List$map,
          function(bit) {
            return _Utils_Tuple2(
              $author$project$User$Layer$hypaethralBitKey(bit),
              bit
            );
          },
          $author$project$User$Layer$allHypaethralBits
        )
      );
      var $author$project$User$Layer$retrieveHypaethralData = function(retrievalFn) {
        return $elm$core$Task$sequence(
          A2(
            $elm$core$List$map,
            function(_v0) {
              var bit = _v0.b;
              return A2(
                $elm$core$Task$map,
                function(value) {
                  return _Utils_Tuple2(bit, value);
                },
                retrievalFn(bit)
              );
            },
            $author$project$User$Layer$hypaethralBit.list
          )
        );
      };
      var $author$project$Brain$Task$Ports$fromCacheWithSuffix = F3(
        function(tag, suffix, decoder) {
          return A2(
            $lobanov$elm_taskport$TaskPort$call,
            {
              argsEncoder: $elm$json$Json$Encode$string,
              _function: "fromCache",
              valueDecoder: $elm$json$Json$Decode$maybe(decoder)
            },
            $author$project$Alien$tagToString(tag) + ("_" + suffix)
          );
        }
      );
      var $author$project$User$Layer$hypaethralBitFileName = function(bit) {
        return $author$project$User$Layer$hypaethralBitKey(bit) + ".json";
      };
      var $elm$core$Task$mapError = F2(
        function(convert, task) {
          return A2(
            $elm$core$Task$onError,
            A2($elm$core$Basics$composeL, $elm$core$Task$fail, convert),
            task
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$retrieveLocal = function(bit) {
        return A2(
          $elm$core$Task$mapError,
          $author$project$TaskPort$Extra$errorToStringCustom,
          A3(
            $author$project$Brain$Task$Ports$fromCacheWithSuffix,
            $author$project$Alien$SyncLocal,
            $author$project$User$Layer$hypaethralBitFileName(bit),
            $elm$json$Json$Decode$value
          )
        );
      };
      var $elm$core$Result$withDefault = F2(
        function(def, result) {
          if (result.$ === "Ok") {
            var a = result.a;
            return a;
          } else {
            return def;
          }
        }
      );
      var $author$project$Brain$User$State$loadLocalHypaethralData = function(_v0) {
        var initialUrl = _v0.initialUrl;
        var methodTask = _v0.methodTask;
        return A2(
          $author$project$Brain$Common$State$attemptTask,
          function(_v2) {
            var maybeMethod = _v2.a;
            var hypaethralJson = _v2.b;
            return $author$project$Brain$Types$UserMsg(
              A3(
                $author$project$Brain$User$Types$Commence,
                maybeMethod,
                initialUrl,
                A2(
                  $elm$core$Result$withDefault,
                  _Utils_Tuple2(
                    $author$project$User$Layer$encodeHypaethralData($author$project$User$Layer$emptyHypaethralData),
                    $author$project$User$Layer$emptyHypaethralData
                  ),
                  A2(
                    $elm$core$Result$map,
                    function(hypaethralData) {
                      return _Utils_Tuple2(hypaethralJson, hypaethralData);
                    },
                    $author$project$User$Layer$decodeHypaethralData(hypaethralJson)
                  )
                )
              )
            );
          },
          A2(
            $elm$core$Task$andThen,
            function(maybeMethod) {
              return A2(
                $elm$core$Task$map,
                $elm$core$Tuple$pair(maybeMethod),
                A2(
                  $elm$core$Task$map,
                  function(bits) {
                    return $elm$json$Json$Encode$object(
                      A2(
                        $elm$core$List$map,
                        function(_v1) {
                          var a = _v1.a;
                          var b = _v1.b;
                          return _Utils_Tuple2(
                            $author$project$User$Layer$hypaethralBitKey(a),
                            A2($elm$core$Maybe$withDefault, $elm$json$Json$Encode$null, b)
                          );
                        },
                        bits
                      )
                    );
                  },
                  $author$project$User$Layer$retrieveHypaethralData($author$project$Brain$User$Hypaethral$retrieveLocal)
                )
              );
            },
            methodTask
          )
        );
      };
      var $elm$core$Maybe$andThen = F2(
        function(callback, maybeValue) {
          if (maybeValue.$ === "Just") {
            var value = maybeValue.a;
            return callback(value);
          } else {
            return $elm$core$Maybe$Nothing;
          }
        }
      );
      var $author$project$User$Layer$Dropbox = function(a) {
        return { $: "Dropbox", a };
      };
      var $author$project$User$Layer$Fission = function(a) {
        return { $: "Fission", a };
      };
      var $author$project$User$Layer$Ipfs = function(a) {
        return { $: "Ipfs", a };
      };
      var $author$project$User$Layer$RemoteStorage = function(a) {
        return { $: "RemoteStorage", a };
      };
      var $author$project$User$Layer$methodSeparator = "___";
      var $author$project$User$Layer$methodFromString = function(string) {
        var _v0 = A2($elm$core$String$split, $author$project$User$Layer$methodSeparator, string);
        _v0$4:
          while (true) {
            if (_v0.b) {
              if (!_v0.b.b) {
                if (_v0.a === "FISSION") {
                  return $elm$core$Maybe$Just(
                    $author$project$User$Layer$Fission(
                      {}
                    )
                  );
                } else {
                  break _v0$4;
                }
              } else {
                if (!_v0.b.b.b) {
                  if (_v0.a === "IPFS") {
                    var _v4 = _v0.b;
                    var a = _v4.a;
                    return $elm$core$Maybe$Just(
                      $author$project$User$Layer$Ipfs(
                        { apiOrigin: a }
                      )
                    );
                  } else {
                    break _v0$4;
                  }
                } else {
                  if (_v0.b.b.b.b) {
                    if (_v0.a === "DROPBOX" && !_v0.b.b.b.b.b) {
                      var _v1 = _v0.b;
                      var a = _v1.a;
                      var _v2 = _v1.b;
                      var e = _v2.a;
                      var _v3 = _v2.b;
                      var r = _v3.a;
                      return $elm$core$Maybe$Just(
                        $author$project$User$Layer$Dropbox(
                          {
                            accessToken: a,
                            expiresAt: A2(
                              $elm$core$Maybe$withDefault,
                              0,
                              $elm$core$String$toInt(e)
                            ),
                            refreshToken: r
                          }
                        )
                      );
                    } else {
                      break _v0$4;
                    }
                  } else {
                    if (_v0.a === "REMOTE_STORAGE") {
                      var _v5 = _v0.b;
                      var u = _v5.a;
                      var _v6 = _v5.b;
                      var t = _v6.a;
                      return $elm$core$Maybe$Just(
                        $author$project$User$Layer$RemoteStorage(
                          { token: t, userAddress: u }
                        )
                      );
                    } else {
                      break _v0$4;
                    }
                  }
                }
              }
            } else {
              break _v0$4;
            }
          }
        return $elm$core$Maybe$Nothing;
      };
      var $elm$core$Result$toMaybe = function(result) {
        if (result.$ === "Ok") {
          var v = result.a;
          return $elm$core$Maybe$Just(v);
        } else {
          return $elm$core$Maybe$Nothing;
        }
      };
      var $author$project$User$Layer$decodeMethod = A2(
        $elm$core$Basics$composeR,
        $elm$json$Json$Decode$decodeValue(
          A2($elm$json$Json$Decode$map, $author$project$User$Layer$methodFromString, $elm$json$Json$Decode$string)
        ),
        A2($elm$core$Basics$composeR, $elm$core$Result$toMaybe, $elm_community$maybe_extra$Maybe$Extra$join)
      );
      var $author$project$Brain$User$State$loadSyncMethod = A2(
        $elm$core$Task$map,
        $elm$core$Maybe$andThen($author$project$User$Layer$decodeMethod),
        A2(
          $elm$core$Task$mapError,
          $author$project$TaskPort$Extra$errorToStringCustom,
          A2($author$project$Brain$Task$Ports$fromCache, $author$project$Alien$SyncMethod, $elm$json$Json$Decode$value)
        )
      );
      var $author$project$Brain$User$State$initialCommand = function(uiUrl) {
        var _v0 = $author$project$Url$Ext$action(uiUrl);
        if (_v0.b && _v0.a === "authenticate" && _v0.b.b && _v0.b.a === "fission" && !_v0.b.b.b) {
          var _v1 = _v0.b;
          return $elm$core$Platform$Cmd$batch(
            _List_fromArray(
              [
                $author$project$Brain$User$State$loadEnclosedData,
                $author$project$Brain$User$State$loadLocalHypaethralData(
                  {
                    initialUrl: uiUrl,
                    methodTask: $elm$core$Task$succeed($elm$core$Maybe$Nothing)
                  }
                )
              ]
            )
          );
        } else {
          return $elm$core$Platform$Cmd$batch(
            _List_fromArray(
              [
                $author$project$Brain$User$State$loadEnclosedData,
                $author$project$Brain$User$State$loadLocalHypaethralData(
                  { initialUrl: uiUrl, methodTask: $author$project$Brain$User$State$loadSyncMethod }
                )
              ]
            )
          );
        }
      };
      var $elm$time$Time$Name = function(a) {
        return { $: "Name", a };
      };
      var $elm$time$Time$Offset = function(a) {
        return { $: "Offset", a };
      };
      var $elm$time$Time$Zone = F2(
        function(a, b) {
          return { $: "Zone", a, b };
        }
      );
      var $elm$time$Time$customZone = $elm$time$Time$Zone;
      var $elm$time$Time$now = _Time_now($elm$time$Time$millisToPosix);
      var $elm$core$Task$perform = F2(
        function(toMessage, task) {
          return $elm$core$Task$command(
            $elm$core$Task$Perform(
              A2($elm$core$Task$map, toMessage, task)
            )
          );
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Internal$Debouncer = F2(
        function(a, b) {
          return { $: "Debouncer", a, b };
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Internal$Settled = { $: "Settled" };
      var $Gizra$elm_debouncer$Debouncer$Internal$nothingIfNegative = $elm$core$Maybe$andThen(
        function(num) {
          return num < 0 ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(num);
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Internal$sanitizeConfig = function(_v0) {
        var config = _v0.a;
        return $Gizra$elm_debouncer$Debouncer$Internal$Config(
          {
            accumulator: config.accumulator,
            emitWhenUnsettled: $Gizra$elm_debouncer$Debouncer$Internal$nothingIfNegative(config.emitWhenUnsettled),
            emitWhileUnsettled: $Gizra$elm_debouncer$Debouncer$Internal$nothingIfNegative(config.emitWhileUnsettled),
            settleWhenQuietFor: $Gizra$elm_debouncer$Debouncer$Internal$nothingIfNegative(config.settleWhenQuietFor)
          }
        );
      };
      var $Gizra$elm_debouncer$Debouncer$Internal$toDebouncer = function(config) {
        return A2(
          $Gizra$elm_debouncer$Debouncer$Internal$Debouncer,
          $Gizra$elm_debouncer$Debouncer$Internal$sanitizeConfig(config),
          $Gizra$elm_debouncer$Debouncer$Internal$Settled
        );
      };
      var $Gizra$elm_debouncer$Debouncer$Basic$toDebouncer = $Gizra$elm_debouncer$Debouncer$Internal$toDebouncer;
      var $author$project$Brain$init = function(flags2) {
        var initialUrl = A2(
          $elm$core$Maybe$withDefault,
          { fragment: $elm$core$Maybe$Nothing, host: "", path: "", port_: $elm$core$Maybe$Nothing, protocol: $elm$url$Url$Http, query: $elm$core$Maybe$Nothing },
          $elm$url$Url$fromString(flags2.initialUrl)
        );
        var hypDebouncer = $Gizra$elm_debouncer$Debouncer$Basic$toDebouncer(
          A2(
            $Gizra$elm_debouncer$Debouncer$Basic$accumulateWith,
            $Gizra$elm_debouncer$Debouncer$Basic$allInputs,
            $Gizra$elm_debouncer$Debouncer$Basic$debounce(
              $Gizra$elm_debouncer$Debouncer$Basic$fromSeconds(2.5)
            )
          )
        );
        return _Utils_Tuple2(
          { currentTime: $author$project$Time$Ext$default, hypaethralDebouncer: hypDebouncer, hypaethralRetrieval: $elm$core$Maybe$Nothing, hypaethralStorage: _List_Nil, hypaethralUserData: $author$project$User$Layer$emptyHypaethralData, origin: "ORIGIN_UNKNOWN", processingStatus: $author$project$Sources$Processing$NotProcessing, userSyncMethod: $elm$core$Maybe$Nothing },
          $elm$core$Platform$Cmd$batch(
            _List_fromArray(
              [
                A2($elm$core$Task$perform, $author$project$Brain$Types$SetCurrentTime, $elm$time$Time$now),
                $author$project$Brain$User$State$initialCommand(initialUrl)
              ]
            )
          )
        );
      };
      var $author$project$Brain$Types$GotSearchResults = function(a) {
        return { $: "GotSearchResults", a };
      };
      var $author$project$Brain$Types$MakeArtworkTrackUrls = function(a) {
        return { $: "MakeArtworkTrackUrls", a };
      };
      var $author$project$Brain$Types$ProcessingMsg = function(a) {
        return { $: "ProcessingMsg", a };
      };
      var $author$project$Brain$Types$RefreshedAccessToken = function(a) {
        return { $: "RefreshedAccessToken", a };
      };
      var $author$project$Brain$Types$ReplaceTrackTags = function(a) {
        return { $: "ReplaceTrackTags", a };
      };
      var $author$project$Brain$Sources$Processing$Types$TagsStep = function(a) {
        return { $: "TagsStep", a };
      };
      var $author$project$Brain$Types$Bypass = { $: "Bypass" };
      var $author$project$Alien$tagFromString = $author$project$Alien$enum.fromString;
      var $author$project$Brain$Types$DownloadTracks = function(a) {
        return { $: "DownloadTracks", a };
      };
      var $author$project$Brain$User$Types$EnclosedDataRetrieved = function(a) {
        return { $: "EnclosedDataRetrieved", a };
      };
      var $author$project$Brain$Sources$Processing$Types$Process = function(a) {
        return { $: "Process", a };
      };
      var $author$project$Brain$User$Types$RemoveEncryptionKey = { $: "RemoveEncryptionKey" };
      var $author$project$Brain$Types$RemoveTracksBySourceId = function(a) {
        return { $: "RemoveTracksBySourceId", a };
      };
      var $author$project$Brain$Types$RemoveTracksFromCache = function(a) {
        return { $: "RemoveTracksFromCache", a };
      };
      var $author$project$Brain$User$Types$SaveEnclosedData = function(a) {
        return { $: "SaveEnclosedData", a };
      };
      var $author$project$Brain$User$Types$SaveFavourites = function(a) {
        return { $: "SaveFavourites", a };
      };
      var $author$project$Brain$User$Types$SavePlaylists = function(a) {
        return { $: "SavePlaylists", a };
      };
      var $author$project$Brain$User$Types$SaveProgress = function(a) {
        return { $: "SaveProgress", a };
      };
      var $author$project$Brain$User$Types$SaveSettings = function(a) {
        return { $: "SaveSettings", a };
      };
      var $author$project$Brain$User$Types$SaveSources = function(a) {
        return { $: "SaveSources", a };
      };
      var $author$project$Brain$User$Types$SaveTracks = function(a) {
        return { $: "SaveTracks", a };
      };
      var $author$project$Brain$Types$Search = function(a) {
        return { $: "Search", a };
      };
      var $author$project$Brain$User$Types$SetSyncMethod = function(a) {
        return { $: "SetSyncMethod", a };
      };
      var $author$project$Brain$Sources$Processing$Types$StopProcessing = { $: "StopProcessing" };
      var $author$project$Brain$Types$StoreTracksInCache = function(a) {
        return { $: "StoreTracksInCache", a };
      };
      var $author$project$Brain$Types$SyncTrackTags = function(a) {
        return { $: "SyncTrackTags", a };
      };
      var $author$project$Brain$Types$ToCache = function(a) {
        return { $: "ToCache", a };
      };
      var $author$project$Brain$User$Types$UnsetSyncMethod = { $: "UnsetSyncMethod" };
      var $author$project$Brain$User$Types$UpdateEncryptionKey = function(a) {
        return { $: "UpdateEncryptionKey", a };
      };
      var $author$project$Brain$translateAlienData = F2(
        function(tag, data) {
          switch (tag.$) {
            case "EnclosedData":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$EnclosedDataRetrieved(data)
              );
            case "SearchTracks":
              return $author$project$Brain$Types$Search(data);
            case "DownloadTracks":
              return $author$project$Brain$Types$DownloadTracks(data);
            case "ProcessSources":
              return $author$project$Brain$Types$ProcessingMsg(
                $author$project$Brain$Sources$Processing$Types$Process(data)
              );
            case "RefreshedAccessToken":
              return $author$project$Brain$Types$RefreshedAccessToken(data);
            case "RemoveEncryptionKey":
              return $author$project$Brain$Types$UserMsg($author$project$Brain$User$Types$RemoveEncryptionKey);
            case "RemoveTracksBySourceId":
              return $author$project$Brain$Types$RemoveTracksBySourceId(data);
            case "RemoveTracksFromCache":
              return $author$project$Brain$Types$RemoveTracksFromCache(data);
            case "SaveEnclosedUserData":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SaveEnclosedData(data)
              );
            case "SaveFavourites":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SaveFavourites(data)
              );
            case "SavePlaylists":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SavePlaylists(data)
              );
            case "SaveProgress":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SaveProgress(data)
              );
            case "SaveSettings":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SaveSettings(data)
              );
            case "SaveSources":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SaveSources(data)
              );
            case "SaveTracks":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SaveTracks(data)
              );
            case "SetSyncMethod":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$SetSyncMethod(data)
              );
            case "StopProcessing":
              return $author$project$Brain$Types$ProcessingMsg($author$project$Brain$Sources$Processing$Types$StopProcessing);
            case "StoreTracksInCache":
              return $author$project$Brain$Types$StoreTracksInCache(data);
            case "SyncTrackTags":
              return $author$project$Brain$Types$SyncTrackTags(data);
            case "ToCache":
              return $author$project$Brain$Types$ToCache(data);
            case "UnsetSyncMethod":
              return $author$project$Brain$Types$UserMsg($author$project$Brain$User$Types$UnsetSyncMethod);
            case "UpdateEncryptionKey":
              return $author$project$Brain$Types$UserMsg(
                $author$project$Brain$User$Types$UpdateEncryptionKey(data)
              );
            default:
              return $author$project$Brain$Types$Bypass;
          }
        }
      );
      var $author$project$Brain$translateAlienError = F3(
        function(tag, _v0, err) {
          if (err === "db is undefined") {
            return A2($author$project$Brain$Common$State$reportUICmdMsg, tag, "Can't connect to the browser's IndexedDB. FYI, this is __not supported in Firefox's private mode__.");
          } else {
            return A2($author$project$Brain$Common$State$reportUICmdMsg, tag, err);
          }
        }
      );
      var $author$project$Brain$alien = function(event) {
        var _v0 = _Utils_Tuple2(
          event.error,
          $author$project$Alien$tagFromString(event.tag)
        );
        _v0$2:
          while (true) {
            if (_v0.a.$ === "Nothing") {
              if (_v0.b.$ === "Just") {
                var _v1 = _v0.a;
                var tag = _v0.b.a;
                return A2($author$project$Brain$translateAlienData, tag, event.data);
              } else {
                break _v0$2;
              }
            } else {
              if (_v0.b.$ === "Just") {
                var err = _v0.a.a;
                var tag = _v0.b.a;
                return A3($author$project$Brain$translateAlienError, tag, event.data, err);
              } else {
                break _v0$2;
              }
            }
          }
        return $author$project$Brain$Types$Bypass;
      };
      var $elm$core$Platform$Sub$batch = _Platform_batch;
      var $elm$time$Time$Every = F2(
        function(a, b) {
          return { $: "Every", a, b };
        }
      );
      var $elm$time$Time$State = F2(
        function(taggers, processes) {
          return { processes, taggers };
        }
      );
      var $elm$time$Time$init = $elm$core$Task$succeed(
        A2($elm$time$Time$State, $elm$core$Dict$empty, $elm$core$Dict$empty)
      );
      var $elm$time$Time$addMySub = F2(
        function(_v0, state) {
          var interval = _v0.a;
          var tagger = _v0.b;
          var _v1 = A2($elm$core$Dict$get, interval, state);
          if (_v1.$ === "Nothing") {
            return A3(
              $elm$core$Dict$insert,
              interval,
              _List_fromArray(
                [tagger]
              ),
              state
            );
          } else {
            var taggers = _v1.a;
            return A3(
              $elm$core$Dict$insert,
              interval,
              A2($elm$core$List$cons, tagger, taggers),
              state
            );
          }
        }
      );
      var $elm$core$Process$kill = _Scheduler_kill;
      var $elm$core$Dict$merge = F6(
        function(leftStep, bothStep, rightStep, leftDict, rightDict, initialResult) {
          var stepState = F3(
            function(rKey, rValue, _v0) {
              stepState:
                while (true) {
                  var list = _v0.a;
                  var result = _v0.b;
                  if (!list.b) {
                    return _Utils_Tuple2(
                      list,
                      A3(rightStep, rKey, rValue, result)
                    );
                  } else {
                    var _v2 = list.a;
                    var lKey = _v2.a;
                    var lValue = _v2.b;
                    var rest = list.b;
                    if (_Utils_cmp(lKey, rKey) < 0) {
                      var $temp$rKey = rKey, $temp$rValue = rValue, $temp$_v0 = _Utils_Tuple2(
                        rest,
                        A3(leftStep, lKey, lValue, result)
                      );
                      rKey = $temp$rKey;
                      rValue = $temp$rValue;
                      _v0 = $temp$_v0;
                      continue stepState;
                    } else {
                      if (_Utils_cmp(lKey, rKey) > 0) {
                        return _Utils_Tuple2(
                          list,
                          A3(rightStep, rKey, rValue, result)
                        );
                      } else {
                        return _Utils_Tuple2(
                          rest,
                          A4(bothStep, lKey, lValue, rValue, result)
                        );
                      }
                    }
                  }
                }
            }
          );
          var _v3 = A3(
            $elm$core$Dict$foldl,
            stepState,
            _Utils_Tuple2(
              $elm$core$Dict$toList(leftDict),
              initialResult
            ),
            rightDict
          );
          var leftovers = _v3.a;
          var intermediateResult = _v3.b;
          return A3(
            $elm$core$List$foldl,
            F2(
              function(_v4, result) {
                var k = _v4.a;
                var v = _v4.b;
                return A3(leftStep, k, v, result);
              }
            ),
            intermediateResult,
            leftovers
          );
        }
      );
      var $elm$time$Time$setInterval = _Time_setInterval;
      var $elm$core$Process$spawn = _Scheduler_spawn;
      var $elm$time$Time$spawnHelp = F3(
        function(router, intervals, processes) {
          if (!intervals.b) {
            return $elm$core$Task$succeed(processes);
          } else {
            var interval = intervals.a;
            var rest = intervals.b;
            var spawnTimer = $elm$core$Process$spawn(
              A2(
                $elm$time$Time$setInterval,
                interval,
                A2($elm$core$Platform$sendToSelf, router, interval)
              )
            );
            var spawnRest = function(id) {
              return A3(
                $elm$time$Time$spawnHelp,
                router,
                rest,
                A3($elm$core$Dict$insert, interval, id, processes)
              );
            };
            return A2($elm$core$Task$andThen, spawnRest, spawnTimer);
          }
        }
      );
      var $elm$time$Time$onEffects = F3(
        function(router, subs, _v0) {
          var processes = _v0.processes;
          var rightStep = F3(
            function(_v6, id, _v7) {
              var spawns = _v7.a;
              var existing = _v7.b;
              var kills = _v7.c;
              return _Utils_Tuple3(
                spawns,
                existing,
                A2(
                  $elm$core$Task$andThen,
                  function(_v5) {
                    return kills;
                  },
                  $elm$core$Process$kill(id)
                )
              );
            }
          );
          var newTaggers = A3($elm$core$List$foldl, $elm$time$Time$addMySub, $elm$core$Dict$empty, subs);
          var leftStep = F3(
            function(interval, taggers, _v4) {
              var spawns = _v4.a;
              var existing = _v4.b;
              var kills = _v4.c;
              return _Utils_Tuple3(
                A2($elm$core$List$cons, interval, spawns),
                existing,
                kills
              );
            }
          );
          var bothStep = F4(
            function(interval, taggers, id, _v3) {
              var spawns = _v3.a;
              var existing = _v3.b;
              var kills = _v3.c;
              return _Utils_Tuple3(
                spawns,
                A3($elm$core$Dict$insert, interval, id, existing),
                kills
              );
            }
          );
          var _v1 = A6(
            $elm$core$Dict$merge,
            leftStep,
            bothStep,
            rightStep,
            newTaggers,
            processes,
            _Utils_Tuple3(
              _List_Nil,
              $elm$core$Dict$empty,
              $elm$core$Task$succeed(_Utils_Tuple0)
            )
          );
          var spawnList = _v1.a;
          var existingDict = _v1.b;
          var killTask = _v1.c;
          return A2(
            $elm$core$Task$andThen,
            function(newProcesses) {
              return $elm$core$Task$succeed(
                A2($elm$time$Time$State, newTaggers, newProcesses)
              );
            },
            A2(
              $elm$core$Task$andThen,
              function(_v2) {
                return A3($elm$time$Time$spawnHelp, router, spawnList, existingDict);
              },
              killTask
            )
          );
        }
      );
      var $elm$time$Time$onSelfMsg = F3(
        function(router, interval, state) {
          var _v0 = A2($elm$core$Dict$get, interval, state.taggers);
          if (_v0.$ === "Nothing") {
            return $elm$core$Task$succeed(state);
          } else {
            var taggers = _v0.a;
            var tellTaggers = function(time) {
              return $elm$core$Task$sequence(
                A2(
                  $elm$core$List$map,
                  function(tagger) {
                    return A2(
                      $elm$core$Platform$sendToApp,
                      router,
                      tagger(time)
                    );
                  },
                  taggers
                )
              );
            };
            return A2(
              $elm$core$Task$andThen,
              function(_v1) {
                return $elm$core$Task$succeed(state);
              },
              A2($elm$core$Task$andThen, tellTaggers, $elm$time$Time$now)
            );
          }
        }
      );
      var $elm$time$Time$subMap = F2(
        function(f, _v0) {
          var interval = _v0.a;
          var tagger = _v0.b;
          return A2(
            $elm$time$Time$Every,
            interval,
            A2($elm$core$Basics$composeL, f, tagger)
          );
        }
      );
      _Platform_effectManagers["Time"] = _Platform_createManager($elm$time$Time$init, $elm$time$Time$onEffects, $elm$time$Time$onSelfMsg, 0, $elm$time$Time$subMap);
      var $elm$time$Time$subscription = _Platform_leaf("Time");
      var $elm$time$Time$every = F2(
        function(interval, tagger) {
          return $elm$time$Time$subscription(
            A2($elm$time$Time$Every, interval, tagger)
          );
        }
      );
      var $author$project$Brain$Ports$fromAlien = _Platform_incomingPort(
        "fromAlien",
        A2(
          $elm$json$Json$Decode$andThen,
          function(tag) {
            return A2(
              $elm$json$Json$Decode$andThen,
              function(error) {
                return A2(
                  $elm$json$Json$Decode$andThen,
                  function(data) {
                    return $elm$json$Json$Decode$succeed(
                      { data, error, tag }
                    );
                  },
                  A2($elm$json$Json$Decode$field, "data", $elm$json$Json$Decode$value)
                );
              },
              A2(
                $elm$json$Json$Decode$field,
                "error",
                $elm$json$Json$Decode$oneOf(
                  _List_fromArray(
                    [
                      $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                      A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$string)
                    ]
                  )
                )
              )
            );
          },
          A2($elm$json$Json$Decode$field, "tag", $elm$json$Json$Decode$string)
        )
      );
      var $author$project$Brain$Ports$makeArtworkTrackUrls = _Platform_incomingPort("makeArtworkTrackUrls", $elm$json$Json$Decode$value);
      var $author$project$Brain$Ports$receiveSearchResults = _Platform_incomingPort(
        "receiveSearchResults",
        $elm$json$Json$Decode$list($elm$json$Json$Decode$string)
      );
      var $author$project$Brain$Ports$receiveTags = _Platform_incomingPort(
        "receiveTags",
        A2(
          $elm$json$Json$Decode$andThen,
          function(urlsForTags) {
            return A2(
              $elm$json$Json$Decode$andThen,
              function(sourceId) {
                return A2(
                  $elm$json$Json$Decode$andThen,
                  function(receivedTags) {
                    return A2(
                      $elm$json$Json$Decode$andThen,
                      function(receivedFilePaths) {
                        return A2(
                          $elm$json$Json$Decode$andThen,
                          function(nextFilePaths) {
                            return A2(
                              $elm$json$Json$Decode$andThen,
                              function(amount) {
                                return $elm$json$Json$Decode$succeed(
                                  { amount, nextFilePaths, receivedFilePaths, receivedTags, sourceId, urlsForTags }
                                );
                              },
                              A2($elm$json$Json$Decode$field, "amount", $elm$json$Json$Decode$int)
                            );
                          },
                          A2(
                            $elm$json$Json$Decode$field,
                            "nextFilePaths",
                            $elm$json$Json$Decode$list($elm$json$Json$Decode$string)
                          )
                        );
                      },
                      A2(
                        $elm$json$Json$Decode$field,
                        "receivedFilePaths",
                        $elm$json$Json$Decode$list($elm$json$Json$Decode$string)
                      )
                    );
                  },
                  A2(
                    $elm$json$Json$Decode$field,
                    "receivedTags",
                    $elm$json$Json$Decode$list(
                      $elm$json$Json$Decode$oneOf(
                        _List_fromArray(
                          [
                            $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                            A2(
                              $elm$json$Json$Decode$map,
                              $elm$core$Maybe$Just,
                              A2(
                                $elm$json$Json$Decode$andThen,
                                function(year) {
                                  return A2(
                                    $elm$json$Json$Decode$andThen,
                                    function(title) {
                                      return A2(
                                        $elm$json$Json$Decode$andThen,
                                        function(picture) {
                                          return A2(
                                            $elm$json$Json$Decode$andThen,
                                            function(nr) {
                                              return A2(
                                                $elm$json$Json$Decode$andThen,
                                                function(genre) {
                                                  return A2(
                                                    $elm$json$Json$Decode$andThen,
                                                    function(disc) {
                                                      return A2(
                                                        $elm$json$Json$Decode$andThen,
                                                        function(artist) {
                                                          return A2(
                                                            $elm$json$Json$Decode$andThen,
                                                            function(album) {
                                                              return $elm$json$Json$Decode$succeed(
                                                                { album, artist, disc, genre, nr, picture, title, year }
                                                              );
                                                            },
                                                            A2($elm$json$Json$Decode$field, "album", $elm$json$Json$Decode$string)
                                                          );
                                                        },
                                                        A2($elm$json$Json$Decode$field, "artist", $elm$json$Json$Decode$string)
                                                      );
                                                    },
                                                    A2($elm$json$Json$Decode$field, "disc", $elm$json$Json$Decode$int)
                                                  );
                                                },
                                                A2(
                                                  $elm$json$Json$Decode$field,
                                                  "genre",
                                                  $elm$json$Json$Decode$oneOf(
                                                    _List_fromArray(
                                                      [
                                                        $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                                                        A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$string)
                                                      ]
                                                    )
                                                  )
                                                )
                                              );
                                            },
                                            A2($elm$json$Json$Decode$field, "nr", $elm$json$Json$Decode$int)
                                          );
                                        },
                                        A2(
                                          $elm$json$Json$Decode$field,
                                          "picture",
                                          $elm$json$Json$Decode$oneOf(
                                            _List_fromArray(
                                              [
                                                $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                                                A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$string)
                                              ]
                                            )
                                          )
                                        )
                                      );
                                    },
                                    A2($elm$json$Json$Decode$field, "title", $elm$json$Json$Decode$string)
                                  );
                                },
                                A2(
                                  $elm$json$Json$Decode$field,
                                  "year",
                                  $elm$json$Json$Decode$oneOf(
                                    _List_fromArray(
                                      [
                                        $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                                        A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$int)
                                      ]
                                    )
                                  )
                                )
                              )
                            )
                          ]
                        )
                      )
                    )
                  )
                );
              },
              A2($elm$json$Json$Decode$field, "sourceId", $elm$json$Json$Decode$string)
            );
          },
          A2(
            $elm$json$Json$Decode$field,
            "urlsForTags",
            $elm$json$Json$Decode$list(
              A2(
                $elm$json$Json$Decode$andThen,
                function(headUrl) {
                  return A2(
                    $elm$json$Json$Decode$andThen,
                    function(getUrl) {
                      return $elm$json$Json$Decode$succeed(
                        { getUrl, headUrl }
                      );
                    },
                    A2($elm$json$Json$Decode$field, "getUrl", $elm$json$Json$Decode$string)
                  );
                },
                A2($elm$json$Json$Decode$field, "headUrl", $elm$json$Json$Decode$string)
              )
            )
          )
        )
      );
      var $author$project$Brain$Ports$refreshedAccessToken = _Platform_incomingPort("refreshedAccessToken", $elm$json$Json$Decode$value);
      var $author$project$Brain$Ports$replaceTags = _Platform_incomingPort(
        "replaceTags",
        A2(
          $elm$json$Json$Decode$andThen,
          function(urlsForTags) {
            return A2(
              $elm$json$Json$Decode$andThen,
              function(trackIds) {
                return A2(
                  $elm$json$Json$Decode$andThen,
                  function(receivedTags) {
                    return A2(
                      $elm$json$Json$Decode$andThen,
                      function(receivedFilePaths) {
                        return $elm$json$Json$Decode$succeed(
                          { receivedFilePaths, receivedTags, trackIds, urlsForTags }
                        );
                      },
                      A2(
                        $elm$json$Json$Decode$field,
                        "receivedFilePaths",
                        $elm$json$Json$Decode$list($elm$json$Json$Decode$string)
                      )
                    );
                  },
                  A2(
                    $elm$json$Json$Decode$field,
                    "receivedTags",
                    $elm$json$Json$Decode$list(
                      $elm$json$Json$Decode$oneOf(
                        _List_fromArray(
                          [
                            $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                            A2(
                              $elm$json$Json$Decode$map,
                              $elm$core$Maybe$Just,
                              A2(
                                $elm$json$Json$Decode$andThen,
                                function(year) {
                                  return A2(
                                    $elm$json$Json$Decode$andThen,
                                    function(title) {
                                      return A2(
                                        $elm$json$Json$Decode$andThen,
                                        function(picture) {
                                          return A2(
                                            $elm$json$Json$Decode$andThen,
                                            function(nr) {
                                              return A2(
                                                $elm$json$Json$Decode$andThen,
                                                function(genre) {
                                                  return A2(
                                                    $elm$json$Json$Decode$andThen,
                                                    function(disc) {
                                                      return A2(
                                                        $elm$json$Json$Decode$andThen,
                                                        function(artist) {
                                                          return A2(
                                                            $elm$json$Json$Decode$andThen,
                                                            function(album) {
                                                              return $elm$json$Json$Decode$succeed(
                                                                { album, artist, disc, genre, nr, picture, title, year }
                                                              );
                                                            },
                                                            A2($elm$json$Json$Decode$field, "album", $elm$json$Json$Decode$string)
                                                          );
                                                        },
                                                        A2($elm$json$Json$Decode$field, "artist", $elm$json$Json$Decode$string)
                                                      );
                                                    },
                                                    A2($elm$json$Json$Decode$field, "disc", $elm$json$Json$Decode$int)
                                                  );
                                                },
                                                A2(
                                                  $elm$json$Json$Decode$field,
                                                  "genre",
                                                  $elm$json$Json$Decode$oneOf(
                                                    _List_fromArray(
                                                      [
                                                        $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                                                        A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$string)
                                                      ]
                                                    )
                                                  )
                                                )
                                              );
                                            },
                                            A2($elm$json$Json$Decode$field, "nr", $elm$json$Json$Decode$int)
                                          );
                                        },
                                        A2(
                                          $elm$json$Json$Decode$field,
                                          "picture",
                                          $elm$json$Json$Decode$oneOf(
                                            _List_fromArray(
                                              [
                                                $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                                                A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$string)
                                              ]
                                            )
                                          )
                                        )
                                      );
                                    },
                                    A2($elm$json$Json$Decode$field, "title", $elm$json$Json$Decode$string)
                                  );
                                },
                                A2(
                                  $elm$json$Json$Decode$field,
                                  "year",
                                  $elm$json$Json$Decode$oneOf(
                                    _List_fromArray(
                                      [
                                        $elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
                                        A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$int)
                                      ]
                                    )
                                  )
                                )
                              )
                            )
                          ]
                        )
                      )
                    )
                  )
                );
              },
              A2(
                $elm$json$Json$Decode$field,
                "trackIds",
                $elm$json$Json$Decode$list($elm$json$Json$Decode$string)
              )
            );
          },
          A2(
            $elm$json$Json$Decode$field,
            "urlsForTags",
            $elm$json$Json$Decode$list(
              A2(
                $elm$json$Json$Decode$andThen,
                function(headUrl) {
                  return A2(
                    $elm$json$Json$Decode$andThen,
                    function(getUrl) {
                      return $elm$json$Json$Decode$succeed(
                        { getUrl, headUrl }
                      );
                    },
                    A2($elm$json$Json$Decode$field, "getUrl", $elm$json$Json$Decode$string)
                  );
                },
                A2($elm$json$Json$Decode$field, "headUrl", $elm$json$Json$Decode$string)
              )
            )
          )
        )
      );
      var $author$project$Brain$subscriptions = function(_v0) {
        return $elm$core$Platform$Sub$batch(
          _List_fromArray(
            [
              $author$project$Brain$Ports$fromAlien($author$project$Brain$alien),
              $author$project$Brain$Ports$makeArtworkTrackUrls($author$project$Brain$Types$MakeArtworkTrackUrls),
              $author$project$Brain$Ports$refreshedAccessToken($author$project$Brain$Types$RefreshedAccessToken),
              $author$project$Brain$Ports$receiveSearchResults($author$project$Brain$Types$GotSearchResults),
              $author$project$Brain$Ports$receiveTags(
                A2($elm$core$Basics$composeL, $author$project$Brain$Types$ProcessingMsg, $author$project$Brain$Sources$Processing$Types$TagsStep)
              ),
              $author$project$Brain$Ports$replaceTags($author$project$Brain$Types$ReplaceTrackTags),
              A2($elm$time$Time$every, 60 * 1e3, $author$project$Brain$Types$SetCurrentTime)
            ]
          )
        );
      };
      var $author$project$Return$Ext$communicate = F2(
        function(c, m) {
          return _Utils_Tuple2(m, c);
        }
      );
      var $elm$core$String$concat = function(strings) {
        return A2($elm$core$String$join, "", strings);
      };
      var $author$project$Brain$Tracks$State$downloadParamsDecoder = A3(
        $elm$json$Json$Decode$map2,
        $elm$core$Tuple$pair,
        A2($elm$json$Json$Decode$field, "zipName", $elm$json$Json$Decode$string),
        A2(
          $elm$json$Json$Decode$field,
          "trackIds",
          $elm$json$Json$Decode$list($elm$json$Json$Decode$string)
        )
      );
      var $author$project$Brain$Ports$downloadTracks = _Platform_outgoingPort("downloadTracks", $elm$core$Basics$identity);
      var $elm_community$list_extra$List$Extra$find = F2(
        function(predicate, list) {
          find:
            while (true) {
              if (!list.b) {
                return $elm$core$Maybe$Nothing;
              } else {
                var first = list.a;
                var rest = list.b;
                if (predicate(first)) {
                  return $elm$core$Maybe$Just(first);
                } else {
                  var $temp$predicate = predicate, $temp$list = rest;
                  predicate = $temp$predicate;
                  list = $temp$list;
                  continue find;
                }
              }
            }
        }
      );
      var $author$project$Sources$Processing$Get = { $: "Get" };
      var $elm$core$List$append = F2(
        function(xs, ys) {
          if (!ys.b) {
            return xs;
          } else {
            return A3($elm$core$List$foldr, $elm$core$List$cons, ys, xs);
          }
        }
      );
      var $elm$core$String$append = _String_append;
      var $elm$core$Basics$negate = function(n) {
        return -n;
      };
      var $elm$core$String$dropRight = F2(
        function(n, string) {
          return n < 1 ? string : A3($elm$core$String$slice, 0, -n, string);
        }
      );
      var $elm$core$String$endsWith = _String_endsWith;
      var $author$project$String$Ext$chopEnd = F2(
        function(needle, str) {
          return A2($elm$core$String$endsWith, needle, str) ? A2(
            $author$project$String$Ext$chopEnd,
            needle,
            A2(
              $elm$core$String$dropRight,
              $elm$core$String$length(needle),
              str
            )
          ) : str;
        }
      );
      var $author$project$String$Ext$chopStart = F2(
        function(needle, str) {
          return A2($elm$core$String$startsWith, needle, str) ? A2(
            $author$project$String$Ext$chopStart,
            needle,
            A2(
              $elm$core$String$dropLeft,
              $elm$core$String$length(needle),
              str
            )
          ) : str;
        }
      );
      var $ryannhg$date_format$DateFormat$DayOfMonthFixed = { $: "DayOfMonthFixed" };
      var $ryannhg$date_format$DateFormat$dayOfMonthFixed = $ryannhg$date_format$DateFormat$DayOfMonthFixed;
      var $elm$regex$Regex$Match = F4(
        function(match, index, number, submatches) {
          return { index, match, number, submatches };
        }
      );
      var $elm$regex$Regex$fromStringWith = _Regex_fromStringWith;
      var $elm$regex$Regex$fromString = function(string) {
        return A2(
          $elm$regex$Regex$fromStringWith,
          { caseInsensitive: false, multiline: false },
          string
        );
      };
      var $elm$regex$Regex$never = _Regex_never;
      var $elm$regex$Regex$replace = _Regex_replaceAtMost(_Regex_infinity);
      var $elm$core$String$foldr = _String_foldr;
      var $elm$core$String$toList = function(string) {
        return A3($elm$core$String$foldr, $elm$core$List$cons, _List_Nil, string);
      };
      var $elm$core$String$fromList = _String_fromList;
      var $elm$core$Basics$modBy = _Basics_modBy;
      var $rtfeldman$elm_hex$Hex$unsafeToDigit = function(num) {
        unsafeToDigit:
          while (true) {
            switch (num) {
              case 0:
                return _Utils_chr("0");
              case 1:
                return _Utils_chr("1");
              case 2:
                return _Utils_chr("2");
              case 3:
                return _Utils_chr("3");
              case 4:
                return _Utils_chr("4");
              case 5:
                return _Utils_chr("5");
              case 6:
                return _Utils_chr("6");
              case 7:
                return _Utils_chr("7");
              case 8:
                return _Utils_chr("8");
              case 9:
                return _Utils_chr("9");
              case 10:
                return _Utils_chr("a");
              case 11:
                return _Utils_chr("b");
              case 12:
                return _Utils_chr("c");
              case 13:
                return _Utils_chr("d");
              case 14:
                return _Utils_chr("e");
              case 15:
                return _Utils_chr("f");
              default:
                var $temp$num = num;
                num = $temp$num;
                continue unsafeToDigit;
            }
          }
      };
      var $rtfeldman$elm_hex$Hex$unsafePositiveToDigits = F2(
        function(digits, num) {
          unsafePositiveToDigits:
            while (true) {
              if (num < 16) {
                return A2(
                  $elm$core$List$cons,
                  $rtfeldman$elm_hex$Hex$unsafeToDigit(num),
                  digits
                );
              } else {
                var $temp$digits = A2(
                  $elm$core$List$cons,
                  $rtfeldman$elm_hex$Hex$unsafeToDigit(
                    A2($elm$core$Basics$modBy, 16, num)
                  ),
                  digits
                ), $temp$num = num / 16 | 0;
                digits = $temp$digits;
                num = $temp$num;
                continue unsafePositiveToDigits;
              }
            }
        }
      );
      var $rtfeldman$elm_hex$Hex$toString = function(num) {
        return $elm$core$String$fromList(
          num < 0 ? A2(
            $elm$core$List$cons,
            _Utils_chr("-"),
            A2($rtfeldman$elm_hex$Hex$unsafePositiveToDigits, _List_Nil, -num)
          ) : A2($rtfeldman$elm_hex$Hex$unsafePositiveToDigits, _List_Nil, num)
        );
      };
      var $elm$core$String$toUpper = _String_toUpper;
      var $author$project$Sources$Services$AmazonS3$Presign$encodeAdditionalCharacters = function(query) {
        return A3(
          $elm$regex$Regex$replace,
          A2(
            $elm$core$Maybe$withDefault,
            $elm$regex$Regex$never,
            $elm$regex$Regex$fromString("[!*'()]")
          ),
          function(_v0) {
            var match = _v0.match;
            return $elm$core$String$concat(
              A2(
                $elm$core$List$map,
                A2(
                  $elm$core$Basics$composeR,
                  $elm$core$Char$toCode,
                  A2(
                    $elm$core$Basics$composeR,
                    $rtfeldman$elm_hex$Hex$toString,
                    A2(
                      $elm$core$Basics$composeR,
                      $elm$core$String$toUpper,
                      $elm$core$Basics$append("%")
                    )
                  )
                ),
                $elm$core$String$toList(match)
              )
            );
          },
          query
        );
      };
      var $author$project$Dict$Ext$fetch = F3(
        function(key, _default, dict) {
          return A2(
            $elm$core$Maybe$withDefault,
            _default,
            A2($elm$core$Dict$get, key, dict)
          );
        }
      );
      var $author$project$Dict$Ext$fetchUnknown = F2(
        function(key, dict) {
          return A3($author$project$Dict$Ext$fetch, key, "MISSING_VALUE", dict);
        }
      );
      var $ryannhg$date_format$DateFormat$Language$Language = F6(
        function(toMonthName, toMonthAbbreviation, toWeekdayName, toWeekdayAbbreviation, toAmPm, toOrdinalSuffix) {
          return { toAmPm, toMonthAbbreviation, toMonthName, toOrdinalSuffix, toWeekdayAbbreviation, toWeekdayName };
        }
      );
      var $ryannhg$date_format$DateFormat$Language$toEnglishAmPm = function(hour) {
        return hour > 11 ? "pm" : "am";
      };
      var $ryannhg$date_format$DateFormat$Language$toEnglishMonthName = function(month) {
        switch (month.$) {
          case "Jan":
            return "January";
          case "Feb":
            return "February";
          case "Mar":
            return "March";
          case "Apr":
            return "April";
          case "May":
            return "May";
          case "Jun":
            return "June";
          case "Jul":
            return "July";
          case "Aug":
            return "August";
          case "Sep":
            return "September";
          case "Oct":
            return "October";
          case "Nov":
            return "November";
          default:
            return "December";
        }
      };
      var $ryannhg$date_format$DateFormat$Language$toEnglishSuffix = function(num) {
        var _v0 = A2($elm$core$Basics$modBy, 100, num);
        switch (_v0) {
          case 11:
            return "th";
          case 12:
            return "th";
          case 13:
            return "th";
          default:
            var _v1 = A2($elm$core$Basics$modBy, 10, num);
            switch (_v1) {
              case 1:
                return "st";
              case 2:
                return "nd";
              case 3:
                return "rd";
              default:
                return "th";
            }
        }
      };
      var $ryannhg$date_format$DateFormat$Language$toEnglishWeekdayName = function(weekday) {
        switch (weekday.$) {
          case "Mon":
            return "Monday";
          case "Tue":
            return "Tuesday";
          case "Wed":
            return "Wednesday";
          case "Thu":
            return "Thursday";
          case "Fri":
            return "Friday";
          case "Sat":
            return "Saturday";
          default:
            return "Sunday";
        }
      };
      var $ryannhg$date_format$DateFormat$Language$english = A6(
        $ryannhg$date_format$DateFormat$Language$Language,
        $ryannhg$date_format$DateFormat$Language$toEnglishMonthName,
        A2(
          $elm$core$Basics$composeR,
          $ryannhg$date_format$DateFormat$Language$toEnglishMonthName,
          $elm$core$String$left(3)
        ),
        $ryannhg$date_format$DateFormat$Language$toEnglishWeekdayName,
        A2(
          $elm$core$Basics$composeR,
          $ryannhg$date_format$DateFormat$Language$toEnglishWeekdayName,
          $elm$core$String$left(3)
        ),
        $ryannhg$date_format$DateFormat$Language$toEnglishAmPm,
        $ryannhg$date_format$DateFormat$Language$toEnglishSuffix
      );
      var $elm$time$Time$flooredDiv = F2(
        function(numerator, denominator) {
          return $elm$core$Basics$floor(numerator / denominator);
        }
      );
      var $elm$time$Time$toAdjustedMinutesHelp = F3(
        function(defaultOffset, posixMinutes, eras) {
          toAdjustedMinutesHelp:
            while (true) {
              if (!eras.b) {
                return posixMinutes + defaultOffset;
              } else {
                var era = eras.a;
                var olderEras = eras.b;
                if (_Utils_cmp(era.start, posixMinutes) < 0) {
                  return posixMinutes + era.offset;
                } else {
                  var $temp$defaultOffset = defaultOffset, $temp$posixMinutes = posixMinutes, $temp$eras = olderEras;
                  defaultOffset = $temp$defaultOffset;
                  posixMinutes = $temp$posixMinutes;
                  eras = $temp$eras;
                  continue toAdjustedMinutesHelp;
                }
              }
            }
        }
      );
      var $elm$time$Time$toAdjustedMinutes = F2(
        function(_v0, time) {
          var defaultOffset = _v0.a;
          var eras = _v0.b;
          return A3(
            $elm$time$Time$toAdjustedMinutesHelp,
            defaultOffset,
            A2(
              $elm$time$Time$flooredDiv,
              $elm$time$Time$posixToMillis(time),
              6e4
            ),
            eras
          );
        }
      );
      var $elm$time$Time$toHour = F2(
        function(zone, time) {
          return A2(
            $elm$core$Basics$modBy,
            24,
            A2(
              $elm$time$Time$flooredDiv,
              A2($elm$time$Time$toAdjustedMinutes, zone, time),
              60
            )
          );
        }
      );
      var $ryannhg$date_format$DateFormat$amPm = F3(
        function(language, zone, posix) {
          return language.toAmPm(
            A2($elm$time$Time$toHour, zone, posix)
          );
        }
      );
      var $elm$core$Basics$ge = _Utils_ge;
      var $elm$time$Time$toCivil = function(minutes) {
        var rawDay = A2($elm$time$Time$flooredDiv, minutes, 60 * 24) + 719468;
        var era = (rawDay >= 0 ? rawDay : rawDay - 146096) / 146097 | 0;
        var dayOfEra = rawDay - era * 146097;
        var yearOfEra = (dayOfEra - (dayOfEra / 1460 | 0) + (dayOfEra / 36524 | 0) - (dayOfEra / 146096 | 0)) / 365 | 0;
        var dayOfYear = dayOfEra - (365 * yearOfEra + (yearOfEra / 4 | 0) - (yearOfEra / 100 | 0));
        var mp = (5 * dayOfYear + 2) / 153 | 0;
        var month = mp + (mp < 10 ? 3 : -9);
        var year = yearOfEra + era * 400;
        return {
          day: dayOfYear - ((153 * mp + 2) / 5 | 0) + 1,
          month,
          year: year + (month <= 2 ? 1 : 0)
        };
      };
      var $elm$time$Time$toDay = F2(
        function(zone, time) {
          return $elm$time$Time$toCivil(
            A2($elm$time$Time$toAdjustedMinutes, zone, time)
          ).day;
        }
      );
      var $ryannhg$date_format$DateFormat$dayOfMonth = $elm$time$Time$toDay;
      var $elm$time$Time$Sun = { $: "Sun" };
      var $elm$time$Time$Fri = { $: "Fri" };
      var $elm$time$Time$Mon = { $: "Mon" };
      var $elm$time$Time$Sat = { $: "Sat" };
      var $elm$time$Time$Thu = { $: "Thu" };
      var $elm$time$Time$Tue = { $: "Tue" };
      var $elm$time$Time$Wed = { $: "Wed" };
      var $ryannhg$date_format$DateFormat$days = _List_fromArray(
        [$elm$time$Time$Sun, $elm$time$Time$Mon, $elm$time$Time$Tue, $elm$time$Time$Wed, $elm$time$Time$Thu, $elm$time$Time$Fri, $elm$time$Time$Sat]
      );
      var $elm$time$Time$toWeekday = F2(
        function(zone, time) {
          var _v0 = A2(
            $elm$core$Basics$modBy,
            7,
            A2(
              $elm$time$Time$flooredDiv,
              A2($elm$time$Time$toAdjustedMinutes, zone, time),
              60 * 24
            )
          );
          switch (_v0) {
            case 0:
              return $elm$time$Time$Thu;
            case 1:
              return $elm$time$Time$Fri;
            case 2:
              return $elm$time$Time$Sat;
            case 3:
              return $elm$time$Time$Sun;
            case 4:
              return $elm$time$Time$Mon;
            case 5:
              return $elm$time$Time$Tue;
            default:
              return $elm$time$Time$Wed;
          }
        }
      );
      var $ryannhg$date_format$DateFormat$dayOfWeek = F2(
        function(zone, posix) {
          return function(_v1) {
            var i = _v1.a;
            return i;
          }(
            A2(
              $elm$core$Maybe$withDefault,
              _Utils_Tuple2(0, $elm$time$Time$Sun),
              $elm$core$List$head(
                A2(
                  $elm$core$List$filter,
                  function(_v0) {
                    var day = _v0.b;
                    return _Utils_eq(
                      day,
                      A2($elm$time$Time$toWeekday, zone, posix)
                    );
                  },
                  A2(
                    $elm$core$List$indexedMap,
                    F2(
                      function(i, day) {
                        return _Utils_Tuple2(i, day);
                      }
                    ),
                    $ryannhg$date_format$DateFormat$days
                  )
                )
              )
            )
          );
        }
      );
      var $elm$core$Basics$neq = _Utils_notEqual;
      var $ryannhg$date_format$DateFormat$isLeapYear = function(year_) {
        return !!A2($elm$core$Basics$modBy, 4, year_) ? false : !!A2($elm$core$Basics$modBy, 100, year_) ? true : !!A2($elm$core$Basics$modBy, 400, year_) ? false : true;
      };
      var $ryannhg$date_format$DateFormat$daysInMonth = F2(
        function(year_, month) {
          switch (month.$) {
            case "Jan":
              return 31;
            case "Feb":
              return $ryannhg$date_format$DateFormat$isLeapYear(year_) ? 29 : 28;
            case "Mar":
              return 31;
            case "Apr":
              return 30;
            case "May":
              return 31;
            case "Jun":
              return 30;
            case "Jul":
              return 31;
            case "Aug":
              return 31;
            case "Sep":
              return 30;
            case "Oct":
              return 31;
            case "Nov":
              return 30;
            default:
              return 31;
          }
        }
      );
      var $elm$time$Time$Jan = { $: "Jan" };
      var $elm$time$Time$Apr = { $: "Apr" };
      var $elm$time$Time$Aug = { $: "Aug" };
      var $elm$time$Time$Dec = { $: "Dec" };
      var $elm$time$Time$Feb = { $: "Feb" };
      var $elm$time$Time$Jul = { $: "Jul" };
      var $elm$time$Time$Jun = { $: "Jun" };
      var $elm$time$Time$Mar = { $: "Mar" };
      var $elm$time$Time$May = { $: "May" };
      var $elm$time$Time$Nov = { $: "Nov" };
      var $elm$time$Time$Oct = { $: "Oct" };
      var $elm$time$Time$Sep = { $: "Sep" };
      var $ryannhg$date_format$DateFormat$months = _List_fromArray(
        [$elm$time$Time$Jan, $elm$time$Time$Feb, $elm$time$Time$Mar, $elm$time$Time$Apr, $elm$time$Time$May, $elm$time$Time$Jun, $elm$time$Time$Jul, $elm$time$Time$Aug, $elm$time$Time$Sep, $elm$time$Time$Oct, $elm$time$Time$Nov, $elm$time$Time$Dec]
      );
      var $elm$time$Time$toMonth = F2(
        function(zone, time) {
          var _v0 = $elm$time$Time$toCivil(
            A2($elm$time$Time$toAdjustedMinutes, zone, time)
          ).month;
          switch (_v0) {
            case 1:
              return $elm$time$Time$Jan;
            case 2:
              return $elm$time$Time$Feb;
            case 3:
              return $elm$time$Time$Mar;
            case 4:
              return $elm$time$Time$Apr;
            case 5:
              return $elm$time$Time$May;
            case 6:
              return $elm$time$Time$Jun;
            case 7:
              return $elm$time$Time$Jul;
            case 8:
              return $elm$time$Time$Aug;
            case 9:
              return $elm$time$Time$Sep;
            case 10:
              return $elm$time$Time$Oct;
            case 11:
              return $elm$time$Time$Nov;
            default:
              return $elm$time$Time$Dec;
          }
        }
      );
      var $ryannhg$date_format$DateFormat$monthPair = F2(
        function(zone, posix) {
          return A2(
            $elm$core$Maybe$withDefault,
            _Utils_Tuple2(0, $elm$time$Time$Jan),
            $elm$core$List$head(
              A2(
                $elm$core$List$filter,
                function(_v0) {
                  var i = _v0.a;
                  var m = _v0.b;
                  return _Utils_eq(
                    m,
                    A2($elm$time$Time$toMonth, zone, posix)
                  );
                },
                A2(
                  $elm$core$List$indexedMap,
                  F2(
                    function(a, b) {
                      return _Utils_Tuple2(a, b);
                    }
                  ),
                  $ryannhg$date_format$DateFormat$months
                )
              )
            )
          );
        }
      );
      var $ryannhg$date_format$DateFormat$monthNumber_ = F2(
        function(zone, posix) {
          return 1 + function(_v0) {
            var i = _v0.a;
            var m = _v0.b;
            return i;
          }(
            A2($ryannhg$date_format$DateFormat$monthPair, zone, posix)
          );
        }
      );
      var $elm$core$List$sum = function(numbers) {
        return A3($elm$core$List$foldl, $elm$core$Basics$add, 0, numbers);
      };
      var $elm$core$List$takeReverse = F3(
        function(n, list, kept) {
          takeReverse:
            while (true) {
              if (n <= 0) {
                return kept;
              } else {
                if (!list.b) {
                  return kept;
                } else {
                  var x = list.a;
                  var xs = list.b;
                  var $temp$n = n - 1, $temp$list = xs, $temp$kept = A2($elm$core$List$cons, x, kept);
                  n = $temp$n;
                  list = $temp$list;
                  kept = $temp$kept;
                  continue takeReverse;
                }
              }
            }
        }
      );
      var $elm$core$List$takeTailRec = F2(
        function(n, list) {
          return $elm$core$List$reverse(
            A3($elm$core$List$takeReverse, n, list, _List_Nil)
          );
        }
      );
      var $elm$core$List$takeFast = F3(
        function(ctr, n, list) {
          if (n <= 0) {
            return _List_Nil;
          } else {
            var _v0 = _Utils_Tuple2(n, list);
            _v0$1:
              while (true) {
                _v0$5:
                  while (true) {
                    if (!_v0.b.b) {
                      return list;
                    } else {
                      if (_v0.b.b.b) {
                        switch (_v0.a) {
                          case 1:
                            break _v0$1;
                          case 2:
                            var _v2 = _v0.b;
                            var x = _v2.a;
                            var _v3 = _v2.b;
                            var y = _v3.a;
                            return _List_fromArray(
                              [x, y]
                            );
                          case 3:
                            if (_v0.b.b.b.b) {
                              var _v4 = _v0.b;
                              var x = _v4.a;
                              var _v5 = _v4.b;
                              var y = _v5.a;
                              var _v6 = _v5.b;
                              var z = _v6.a;
                              return _List_fromArray(
                                [x, y, z]
                              );
                            } else {
                              break _v0$5;
                            }
                          default:
                            if (_v0.b.b.b.b && _v0.b.b.b.b.b) {
                              var _v7 = _v0.b;
                              var x = _v7.a;
                              var _v8 = _v7.b;
                              var y = _v8.a;
                              var _v9 = _v8.b;
                              var z = _v9.a;
                              var _v10 = _v9.b;
                              var w = _v10.a;
                              var tl = _v10.b;
                              return ctr > 1e3 ? A2(
                                $elm$core$List$cons,
                                x,
                                A2(
                                  $elm$core$List$cons,
                                  y,
                                  A2(
                                    $elm$core$List$cons,
                                    z,
                                    A2(
                                      $elm$core$List$cons,
                                      w,
                                      A2($elm$core$List$takeTailRec, n - 4, tl)
                                    )
                                  )
                                )
                              ) : A2(
                                $elm$core$List$cons,
                                x,
                                A2(
                                  $elm$core$List$cons,
                                  y,
                                  A2(
                                    $elm$core$List$cons,
                                    z,
                                    A2(
                                      $elm$core$List$cons,
                                      w,
                                      A3($elm$core$List$takeFast, ctr + 1, n - 4, tl)
                                    )
                                  )
                                )
                              );
                            } else {
                              break _v0$5;
                            }
                        }
                      } else {
                        if (_v0.a === 1) {
                          break _v0$1;
                        } else {
                          break _v0$5;
                        }
                      }
                    }
                  }
                return list;
              }
            var _v1 = _v0.b;
            var x = _v1.a;
            return _List_fromArray(
              [x]
            );
          }
        }
      );
      var $elm$core$List$take = F2(
        function(n, list) {
          return A3($elm$core$List$takeFast, 0, n, list);
        }
      );
      var $elm$time$Time$toYear = F2(
        function(zone, time) {
          return $elm$time$Time$toCivil(
            A2($elm$time$Time$toAdjustedMinutes, zone, time)
          ).year;
        }
      );
      var $ryannhg$date_format$DateFormat$dayOfYear = F2(
        function(zone, posix) {
          var monthsBeforeThisOne = A2(
            $elm$core$List$take,
            A2($ryannhg$date_format$DateFormat$monthNumber_, zone, posix) - 1,
            $ryannhg$date_format$DateFormat$months
          );
          var daysBeforeThisMonth = $elm$core$List$sum(
            A2(
              $elm$core$List$map,
              $ryannhg$date_format$DateFormat$daysInMonth(
                A2($elm$time$Time$toYear, zone, posix)
              ),
              monthsBeforeThisOne
            )
          );
          return daysBeforeThisMonth + A2($ryannhg$date_format$DateFormat$dayOfMonth, zone, posix);
        }
      );
      var $ryannhg$date_format$DateFormat$quarter = F2(
        function(zone, posix) {
          return A2($ryannhg$date_format$DateFormat$monthNumber_, zone, posix) / 4 | 0;
        }
      );
      var $elm$core$String$right = F2(
        function(n, string) {
          return n < 1 ? "" : A3(
            $elm$core$String$slice,
            -n,
            $elm$core$String$length(string),
            string
          );
        }
      );
      var $ryannhg$date_format$DateFormat$toFixedLength = F2(
        function(totalChars, num) {
          var numStr = $elm$core$String$fromInt(num);
          var numZerosNeeded = totalChars - $elm$core$String$length(numStr);
          var zeros = A2(
            $elm$core$String$join,
            "",
            A2(
              $elm$core$List$map,
              function(_v0) {
                return "0";
              },
              A2($elm$core$List$range, 1, numZerosNeeded)
            )
          );
          return _Utils_ap(zeros, numStr);
        }
      );
      var $elm$core$String$toLower = _String_toLower;
      var $elm$time$Time$toMillis = F2(
        function(_v0, time) {
          return A2(
            $elm$core$Basics$modBy,
            1e3,
            $elm$time$Time$posixToMillis(time)
          );
        }
      );
      var $elm$time$Time$toMinute = F2(
        function(zone, time) {
          return A2(
            $elm$core$Basics$modBy,
            60,
            A2($elm$time$Time$toAdjustedMinutes, zone, time)
          );
        }
      );
      var $ryannhg$date_format$DateFormat$toNonMilitary = function(num) {
        return !num ? 12 : num <= 12 ? num : num - 12;
      };
      var $elm$time$Time$toSecond = F2(
        function(_v0, time) {
          return A2(
            $elm$core$Basics$modBy,
            60,
            A2(
              $elm$time$Time$flooredDiv,
              $elm$time$Time$posixToMillis(time),
              1e3
            )
          );
        }
      );
      var $ryannhg$date_format$DateFormat$millisecondsPerYear = $elm$core$Basics$round(1e3 * 60 * 60 * 24 * 365.25);
      var $ryannhg$date_format$DateFormat$firstDayOfYear = F2(
        function(zone, time) {
          return $elm$time$Time$millisToPosix(
            $ryannhg$date_format$DateFormat$millisecondsPerYear * A2($elm$time$Time$toYear, zone, time)
          );
        }
      );
      var $ryannhg$date_format$DateFormat$weekOfYear = F2(
        function(zone, posix) {
          var firstDay = A2($ryannhg$date_format$DateFormat$firstDayOfYear, zone, posix);
          var firstDayOffset = A2($ryannhg$date_format$DateFormat$dayOfWeek, zone, firstDay);
          var daysSoFar = A2($ryannhg$date_format$DateFormat$dayOfYear, zone, posix);
          return ((daysSoFar + firstDayOffset) / 7 | 0) + 1;
        }
      );
      var $ryannhg$date_format$DateFormat$year = F2(
        function(zone, time) {
          return $elm$core$String$fromInt(
            A2($elm$time$Time$toYear, zone, time)
          );
        }
      );
      var $ryannhg$date_format$DateFormat$piece = F4(
        function(language, zone, posix, token) {
          switch (token.$) {
            case "MonthNumber":
              return $elm$core$String$fromInt(
                A2($ryannhg$date_format$DateFormat$monthNumber_, zone, posix)
              );
            case "MonthSuffix":
              return function(num) {
                return _Utils_ap(
                  $elm$core$String$fromInt(num),
                  language.toOrdinalSuffix(num)
                );
              }(
                A2($ryannhg$date_format$DateFormat$monthNumber_, zone, posix)
              );
            case "MonthFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                A2($ryannhg$date_format$DateFormat$monthNumber_, zone, posix)
              );
            case "MonthNameAbbreviated":
              return language.toMonthAbbreviation(
                A2($elm$time$Time$toMonth, zone, posix)
              );
            case "MonthNameFull":
              return language.toMonthName(
                A2($elm$time$Time$toMonth, zone, posix)
              );
            case "QuarterNumber":
              return $elm$core$String$fromInt(
                1 + A2($ryannhg$date_format$DateFormat$quarter, zone, posix)
              );
            case "QuarterSuffix":
              return function(num) {
                return _Utils_ap(
                  $elm$core$String$fromInt(num),
                  language.toOrdinalSuffix(num)
                );
              }(
                1 + A2($ryannhg$date_format$DateFormat$quarter, zone, posix)
              );
            case "DayOfMonthNumber":
              return $elm$core$String$fromInt(
                A2($ryannhg$date_format$DateFormat$dayOfMonth, zone, posix)
              );
            case "DayOfMonthSuffix":
              return function(num) {
                return _Utils_ap(
                  $elm$core$String$fromInt(num),
                  language.toOrdinalSuffix(num)
                );
              }(
                A2($ryannhg$date_format$DateFormat$dayOfMonth, zone, posix)
              );
            case "DayOfMonthFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                A2($ryannhg$date_format$DateFormat$dayOfMonth, zone, posix)
              );
            case "DayOfYearNumber":
              return $elm$core$String$fromInt(
                A2($ryannhg$date_format$DateFormat$dayOfYear, zone, posix)
              );
            case "DayOfYearSuffix":
              return function(num) {
                return _Utils_ap(
                  $elm$core$String$fromInt(num),
                  language.toOrdinalSuffix(num)
                );
              }(
                A2($ryannhg$date_format$DateFormat$dayOfYear, zone, posix)
              );
            case "DayOfYearFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                3,
                A2($ryannhg$date_format$DateFormat$dayOfYear, zone, posix)
              );
            case "DayOfWeekNumber":
              return $elm$core$String$fromInt(
                A2($ryannhg$date_format$DateFormat$dayOfWeek, zone, posix)
              );
            case "DayOfWeekSuffix":
              return function(num) {
                return _Utils_ap(
                  $elm$core$String$fromInt(num),
                  language.toOrdinalSuffix(num)
                );
              }(
                A2($ryannhg$date_format$DateFormat$dayOfWeek, zone, posix)
              );
            case "DayOfWeekNameAbbreviated":
              return language.toWeekdayAbbreviation(
                A2($elm$time$Time$toWeekday, zone, posix)
              );
            case "DayOfWeekNameFull":
              return language.toWeekdayName(
                A2($elm$time$Time$toWeekday, zone, posix)
              );
            case "WeekOfYearNumber":
              return $elm$core$String$fromInt(
                A2($ryannhg$date_format$DateFormat$weekOfYear, zone, posix)
              );
            case "WeekOfYearSuffix":
              return function(num) {
                return _Utils_ap(
                  $elm$core$String$fromInt(num),
                  language.toOrdinalSuffix(num)
                );
              }(
                A2($ryannhg$date_format$DateFormat$weekOfYear, zone, posix)
              );
            case "WeekOfYearFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                A2($ryannhg$date_format$DateFormat$weekOfYear, zone, posix)
              );
            case "YearNumberLastTwo":
              return A2(
                $elm$core$String$right,
                2,
                A2($ryannhg$date_format$DateFormat$year, zone, posix)
              );
            case "YearNumber":
              return A2($ryannhg$date_format$DateFormat$year, zone, posix);
            case "AmPmUppercase":
              return $elm$core$String$toUpper(
                A3($ryannhg$date_format$DateFormat$amPm, language, zone, posix)
              );
            case "AmPmLowercase":
              return $elm$core$String$toLower(
                A3($ryannhg$date_format$DateFormat$amPm, language, zone, posix)
              );
            case "HourMilitaryNumber":
              return $elm$core$String$fromInt(
                A2($elm$time$Time$toHour, zone, posix)
              );
            case "HourMilitaryFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                A2($elm$time$Time$toHour, zone, posix)
              );
            case "HourNumber":
              return $elm$core$String$fromInt(
                $ryannhg$date_format$DateFormat$toNonMilitary(
                  A2($elm$time$Time$toHour, zone, posix)
                )
              );
            case "HourFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                $ryannhg$date_format$DateFormat$toNonMilitary(
                  A2($elm$time$Time$toHour, zone, posix)
                )
              );
            case "HourMilitaryFromOneNumber":
              return $elm$core$String$fromInt(
                1 + A2($elm$time$Time$toHour, zone, posix)
              );
            case "HourMilitaryFromOneFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                1 + A2($elm$time$Time$toHour, zone, posix)
              );
            case "MinuteNumber":
              return $elm$core$String$fromInt(
                A2($elm$time$Time$toMinute, zone, posix)
              );
            case "MinuteFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                A2($elm$time$Time$toMinute, zone, posix)
              );
            case "SecondNumber":
              return $elm$core$String$fromInt(
                A2($elm$time$Time$toSecond, zone, posix)
              );
            case "SecondFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                2,
                A2($elm$time$Time$toSecond, zone, posix)
              );
            case "MillisecondNumber":
              return $elm$core$String$fromInt(
                A2($elm$time$Time$toMillis, zone, posix)
              );
            case "MillisecondFixed":
              return A2(
                $ryannhg$date_format$DateFormat$toFixedLength,
                3,
                A2($elm$time$Time$toMillis, zone, posix)
              );
            default:
              var string = token.a;
              return string;
          }
        }
      );
      var $ryannhg$date_format$DateFormat$formatWithLanguage = F4(
        function(language, tokens, zone, time) {
          return A2(
            $elm$core$String$join,
            "",
            A2(
              $elm$core$List$map,
              A3($ryannhg$date_format$DateFormat$piece, language, zone, time),
              tokens
            )
          );
        }
      );
      var $ryannhg$date_format$DateFormat$format = $ryannhg$date_format$DateFormat$formatWithLanguage($ryannhg$date_format$DateFormat$Language$english);
      var $elm$core$List$concat = function(lists) {
        return A3($elm$core$List$foldr, $elm$core$List$append, _List_Nil, lists);
      };
      var $elm$core$List$concatMap = F2(
        function(f, list) {
          return $elm$core$List$concat(
            A2($elm$core$List$map, f, list)
          );
        }
      );
      var $icidasset$elm_binary$Binary$Bits = function(a) {
        return { $: "Bits", a };
      };
      var $icidasset$elm_binary$Binary$ifThenElse = F3(
        function(bool, a, b) {
          return bool ? a : b;
        }
      );
      var $icidasset$elm_binary$Binary$fromIntegers = A2(
        $elm$core$Basics$composeR,
        $elm$core$List$map(
          function(i) {
            return A3($icidasset$elm_binary$Binary$ifThenElse, i <= 0, false, true);
          }
        ),
        $icidasset$elm_binary$Binary$Bits
      );
      var $elm$core$List$drop = F2(
        function(n, list) {
          drop:
            while (true) {
              if (n <= 0) {
                return list;
              } else {
                if (!list.b) {
                  return list;
                } else {
                  var x = list.a;
                  var xs = list.b;
                  var $temp$n = n - 1, $temp$list = xs;
                  n = $temp$n;
                  list = $temp$list;
                  continue drop;
                }
              }
            }
        }
      );
      var $elm$core$List$repeatHelp = F3(
        function(result, n, value) {
          repeatHelp:
            while (true) {
              if (n <= 0) {
                return result;
              } else {
                var $temp$result = A2($elm$core$List$cons, value, result), $temp$n = n - 1, $temp$value = value;
                result = $temp$result;
                n = $temp$n;
                value = $temp$value;
                continue repeatHelp;
              }
            }
        }
      );
      var $elm$core$List$repeat = F2(
        function(n, value) {
          return A3($elm$core$List$repeatHelp, _List_Nil, n, value);
        }
      );
      var $icidasset$elm_binary$Binary$ensureSize = F2(
        function(size, _v0) {
          var bits = _v0.a;
          var currentLength = $elm$core$List$length(bits);
          return _Utils_eq(currentLength, size) ? $icidasset$elm_binary$Binary$Bits(bits) : _Utils_cmp(currentLength, size) > 0 ? $icidasset$elm_binary$Binary$Bits(
            A2($elm$core$List$drop, currentLength - size, bits)
          ) : $icidasset$elm_binary$Binary$Bits(
            _Utils_ap(
              A2($elm$core$List$repeat, size - currentLength, false),
              bits
            )
          );
        }
      );
      var $icidasset$elm_binary$Binary$fromDecimal_ = F2(
        function(acc, n) {
          fromDecimal_:
            while (true) {
              var _v0 = _Utils_Tuple2(n / 2 | 0, n % 2);
              var x = _v0.a;
              var bit = _v0.b;
              var bits = A2(
                $elm$core$List$cons,
                A2($elm$core$Basics$modBy, 2, bit),
                acc
              );
              if (x > 0) {
                var $temp$acc = bits, $temp$n = x;
                acc = $temp$acc;
                n = $temp$n;
                continue fromDecimal_;
              } else {
                return bits;
              }
            }
        }
      );
      var $icidasset$elm_binary$Binary$fromDecimal = A2(
        $elm$core$Basics$composeR,
        $icidasset$elm_binary$Binary$fromDecimal_(_List_Nil),
        $icidasset$elm_binary$Binary$fromIntegers
      );
      var $icidasset$elm_binary$Binary$toIntegers = function(_v0) {
        var bits = _v0.a;
        return A2(
          $elm$core$List$map,
          function(b) {
            return A3($icidasset$elm_binary$Binary$ifThenElse, b, 1, 0);
          },
          bits
        );
      };
      var $elm_community$list_extra$List$Extra$splitAt = F2(
        function(n, xs) {
          return _Utils_Tuple2(
            A2($elm$core$List$take, n, xs),
            A2($elm$core$List$drop, n, xs)
          );
        }
      );
      var $icidasset$elm_binary$Binary$unicodeCharToUtf8Bits_ = F2(
        function(startingBits, codepoint) {
          return A3(
            $elm$core$List$foldr,
            F2(
              function(start, _v0) {
                var all = _v0.a;
                var acc = _v0.b;
                var takeAway = 8 - $elm$core$List$length(start);
                var _v1 = A2($elm_community$list_extra$List$Extra$splitAt, takeAway, acc);
                var end = _v1.a;
                var rest = _v1.b;
                return _Utils_Tuple2(
                  _Utils_ap(
                    start,
                    _Utils_ap(
                      $elm$core$List$reverse(end),
                      all
                    )
                  ),
                  rest
                );
              }
            ),
            _Utils_Tuple2(
              _List_Nil,
              $elm$core$List$reverse(
                $icidasset$elm_binary$Binary$toIntegers(
                  A2(
                    $icidasset$elm_binary$Binary$ensureSize,
                    8 * $elm$core$List$length(startingBits),
                    $icidasset$elm_binary$Binary$fromDecimal(codepoint)
                  )
                )
              )
            ),
            startingBits
          ).a;
        }
      );
      var $icidasset$elm_binary$Binary$unicodeCharToUtf8Bits = function(_char) {
        var codepoint = $elm$core$Char$toCode(_char);
        return codepoint < 128 ? $icidasset$elm_binary$Binary$toIntegers(
          A2(
            $icidasset$elm_binary$Binary$ensureSize,
            8,
            $icidasset$elm_binary$Binary$fromDecimal(codepoint)
          )
        ) : codepoint < 2048 ? A2(
          $icidasset$elm_binary$Binary$unicodeCharToUtf8Bits_,
          _List_fromArray(
            [
              _List_fromArray(
                [1, 1, 0]
              ),
              _List_fromArray(
                [1, 0]
              )
            ]
          ),
          codepoint
        ) : codepoint < 65536 ? A2(
          $icidasset$elm_binary$Binary$unicodeCharToUtf8Bits_,
          _List_fromArray(
            [
              _List_fromArray(
                [1, 1, 1, 0]
              ),
              _List_fromArray(
                [1, 0]
              ),
              _List_fromArray(
                [1, 0]
              )
            ]
          ),
          codepoint
        ) : A2(
          $icidasset$elm_binary$Binary$unicodeCharToUtf8Bits_,
          _List_fromArray(
            [
              _List_fromArray(
                [1, 1, 1, 1, 0]
              ),
              _List_fromArray(
                [1, 0]
              ),
              _List_fromArray(
                [1, 0]
              ),
              _List_fromArray(
                [1, 0]
              )
            ]
          ),
          codepoint
        );
      };
      var $icidasset$elm_binary$Binary$fromStringAsUtf8 = function(string) {
        return $icidasset$elm_binary$Binary$fromIntegers(
          A2(
            $elm$core$List$concatMap,
            $icidasset$elm_binary$Binary$unicodeCharToUtf8Bits,
            $elm$core$String$toList(string)
          )
        );
      };
      var $icidasset$elm_binary$Binary$append = F2(
        function(_v0, _v1) {
          var a = _v0.a;
          var b = _v1.a;
          return $icidasset$elm_binary$Binary$Bits(
            A2($elm$core$List$append, a, b)
          );
        }
      );
      var $icidasset$elm_binary$Binary$concatMap = function(fn) {
        return A2(
          $elm$core$List$foldr,
          function(a) {
            return $elm$core$List$append(
              fn(a)
            );
          },
          _List_Nil
        );
      };
      var $icidasset$elm_binary$Binary$unwrap = function(_v0) {
        var bits = _v0.a;
        return bits;
      };
      var $icidasset$elm_binary$Binary$fromString_ = F2(
        function(amountOfBitsPerCharacter, _char) {
          return $icidasset$elm_binary$Binary$unwrap(
            A2(
              $icidasset$elm_binary$Binary$ensureSize,
              amountOfBitsPerCharacter,
              $icidasset$elm_binary$Binary$fromDecimal(
                $elm$core$Char$toCode(_char)
              )
            )
          );
        }
      );
      var $icidasset$elm_binary$Binary$fromString = F2(
        function(amountOfBitsPerCharacter, string) {
          return $icidasset$elm_binary$Binary$Bits(
            A2(
              $icidasset$elm_binary$Binary$concatMap,
              $icidasset$elm_binary$Binary$fromString_(amountOfBitsPerCharacter),
              $elm$core$String$toList(string)
            )
          );
        }
      );
      var $elm$core$Tuple$mapBoth = F3(
        function(funcA, funcB, _v0) {
          var x = _v0.a;
          var y = _v0.b;
          return _Utils_Tuple2(
            funcA(x),
            funcB(y)
          );
        }
      );
      var $icidasset$elm_binary$Binary$fromBooleans = $icidasset$elm_binary$Binary$Bits;
      var $icidasset$elm_binary$Binary$toBooleans = function(_v0) {
        var bits = _v0.a;
        return bits;
      };
      var $icidasset$elm_binary$Binary$width = function(_v0) {
        var bits = _v0.a;
        return $elm$core$List$length(bits);
      };
      var $author$project$Cryptography$Hmac$padRight = F2(
        function(_int, bits) {
          var size = $icidasset$elm_binary$Binary$width(bits);
          return $icidasset$elm_binary$Binary$fromBooleans(
            A2(
              $elm$core$List$append,
              $icidasset$elm_binary$Binary$toBooleans(bits),
              A2($elm$core$List$repeat, _int - size, false)
            )
          );
        }
      );
      var $icidasset$elm_binary$Binary$concat = A2(
        $elm$core$Basics$composeR,
        $icidasset$elm_binary$Binary$concatMap($icidasset$elm_binary$Binary$unwrap),
        $icidasset$elm_binary$Binary$Bits
      );
      var $elm$core$Char$toUpper = _Char_toUpper;
      var $icidasset$elm_binary$Binary$hexCharToBinary = function(_char) {
        var _v0 = $elm$core$Char$toUpper(_char);
        switch (_v0.valueOf()) {
          case "0":
            return _List_fromArray(
              [false, false, false, false]
            );
          case "1":
            return _List_fromArray(
              [false, false, false, true]
            );
          case "2":
            return _List_fromArray(
              [false, false, true, false]
            );
          case "3":
            return _List_fromArray(
              [false, false, true, true]
            );
          case "4":
            return _List_fromArray(
              [false, true, false, false]
            );
          case "5":
            return _List_fromArray(
              [false, true, false, true]
            );
          case "6":
            return _List_fromArray(
              [false, true, true, false]
            );
          case "7":
            return _List_fromArray(
              [false, true, true, true]
            );
          case "8":
            return _List_fromArray(
              [true, false, false, false]
            );
          case "9":
            return _List_fromArray(
              [true, false, false, true]
            );
          case "A":
            return _List_fromArray(
              [true, false, true, false]
            );
          case "B":
            return _List_fromArray(
              [true, false, true, true]
            );
          case "C":
            return _List_fromArray(
              [true, true, false, false]
            );
          case "D":
            return _List_fromArray(
              [true, true, false, true]
            );
          case "E":
            return _List_fromArray(
              [true, true, true, false]
            );
          case "F":
            return _List_fromArray(
              [true, true, true, true]
            );
          default:
            return _List_Nil;
        }
      };
      var $icidasset$elm_binary$Binary$fromHex = function(hex) {
        return $icidasset$elm_binary$Binary$Bits(
          A2(
            $icidasset$elm_binary$Binary$concatMap,
            $icidasset$elm_binary$Binary$hexCharToBinary,
            $elm$core$String$toList(hex)
          )
        );
      };
      var $author$project$Cryptography$Hmac$padding128 = _Utils_Tuple2(
        $icidasset$elm_binary$Binary$concat(
          A2(
            $elm$core$List$repeat,
            128,
            $icidasset$elm_binary$Binary$fromHex("36")
          )
        ),
        $icidasset$elm_binary$Binary$concat(
          A2(
            $elm$core$List$repeat,
            128,
            $icidasset$elm_binary$Binary$fromHex("5C")
          )
        )
      );
      var $author$project$Cryptography$Hmac$padding64 = _Utils_Tuple2(
        $icidasset$elm_binary$Binary$concat(
          A2(
            $elm$core$List$repeat,
            64,
            $icidasset$elm_binary$Binary$fromHex("36")
          )
        ),
        $icidasset$elm_binary$Binary$concat(
          A2(
            $elm$core$List$repeat,
            64,
            $icidasset$elm_binary$Binary$fromHex("5C")
          )
        )
      );
      var $author$project$Cryptography$Hmac$padding = function(blockSize) {
        switch (blockSize) {
          case 64:
            return $author$project$Cryptography$Hmac$padding64;
          case 128:
            return $author$project$Cryptography$Hmac$padding128;
          default:
            return _Utils_Tuple2(
              $icidasset$elm_binary$Binary$concat(
                A2(
                  $elm$core$List$repeat,
                  blockSize,
                  $icidasset$elm_binary$Binary$fromHex("36")
                )
              ),
              $icidasset$elm_binary$Binary$concat(
                A2(
                  $elm$core$List$repeat,
                  blockSize,
                  $icidasset$elm_binary$Binary$fromHex("5C")
                )
              )
            );
        }
      };
      var $icidasset$elm_binary$Binary$condense = F2(
        function(fn, _v0) {
          var a = _v0.a.a;
          var b = _v0.b.a;
          return $icidasset$elm_binary$Binary$Bits(
            A3($elm$core$List$map2, fn, a, b)
          );
        }
      );
      var $icidasset$elm_binary$Binary$makeIsometric = F2(
        function(a, b) {
          var _v0 = _Utils_Tuple2(
            $icidasset$elm_binary$Binary$width(a),
            $icidasset$elm_binary$Binary$width(b)
          );
          var widthA = _v0.a;
          var widthB = _v0.b;
          return _Utils_eq(widthA, widthB) ? _Utils_Tuple2(a, b) : _Utils_cmp(widthA, widthB) > 0 ? _Utils_Tuple2(
            a,
            A2($icidasset$elm_binary$Binary$ensureSize, widthA, b)
          ) : _Utils_Tuple2(
            A2($icidasset$elm_binary$Binary$ensureSize, widthB, a),
            b
          );
        }
      );
      var $elm$core$Basics$xor = _Basics_xor;
      var $icidasset$elm_binary$Binary$xor = F2(
        function(a, b) {
          return A2(
            $icidasset$elm_binary$Binary$condense,
            $elm$core$Basics$xor,
            A2($icidasset$elm_binary$Binary$makeIsometric, a, b)
          );
        }
      );
      var $author$project$Cryptography$Hmac$encrypt = F4(
        function(blockSize, hash, messageString, key) {
          var keySize = $icidasset$elm_binary$Binary$width(key);
          var keyWithBlockSize = _Utils_cmp(keySize, blockSize) > 0 ? A2(
            $author$project$Cryptography$Hmac$padRight,
            blockSize,
            hash(key)
          ) : _Utils_cmp(keySize, blockSize) < 0 ? A2($author$project$Cryptography$Hmac$padRight, blockSize, key) : key;
          var _v0 = A3(
            $elm$core$Tuple$mapBoth,
            $icidasset$elm_binary$Binary$xor(keyWithBlockSize),
            $icidasset$elm_binary$Binary$xor(keyWithBlockSize),
            $author$project$Cryptography$Hmac$padding(blockSize / 8 | 0)
          );
          var binSeqOne = _v0.a;
          var binSeqTwo = _v0.b;
          return hash(
            A2(
              $icidasset$elm_binary$Binary$append,
              binSeqTwo,
              hash(
                A2(
                  $icidasset$elm_binary$Binary$append,
                  binSeqOne,
                  A2($icidasset$elm_binary$Binary$fromString, 8, messageString)
                )
              )
            )
          );
        }
      );
      var $author$project$Cryptography$Hmac$encrypt64 = $author$project$Cryptography$Hmac$encrypt(64 * 8);
      var $icidasset$elm_sha$SHA$Internal$SHA256$chunkSize = 512;
      var $icidasset$elm_binary$Binary$and = F2(
        function(a, b) {
          return A2(
            $icidasset$elm_binary$Binary$condense,
            $elm$core$Basics$and,
            A2($icidasset$elm_binary$Binary$makeIsometric, a, b)
          );
        }
      );
      var $icidasset$elm_binary$Binary$add_ = F2(
        function(_v0, _v1) {
          var x = _v0.a;
          var y = _v0.b;
          var bits = _v1.bits;
          var carryOver = _v1.carryOver;
          return carryOver && (x && y) ? {
            bits: A2($elm$core$List$cons, true, bits),
            carryOver: true
          } : x && y ? {
            bits: A2($elm$core$List$cons, false, bits),
            carryOver: true
          } : carryOver && (x || y) ? {
            bits: A2($elm$core$List$cons, false, bits),
            carryOver: true
          } : x || y ? {
            bits: A2($elm$core$List$cons, true, bits),
            carryOver: false
          } : carryOver ? {
            bits: A2($elm$core$List$cons, true, bits),
            carryOver: false
          } : {
            bits: A2($elm$core$List$cons, false, bits),
            carryOver: false
          };
        }
      );
      var $elm_community$list_extra$List$Extra$zip = $elm$core$List$map2($elm$core$Tuple$pair);
      var $icidasset$elm_binary$Binary$add = F2(
        function(a, b) {
          return $icidasset$elm_binary$Binary$Bits(
            A2(
              $icidasset$elm_binary$Binary$add_,
              _Utils_Tuple2(false, false),
              A3(
                $elm$core$List$foldr,
                $icidasset$elm_binary$Binary$add_,
                { bits: _List_Nil, carryOver: false },
                function(_v0) {
                  var c = _v0.a.a;
                  var d = _v0.b.a;
                  return A2($elm_community$list_extra$List$Extra$zip, c, d);
                }(
                  A2($icidasset$elm_binary$Binary$makeIsometric, a, b)
                )
              )
            ).bits
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$Common$combine = F3(
        function(sizeInBits, x, y) {
          var sum = A2($icidasset$elm_binary$Binary$add, x, y);
          var width = $icidasset$elm_binary$Binary$width(sum);
          return _Utils_cmp(width, sizeInBits) > 0 ? $icidasset$elm_binary$Binary$fromBooleans(
            A2(
              $elm$core$List$drop,
              width - sizeInBits,
              $icidasset$elm_binary$Binary$toBooleans(sum)
            )
          ) : sum;
        }
      );
      var $icidasset$elm_sha$SHA$Internal$SHA256$combine = $icidasset$elm_sha$SHA$Internal$Common$combine($icidasset$elm_sha$SHA$Internal$SHA256$chunkSize / 16 | 0);
      var $icidasset$elm_binary$Binary$empty = $icidasset$elm_binary$Binary$Bits(_List_Nil);
      var $elm$core$Bitwise$and = _Bitwise_and;
      var $elm$core$Bitwise$shiftRightZfBy = _Bitwise_shiftRightZfBy;
      var $elm$core$Array$bitMask = 4294967295 >>> 32 - $elm$core$Array$shiftStep;
      var $elm$core$Elm$JsArray$unsafeGet = _JsArray_unsafeGet;
      var $elm$core$Array$getHelp = F3(
        function(shift, index, tree) {
          getHelp:
            while (true) {
              var pos = $elm$core$Array$bitMask & index >>> shift;
              var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
              if (_v0.$ === "SubTree") {
                var subTree = _v0.a;
                var $temp$shift = shift - $elm$core$Array$shiftStep, $temp$index = index, $temp$tree = subTree;
                shift = $temp$shift;
                index = $temp$index;
                tree = $temp$tree;
                continue getHelp;
              } else {
                var values = _v0.a;
                return A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, values);
              }
            }
        }
      );
      var $elm$core$Bitwise$shiftLeftBy = _Bitwise_shiftLeftBy;
      var $elm$core$Array$tailIndex = function(len) {
        return len >>> 5 << 5;
      };
      var $elm$core$Array$get = F2(
        function(index, _v0) {
          var len = _v0.a;
          var startShift = _v0.b;
          var tree = _v0.c;
          var tail = _v0.d;
          return index < 0 || _Utils_cmp(index, len) > -1 ? $elm$core$Maybe$Nothing : _Utils_cmp(
            index,
            $elm$core$Array$tailIndex(len)
          ) > -1 ? $elm$core$Maybe$Just(
            A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, tail)
          ) : $elm$core$Maybe$Just(
            A3($elm$core$Array$getHelp, startShift, index, tree)
          );
        }
      );
      var $icidasset$elm_binary$Binary$map = F2(
        function(fn, _v0) {
          var list = _v0.a;
          return $icidasset$elm_binary$Binary$Bits(
            fn(list)
          );
        }
      );
      var $elm$core$Basics$not = _Basics_not;
      var $icidasset$elm_binary$Binary$not = $icidasset$elm_binary$Binary$map(
        $elm$core$List$map($elm$core$Basics$not)
      );
      var $icidasset$elm_binary$Binary$rotateRightBy = function(n) {
        return $icidasset$elm_binary$Binary$map(
          function(bits) {
            return function(_v0) {
              var a = _v0.a;
              var b = _v0.b;
              return _Utils_ap(b, a);
            }(
              A2(
                $elm_community$list_extra$List$Extra$splitAt,
                $elm$core$List$length(bits) - n,
                bits
              )
            );
          }
        );
      };
      var $elm$core$Array$fromListHelp = F3(
        function(list, nodeList, nodeListSize) {
          fromListHelp:
            while (true) {
              var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, list);
              var jsArray = _v0.a;
              var remainingItems = _v0.b;
              if (_Utils_cmp(
                $elm$core$Elm$JsArray$length(jsArray),
                $elm$core$Array$branchFactor
              ) < 0) {
                return A2(
                  $elm$core$Array$builderToArray,
                  true,
                  { nodeList, nodeListSize, tail: jsArray }
                );
              } else {
                var $temp$list = remainingItems, $temp$nodeList = A2(
                  $elm$core$List$cons,
                  $elm$core$Array$Leaf(jsArray),
                  nodeList
                ), $temp$nodeListSize = nodeListSize + 1;
                list = $temp$list;
                nodeList = $temp$nodeList;
                nodeListSize = $temp$nodeListSize;
                continue fromListHelp;
              }
            }
        }
      );
      var $elm$core$Array$fromList = function(list) {
        if (!list.b) {
          return $elm$core$Array$empty;
        } else {
          return A3($elm$core$Array$fromListHelp, list, _List_Nil, 0);
        }
      };
      var $icidasset$elm_sha$SHA$Internal$SHA256$roundConstants = $elm$core$Array$fromList(
        _List_fromArray(
          [
            $icidasset$elm_binary$Binary$fromHex("428A2F98"),
            $icidasset$elm_binary$Binary$fromHex("71374491"),
            $icidasset$elm_binary$Binary$fromHex("B5C0FBCF"),
            $icidasset$elm_binary$Binary$fromHex("E9B5DBA5"),
            $icidasset$elm_binary$Binary$fromHex("3956C25B"),
            $icidasset$elm_binary$Binary$fromHex("59F111F1"),
            $icidasset$elm_binary$Binary$fromHex("923F82A4"),
            $icidasset$elm_binary$Binary$fromHex("AB1C5ED5"),
            $icidasset$elm_binary$Binary$fromHex("D807AA98"),
            $icidasset$elm_binary$Binary$fromHex("12835B01"),
            $icidasset$elm_binary$Binary$fromHex("243185BE"),
            $icidasset$elm_binary$Binary$fromHex("550C7DC3"),
            $icidasset$elm_binary$Binary$fromHex("72BE5D74"),
            $icidasset$elm_binary$Binary$fromHex("80DEB1FE"),
            $icidasset$elm_binary$Binary$fromHex("9BDC06A7"),
            $icidasset$elm_binary$Binary$fromHex("C19BF174"),
            $icidasset$elm_binary$Binary$fromHex("E49B69C1"),
            $icidasset$elm_binary$Binary$fromHex("EFBE4786"),
            $icidasset$elm_binary$Binary$fromHex("0FC19DC6"),
            $icidasset$elm_binary$Binary$fromHex("240CA1CC"),
            $icidasset$elm_binary$Binary$fromHex("2DE92C6F"),
            $icidasset$elm_binary$Binary$fromHex("4A7484AA"),
            $icidasset$elm_binary$Binary$fromHex("5CB0A9DC"),
            $icidasset$elm_binary$Binary$fromHex("76F988DA"),
            $icidasset$elm_binary$Binary$fromHex("983E5152"),
            $icidasset$elm_binary$Binary$fromHex("A831C66D"),
            $icidasset$elm_binary$Binary$fromHex("B00327C8"),
            $icidasset$elm_binary$Binary$fromHex("BF597FC7"),
            $icidasset$elm_binary$Binary$fromHex("C6E00BF3"),
            $icidasset$elm_binary$Binary$fromHex("D5A79147"),
            $icidasset$elm_binary$Binary$fromHex("06CA6351"),
            $icidasset$elm_binary$Binary$fromHex("14292967"),
            $icidasset$elm_binary$Binary$fromHex("27B70A85"),
            $icidasset$elm_binary$Binary$fromHex("2E1B2138"),
            $icidasset$elm_binary$Binary$fromHex("4D2C6DFC"),
            $icidasset$elm_binary$Binary$fromHex("53380D13"),
            $icidasset$elm_binary$Binary$fromHex("650A7354"),
            $icidasset$elm_binary$Binary$fromHex("766A0ABB"),
            $icidasset$elm_binary$Binary$fromHex("81C2C92E"),
            $icidasset$elm_binary$Binary$fromHex("92722C85"),
            $icidasset$elm_binary$Binary$fromHex("A2BFE8A1"),
            $icidasset$elm_binary$Binary$fromHex("A81A664B"),
            $icidasset$elm_binary$Binary$fromHex("C24B8B70"),
            $icidasset$elm_binary$Binary$fromHex("C76C51A3"),
            $icidasset$elm_binary$Binary$fromHex("D192E819"),
            $icidasset$elm_binary$Binary$fromHex("D6990624"),
            $icidasset$elm_binary$Binary$fromHex("F40E3585"),
            $icidasset$elm_binary$Binary$fromHex("106AA070"),
            $icidasset$elm_binary$Binary$fromHex("19A4C116"),
            $icidasset$elm_binary$Binary$fromHex("1E376C08"),
            $icidasset$elm_binary$Binary$fromHex("2748774C"),
            $icidasset$elm_binary$Binary$fromHex("34B0BCB5"),
            $icidasset$elm_binary$Binary$fromHex("391C0CB3"),
            $icidasset$elm_binary$Binary$fromHex("4ED8AA4A"),
            $icidasset$elm_binary$Binary$fromHex("5B9CCA4F"),
            $icidasset$elm_binary$Binary$fromHex("682E6FF3"),
            $icidasset$elm_binary$Binary$fromHex("748F82EE"),
            $icidasset$elm_binary$Binary$fromHex("78A5636F"),
            $icidasset$elm_binary$Binary$fromHex("84C87814"),
            $icidasset$elm_binary$Binary$fromHex("8CC70208"),
            $icidasset$elm_binary$Binary$fromHex("90BEFFFA"),
            $icidasset$elm_binary$Binary$fromHex("A4506CEB"),
            $icidasset$elm_binary$Binary$fromHex("BEF9A3F7"),
            $icidasset$elm_binary$Binary$fromHex("C67178F2")
          ]
        )
      );
      var $icidasset$elm_sha$SHA$Internal$SHA256$compressor = F2(
        function(_v0, hashTable) {
          var index = _v0.index;
          var scheduleNumber = _v0.scheduleNumber;
          var y2 = A2(
            $icidasset$elm_binary$Binary$xor,
            A2($icidasset$elm_binary$Binary$and, hashTable.a, hashTable.b),
            A2(
              $icidasset$elm_binary$Binary$xor,
              A2($icidasset$elm_binary$Binary$and, hashTable.a, hashTable.c),
              A2($icidasset$elm_binary$Binary$and, hashTable.b, hashTable.c)
            )
          );
          var y1 = A2(
            $icidasset$elm_binary$Binary$xor,
            A2($icidasset$elm_binary$Binary$rotateRightBy, 2, hashTable.a),
            A2(
              $icidasset$elm_binary$Binary$xor,
              A2($icidasset$elm_binary$Binary$rotateRightBy, 13, hashTable.a),
              A2($icidasset$elm_binary$Binary$rotateRightBy, 22, hashTable.a)
            )
          );
          var y = A2($icidasset$elm_sha$SHA$Internal$SHA256$combine, y1, y2);
          var x2 = A2(
            $icidasset$elm_binary$Binary$xor,
            A2($icidasset$elm_binary$Binary$and, hashTable.e, hashTable.f),
            A2(
              $icidasset$elm_binary$Binary$and,
              $icidasset$elm_binary$Binary$not(hashTable.e),
              hashTable.g
            )
          );
          var x1 = A2(
            $icidasset$elm_binary$Binary$xor,
            A2($icidasset$elm_binary$Binary$rotateRightBy, 6, hashTable.e),
            A2(
              $icidasset$elm_binary$Binary$xor,
              A2($icidasset$elm_binary$Binary$rotateRightBy, 11, hashTable.e),
              A2($icidasset$elm_binary$Binary$rotateRightBy, 25, hashTable.e)
            )
          );
          var x = A3(
            $elm$core$List$foldl,
            $icidasset$elm_sha$SHA$Internal$SHA256$combine,
            $icidasset$elm_binary$Binary$empty,
            _List_fromArray(
              [
                hashTable.h,
                x1,
                x2,
                A2(
                  $elm$core$Maybe$withDefault,
                  $icidasset$elm_binary$Binary$empty,
                  A2($elm$core$Array$get, index, $icidasset$elm_sha$SHA$Internal$SHA256$roundConstants)
                ),
                scheduleNumber
              ]
            )
          );
          return {
            a: A2($icidasset$elm_sha$SHA$Internal$SHA256$combine, x, y),
            b: hashTable.a,
            c: hashTable.b,
            d: hashTable.c,
            e: A2($icidasset$elm_sha$SHA$Internal$SHA256$combine, hashTable.d, x),
            f: hashTable.e,
            g: hashTable.f,
            h: hashTable.g
          };
        }
      );
      var $icidasset$elm_binary$Binary$shiftRightZfBy = F2(
        function(n, _v0) {
          var bits = _v0.a;
          return $icidasset$elm_binary$Binary$Bits(
            A2(
              $elm$core$List$append,
              A2($elm$core$List$repeat, n, false),
              A2(
                $elm$core$List$take,
                $elm$core$List$length(bits) - n,
                bits
              )
            )
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$SHA256$extender = function(_v0) {
        var i2 = _v0.i2;
        var i7 = _v0.i7;
        var i15 = _v0.i15;
        var i16 = _v0.i16;
        var b = A2(
          $icidasset$elm_binary$Binary$xor,
          A2($icidasset$elm_binary$Binary$rotateRightBy, 17, i2),
          A2(
            $icidasset$elm_binary$Binary$xor,
            A2($icidasset$elm_binary$Binary$rotateRightBy, 19, i2),
            A2($icidasset$elm_binary$Binary$shiftRightZfBy, 10, i2)
          )
        );
        var a = A2(
          $icidasset$elm_binary$Binary$xor,
          A2($icidasset$elm_binary$Binary$rotateRightBy, 7, i15),
          A2(
            $icidasset$elm_binary$Binary$xor,
            A2($icidasset$elm_binary$Binary$rotateRightBy, 18, i15),
            A2($icidasset$elm_binary$Binary$shiftRightZfBy, 3, i15)
          )
        );
        return A3(
          $elm$core$List$foldl,
          $icidasset$elm_sha$SHA$Internal$SHA256$combine,
          $icidasset$elm_binary$Binary$empty,
          _List_fromArray(
            [i16, a, i7, b]
          )
        );
      };
      var $icidasset$elm_sha$SHA$Internal$SHA256$initialHashTable = {
        a: $icidasset$elm_binary$Binary$fromHex("6A09E667"),
        b: $icidasset$elm_binary$Binary$fromHex("BB67AE85"),
        c: $icidasset$elm_binary$Binary$fromHex("3C6EF372"),
        d: $icidasset$elm_binary$Binary$fromHex("A54FF53A"),
        e: $icidasset$elm_binary$Binary$fromHex("510E527F"),
        f: $icidasset$elm_binary$Binary$fromHex("9B05688C"),
        g: $icidasset$elm_binary$Binary$fromHex("1F83D9AB"),
        h: $icidasset$elm_binary$Binary$fromHex("5BE0CD19")
      };
      var $icidasset$elm_sha$SHA$Internal$SHA256$computationSetup = { chunkSize: $icidasset$elm_sha$SHA$Internal$SHA256$chunkSize, compressor: $icidasset$elm_sha$SHA$Internal$SHA256$compressor, extender: $icidasset$elm_sha$SHA$Internal$SHA256$extender, initialHashTable: $icidasset$elm_sha$SHA$Internal$SHA256$initialHashTable, roundConstants: $icidasset$elm_sha$SHA$Internal$SHA256$roundConstants };
      var $icidasset$elm_sha$SHA$Internal$HashTable$combineHashTables = F3(
        function(sizeInBits, x, y) {
          return {
            a: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.a, y.a),
            b: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.b, y.b),
            c: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.c, y.c),
            d: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.d, y.d),
            e: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.e, y.e),
            f: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.f, y.f),
            g: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.g, y.g),
            h: A3($icidasset$elm_sha$SHA$Internal$Common$combine, sizeInBits, x.h, y.h)
          };
        }
      );
      var $elm$core$Tuple$second = function(_v0) {
        var y = _v0.b;
        return y;
      };
      var $elm$core$Array$toIndexedList = function(array) {
        var len = array.a;
        var helper = F2(
          function(entry, _v0) {
            var index = _v0.a;
            var list = _v0.b;
            return _Utils_Tuple2(
              index - 1,
              A2(
                $elm$core$List$cons,
                _Utils_Tuple2(index, entry),
                list
              )
            );
          }
        );
        return A3(
          $elm$core$Array$foldr,
          helper,
          _Utils_Tuple2(len - 1, _List_Nil),
          array
        ).b;
      };
      var $icidasset$elm_sha$SHA$Internal$useCompressor = F2(
        function(compressor, _v0) {
          var index = _v0.a;
          var scheduleNumber = _v0.b;
          return compressor(
            { index, scheduleNumber }
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$compress = F3(
        function(setup, hashTable, schedule) {
          return A3(
            $icidasset$elm_sha$SHA$Internal$HashTable$combineHashTables,
            setup.chunkSize / 16 | 0,
            hashTable,
            A3(
              $elm$core$List$foldl,
              $icidasset$elm_sha$SHA$Internal$useCompressor(setup.compressor),
              hashTable,
              $elm$core$Array$toIndexedList(schedule)
            )
          );
        }
      );
      var $elm$core$Elm$JsArray$appendN = _JsArray_appendN;
      var $elm$core$Elm$JsArray$slice = _JsArray_slice;
      var $elm$core$Array$appendHelpBuilder = F2(
        function(tail, builder) {
          var tailLen = $elm$core$Elm$JsArray$length(tail);
          var notAppended = $elm$core$Array$branchFactor - $elm$core$Elm$JsArray$length(builder.tail) - tailLen;
          var appended = A3($elm$core$Elm$JsArray$appendN, $elm$core$Array$branchFactor, builder.tail, tail);
          return notAppended < 0 ? {
            nodeList: A2(
              $elm$core$List$cons,
              $elm$core$Array$Leaf(appended),
              builder.nodeList
            ),
            nodeListSize: builder.nodeListSize + 1,
            tail: A3($elm$core$Elm$JsArray$slice, notAppended, tailLen, tail)
          } : !notAppended ? {
            nodeList: A2(
              $elm$core$List$cons,
              $elm$core$Array$Leaf(appended),
              builder.nodeList
            ),
            nodeListSize: builder.nodeListSize + 1,
            tail: $elm$core$Elm$JsArray$empty
          } : { nodeList: builder.nodeList, nodeListSize: builder.nodeListSize, tail: appended };
        }
      );
      var $elm$core$Elm$JsArray$push = _JsArray_push;
      var $elm$core$Elm$JsArray$singleton = _JsArray_singleton;
      var $elm$core$Elm$JsArray$unsafeSet = _JsArray_unsafeSet;
      var $elm$core$Array$insertTailInTree = F4(
        function(shift, index, tail, tree) {
          var pos = $elm$core$Array$bitMask & index >>> shift;
          if (_Utils_cmp(
            pos,
            $elm$core$Elm$JsArray$length(tree)
          ) > -1) {
            if (shift === 5) {
              return A2(
                $elm$core$Elm$JsArray$push,
                $elm$core$Array$Leaf(tail),
                tree
              );
            } else {
              var newSub = $elm$core$Array$SubTree(
                A4($elm$core$Array$insertTailInTree, shift - $elm$core$Array$shiftStep, index, tail, $elm$core$Elm$JsArray$empty)
              );
              return A2($elm$core$Elm$JsArray$push, newSub, tree);
            }
          } else {
            var value = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
            if (value.$ === "SubTree") {
              var subTree = value.a;
              var newSub = $elm$core$Array$SubTree(
                A4($elm$core$Array$insertTailInTree, shift - $elm$core$Array$shiftStep, index, tail, subTree)
              );
              return A3($elm$core$Elm$JsArray$unsafeSet, pos, newSub, tree);
            } else {
              var newSub = $elm$core$Array$SubTree(
                A4(
                  $elm$core$Array$insertTailInTree,
                  shift - $elm$core$Array$shiftStep,
                  index,
                  tail,
                  $elm$core$Elm$JsArray$singleton(value)
                )
              );
              return A3($elm$core$Elm$JsArray$unsafeSet, pos, newSub, tree);
            }
          }
        }
      );
      var $elm$core$Array$unsafeReplaceTail = F2(
        function(newTail, _v0) {
          var len = _v0.a;
          var startShift = _v0.b;
          var tree = _v0.c;
          var tail = _v0.d;
          var originalTailLen = $elm$core$Elm$JsArray$length(tail);
          var newTailLen = $elm$core$Elm$JsArray$length(newTail);
          var newArrayLen = len + (newTailLen - originalTailLen);
          if (_Utils_eq(newTailLen, $elm$core$Array$branchFactor)) {
            var overflow = _Utils_cmp(newArrayLen >>> $elm$core$Array$shiftStep, 1 << startShift) > 0;
            if (overflow) {
              var newShift = startShift + $elm$core$Array$shiftStep;
              var newTree = A4(
                $elm$core$Array$insertTailInTree,
                newShift,
                len,
                newTail,
                $elm$core$Elm$JsArray$singleton(
                  $elm$core$Array$SubTree(tree)
                )
              );
              return A4($elm$core$Array$Array_elm_builtin, newArrayLen, newShift, newTree, $elm$core$Elm$JsArray$empty);
            } else {
              return A4(
                $elm$core$Array$Array_elm_builtin,
                newArrayLen,
                startShift,
                A4($elm$core$Array$insertTailInTree, startShift, len, newTail, tree),
                $elm$core$Elm$JsArray$empty
              );
            }
          } else {
            return A4($elm$core$Array$Array_elm_builtin, newArrayLen, startShift, tree, newTail);
          }
        }
      );
      var $elm$core$Array$appendHelpTree = F2(
        function(toAppend, array) {
          var len = array.a;
          var tree = array.c;
          var tail = array.d;
          var itemsToAppend = $elm$core$Elm$JsArray$length(toAppend);
          var notAppended = $elm$core$Array$branchFactor - $elm$core$Elm$JsArray$length(tail) - itemsToAppend;
          var appended = A3($elm$core$Elm$JsArray$appendN, $elm$core$Array$branchFactor, tail, toAppend);
          var newArray = A2($elm$core$Array$unsafeReplaceTail, appended, array);
          if (notAppended < 0) {
            var nextTail = A3($elm$core$Elm$JsArray$slice, notAppended, itemsToAppend, toAppend);
            return A2($elm$core$Array$unsafeReplaceTail, nextTail, newArray);
          } else {
            return newArray;
          }
        }
      );
      var $elm$core$Elm$JsArray$foldl = _JsArray_foldl;
      var $elm$core$Array$builderFromArray = function(_v0) {
        var len = _v0.a;
        var tree = _v0.c;
        var tail = _v0.d;
        var helper = F2(
          function(node, acc) {
            if (node.$ === "SubTree") {
              var subTree = node.a;
              return A3($elm$core$Elm$JsArray$foldl, helper, acc, subTree);
            } else {
              return A2($elm$core$List$cons, node, acc);
            }
          }
        );
        return {
          nodeList: A3($elm$core$Elm$JsArray$foldl, helper, _List_Nil, tree),
          nodeListSize: len / $elm$core$Array$branchFactor | 0,
          tail
        };
      };
      var $elm$core$Array$append = F2(
        function(a, _v0) {
          var aTail = a.d;
          var bLen = _v0.a;
          var bTree = _v0.c;
          var bTail = _v0.d;
          if (_Utils_cmp(bLen, $elm$core$Array$branchFactor * 4) < 1) {
            var foldHelper = F2(
              function(node, array) {
                if (node.$ === "SubTree") {
                  var tree = node.a;
                  return A3($elm$core$Elm$JsArray$foldl, foldHelper, array, tree);
                } else {
                  var leaf = node.a;
                  return A2($elm$core$Array$appendHelpTree, leaf, array);
                }
              }
            );
            return A2(
              $elm$core$Array$appendHelpTree,
              bTail,
              A3($elm$core$Elm$JsArray$foldl, foldHelper, a, bTree)
            );
          } else {
            var foldHelper = F2(
              function(node, builder) {
                if (node.$ === "SubTree") {
                  var tree = node.a;
                  return A3($elm$core$Elm$JsArray$foldl, foldHelper, builder, tree);
                } else {
                  var leaf = node.a;
                  return A2($elm$core$Array$appendHelpBuilder, leaf, builder);
                }
              }
            );
            return A2(
              $elm$core$Array$builderToArray,
              true,
              A2(
                $elm$core$Array$appendHelpBuilder,
                bTail,
                A3(
                  $elm$core$Elm$JsArray$foldl,
                  foldHelper,
                  $elm$core$Array$builderFromArray(a),
                  bTree
                )
              )
            );
          }
        }
      );
      var $elm$core$Maybe$map4 = F5(
        function(func, ma, mb, mc, md) {
          if (ma.$ === "Nothing") {
            return $elm$core$Maybe$Nothing;
          } else {
            var a = ma.a;
            if (mb.$ === "Nothing") {
              return $elm$core$Maybe$Nothing;
            } else {
              var b = mb.a;
              if (mc.$ === "Nothing") {
                return $elm$core$Maybe$Nothing;
              } else {
                var c = mc.a;
                if (md.$ === "Nothing") {
                  return $elm$core$Maybe$Nothing;
                } else {
                  var d = md.a;
                  return $elm$core$Maybe$Just(
                    A4(func, a, b, c, d)
                  );
                }
              }
            }
          }
        }
      );
      var $elm$core$Array$setHelp = F4(
        function(shift, index, value, tree) {
          var pos = $elm$core$Array$bitMask & index >>> shift;
          var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
          if (_v0.$ === "SubTree") {
            var subTree = _v0.a;
            var newSub = A4($elm$core$Array$setHelp, shift - $elm$core$Array$shiftStep, index, value, subTree);
            return A3(
              $elm$core$Elm$JsArray$unsafeSet,
              pos,
              $elm$core$Array$SubTree(newSub),
              tree
            );
          } else {
            var values = _v0.a;
            var newLeaf = A3($elm$core$Elm$JsArray$unsafeSet, $elm$core$Array$bitMask & index, value, values);
            return A3(
              $elm$core$Elm$JsArray$unsafeSet,
              pos,
              $elm$core$Array$Leaf(newLeaf),
              tree
            );
          }
        }
      );
      var $elm$core$Array$set = F3(
        function(index, value, array) {
          var len = array.a;
          var startShift = array.b;
          var tree = array.c;
          var tail = array.d;
          return index < 0 || _Utils_cmp(index, len) > -1 ? array : _Utils_cmp(
            index,
            $elm$core$Array$tailIndex(len)
          ) > -1 ? A4(
            $elm$core$Array$Array_elm_builtin,
            len,
            startShift,
            tree,
            A3($elm$core$Elm$JsArray$unsafeSet, $elm$core$Array$bitMask & index, value, tail)
          ) : A4(
            $elm$core$Array$Array_elm_builtin,
            len,
            startShift,
            A4($elm$core$Array$setHelp, startShift, index, value, tree),
            tail
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$extend = F3(
        function(setup, index, schedule) {
          return A2(
            $elm$core$Maybe$withDefault,
            schedule,
            A2(
              $elm$core$Maybe$map,
              function(bits) {
                return A3($elm$core$Array$set, index, bits, schedule);
              },
              A5(
                $elm$core$Maybe$map4,
                F4(
                  function(i2, i7, i15, i16) {
                    return setup.extender(
                      { i15, i16, i2, i7 }
                    );
                  }
                ),
                A2($elm$core$Array$get, index - 2, schedule),
                A2($elm$core$Array$get, index - 7, schedule),
                A2($elm$core$Array$get, index - 15, schedule),
                A2($elm$core$Array$get, index - 16, schedule)
              )
            )
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$extendInitialSchedule = F3(
        function(setup, chunkComputer, initialSchedule) {
          var lengthySchedule = A2($elm$core$Array$append, initialSchedule, chunkComputer.scheduleExtArray);
          return A3(
            $elm$core$List$foldl,
            $icidasset$elm_sha$SHA$Internal$extend(setup),
            lengthySchedule,
            chunkComputer.scheduleExtRange
          );
        }
      );
      var $elm$core$Array$sliceLeft = F2(
        function(from, array) {
          var len = array.a;
          var tree = array.c;
          var tail = array.d;
          if (!from) {
            return array;
          } else {
            if (_Utils_cmp(
              from,
              $elm$core$Array$tailIndex(len)
            ) > -1) {
              return A4(
                $elm$core$Array$Array_elm_builtin,
                len - from,
                $elm$core$Array$shiftStep,
                $elm$core$Elm$JsArray$empty,
                A3(
                  $elm$core$Elm$JsArray$slice,
                  from - $elm$core$Array$tailIndex(len),
                  $elm$core$Elm$JsArray$length(tail),
                  tail
                )
              );
            } else {
              var skipNodes = from / $elm$core$Array$branchFactor | 0;
              var helper = F2(
                function(node, acc) {
                  if (node.$ === "SubTree") {
                    var subTree = node.a;
                    return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
                  } else {
                    var leaf = node.a;
                    return A2($elm$core$List$cons, leaf, acc);
                  }
                }
              );
              var leafNodes = A3(
                $elm$core$Elm$JsArray$foldr,
                helper,
                _List_fromArray(
                  [tail]
                ),
                tree
              );
              var nodesToInsert = A2($elm$core$List$drop, skipNodes, leafNodes);
              if (!nodesToInsert.b) {
                return $elm$core$Array$empty;
              } else {
                var head = nodesToInsert.a;
                var rest = nodesToInsert.b;
                var firstSlice = from - skipNodes * $elm$core$Array$branchFactor;
                var initialBuilder = {
                  nodeList: _List_Nil,
                  nodeListSize: 0,
                  tail: A3(
                    $elm$core$Elm$JsArray$slice,
                    firstSlice,
                    $elm$core$Elm$JsArray$length(head),
                    head
                  )
                };
                return A2(
                  $elm$core$Array$builderToArray,
                  true,
                  A3($elm$core$List$foldl, $elm$core$Array$appendHelpBuilder, initialBuilder, rest)
                );
              }
            }
          }
        }
      );
      var $elm$core$Array$fetchNewTail = F4(
        function(shift, end, treeEnd, tree) {
          fetchNewTail:
            while (true) {
              var pos = $elm$core$Array$bitMask & treeEnd >>> shift;
              var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
              if (_v0.$ === "SubTree") {
                var sub = _v0.a;
                var $temp$shift = shift - $elm$core$Array$shiftStep, $temp$end = end, $temp$treeEnd = treeEnd, $temp$tree = sub;
                shift = $temp$shift;
                end = $temp$end;
                treeEnd = $temp$treeEnd;
                tree = $temp$tree;
                continue fetchNewTail;
              } else {
                var values = _v0.a;
                return A3($elm$core$Elm$JsArray$slice, 0, $elm$core$Array$bitMask & end, values);
              }
            }
        }
      );
      var $elm$core$Array$hoistTree = F3(
        function(oldShift, newShift, tree) {
          hoistTree:
            while (true) {
              if (_Utils_cmp(oldShift, newShift) < 1 || !$elm$core$Elm$JsArray$length(tree)) {
                return tree;
              } else {
                var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, 0, tree);
                if (_v0.$ === "SubTree") {
                  var sub = _v0.a;
                  var $temp$oldShift = oldShift - $elm$core$Array$shiftStep, $temp$newShift = newShift, $temp$tree = sub;
                  oldShift = $temp$oldShift;
                  newShift = $temp$newShift;
                  tree = $temp$tree;
                  continue hoistTree;
                } else {
                  return tree;
                }
              }
            }
        }
      );
      var $elm$core$Array$sliceTree = F3(
        function(shift, endIdx, tree) {
          var lastPos = $elm$core$Array$bitMask & endIdx >>> shift;
          var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, lastPos, tree);
          if (_v0.$ === "SubTree") {
            var sub = _v0.a;
            var newSub = A3($elm$core$Array$sliceTree, shift - $elm$core$Array$shiftStep, endIdx, sub);
            return !$elm$core$Elm$JsArray$length(newSub) ? A3($elm$core$Elm$JsArray$slice, 0, lastPos, tree) : A3(
              $elm$core$Elm$JsArray$unsafeSet,
              lastPos,
              $elm$core$Array$SubTree(newSub),
              A3($elm$core$Elm$JsArray$slice, 0, lastPos + 1, tree)
            );
          } else {
            return A3($elm$core$Elm$JsArray$slice, 0, lastPos, tree);
          }
        }
      );
      var $elm$core$Array$sliceRight = F2(
        function(end, array) {
          var len = array.a;
          var startShift = array.b;
          var tree = array.c;
          var tail = array.d;
          if (_Utils_eq(end, len)) {
            return array;
          } else {
            if (_Utils_cmp(
              end,
              $elm$core$Array$tailIndex(len)
            ) > -1) {
              return A4(
                $elm$core$Array$Array_elm_builtin,
                end,
                startShift,
                tree,
                A3($elm$core$Elm$JsArray$slice, 0, $elm$core$Array$bitMask & end, tail)
              );
            } else {
              var endIdx = $elm$core$Array$tailIndex(end);
              var depth = $elm$core$Basics$floor(
                A2(
                  $elm$core$Basics$logBase,
                  $elm$core$Array$branchFactor,
                  A2($elm$core$Basics$max, 1, endIdx - 1)
                )
              );
              var newShift = A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep);
              return A4(
                $elm$core$Array$Array_elm_builtin,
                end,
                newShift,
                A3(
                  $elm$core$Array$hoistTree,
                  startShift,
                  newShift,
                  A3($elm$core$Array$sliceTree, startShift, endIdx, tree)
                ),
                A4($elm$core$Array$fetchNewTail, startShift, end, endIdx, tree)
              );
            }
          }
        }
      );
      var $elm$core$Array$translateIndex = F2(
        function(index, _v0) {
          var len = _v0.a;
          var posIndex = index < 0 ? len + index : index;
          return posIndex < 0 ? 0 : _Utils_cmp(posIndex, len) > 0 ? len : posIndex;
        }
      );
      var $elm$core$Array$slice = F3(
        function(from, to, array) {
          var correctTo = A2($elm$core$Array$translateIndex, to, array);
          var correctFrom = A2($elm$core$Array$translateIndex, from, array);
          return _Utils_cmp(correctFrom, correctTo) > 0 ? $elm$core$Array$empty : A2(
            $elm$core$Array$sliceLeft,
            correctFrom,
            A2($elm$core$Array$sliceRight, correctTo, array)
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$computeChunk = F4(
        function(setup, chunkComputer, pieces, hashTable) {
          computeChunk:
            while (true) {
              var newHashTable = A3(
                $icidasset$elm_sha$SHA$Internal$compress,
                setup,
                hashTable,
                A3(
                  $icidasset$elm_sha$SHA$Internal$extendInitialSchedule,
                  setup,
                  chunkComputer,
                  A3(
                    $elm$core$Array$slice,
                    A2($elm$core$Basics$max, 0, (chunkComputer.currentChunk - 1) * 16),
                    chunkComputer.currentChunk * 16,
                    pieces
                  )
                )
              );
              if (_Utils_cmp(chunkComputer.currentChunk, chunkComputer.totalChunks) < 0) {
                var $temp$setup = setup, $temp$chunkComputer = _Utils_update(
                  chunkComputer,
                  { currentChunk: chunkComputer.currentChunk + 1 }
                ), $temp$pieces = pieces, $temp$hashTable = newHashTable;
                setup = $temp$setup;
                chunkComputer = $temp$chunkComputer;
                pieces = $temp$pieces;
                hashTable = $temp$hashTable;
                continue computeChunk;
              } else {
                return newHashTable;
              }
            }
        }
      );
      var $elm$core$List$isEmpty = function(xs) {
        if (!xs.b) {
          return true;
        } else {
          return false;
        }
      };
      var $elm_community$list_extra$List$Extra$greedyGroupsOfWithStep = F3(
        function(size, step, list) {
          if (size <= 0 || step <= 0) {
            return _List_Nil;
          } else {
            var go = F2(
              function(xs, acc) {
                go:
                  while (true) {
                    if ($elm$core$List$isEmpty(xs)) {
                      return $elm$core$List$reverse(acc);
                    } else {
                      var $temp$xs = A2($elm$core$List$drop, step, xs), $temp$acc = A2(
                        $elm$core$List$cons,
                        A2($elm$core$List$take, size, xs),
                        acc
                      );
                      xs = $temp$xs;
                      acc = $temp$acc;
                      continue go;
                    }
                  }
              }
            );
            return A2(go, list, _List_Nil);
          }
        }
      );
      var $elm_community$list_extra$List$Extra$greedyGroupsOf = F2(
        function(size, xs) {
          return A3($elm_community$list_extra$List$Extra$greedyGroupsOfWithStep, size, size, xs);
        }
      );
      var $elm$core$Array$length = function(_v0) {
        var len = _v0.a;
        return len;
      };
      var $elm$core$Elm$JsArray$map = _JsArray_map;
      var $elm$core$Array$map = F2(
        function(func, _v0) {
          var len = _v0.a;
          var startShift = _v0.b;
          var tree = _v0.c;
          var tail = _v0.d;
          var helper = function(node) {
            if (node.$ === "SubTree") {
              var subTree = node.a;
              return $elm$core$Array$SubTree(
                A2($elm$core$Elm$JsArray$map, helper, subTree)
              );
            } else {
              var values = node.a;
              return $elm$core$Array$Leaf(
                A2($elm$core$Elm$JsArray$map, func, values)
              );
            }
          };
          return A4(
            $elm$core$Array$Array_elm_builtin,
            len,
            startShift,
            A2($elm$core$Elm$JsArray$map, helper, tree),
            A2($elm$core$Elm$JsArray$map, func, tail)
          );
        }
      );
      var $elm$core$Array$repeat = F2(
        function(n, e) {
          return A2(
            $elm$core$Array$initialize,
            n,
            function(_v0) {
              return e;
            }
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$compute = F2(
        function(setup, bits) {
          var scheduleSize = $elm$core$Array$length(setup.roundConstants) - 1;
          var chunkComputer = {
            currentChunk: 1,
            scheduleExtArray: A2($elm$core$Array$repeat, scheduleSize - 15, $icidasset$elm_binary$Binary$empty),
            scheduleExtRange: A2($elm$core$List$range, 16, scheduleSize),
            totalChunks: $elm$core$Basics$ceiling(
              $icidasset$elm_binary$Binary$width(bits) / setup.chunkSize
            )
          };
          return A4(
            $icidasset$elm_sha$SHA$Internal$computeChunk,
            setup,
            chunkComputer,
            A2(
              $elm$core$Array$map,
              $icidasset$elm_binary$Binary$fromBooleans,
              $elm$core$Array$fromList(
                A2(
                  $elm_community$list_extra$List$Extra$greedyGroupsOf,
                  setup.chunkSize / 16 | 0,
                  $icidasset$elm_binary$Binary$toBooleans(bits)
                )
              )
            ),
            setup.initialHashTable
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$HashTable$partialHashTableToBits = F2(
        function(accessors, hashTable) {
          return $icidasset$elm_binary$Binary$concat(
            A2(
              $elm$core$List$map,
              function(accessor) {
                return accessor(hashTable);
              },
              accessors
            )
          );
        }
      );
      var $icidasset$elm_sha$SHA$Internal$HashTable$hashTableToBits = $icidasset$elm_sha$SHA$Internal$HashTable$partialHashTableToBits(
        _List_fromArray(
          [
            function($) {
              return $.a;
            },
            function($) {
              return $.b;
            },
            function($) {
              return $.c;
            },
            function($) {
              return $.d;
            },
            function($) {
              return $.e;
            },
            function($) {
              return $.f;
            },
            function($) {
              return $.g;
            },
            function($) {
              return $.h;
            }
          ]
        )
      );
      var $icidasset$elm_sha$SHA$Internal$preprocess = F2(
        function(_v0, message) {
          var blockLength = _v0.blockLength;
          var l = $icidasset$elm_binary$Binary$width(message);
          var k = blockLength - A2($elm$core$Basics$modBy, blockLength, l + 1 + (blockLength / 8 | 0));
          return $icidasset$elm_binary$Binary$concat(
            _List_fromArray(
              [
                message,
                $icidasset$elm_binary$Binary$fromBooleans(
                  _List_fromArray(
                    [true]
                  )
                ),
                $icidasset$elm_binary$Binary$fromBooleans(
                  A2($elm$core$List$repeat, k, false)
                ),
                A2(
                  $icidasset$elm_binary$Binary$ensureSize,
                  blockLength / 8 | 0,
                  $icidasset$elm_binary$Binary$fromDecimal(l)
                )
              ]
            )
          );
        }
      );
      var $icidasset$elm_sha$SHA$sha256 = function(message) {
        return $icidasset$elm_sha$SHA$Internal$HashTable$hashTableToBits(
          A2(
            $icidasset$elm_sha$SHA$Internal$compute,
            $icidasset$elm_sha$SHA$Internal$SHA256$computationSetup,
            A2(
              $icidasset$elm_sha$SHA$Internal$preprocess,
              { blockLength: 512 },
              message
            )
          )
        );
      };
      var $author$project$Sources$Services$AmazonS3$Presign$hmacSha256 = $author$project$Cryptography$Hmac$encrypt64($icidasset$elm_sha$SHA$sha256);
      var $ryannhg$date_format$DateFormat$HourMilitaryFixed = { $: "HourMilitaryFixed" };
      var $ryannhg$date_format$DateFormat$hourMilitaryFixed = $ryannhg$date_format$DateFormat$HourMilitaryFixed;
      var $author$project$Sources$Processing$httpMethod = function(method) {
        if (method.$ === "Get") {
          return "GET";
        } else {
          return "HEAD";
        }
      };
      var $elm_community$maybe_extra$Maybe$Extra$isJust = function(m) {
        if (m.$ === "Nothing") {
          return false;
        } else {
          return true;
        }
      };
      var $ryannhg$date_format$DateFormat$MinuteFixed = { $: "MinuteFixed" };
      var $ryannhg$date_format$DateFormat$minuteFixed = $ryannhg$date_format$DateFormat$MinuteFixed;
      var $ryannhg$date_format$DateFormat$MonthFixed = { $: "MonthFixed" };
      var $ryannhg$date_format$DateFormat$monthFixed = $ryannhg$date_format$DateFormat$MonthFixed;
      var $elm$url$Url$percentEncode = _Url_percentEncode;
      var $elm$url$Url$Builder$QueryParameter = F2(
        function(a, b) {
          return { $: "QueryParameter", a, b };
        }
      );
      var $elm$url$Url$Builder$string = F2(
        function(key, value) {
          return A2(
            $elm$url$Url$Builder$QueryParameter,
            $elm$url$Url$percentEncode(key),
            $elm$url$Url$percentEncode(value)
          );
        }
      );
      var $elm$url$Url$Builder$toQueryPair = function(_v0) {
        var key = _v0.a;
        var value = _v0.b;
        return key + ("=" + value);
      };
      var $elm$url$Url$Builder$toQuery = function(parameters) {
        if (!parameters.b) {
          return "";
        } else {
          return "?" + A2(
            $elm$core$String$join,
            "&",
            A2($elm$core$List$map, $elm$url$Url$Builder$toQueryPair, parameters)
          );
        }
      };
      var $author$project$Tuple$Ext$uncurry = F2(
        function(fn, _v0) {
          var a = _v0.a;
          var b = _v0.b;
          return A2(fn, a, b);
        }
      );
      var $author$project$Common$queryString = A2(
        $elm$core$Basics$composeR,
        $elm$core$List$map(
          $author$project$Tuple$Ext$uncurry($elm$url$Url$Builder$string)
        ),
        $elm$url$Url$Builder$toQuery
      );
      var $ryannhg$date_format$DateFormat$SecondFixed = { $: "SecondFixed" };
      var $ryannhg$date_format$DateFormat$secondFixed = $ryannhg$date_format$DateFormat$SecondFixed;
      var $ryannhg$date_format$DateFormat$Text = function(a) {
        return { $: "Text", a };
      };
      var $ryannhg$date_format$DateFormat$text = $ryannhg$date_format$DateFormat$Text;
      var $icidasset$elm_binary$Binary$binaryToHexChar = function(binary) {
        _v0$16:
          while (true) {
            if (binary.b) {
              if (!binary.a) {
                if (binary.b.b) {
                  if (!binary.b.a) {
                    if (binary.b.b.b) {
                      if (!binary.b.b.a) {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v1 = binary.b;
                              var _v2 = _v1.b;
                              var _v3 = _v2.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("0")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v4 = binary.b;
                              var _v5 = _v4.b;
                              var _v6 = _v5.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("1")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      } else {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v7 = binary.b;
                              var _v8 = _v7.b;
                              var _v9 = _v8.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("2")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v10 = binary.b;
                              var _v11 = _v10.b;
                              var _v12 = _v11.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("3")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      }
                    } else {
                      break _v0$16;
                    }
                  } else {
                    if (binary.b.b.b) {
                      if (!binary.b.b.a) {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v13 = binary.b;
                              var _v14 = _v13.b;
                              var _v15 = _v14.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("4")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v16 = binary.b;
                              var _v17 = _v16.b;
                              var _v18 = _v17.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("5")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      } else {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v19 = binary.b;
                              var _v20 = _v19.b;
                              var _v21 = _v20.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("6")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v22 = binary.b;
                              var _v23 = _v22.b;
                              var _v24 = _v23.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("7")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      }
                    } else {
                      break _v0$16;
                    }
                  }
                } else {
                  break _v0$16;
                }
              } else {
                if (binary.b.b) {
                  if (!binary.b.a) {
                    if (binary.b.b.b) {
                      if (!binary.b.b.a) {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v25 = binary.b;
                              var _v26 = _v25.b;
                              var _v27 = _v26.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("8")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v28 = binary.b;
                              var _v29 = _v28.b;
                              var _v30 = _v29.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("9")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      } else {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v31 = binary.b;
                              var _v32 = _v31.b;
                              var _v33 = _v32.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("A")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v34 = binary.b;
                              var _v35 = _v34.b;
                              var _v36 = _v35.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("B")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      }
                    } else {
                      break _v0$16;
                    }
                  } else {
                    if (binary.b.b.b) {
                      if (!binary.b.b.a) {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v37 = binary.b;
                              var _v38 = _v37.b;
                              var _v39 = _v38.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("C")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v40 = binary.b;
                              var _v41 = _v40.b;
                              var _v42 = _v41.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("D")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      } else {
                        if (binary.b.b.b.b) {
                          if (!binary.b.b.b.a) {
                            if (!binary.b.b.b.b.b) {
                              var _v43 = binary.b;
                              var _v44 = _v43.b;
                              var _v45 = _v44.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("E")
                              );
                            } else {
                              break _v0$16;
                            }
                          } else {
                            if (!binary.b.b.b.b.b) {
                              var _v46 = binary.b;
                              var _v47 = _v46.b;
                              var _v48 = _v47.b;
                              return $elm$core$Maybe$Just(
                                _Utils_chr("F")
                              );
                            } else {
                              break _v0$16;
                            }
                          }
                        } else {
                          break _v0$16;
                        }
                      }
                    } else {
                      break _v0$16;
                    }
                  }
                } else {
                  break _v0$16;
                }
              }
            } else {
              break _v0$16;
            }
          }
        return $elm$core$Maybe$Nothing;
      };
      var $icidasset$elm_binary$Binary$toHex = function(_v0) {
        var bits = _v0.a;
        var missingLeadingZeros = 4 - A2(
          $elm$core$Basics$modBy,
          4,
          $elm$core$List$length(bits)
        );
        var bitsWithLeadingZeros = !missingLeadingZeros || missingLeadingZeros === 4 ? bits : _Utils_ap(
          A2($elm$core$List$repeat, missingLeadingZeros, false),
          bits
        );
        return $elm$core$String$fromList(
          A2(
            $elm$core$List$map,
            A2(
              $elm$core$Basics$composeR,
              $icidasset$elm_binary$Binary$binaryToHexChar,
              $elm$core$Maybe$withDefault(
                _Utils_chr("0")
              )
            ),
            A2($elm_community$list_extra$List$Extra$greedyGroupsOf, 4, bitsWithLeadingZeros)
          )
        );
      };
      var $elm$core$String$trim = _String_trim;
      var $elm$time$Time$utc = A2($elm$time$Time$Zone, 0, _List_Nil);
      var $ryannhg$date_format$DateFormat$YearNumber = { $: "YearNumber" };
      var $ryannhg$date_format$DateFormat$yearNumber = $ryannhg$date_format$DateFormat$YearNumber;
      var $author$project$Sources$Services$AmazonS3$Presign$presignedUrl = F6(
        function(method, lifeExpectancyInSeconds, extraParams, currentTime, srcData, pathToFile) {
          var timestamp = A3(
            $ryannhg$date_format$DateFormat$format,
            _List_fromArray(
              [
                $ryannhg$date_format$DateFormat$yearNumber,
                $ryannhg$date_format$DateFormat$monthFixed,
                $ryannhg$date_format$DateFormat$dayOfMonthFixed,
                $ryannhg$date_format$DateFormat$text("T"),
                $ryannhg$date_format$DateFormat$hourMilitaryFixed,
                $ryannhg$date_format$DateFormat$minuteFixed,
                $ryannhg$date_format$DateFormat$secondFixed,
                $ryannhg$date_format$DateFormat$text("Z")
              ]
            ),
            $elm$time$Time$utc,
            currentTime
          );
          var date = A3(
            $ryannhg$date_format$DateFormat$format,
            _List_fromArray(
              [$ryannhg$date_format$DateFormat$yearNumber, $ryannhg$date_format$DateFormat$monthFixed, $ryannhg$date_format$DateFormat$dayOfMonthFixed]
            ),
            $elm$time$Time$utc,
            currentTime
          );
          var aws = srcData;
          var bucketName = A2($author$project$Dict$Ext$fetchUnknown, "bucketName", aws);
          var customHost = function() {
            var _v2 = A3($author$project$Dict$Ext$fetch, "host", "", aws);
            if (_v2 === "") {
              return $elm$core$Maybe$Nothing;
            } else {
              var x = _v2;
              return $elm$core$Maybe$Just(x);
            }
          }();
          var filePathPrefix = $elm_community$maybe_extra$Maybe$Extra$isJust(customHost) ? bucketName + "/" : "";
          var filePath = A2(
            $elm$core$String$append,
            "/" + filePathPrefix,
            A2(
              $elm$core$String$join,
              "/",
              A2(
                $elm$core$List$map,
                A2($elm$core$Basics$composeR, $elm$url$Url$percentEncode, $author$project$Sources$Services$AmazonS3$Presign$encodeAdditionalCharacters),
                A2(
                  $elm$core$String$split,
                  "/",
                  A2($author$project$String$Ext$chopStart, "/", pathToFile)
                )
              )
            )
          );
          var protocol = A2(
            $elm$core$String$contains,
            "http://",
            A2($elm$core$Maybe$withDefault, "", customHost)
          ) ? "http://" : "https://";
          var region = A2($author$project$Dict$Ext$fetchUnknown, "region", aws);
          var credential = A2(
            $elm$core$String$join,
            "/",
            _List_fromArray(
              [
                A2($author$project$Dict$Ext$fetchUnknown, "accessKey", aws),
                date,
                region,
                "s3",
                "aws4_request"
              ]
            )
          );
          var queryString = $author$project$Sources$Services$AmazonS3$Presign$encodeAdditionalCharacters(
            A2(
              $elm$core$String$dropLeft,
              1,
              $author$project$Common$queryString(
                A2(
                  $elm$core$List$sortBy,
                  $elm$core$Tuple$first,
                  A2(
                    $elm$core$List$append,
                    extraParams,
                    _List_fromArray(
                      [
                        _Utils_Tuple2("X-Amz-Algorithm", "AWS4-HMAC-SHA256"),
                        _Utils_Tuple2("X-Amz-Credential", credential),
                        _Utils_Tuple2("X-Amz-Date", timestamp),
                        _Utils_Tuple2(
                          "X-Amz-Expires",
                          $elm$core$String$fromInt(lifeExpectancyInSeconds)
                        ),
                        _Utils_Tuple2("X-Amz-SignedHeaders", "host")
                      ]
                    )
                  )
                )
              )
            )
          );
          var host = function() {
            if (customHost.$ === "Just") {
              var h = customHost.a;
              return A2(
                $author$project$String$Ext$chopEnd,
                "/",
                A2(
                  $author$project$String$Ext$chopStart,
                  "https://",
                  A2($author$project$String$Ext$chopStart, "http://", h)
                )
              );
            } else {
              var _v1 = $elm$core$String$trim(region);
              if (_v1 === "") {
                return bucketName + ".s3.amazonaws.com";
              } else {
                var r = _v1;
                return bucketName + (".s3." + (r + ".amazonaws.com"));
              }
            }
          }();
          var request = A2(
            $elm$core$String$join,
            "\n",
            _List_fromArray(
              [
                $author$project$Sources$Processing$httpMethod(method),
                filePath,
                queryString,
                "host:" + host,
                "",
                "host",
                "UNSIGNED-PAYLOAD"
              ]
            )
          );
          var stringToSign = A2(
            $elm$core$String$join,
            "\n",
            _List_fromArray(
              [
                "AWS4-HMAC-SHA256",
                timestamp,
                A2(
                  $elm$core$String$join,
                  "/",
                  _List_fromArray(
                    [date, region, "s3", "aws4_request"]
                  )
                ),
                $elm$core$String$toLower(
                  $icidasset$elm_binary$Binary$toHex(
                    $icidasset$elm_sha$SHA$sha256(
                      $icidasset$elm_binary$Binary$fromStringAsUtf8(request)
                    )
                  )
                )
              ]
            )
          );
          var signature = $elm$core$String$toLower(
            $icidasset$elm_binary$Binary$toHex(
              A2(
                $author$project$Sources$Services$AmazonS3$Presign$hmacSha256,
                stringToSign,
                A2(
                  $author$project$Sources$Services$AmazonS3$Presign$hmacSha256,
                  "aws4_request",
                  A2(
                    $author$project$Sources$Services$AmazonS3$Presign$hmacSha256,
                    "s3",
                    A2(
                      $author$project$Sources$Services$AmazonS3$Presign$hmacSha256,
                      region,
                      A2(
                        $author$project$Sources$Services$AmazonS3$Presign$hmacSha256,
                        date,
                        $icidasset$elm_binary$Binary$fromStringAsUtf8(
                          "AWS4" + A2($author$project$Dict$Ext$fetchUnknown, "secretKey", aws)
                        )
                      )
                    )
                  )
                )
              )
            )
          );
          return $elm$core$String$concat(
            _List_fromArray(
              [protocol, host, filePath, "?", queryString, "&X-Amz-Signature=", signature]
            )
          );
        }
      );
      var $author$project$Sources$Services$AmazonS3$makeTrackUrl = F5(
        function(currentTime, _v0, srcData, method, pathToFile) {
          return A6($author$project$Sources$Services$AmazonS3$Presign$presignedUrl, method, 172800, _List_Nil, currentTime, srcData, pathToFile);
        }
      );
      var $author$project$Sources$Services$Azure$Authorization$Blob = { $: "Blob" };
      var $author$project$Sources$Services$Azure$Authorization$Read = { $: "Read" };
      var $icidasset$elm_binary$Binary$chunksOf = F2(
        function(n, _v0) {
          var bits = _v0.a;
          return A2(
            $elm$core$List$map,
            $icidasset$elm_binary$Binary$Bits,
            A2($elm_community$list_extra$List$Extra$greedyGroupsOf, n, bits)
          );
        }
      );
      var $elm_community$list_extra$List$Extra$takeWhile = function(predicate) {
        var takeWhileMemo = F2(
          function(memo, list) {
            takeWhileMemo:
              while (true) {
                if (!list.b) {
                  return $elm$core$List$reverse(memo);
                } else {
                  var x = list.a;
                  var xs = list.b;
                  if (predicate(x)) {
                    var $temp$memo = A2($elm$core$List$cons, x, memo), $temp$list = xs;
                    memo = $temp$memo;
                    list = $temp$list;
                    continue takeWhileMemo;
                  } else {
                    return $elm$core$List$reverse(memo);
                  }
                }
              }
          }
        );
        return takeWhileMemo(_List_Nil);
      };
      var $newlandsvalley$elm_binary_base64$BinaryBase64$dcd = function(cs) {
        return A2(
          $elm$core$List$map,
          function(h) {
            return _Utils_cmp(
              h,
              _Utils_chr("Z")
            ) < 1 && _Utils_cmp(
              h,
              _Utils_chr("A")
            ) > -1 ? $elm$core$Char$toCode(h) - $elm$core$Char$toCode(
              _Utils_chr("A")
            ) : _Utils_cmp(
              h,
              _Utils_chr("0")
            ) > -1 && _Utils_cmp(
              h,
              _Utils_chr("9")
            ) < 1 ? $elm$core$Char$toCode(h) - $elm$core$Char$toCode(
              _Utils_chr("0")
            ) + 52 : _Utils_cmp(
              h,
              _Utils_chr("a")
            ) > -1 && _Utils_cmp(
              h,
              _Utils_chr("z")
            ) < 1 ? $elm$core$Char$toCode(h) - $elm$core$Char$toCode(
              _Utils_chr("a")
            ) + 26 : _Utils_eq(
              h,
              _Utils_chr("+")
            ) ? 62 : _Utils_eq(
              h,
              _Utils_chr("/")
            ) ? 63 : 0;
          },
          A2(
            $elm_community$list_extra$List$Extra$takeWhile,
            function(a) {
              return !_Utils_eq(
                a,
                _Utils_chr("=")
              );
            },
            cs
          )
        );
      };
      var $elm$core$Char$fromCode = _Char_fromCode;
      var $elm$core$Bitwise$or = _Bitwise_or;
      var $elm$core$Bitwise$shiftRightBy = _Bitwise_shiftRightBy;
      var $newlandsvalley$elm_binary_base64$BinaryBase64$int4_char3 = function(is) {
        var groupsOfFour = function(values) {
          var grouper = F2(
            function(elem, acc) {
              if (!acc.b) {
                return _List_fromArray(
                  [
                    _List_fromArray(
                      [elem]
                    )
                  ]
                );
              } else {
                var x = acc.a;
                var xs = acc.b;
                return $elm$core$List$length(x) === 4 ? A2(
                  $elm$core$List$cons,
                  _List_fromArray(
                    [elem]
                  ),
                  acc
                ) : A2(
                  $elm$core$List$cons,
                  _Utils_ap(
                    x,
                    _List_fromArray(
                      [elem]
                    )
                  ),
                  xs
                );
              }
            }
          );
          return $elm$core$List$reverse(
            A3($elm$core$List$foldl, grouper, _List_Nil, values)
          );
        };
        return $elm$core$List$concat(
          A2(
            $elm$core$List$map,
            function(subgroup) {
              if (subgroup.b) {
                if (subgroup.b.b) {
                  if (subgroup.b.b.b) {
                    if (subgroup.b.b.b.b) {
                      var a = subgroup.a;
                      var _v1 = subgroup.b;
                      var b = _v1.a;
                      var _v2 = _v1.b;
                      var c = _v2.a;
                      var _v3 = _v2.b;
                      var d = _v3.a;
                      var t = _v3.b;
                      var n = a << 18 | b << 12 | (c << 6 | d);
                      return A2(
                        $elm$core$List$cons,
                        $elm$core$Char$fromCode(n >> 16 & 255),
                        A2(
                          $elm$core$List$cons,
                          $elm$core$Char$fromCode(n >> 8 & 255),
                          A2(
                            $elm$core$List$cons,
                            $elm$core$Char$fromCode(n & 255),
                            _List_Nil
                          )
                        )
                      );
                    } else {
                      var a = subgroup.a;
                      var _v4 = subgroup.b;
                      var b = _v4.a;
                      var _v5 = _v4.b;
                      var c = _v5.a;
                      var n = a << 18 | b << 12 | c << 6;
                      return _List_fromArray(
                        [
                          $elm$core$Char$fromCode(n >> 16 & 255),
                          $elm$core$Char$fromCode(n >> 8 & 255)
                        ]
                      );
                    }
                  } else {
                    var a = subgroup.a;
                    var _v6 = subgroup.b;
                    var b = _v6.a;
                    var n = a << 18 | b << 12;
                    return _List_fromArray(
                      [
                        $elm$core$Char$fromCode(n >> 16 & 255)
                      ]
                    );
                  }
                } else {
                  return _List_Nil;
                }
              } else {
                return _List_Nil;
              }
            },
            groupsOfFour(is)
          )
        );
      };
      var $newlandsvalley$elm_binary_base64$BinaryBase64$decodeString = A2(
        $elm$core$Basics$composeR,
        $elm$core$String$toList,
        A2(
          $elm$core$Basics$composeR,
          $newlandsvalley$elm_binary_base64$BinaryBase64$dcd,
          A2(
            $elm$core$Basics$composeR,
            $newlandsvalley$elm_binary_base64$BinaryBase64$int4_char3,
            $elm$core$List$map($elm$core$Char$toCode)
          )
        )
      );
      var $newlandsvalley$elm_binary_base64$BinaryBase64$encodeArray = $elm$core$Array$fromList(
        _List_fromArray(
          [
            _Utils_chr("A"),
            _Utils_chr("B"),
            _Utils_chr("C"),
            _Utils_chr("D"),
            _Utils_chr("E"),
            _Utils_chr("F"),
            _Utils_chr("G"),
            _Utils_chr("H"),
            _Utils_chr("I"),
            _Utils_chr("J"),
            _Utils_chr("K"),
            _Utils_chr("L"),
            _Utils_chr("M"),
            _Utils_chr("N"),
            _Utils_chr("O"),
            _Utils_chr("P"),
            _Utils_chr("Q"),
            _Utils_chr("R"),
            _Utils_chr("S"),
            _Utils_chr("T"),
            _Utils_chr("U"),
            _Utils_chr("V"),
            _Utils_chr("W"),
            _Utils_chr("X"),
            _Utils_chr("Y"),
            _Utils_chr("Z"),
            _Utils_chr("a"),
            _Utils_chr("b"),
            _Utils_chr("c"),
            _Utils_chr("d"),
            _Utils_chr("e"),
            _Utils_chr("f"),
            _Utils_chr("g"),
            _Utils_chr("h"),
            _Utils_chr("i"),
            _Utils_chr("j"),
            _Utils_chr("k"),
            _Utils_chr("l"),
            _Utils_chr("m"),
            _Utils_chr("n"),
            _Utils_chr("o"),
            _Utils_chr("p"),
            _Utils_chr("q"),
            _Utils_chr("r"),
            _Utils_chr("s"),
            _Utils_chr("t"),
            _Utils_chr("u"),
            _Utils_chr("v"),
            _Utils_chr("w"),
            _Utils_chr("x"),
            _Utils_chr("y"),
            _Utils_chr("z"),
            _Utils_chr("0"),
            _Utils_chr("1"),
            _Utils_chr("2"),
            _Utils_chr("3"),
            _Utils_chr("4"),
            _Utils_chr("5"),
            _Utils_chr("6"),
            _Utils_chr("7"),
            _Utils_chr("8"),
            _Utils_chr("9"),
            _Utils_chr("+"),
            _Utils_chr("/")
          ]
        )
      );
      var $elm$core$List$any = F2(
        function(isOkay, list) {
          any:
            while (true) {
              if (!list.b) {
                return false;
              } else {
                var x = list.a;
                var xs = list.b;
                if (isOkay(x)) {
                  return true;
                } else {
                  var $temp$isOkay = isOkay, $temp$list = xs;
                  isOkay = $temp$isOkay;
                  list = $temp$list;
                  continue any;
                }
              }
            }
        }
      );
      var $elm$core$List$member = F2(
        function(x, xs) {
          return A2(
            $elm$core$List$any,
            function(a) {
              return _Utils_eq(a, x);
            },
            xs
          );
        }
      );
      var $newlandsvalley$elm_binary_base64$BinaryBase64$isBase64Char = function(c) {
        return A2(
          $elm$core$List$member,
          c,
          $elm$core$Array$toList($newlandsvalley$elm_binary_base64$BinaryBase64$encodeArray)
        ) || _Utils_eq(
          c,
          _Utils_chr("=")
        );
      };
      var $newlandsvalley$elm_binary_base64$BinaryBase64$isBase64 = $elm$core$String$all($newlandsvalley$elm_binary_base64$BinaryBase64$isBase64Char);
      var $newlandsvalley$elm_binary_base64$BinaryBase64$decode = function(s) {
        return $newlandsvalley$elm_binary_base64$BinaryBase64$isBase64(s) ? $elm$core$Result$Ok(
          $newlandsvalley$elm_binary_base64$BinaryBase64$decodeString(s)
        ) : $elm$core$Result$Err("invalid Base64 string");
      };
      var $newlandsvalley$elm_binary_base64$BinaryBase64$char3_int4_fold = F2(
        function(cs, acc) {
          char3_int4_fold:
            while (true) {
              if (cs.b) {
                if (cs.b.b) {
                  if (cs.b.b.b) {
                    var a = cs.a;
                    var _v1 = cs.b;
                    var b = _v1.a;
                    var _v2 = _v1.b;
                    var c = _v2.a;
                    var t = _v2.b;
                    var n = $elm$core$Char$toCode(c) | ($elm$core$Char$toCode(a) << 16 | $elm$core$Char$toCode(b) << 8);
                    var $temp$cs = t, $temp$acc = _Utils_ap(
                      acc,
                      _List_fromArray(
                        [n >> 18 & 63, n >> 12 & 63, n >> 6 & 63, n & 63]
                      )
                    );
                    cs = $temp$cs;
                    acc = $temp$acc;
                    continue char3_int4_fold;
                  } else {
                    var a = cs.a;
                    var _v3 = cs.b;
                    var b = _v3.a;
                    var n = $elm$core$Char$toCode(a) << 16 | $elm$core$Char$toCode(b) << 8;
                    return _Utils_ap(
                      acc,
                      _List_fromArray(
                        [n >> 18 & 63, n >> 12 & 63, n >> 6 & 63]
                      )
                    );
                  }
                } else {
                  var a = cs.a;
                  var n = $elm$core$Char$toCode(a) << 16;
                  return _Utils_ap(
                    acc,
                    _List_fromArray(
                      [n >> 18 & 63, n >> 12 & 63]
                    )
                  );
                }
              } else {
                return acc;
              }
            }
        }
      );
      var $newlandsvalley$elm_binary_base64$BinaryBase64$char3_int4 = function(cs) {
        return A2($newlandsvalley$elm_binary_base64$BinaryBase64$char3_int4_fold, cs, _List_Nil);
      };
      var $newlandsvalley$elm_binary_base64$BinaryBase64$enc1 = function(i) {
        return A2(
          $elm$core$Maybe$withDefault,
          _Utils_chr("?"),
          A2($elm$core$Array$get, i, $newlandsvalley$elm_binary_base64$BinaryBase64$encodeArray)
        );
      };
      var $newlandsvalley$elm_binary_base64$BinaryBase64$quadruplets_fold = F2(
        function(cs, acc) {
          quadruplets_fold:
            while (true) {
              if (cs.b) {
                if (cs.b.b) {
                  if (cs.b.b.b) {
                    if (cs.b.b.b.b) {
                      var a = cs.a;
                      var _v1 = cs.b;
                      var b = _v1.a;
                      var _v2 = _v1.b;
                      var c = _v2.a;
                      var _v3 = _v2.b;
                      var d = _v3.a;
                      var t = _v3.b;
                      var $temp$cs = t, $temp$acc = _Utils_ap(
                        acc,
                        _List_fromArray(
                          [a, b, c, d]
                        )
                      );
                      cs = $temp$cs;
                      acc = $temp$acc;
                      continue quadruplets_fold;
                    } else {
                      var a = cs.a;
                      var _v4 = cs.b;
                      var b = _v4.a;
                      var _v5 = _v4.b;
                      var c = _v5.a;
                      return _Utils_ap(
                        acc,
                        _List_fromArray(
                          [
                            a,
                            b,
                            c,
                            _Utils_chr("=")
                          ]
                        )
                      );
                    }
                  } else {
                    var a = cs.a;
                    var _v6 = cs.b;
                    var b = _v6.a;
                    return _Utils_ap(
                      acc,
                      _List_fromArray(
                        [
                          a,
                          b,
                          _Utils_chr("="),
                          _Utils_chr("=")
                        ]
                      )
                    );
                  }
                } else {
                  return _List_Nil;
                }
              } else {
                return acc;
              }
            }
        }
      );
      var $newlandsvalley$elm_binary_base64$BinaryBase64$quadruplets = function(cs) {
        return A2($newlandsvalley$elm_binary_base64$BinaryBase64$quadruplets_fold, cs, _List_Nil);
      };
      var $newlandsvalley$elm_binary_base64$BinaryBase64$enc = A2(
        $elm$core$Basics$composeR,
        $elm$core$List$map($newlandsvalley$elm_binary_base64$BinaryBase64$enc1),
        $newlandsvalley$elm_binary_base64$BinaryBase64$quadruplets
      );
      var $newlandsvalley$elm_binary_base64$BinaryBase64$encode = A2(
        $elm$core$Basics$composeR,
        $elm$core$List$map($elm$core$Char$fromCode),
        A2(
          $elm$core$Basics$composeR,
          $newlandsvalley$elm_binary_base64$BinaryBase64$char3_int4,
          A2($elm$core$Basics$composeR, $newlandsvalley$elm_binary_base64$BinaryBase64$enc, $elm$core$String$fromList)
        )
      );
      var $elm$core$Basics$pow = _Basics_pow;
      var $icidasset$elm_binary$Binary$toDecimal = function(_v0) {
        var bits = _v0.a;
        return A3(
          $elm$core$List$foldl,
          F2(
            function(bit, _v1) {
              var x = _v1.a;
              var exponent = _v1.b;
              return _Utils_Tuple2(
                A2($elm$core$Basics$pow, 2, exponent) * A3($icidasset$elm_binary$Binary$ifThenElse, bit, 1, 0) + x,
                exponent - 1
              );
            }
          ),
          _Utils_Tuple2(
            0,
            $elm$core$List$length(bits) - 1
          ),
          bits
        ).a;
      };
      var $author$project$Sources$Services$Azure$Authorization$makeSignature = function(_v0) {
        var accountKey = _v0.accountKey;
        var accountName = _v0.accountName;
        var expiryTime = _v0.expiryTime;
        var permissions = _v0.permissions;
        var protocol = _v0.protocol;
        var resources = _v0.resources;
        var services = _v0.services;
        var startTime = _v0.startTime;
        var version = _v0.version;
        var message = A2(
          $elm$core$String$join,
          "\n",
          _List_fromArray(
            [accountName, permissions, services, resources, startTime, expiryTime, "", protocol, version + "\n"]
          )
        );
        return $newlandsvalley$elm_binary_base64$BinaryBase64$encode(
          A2(
            $elm$core$List$map,
            $icidasset$elm_binary$Binary$toDecimal,
            A2(
              $icidasset$elm_binary$Binary$chunksOf,
              8,
              A3(
                $author$project$Cryptography$Hmac$encrypt64,
                $icidasset$elm_sha$SHA$sha256,
                message,
                $icidasset$elm_binary$Binary$concat(
                  A2(
                    $elm$core$List$map,
                    A2(
                      $elm$core$Basics$composeR,
                      $icidasset$elm_binary$Binary$fromDecimal,
                      $icidasset$elm_binary$Binary$ensureSize(8)
                    ),
                    A2(
                      $elm$core$Result$withDefault,
                      _List_Nil,
                      $newlandsvalley$elm_binary_base64$BinaryBase64$decode(accountKey)
                    )
                  )
                )
              )
            )
          )
        );
      };
      var $author$project$Sources$Services$Azure$Authorization$presignedUrl = F8(
        function(storageMethod, computation, _v0, _v1, currentTime, srcData, pathToFile, params) {
          var resourceType = function() {
            if (storageMethod.$ === "Blob") {
              return "blob";
            } else {
              return "file";
            }
          }();
          var resType = function() {
            if (storageMethod.$ === "Blob") {
              return "container";
            } else {
              return "directory";
            }
          }();
          var permissions = function() {
            if (computation.$ === "List") {
              return "l";
            } else {
              return "r";
            }
          }();
          var expiryTime = A3(
            $ryannhg$date_format$DateFormat$format,
            _List_fromArray(
              [
                $ryannhg$date_format$DateFormat$yearNumber,
                $ryannhg$date_format$DateFormat$text("-"),
                $ryannhg$date_format$DateFormat$monthFixed,
                $ryannhg$date_format$DateFormat$text("-"),
                $ryannhg$date_format$DateFormat$dayOfMonthFixed,
                $ryannhg$date_format$DateFormat$text("T"),
                $ryannhg$date_format$DateFormat$hourMilitaryFixed,
                $ryannhg$date_format$DateFormat$text(":"),
                $ryannhg$date_format$DateFormat$minuteFixed,
                $ryannhg$date_format$DateFormat$text("Z")
              ]
            ),
            $elm$time$Time$utc,
            $elm$time$Time$millisToPosix(
              36e5 + $elm$time$Time$posixToMillis(currentTime)
            )
          );
          var azure = srcData;
          var container = A2($author$project$Dict$Ext$fetchUnknown, "container", azure);
          var accountName = A2($author$project$Dict$Ext$fetchUnknown, "accountName", azure);
          var accountKey = A2($author$project$Dict$Ext$fetchUnknown, "accountKey", azure);
          var signatureStuff = { accountKey, accountName, expiryTime, permissions, protocol: "https", resources: "co", services: "bf", startTime: "", version: "2017-04-17" };
          return $elm$core$String$concat(
            _List_fromArray(
              [
                "https://",
                $elm$url$Url$percentEncode(accountName),
                ".",
                $elm$url$Url$percentEncode(resourceType),
                ".core.windows.net/",
                $elm$url$Url$percentEncode(container),
                "/",
                $elm$url$Url$percentEncode(
                  A2($author$project$String$Ext$chopStart, "/", pathToFile)
                ),
                function() {
                  var _v2 = $author$project$Common$queryString(params);
                  if (_v2 === "") {
                    return "?";
                  } else {
                    var qs = _v2;
                    return qs;
                  }
                }(),
                function() {
                  if (computation.$ === "List") {
                    return "&restype=" + (resType + "&comp=list");
                  } else {
                    return "";
                  }
                }(),
                "&sv=",
                $elm$url$Url$percentEncode(signatureStuff.version),
                "&ss=",
                $elm$url$Url$percentEncode(signatureStuff.services),
                "&srt=",
                $elm$url$Url$percentEncode(signatureStuff.resources),
                "&sp=",
                $elm$url$Url$percentEncode(signatureStuff.permissions),
                "&se=",
                $elm$url$Url$percentEncode(signatureStuff.expiryTime),
                "&spr=",
                $elm$url$Url$percentEncode(signatureStuff.protocol),
                "&sig=",
                $elm$url$Url$percentEncode(
                  $author$project$Sources$Services$Azure$Authorization$makeSignature(signatureStuff)
                )
              ]
            )
          );
        }
      );
      var $author$project$Sources$Services$AzureBlob$makeTrackUrl = F5(
        function(currentTime, _v0, srcData, _v1, pathToFile) {
          return A8($author$project$Sources$Services$Azure$Authorization$presignedUrl, $author$project$Sources$Services$Azure$Authorization$Blob, $author$project$Sources$Services$Azure$Authorization$Read, $author$project$Sources$Processing$Get, 48, currentTime, srcData, pathToFile, _List_Nil);
        }
      );
      var $author$project$Sources$Services$Azure$Authorization$File = { $: "File" };
      var $author$project$Sources$Services$AzureFile$makeTrackUrl = F5(
        function(currentTime, _v0, srcData, _v1, pathToFile) {
          return A8($author$project$Sources$Services$Azure$Authorization$presignedUrl, $author$project$Sources$Services$Azure$Authorization$File, $author$project$Sources$Services$Azure$Authorization$Read, $author$project$Sources$Processing$Get, 48, currentTime, srcData, pathToFile, _List_Nil);
        }
      );
      var $author$project$Sources$Services$Ipfs$encodedPath = function(path) {
        return A2(
          $elm$core$String$join,
          "/",
          A2(
            $elm$core$List$map,
            $elm$url$Url$percentEncode,
            A2($elm$core$String$split, "/", path)
          )
        );
      };
      var $author$project$Sources$Services$Ipfs$defaultGateway = "https://ipfs.io";
      var $author$project$Sources$Services$Ipfs$extractGateway = function(srcData) {
        return A2(
          $elm$core$Maybe$withDefault,
          $author$project$Sources$Services$Ipfs$defaultGateway,
          A2(
            $elm$core$Maybe$map,
            $author$project$String$Ext$chopEnd("/"),
            A2(
              $elm$core$Maybe$andThen,
              function(s) {
                if (s === "") {
                  return $elm$core$Maybe$Nothing;
                } else {
                  return $elm$core$Maybe$Just(s);
                }
              },
              A2(
                $elm$core$Maybe$map,
                $elm$core$String$trim,
                A2($elm$core$Dict$get, "gateway", srcData)
              )
            )
          )
        );
      };
      var $author$project$Sources$Services$Ipfs$pathIsDnsLink = $elm$core$String$contains(".");
      var $author$project$Sources$Services$Ipfs$rootHash = function(srcData) {
        return A2(
          $author$project$String$Ext$chopEnd,
          "/",
          A2(
            $elm$core$Maybe$withDefault,
            "",
            A2(
              $elm$core$Maybe$andThen,
              function(path) {
                return $author$project$Sources$Services$Ipfs$pathIsDnsLink(path) ? A2($elm$core$Dict$get, "directoryHashFromDnsLink", srcData) : $elm$core$Maybe$Just(path);
              },
              A2($elm$core$Dict$get, "directoryHash", srcData)
            )
          )
        );
      };
      var $author$project$Sources$Services$Btfs$makeTrackUrl = F5(
        function(_v0, _v1, srcData, _v2, path) {
          return $author$project$Sources$Services$Ipfs$extractGateway(srcData) + ("/btfs/" + ($author$project$Sources$Services$Ipfs$rootHash(srcData) + ("/" + $author$project$Sources$Services$Ipfs$encodedPath(path))));
        }
      );
      var $author$project$Sources$Services$Dropbox$makeTrackUrl = F5(
        function(_v0, _v1, srcData, _v2, pathToFile) {
          return "dropbox://" + (A3($author$project$Dict$Ext$fetch, "accessToken", "", srcData) + ("@" + pathToFile));
        }
      );
      var $author$project$String$Path$sep = "/";
      var $author$project$String$Path$file = function(path) {
        return A2(
          $elm$core$Maybe$withDefault,
          path,
          $elm_community$list_extra$List$Extra$last(
            A2($elm$core$String$split, $author$project$String$Path$sep, path)
          )
        );
      };
      var $author$project$Sources$Services$Google$makeTrackUrl = F5(
        function(currentTime, srcId, srcData, _v0, path) {
          var now = $elm$time$Time$posixToMillis(currentTime);
          var file = $author$project$String$Path$file(path);
          var fileId = A2(
            $elm$core$Maybe$withDefault,
            file,
            $elm$core$List$head(
              A2($elm$core$String$split, "?", file)
            )
          );
          var expiresAt = A3(
            $author$project$Dict$Ext$fetch,
            "expiresAt",
            $elm$core$String$fromInt(now),
            srcData
          );
          return $elm$core$String$concat(
            _List_fromArray(
              [
                "google://",
                A3($author$project$Dict$Ext$fetch, "accessToken", "", srcData),
                ":",
                expiresAt,
                ":",
                A3($author$project$Dict$Ext$fetch, "refreshToken", "", srcData),
                ":",
                A3($author$project$Dict$Ext$fetch, "clientId", "", srcData),
                ":",
                A3($author$project$Dict$Ext$fetch, "clientSecret", "", srcData),
                ":",
                srcId,
                "@",
                fileId
              ]
            )
          );
        }
      );
      var $author$project$Sources$Services$Ipfs$makeTrackUrl = F5(
        function(_v0, _v1, srcData, _v2, path) {
          return !A2($elm$core$String$contains, "/", path) && !A2($elm$core$String$contains, ".", path) ? $author$project$Sources$Services$Ipfs$extractGateway(srcData) + ("/ipfs/" + path) : $author$project$Sources$Services$Ipfs$extractGateway(srcData) + ("/ipfs/" + ($author$project$Sources$Services$Ipfs$rootHash(srcData) + ("/" + $author$project$Sources$Services$Ipfs$encodedPath(path))));
        }
      );
      var $truqu$elm_base64$Base64$Encode$intToBase64 = function(i) {
        switch (i) {
          case 0:
            return "A";
          case 1:
            return "B";
          case 2:
            return "C";
          case 3:
            return "D";
          case 4:
            return "E";
          case 5:
            return "F";
          case 6:
            return "G";
          case 7:
            return "H";
          case 8:
            return "I";
          case 9:
            return "J";
          case 10:
            return "K";
          case 11:
            return "L";
          case 12:
            return "M";
          case 13:
            return "N";
          case 14:
            return "O";
          case 15:
            return "P";
          case 16:
            return "Q";
          case 17:
            return "R";
          case 18:
            return "S";
          case 19:
            return "T";
          case 20:
            return "U";
          case 21:
            return "V";
          case 22:
            return "W";
          case 23:
            return "X";
          case 24:
            return "Y";
          case 25:
            return "Z";
          case 26:
            return "a";
          case 27:
            return "b";
          case 28:
            return "c";
          case 29:
            return "d";
          case 30:
            return "e";
          case 31:
            return "f";
          case 32:
            return "g";
          case 33:
            return "h";
          case 34:
            return "i";
          case 35:
            return "j";
          case 36:
            return "k";
          case 37:
            return "l";
          case 38:
            return "m";
          case 39:
            return "n";
          case 40:
            return "o";
          case 41:
            return "p";
          case 42:
            return "q";
          case 43:
            return "r";
          case 44:
            return "s";
          case 45:
            return "t";
          case 46:
            return "u";
          case 47:
            return "v";
          case 48:
            return "w";
          case 49:
            return "x";
          case 50:
            return "y";
          case 51:
            return "z";
          case 52:
            return "0";
          case 53:
            return "1";
          case 54:
            return "2";
          case 55:
            return "3";
          case 56:
            return "4";
          case 57:
            return "5";
          case 58:
            return "6";
          case 59:
            return "7";
          case 60:
            return "8";
          case 61:
            return "9";
          case 62:
            return "+";
          default:
            return "/";
        }
      };
      var $truqu$elm_base64$Base64$Encode$toBase64 = function(_int) {
        return _Utils_ap(
          $truqu$elm_base64$Base64$Encode$intToBase64(63 & _int >>> 18),
          _Utils_ap(
            $truqu$elm_base64$Base64$Encode$intToBase64(63 & _int >>> 12),
            _Utils_ap(
              $truqu$elm_base64$Base64$Encode$intToBase64(63 & _int >>> 6),
              $truqu$elm_base64$Base64$Encode$intToBase64(63 & _int >>> 0)
            )
          )
        );
      };
      var $truqu$elm_base64$Base64$Encode$add = F2(
        function(_char, _v0) {
          var res = _v0.a;
          var count = _v0.b;
          var acc = _v0.c;
          var current = acc << 8 | _char;
          if (count === 2) {
            return _Utils_Tuple3(
              _Utils_ap(
                res,
                $truqu$elm_base64$Base64$Encode$toBase64(current)
              ),
              0,
              0
            );
          } else {
            return _Utils_Tuple3(res, count + 1, current);
          }
        }
      );
      var $truqu$elm_base64$Base64$Encode$chomp = F2(
        function(char_, acc) {
          var _char = $elm$core$Char$toCode(char_);
          return _char < 128 ? A2($truqu$elm_base64$Base64$Encode$add, _char, acc) : _char < 2048 ? A2(
            $truqu$elm_base64$Base64$Encode$add,
            128 | 63 & _char,
            A2($truqu$elm_base64$Base64$Encode$add, 192 | _char >>> 6, acc)
          ) : _char < 55296 || _char >= 57344 && _char <= 65535 ? A2(
            $truqu$elm_base64$Base64$Encode$add,
            128 | 63 & _char,
            A2(
              $truqu$elm_base64$Base64$Encode$add,
              128 | 63 & _char >>> 6,
              A2($truqu$elm_base64$Base64$Encode$add, 224 | _char >>> 12, acc)
            )
          ) : A2(
            $truqu$elm_base64$Base64$Encode$add,
            128 | 63 & _char,
            A2(
              $truqu$elm_base64$Base64$Encode$add,
              128 | 63 & _char >>> 6,
              A2(
                $truqu$elm_base64$Base64$Encode$add,
                128 | 63 & _char >>> 12,
                A2($truqu$elm_base64$Base64$Encode$add, 240 | _char >>> 18, acc)
              )
            )
          );
        }
      );
      var $elm$core$String$foldl = _String_foldl;
      var $truqu$elm_base64$Base64$Encode$initial = _Utils_Tuple3("", 0, 0);
      var $truqu$elm_base64$Base64$Encode$wrapUp = function(_v0) {
        var res = _v0.a;
        var cnt = _v0.b;
        var acc = _v0.c;
        switch (cnt) {
          case 1:
            return res + ($truqu$elm_base64$Base64$Encode$intToBase64(63 & acc >>> 2) + ($truqu$elm_base64$Base64$Encode$intToBase64(63 & acc << 4) + "=="));
          case 2:
            return res + ($truqu$elm_base64$Base64$Encode$intToBase64(63 & acc >>> 10) + ($truqu$elm_base64$Base64$Encode$intToBase64(63 & acc >>> 4) + ($truqu$elm_base64$Base64$Encode$intToBase64(63 & acc << 2) + "=")));
          default:
            return res;
        }
      };
      var $truqu$elm_base64$Base64$Encode$encode = function(input) {
        return $truqu$elm_base64$Base64$Encode$wrapUp(
          A3($elm$core$String$foldl, $truqu$elm_base64$Base64$Encode$chomp, $truqu$elm_base64$Base64$Encode$initial, input)
        );
      };
      var $truqu$elm_base64$Base64$encode = $truqu$elm_base64$Base64$Encode$encode;
      var $author$project$Sources$Services$WebDav$url = F3(
        function(_v0, srcData, path) {
          var addAuth = _v0.addAuth;
          var username = A3($author$project$Dict$Ext$fetch, "username", "", srcData);
          var password = A3($author$project$Dict$Ext$fetch, "password", "", srcData);
          var host = A2(
            $author$project$String$Ext$chopEnd,
            "/",
            A3($author$project$Dict$Ext$fetch, "url", "", srcData)
          );
          var encodedPath = A2(
            $elm$core$String$join,
            "/",
            A2(
              $elm$core$List$map,
              $elm$url$Url$percentEncode,
              A2(
                $elm$core$String$split,
                "/",
                A2($author$project$String$Ext$chopStart, "/", path)
              )
            )
          );
          var authPrefix = function() {
            var _v1 = _Utils_Tuple2(username, password);
            if (_v1.a === "" && _v1.b === "") {
              return "";
            } else {
              var u = _v1.a;
              var p = _v1.b;
              return u + (":" + p);
            }
          }();
          var authBit = addAuth && $elm$core$String$length(authPrefix) > 0 ? "?service_worker_authentication=" + $elm$url$Url$percentEncode(
            $truqu$elm_base64$Base64$encode(authPrefix)
          ) : "";
          return host + ("/" + (encodedPath + authBit));
        }
      );
      var $author$project$Sources$Services$WebDav$makeTrackUrl = F5(
        function(_v0, _v1, srcData, _v2, filePath) {
          return A3(
            $author$project$Sources$Services$WebDav$url,
            { addAuth: true },
            srcData,
            filePath
          );
        }
      );
      var $author$project$Sources$Services$makeTrackUrl = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return $author$project$Sources$Services$AmazonS3$makeTrackUrl;
          case "AzureBlob":
            return $author$project$Sources$Services$AzureBlob$makeTrackUrl;
          case "AzureFile":
            return $author$project$Sources$Services$AzureFile$makeTrackUrl;
          case "Btfs":
            return $author$project$Sources$Services$Btfs$makeTrackUrl;
          case "Dropbox":
            return $author$project$Sources$Services$Dropbox$makeTrackUrl;
          case "Google":
            return $author$project$Sources$Services$Google$makeTrackUrl;
          case "Ipfs":
            return $author$project$Sources$Services$Ipfs$makeTrackUrl;
          default:
            return $author$project$Sources$Services$WebDav$makeTrackUrl;
        }
      };
      var $author$project$Queue$makeTrackUrl_ = F3(
        function(timestamp, track, source) {
          return A6($author$project$Sources$Services$makeTrackUrl, source.service, timestamp, source.id, source.data, $author$project$Sources$Processing$Get, track.path);
        }
      );
      var $author$project$Queue$makeTrackUrl = F3(
        function(timestamp, sources, track) {
          return A2(
            $elm$core$Maybe$withDefault,
            "<missing-source>",
            A2(
              $elm$core$Maybe$map,
              A2($author$project$Queue$makeTrackUrl_, timestamp, track),
              A2(
                $elm_community$list_extra$List$Extra$find,
                A2(
                  $elm$core$Basics$composeR,
                  function($) {
                    return $.id;
                  },
                  $elm$core$Basics$eq(track.sourceId)
                ),
                sources
              )
            )
          );
        }
      );
      var $elm$core$String$cons = _String_cons;
      var $elm$core$String$fromChar = function(_char) {
        return A2($elm$core$String$cons, _char, "");
      };
      var $elm$core$String$repeatHelp = F3(
        function(n, chunk, result) {
          return n <= 0 ? result : A3(
            $elm$core$String$repeatHelp,
            n >> 1,
            _Utils_ap(chunk, chunk),
            !(n & 1) ? result : _Utils_ap(result, chunk)
          );
        }
      );
      var $elm$core$String$repeat = F2(
        function(n, chunk) {
          return A3($elm$core$String$repeatHelp, n, chunk, "");
        }
      );
      var $elm$core$String$padLeft = F3(
        function(n, _char, string) {
          return _Utils_ap(
            A2(
              $elm$core$String$repeat,
              n - $elm$core$String$length(string),
              $elm$core$String$fromChar(_char)
            ),
            string
          );
        }
      );
      var $author$project$Tracks$PickId = function(a) {
        return { $: "PickId", a };
      };
      var $author$project$Tracks$PickTrack = function(a) {
        return { $: "PickTrack", a };
      };
      var $author$project$Tracks$pick = F2(
        function(ids, collection) {
          return A3(
            $elm$core$List$foldr,
            F2(
              function(picking, acc) {
                if (picking.$ === "PickId") {
                  return acc;
                } else {
                  var track = picking.a;
                  return A2($elm$core$List$cons, track, acc);
                }
              }
            ),
            _List_Nil,
            A3(
              $elm$core$List$foldr,
              function(track) {
                return $elm$core$List$map(
                  function(picking) {
                    if (picking.$ === "PickId") {
                      var id = picking.a;
                      return _Utils_eq(id, track.id) ? $author$project$Tracks$PickTrack(track) : $author$project$Tracks$PickId(id);
                    } else {
                      var p = picking;
                      return p;
                    }
                  }
                );
              },
              A2($elm$core$List$map, $author$project$Tracks$PickId, ids),
              collection
            )
          );
        }
      );
      var $Fresheyeball$elm_return$Return$return = F2(
        function(a, b) {
          return $elm$core$Basics$identity(
            _Utils_Tuple2(a, b)
          );
        }
      );
      var $author$project$Brain$Tracks$State$download = F2(
        function(json, model) {
          var _v0 = A2(
            $elm$core$Result$withDefault,
            _Utils_Tuple2("?", _List_Nil),
            A2($elm$json$Json$Decode$decodeValue, $author$project$Brain$Tracks$State$downloadParamsDecoder, json)
          );
          var zipName = _v0.a;
          var trackIds = _v0.b;
          return A2(
            $Fresheyeball$elm_return$Return$return,
            model,
            $author$project$Brain$Ports$downloadTracks(
              function(encodedTracks) {
                return $elm$json$Json$Encode$object(
                  _List_fromArray(
                    [
                      _Utils_Tuple2(
                        "name",
                        $elm$json$Json$Encode$string(zipName)
                      ),
                      _Utils_Tuple2("tracks", encodedTracks)
                    ]
                  )
                );
              }(
                A2(
                  $elm$json$Json$Encode$list,
                  function(_v1) {
                    var idx = _v1.a;
                    var track = _v1.b;
                    return $elm$json$Json$Encode$object(
                      _List_fromArray(
                        [
                          _Utils_Tuple2(
                            "filename",
                            $elm$json$Json$Encode$string(
                              $elm$core$String$concat(
                                _List_fromArray(
                                  [
                                    A3(
                                      $elm$core$String$padLeft,
                                      2,
                                      _Utils_chr("0"),
                                      $elm$core$String$fromInt(idx + 1)
                                    ),
                                    " - ",
                                    track.tags.artist,
                                    " - ",
                                    track.tags.title
                                  ]
                                )
                              )
                            )
                          ),
                          _Utils_Tuple2(
                            "url",
                            $elm$json$Json$Encode$string(
                              A3($author$project$Queue$makeTrackUrl, model.currentTime, model.hypaethralUserData.sources, track)
                            )
                          )
                        ]
                      )
                    );
                  },
                  A2(
                    $elm$core$List$indexedMap,
                    $elm$core$Tuple$pair,
                    A2($author$project$Tracks$pick, trackIds, model.hypaethralUserData.tracks)
                  )
                )
              )
            )
          );
        }
      );
      var $author$project$Brain$Common$State$giveUI = F2(
        function(tag, data) {
          return $author$project$Return$Ext$communicate(
            A2($author$project$Brain$Common$State$giveUICmd, tag, data)
          );
        }
      );
      var $author$project$Brain$Tracks$State$gotSearchResults = function(results) {
        return A2(
          $author$project$Brain$Common$State$giveUI,
          $author$project$Alien$SearchTracks,
          A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, results)
        );
      };
      var $author$project$Sources$Processing$Head = { $: "Head" };
      var $author$project$Brain$Tracks$State$makeTrackUrl = F4(
        function(timestamp, trackPath, maybeSource, httpMethod) {
          if (maybeSource.$ === "Just") {
            var source = maybeSource.a;
            return A6($author$project$Sources$Services$makeTrackUrl, source.service, timestamp, source.id, source.data, httpMethod, trackPath);
          } else {
            return "<missing-source>";
          }
        }
      );
      var $author$project$Brain$Ports$provideArtworkTrackUrls = _Platform_outgoingPort("provideArtworkTrackUrls", $elm$core$Basics$identity);
      var $elm$core$Platform$Cmd$none = $elm$core$Platform$Cmd$batch(_List_Nil);
      var $Fresheyeball$elm_return$Return$singleton = function(a) {
        return _Utils_Tuple2(a, $elm$core$Platform$Cmd$none);
      };
      var $author$project$Brain$Tracks$State$makeArtworkTrackUrls = F2(
        function(json, model) {
          return A2(
            $elm$core$Result$withDefault,
            $Fresheyeball$elm_return$Return$singleton(model),
            A2(
              $elm$core$Result$map,
              function(dict) {
                var trackPath = A3($author$project$Dict$Ext$fetch, "trackPath", "", dict);
                var maybeSource = A2(
                  $elm$core$Maybe$andThen,
                  function(trackSourceId) {
                    return A2(
                      $elm_community$list_extra$List$Extra$find,
                      A2(
                        $elm$core$Basics$composeR,
                        function($) {
                          return $.id;
                        },
                        $elm$core$Basics$eq(trackSourceId)
                      ),
                      model.hypaethralUserData.sources
                    );
                  },
                  A2($elm$core$Dict$get, "trackSourceId", dict)
                );
                var mkTrackUrl = A3($author$project$Brain$Tracks$State$makeTrackUrl, model.currentTime, trackPath, maybeSource);
                return A2(
                  $Fresheyeball$elm_return$Return$return,
                  model,
                  $author$project$Brain$Ports$provideArtworkTrackUrls(
                    A3(
                      $elm$json$Json$Encode$dict,
                      $elm$core$Basics$identity,
                      $elm$json$Json$Encode$string,
                      A3(
                        $elm$core$Dict$insert,
                        "trackHeadUrl",
                        mkTrackUrl($author$project$Sources$Processing$Head),
                        A3(
                          $elm$core$Dict$insert,
                          "trackGetUrl",
                          mkTrackUrl($author$project$Sources$Processing$Get),
                          A2(
                            $elm$core$Dict$remove,
                            "trackSourceId",
                            A2($elm$core$Dict$remove, "trackPath", dict)
                          )
                        )
                      )
                    )
                  )
                );
              },
              A2(
                $elm$json$Json$Decode$decodeValue,
                $elm$json$Json$Decode$dict($elm$json$Json$Decode$string),
                json
              )
            )
          );
        }
      );
      var $author$project$Sources$Refresh$AccessToken$portArgumentsDecoder = A5(
        $elm$json$Json$Decode$map4,
        F4(
          function(service, sourceId, accessToken, expiresAt) {
            return { accessToken, expiresAt, service, sourceId };
          }
        ),
        A2($elm$json$Json$Decode$field, "service", $author$project$Sources$Encoding$serviceDecoder),
        A2($elm$json$Json$Decode$field, "sourceId", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "accessToken", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "expiresAt", $elm$json$Json$Decode$int)
      );
      var $author$project$Brain$Common$State$reportUI = F2(
        function(tag, error) {
          return $author$project$Return$Ext$communicate(
            A2($author$project$Brain$Common$State$reportUICmd, tag, error)
          );
        }
      );
      var $author$project$Brain$Other$State$refreshedAccessToken = F2(
        function(value, model) {
          var _v0 = A2($elm$json$Json$Decode$decodeValue, $author$project$Sources$Refresh$AccessToken$portArgumentsDecoder, value);
          if (_v0.$ === "Ok") {
            var portArguments = _v0.a;
            var _v1 = portArguments.service;
            if (_v1.$ === "Google") {
              return A2(
                $Fresheyeball$elm_return$Return$return,
                model,
                A2(
                  $elm$core$Maybe$withDefault,
                  $elm$core$Platform$Cmd$none,
                  A2(
                    $elm$core$Maybe$map,
                    function(source) {
                      return $author$project$Brain$Ports$toUI(
                        A2(
                          $author$project$Alien$broadcast,
                          $author$project$Alien$UpdateSourceData,
                          $author$project$Sources$Encoding$encode(source)
                        )
                      );
                    },
                    A2(
                      $elm$core$Maybe$map,
                      function(source) {
                        return function(newData) {
                          return _Utils_update(
                            source,
                            { data: newData }
                          );
                        }(
                          A3(
                            $elm$core$Dict$insert,
                            "expiresAt",
                            $elm$core$String$fromInt(portArguments.expiresAt),
                            A3($elm$core$Dict$insert, "accessToken", portArguments.accessToken, source.data)
                          )
                        );
                      },
                      A2(
                        $elm_community$list_extra$List$Extra$find,
                        A2(
                          $elm$core$Basics$composeR,
                          function($) {
                            return $.id;
                          },
                          $elm$core$Basics$eq(portArguments.sourceId)
                        ),
                        model.hypaethralUserData.sources
                      )
                    )
                  )
                )
              );
            } else {
              return $Fresheyeball$elm_return$Return$singleton(model);
            }
          } else {
            var err = _v0.a;
            return A3(
              $author$project$Brain$Common$State$reportUI,
              $author$project$Alien$ToCache,
              $elm$json$Json$Decode$errorToString(err),
              model
            );
          }
        }
      );
      var $author$project$Tracks$removeBySourceId = F2(
        function(removedSourceId, tracks) {
          return function(_v1) {
            var k = _v1.a;
            var r = _v1.b;
            return { kept: k, removed: r };
          }(
            A3(
              $elm$core$List$foldr,
              F2(
                function(t, _v0) {
                  var kept = _v0.a;
                  var removed = _v0.b;
                  return _Utils_eq(t.sourceId, removedSourceId) ? _Utils_Tuple2(
                    kept,
                    A2($elm$core$List$cons, t, removed)
                  ) : _Utils_Tuple2(
                    A2($elm$core$List$cons, t, kept),
                    removed
                  );
                }
              ),
              _Utils_Tuple2(_List_Nil, _List_Nil),
              tracks
            )
          );
        }
      );
      var $Fresheyeball$elm_return$Return$andThen = F2(
        function(f, _v0) {
          var model = _v0.a;
          var cmd = _v0.b;
          var _v1 = f(model);
          var model_ = _v1.a;
          var cmd_ = _v1.b;
          return _Utils_Tuple2(
            model_,
            $elm$core$Platform$Cmd$batch(
              _List_fromArray(
                [cmd, cmd_]
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$makeHypaethralLens = F3(
        function(setter, model, value) {
          return _Utils_update(
            model,
            {
              hypaethralUserData: A2(setter, model.hypaethralUserData, value)
            }
          );
        }
      );
      var $author$project$Brain$User$State$hypaethralLenses = {
        setFavourites: $author$project$Brain$User$State$makeHypaethralLens(
          F2(
            function(h, f) {
              return _Utils_update(
                h,
                { favourites: f }
              );
            }
          )
        ),
        setPlaylists: $author$project$Brain$User$State$makeHypaethralLens(
          F2(
            function(h, p) {
              return _Utils_update(
                h,
                { playlists: p }
              );
            }
          )
        ),
        setProgress: $author$project$Brain$User$State$makeHypaethralLens(
          F2(
            function(h, p) {
              return _Utils_update(
                h,
                { progress: p }
              );
            }
          )
        ),
        setSettings: $author$project$Brain$User$State$makeHypaethralLens(
          F2(
            function(h, s) {
              return _Utils_update(
                h,
                { settings: s }
              );
            }
          )
        ),
        setSources: $author$project$Brain$User$State$makeHypaethralLens(
          F2(
            function(h, s) {
              return _Utils_update(
                h,
                { sources: s }
              );
            }
          )
        ),
        setTracks: $author$project$Brain$User$State$makeHypaethralLens(
          F2(
            function(h, t) {
              return _Utils_update(
                h,
                { tracks: t }
              );
            }
          )
        )
      };
      var $Gizra$elm_debouncer$Debouncer$Basic$ProvideInput = function(a) {
        return { $: "ProvideInput", a };
      };
      var $Gizra$elm_debouncer$Debouncer$Basic$provideInput = $Gizra$elm_debouncer$Debouncer$Basic$ProvideInput;
      var $author$project$Brain$User$Types$SaveHypaethralDataSlowly = function(a) {
        return { $: "SaveHypaethralDataSlowly", a };
      };
      var $Gizra$elm_all_set$EverySet$EverySet = function(a) {
        return { $: "EverySet", a };
      };
      var $pzp1997$assoc_list$AssocList$D = function(a) {
        return { $: "D", a };
      };
      var $pzp1997$assoc_list$AssocList$empty = $pzp1997$assoc_list$AssocList$D(_List_Nil);
      var $Gizra$elm_all_set$EverySet$empty = $Gizra$elm_all_set$EverySet$EverySet($pzp1997$assoc_list$AssocList$empty);
      var $pzp1997$assoc_list$AssocList$remove = F2(
        function(targetKey, _v0) {
          var alist = _v0.a;
          return $pzp1997$assoc_list$AssocList$D(
            A2(
              $elm$core$List$filter,
              function(_v1) {
                var key = _v1.a;
                return !_Utils_eq(key, targetKey);
              },
              alist
            )
          );
        }
      );
      var $pzp1997$assoc_list$AssocList$insert = F3(
        function(key, value, dict) {
          var _v0 = A2($pzp1997$assoc_list$AssocList$remove, key, dict);
          var alteredAlist = _v0.a;
          return $pzp1997$assoc_list$AssocList$D(
            A2(
              $elm$core$List$cons,
              _Utils_Tuple2(key, value),
              alteredAlist
            )
          );
        }
      );
      var $Gizra$elm_all_set$EverySet$insert = F2(
        function(k, _v0) {
          var d = _v0.a;
          return $Gizra$elm_all_set$EverySet$EverySet(
            A3($pzp1997$assoc_list$AssocList$insert, k, _Utils_Tuple0, d)
          );
        }
      );
      var $Gizra$elm_all_set$EverySet$fromList = function(xs) {
        return A3($elm$core$List$foldl, $Gizra$elm_all_set$EverySet$insert, $Gizra$elm_all_set$EverySet$empty, xs);
      };
      var $elm$core$Platform$Cmd$map = _Platform_map;
      var $author$project$Brain$User$Types$SaveHypaethralDataBits = function(a) {
        return { $: "SaveHypaethralDataBits", a };
      };
      var $elm$core$Basics$always = F2(
        function(a, _v0) {
          return a;
        }
      );
      var $author$project$Syncing$Services$Dropbox$Token$isExpired = function(_v0) {
        var currentTime = _v0.currentTime;
        var expiresAt = _v0.expiresAt;
        var currentTimeInSeconds = $elm$time$Time$posixToMillis(currentTime) / 1e3 | 0;
        var currentTimeWithOffset = currentTimeInSeconds + 60;
        return _Utils_cmp(currentTimeWithOffset, expiresAt) > -1;
      };
      var $author$project$Brain$User$Types$RefreshedDropboxTokens = F3(
        function(a, b, c) {
          return { $: "RefreshedDropboxTokens", a, b, c };
        }
      );
      var $elm$core$Result$andThen = F2(
        function(callback, result) {
          if (result.$ === "Ok") {
            var value = result.a;
            return callback(value);
          } else {
            var msg = result.a;
            return $elm$core$Result$Err(msg);
          }
        }
      );
      var $author$project$User$Layer$Methods$Dropbox$clientId = "te0c9pbeii8f8bw";
      var $author$project$User$Layer$Methods$Dropbox$clientSecret = "kxmlfdsw8k9e0ot";
      var $elm$http$Http$emptyBody = _Http_emptyBody;
      var $author$project$Http$Ext$errorToString = function(err) {
        switch (err.$) {
          case "Timeout":
            return "Timeout exceeded";
          case "NetworkError":
            return "Network error";
          case "BadStatus":
            var code = err.a;
            return "Something went wrong, got status code: " + $elm$core$String$fromInt(code);
          case "BadBody":
            var text = err.a;
            return "Unexpected response: " + text;
          default:
            var url = err.a;
            return "Malformed url: " + url;
        }
      };
      var $elm$http$Http$BadBody = function(a) {
        return { $: "BadBody", a };
      };
      var $elm$http$Http$BadStatus = function(a) {
        return { $: "BadStatus", a };
      };
      var $elm$http$Http$BadUrl = function(a) {
        return { $: "BadUrl", a };
      };
      var $elm$http$Http$NetworkError = { $: "NetworkError" };
      var $elm$http$Http$Timeout = { $: "Timeout" };
      var $jzxhuang$http_extras$Http$Extras$resolve = F2(
        function(toResult, response) {
          switch (response.$) {
            case "BadUrl_":
              var url = response.a;
              return $elm$core$Result$Err(
                $elm$http$Http$BadUrl(url)
              );
            case "Timeout_":
              return $elm$core$Result$Err($elm$http$Http$Timeout);
            case "NetworkError_":
              return $elm$core$Result$Err($elm$http$Http$NetworkError);
            case "BadStatus_":
              var metadata = response.a;
              return $elm$core$Result$Err(
                $elm$http$Http$BadStatus(metadata.statusCode)
              );
            default:
              var body = response.b;
              return A2(
                $elm$core$Result$mapError,
                $elm$http$Http$BadBody,
                toResult(body)
              );
          }
        }
      );
      var $jzxhuang$http_extras$Http$Extras$responseToString = function(responseString) {
        return A2($jzxhuang$http_extras$Http$Extras$resolve, $elm$core$Result$Ok, responseString);
      };
      var $author$project$User$Layer$Methods$Dropbox$tokensDecoder = A4(
        $elm$json$Json$Decode$map3,
        F3(
          function(a, e, r) {
            return { accessToken: a, expiresIn: e, refreshToken: r };
          }
        ),
        A2($elm$json$Json$Decode$field, "access_token", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "expires_in", $elm$json$Json$Decode$int),
        $elm$json$Json$Decode$maybe(
          A2($elm$json$Json$Decode$field, "refresh_token", $elm$json$Json$Decode$string)
        )
      );
      var $author$project$User$Layer$Methods$Dropbox$refreshAccessToken = function(refreshToken) {
        return $elm$http$Http$task(
          function(u) {
            return {
              body: $elm$http$Http$emptyBody,
              headers: _List_Nil,
              method: "POST",
              resolver: $elm$http$Http$stringResolver(
                function(resp) {
                  return A2(
                    $elm$core$Result$andThen,
                    A2(
                      $elm$core$Basics$composeR,
                      $elm$json$Json$Decode$decodeString($author$project$User$Layer$Methods$Dropbox$tokensDecoder),
                      $elm$core$Result$mapError($elm$json$Json$Decode$errorToString)
                    ),
                    A2(
                      $elm$core$Result$mapError,
                      $author$project$Http$Ext$errorToString,
                      $jzxhuang$http_extras$Http$Extras$responseToString(resp)
                    )
                  );
                }
              ),
              timeout: $elm$core$Maybe$Nothing,
              url: u
            };
          }(
            A2(
              $elm$core$String$append,
              "https://api.dropboxapi.com/oauth2/token",
              $author$project$Common$queryString(
                _List_fromArray(
                  [
                    _Utils_Tuple2("client_id", $author$project$User$Layer$Methods$Dropbox$clientId),
                    _Utils_Tuple2("client_secret", $author$project$User$Layer$Methods$Dropbox$clientSecret),
                    _Utils_Tuple2("refresh_token", refreshToken),
                    _Utils_Tuple2("grant_type", "refresh_token")
                  ]
                )
              )
            )
          )
        );
      };
      var $author$project$Brain$User$State$refreshDropboxTokens = F4(
        function(currentTime, msg, initialTask, refreshToken) {
          return A2(
            $elm$core$Task$attempt,
            function(result) {
              if (result.$ === "Ok") {
                var tokens = result.a;
                return $author$project$Brain$Types$UserMsg(
                  A3(
                    $author$project$Brain$User$Types$RefreshedDropboxTokens,
                    {
                      currentTime: $elm$time$Time$posixToMillis(currentTime) / 1e3 | 0,
                      refreshToken
                    },
                    tokens,
                    msg
                  )
                );
              } else {
                var err = result.a;
                return A2($author$project$Brain$Common$State$reportUICmdMsg, $author$project$Alien$ReportError, err);
              }
            },
            A2(
              $elm$core$Task$andThen,
              function(_v0) {
                return $author$project$User$Layer$Methods$Dropbox$refreshAccessToken(refreshToken);
              },
              initialTask
            )
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$fileName = A2($elm$core$Basics$composeL, $elm$json$Json$Encode$string, $author$project$User$Layer$hypaethralBitFileName);
      var $lobanov$elm_taskport$TaskPort$ignoreValue = $elm$json$Json$Decode$succeed(_Utils_Tuple0);
      var $author$project$Brain$User$Hypaethral$saveDropbox = F3(
        function(accessToken, bit, data) {
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A2(
              $lobanov$elm_taskport$TaskPort$call,
              { argsEncoder: $elm$json$Json$Encode$object, _function: "toDropbox", valueDecoder: $lobanov$elm_taskport$TaskPort$ignoreValue },
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "fileName",
                    $author$project$Brain$User$Hypaethral$fileName(bit)
                  ),
                  _Utils_Tuple2("data", data),
                  _Utils_Tuple2(
                    "token",
                    $elm$json$Json$Encode$string(accessToken)
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$saveFission = F2(
        function(bit, data) {
          var savePublicData = _Utils_eq(bit, $author$project$User$Layer$Playlists);
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A2(
              $lobanov$elm_taskport$TaskPort$call,
              { argsEncoder: $elm$json$Json$Encode$object, _function: "toFission", valueDecoder: $lobanov$elm_taskport$TaskPort$ignoreValue },
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "fileName",
                    $author$project$Brain$User$Hypaethral$fileName(bit)
                  ),
                  _Utils_Tuple2("data", data),
                  _Utils_Tuple2(
                    "savePublicData",
                    $elm$json$Json$Encode$bool(savePublicData)
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$Brain$Task$Ports$toCacheWithSuffix = F2(
        function(tag, suffix) {
          var key = $author$project$Alien$tagToString(tag) + ("_" + suffix);
          return $lobanov$elm_taskport$TaskPort$call(
            {
              argsEncoder: function(v) {
                return $elm$json$Json$Encode$object(
                  _List_fromArray(
                    [
                      _Utils_Tuple2(
                        "key",
                        $elm$json$Json$Encode$string(key)
                      ),
                      _Utils_Tuple2("value", v)
                    ]
                  )
                );
              },
              _function: "toCache",
              valueDecoder: $lobanov$elm_taskport$TaskPort$ignoreValue
            }
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$saveLocal = F2(
        function(bit, data) {
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A3(
              $author$project$Brain$Task$Ports$toCacheWithSuffix,
              $author$project$Alien$SyncLocal,
              $author$project$User$Layer$hypaethralBitFileName(bit),
              data
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveHypaethralDataBitsTask = F3(
        function(bits, userData, saveFn) {
          return A3(
            $elm$core$List$foldl,
            function(nextTask) {
              return $elm$core$Task$andThen(
                function(_v0) {
                  return nextTask;
                }
              );
            },
            $elm$core$Task$succeed(_Utils_Tuple0),
            $elm$core$List$concat(
              _List_fromArray(
                [
                  A2(
                    $elm$core$List$map,
                    function(bit) {
                      return A2(
                        $author$project$Brain$User$Hypaethral$saveLocal,
                        bit,
                        A2($author$project$User$Layer$encodeHypaethralBit, bit, userData)
                      );
                    },
                    bits
                  ),
                  A2(
                    $elm$core$List$map,
                    function(bit) {
                      return A2(
                        saveFn,
                        bit,
                        A2($author$project$User$Layer$encodeHypaethralBit, bit, userData)
                      );
                    },
                    bits
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$saveIpfs = F3(
        function(apiOrigin, bit, data) {
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A2(
              $lobanov$elm_taskport$TaskPort$call,
              { argsEncoder: $elm$json$Json$Encode$object, _function: "toIpfs", valueDecoder: $lobanov$elm_taskport$TaskPort$ignoreValue },
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "apiOrigin",
                    $elm$json$Json$Encode$string(apiOrigin)
                  ),
                  _Utils_Tuple2(
                    "fileName",
                    $author$project$Brain$User$Hypaethral$fileName(bit)
                  ),
                  _Utils_Tuple2("data", data)
                ]
              )
            )
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$saveRemoteStorage = F3(
        function(_v0, bit, data) {
          var token = _v0.token;
          var userAddress = _v0.userAddress;
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A2(
              $lobanov$elm_taskport$TaskPort$call,
              { argsEncoder: $elm$json$Json$Encode$object, _function: "toRemoteStorage", valueDecoder: $lobanov$elm_taskport$TaskPort$ignoreValue },
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "fileName",
                    $author$project$Brain$User$Hypaethral$fileName(bit)
                  ),
                  _Utils_Tuple2("data", data),
                  _Utils_Tuple2(
                    "token",
                    $elm$json$Json$Encode$string(token)
                  ),
                  _Utils_Tuple2(
                    "userAddress",
                    $elm$json$Json$Encode$string(userAddress)
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveHypaethralDataBits = F2(
        function(bitsWithoutModifiedAt, model) {
          var userData = model.hypaethralUserData;
          var updatedUserData = _Utils_update(
            userData,
            {
              modifiedAt: $elm$core$Maybe$Just(model.currentTime)
            }
          );
          var updatedModel = _Utils_update(
            model,
            { hypaethralUserData: updatedUserData }
          );
          var bits = A2($elm$core$List$cons, $author$project$User$Layer$ModifiedAt, bitsWithoutModifiedAt);
          var save = function(saveFn) {
            return A2(
              $Fresheyeball$elm_return$Return$return,
              updatedModel,
              A2(
                $author$project$Brain$Common$State$attemptTask,
                $elm$core$Basics$always($author$project$Brain$Types$Bypass),
                A2(
                  $elm$core$Task$andThen,
                  function(currentTime) {
                    return A3(
                      $author$project$Brain$User$State$saveHypaethralDataBitsTask,
                      bits,
                      _Utils_update(
                        updatedUserData,
                        {
                          modifiedAt: $elm$core$Maybe$Just(currentTime)
                        }
                      ),
                      saveFn
                    );
                  },
                  $elm$time$Time$now
                )
              )
            );
          };
          var _v0 = model.userSyncMethod;
          if (_v0.$ === "Just") {
            switch (_v0.a.$) {
              case "Dropbox":
                var accessToken = _v0.a.a.accessToken;
                var expiresAt = _v0.a.a.expiresAt;
                var refreshToken = _v0.a.a.refreshToken;
                return $author$project$Syncing$Services$Dropbox$Token$isExpired(
                  { currentTime: model.currentTime, expiresAt }
                ) ? A2(
                  $Fresheyeball$elm_return$Return$return,
                  model,
                  A4(
                    $author$project$Brain$User$State$refreshDropboxTokens,
                    model.currentTime,
                    $author$project$Brain$User$Types$SaveHypaethralDataBits(bits),
                    $elm$core$Task$succeed(_Utils_Tuple0),
                    refreshToken
                  )
                ) : save(
                  $author$project$Brain$User$Hypaethral$saveDropbox(accessToken)
                );
              case "Fission":
                return save($author$project$Brain$User$Hypaethral$saveFission);
              case "Ipfs":
                var apiOrigin = _v0.a.a.apiOrigin;
                return save(
                  $author$project$Brain$User$Hypaethral$saveIpfs(apiOrigin)
                );
              default:
                var args = _v0.a.a;
                return save(
                  $author$project$Brain$User$Hypaethral$saveRemoteStorage(args)
                );
            }
          } else {
            return save(
              F2(
                function(_v1, _v2) {
                  return $elm$core$Task$succeed(_Utils_Tuple0);
                }
              )
            );
          }
        }
      );
      var $pzp1997$assoc_list$AssocList$keys = function(_v0) {
        var alist = _v0.a;
        return A2($elm$core$List$map, $elm$core$Tuple$first, alist);
      };
      var $Gizra$elm_all_set$EverySet$toList = function(_v0) {
        var d = _v0.a;
        return $pzp1997$assoc_list$AssocList$keys(d);
      };
      var $Gizra$elm_debouncer$Debouncer$Internal$Check = function(a) {
        return { $: "Check", a };
      };
      var $Gizra$elm_debouncer$Debouncer$Internal$InputProvidedAt = F2(
        function(a, b) {
          return { $: "InputProvidedAt", a, b };
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Internal$ManualEmitAt = function(a) {
        return { $: "ManualEmitAt", a };
      };
      var $Gizra$elm_debouncer$Debouncer$Basic$MsgInternal = function(a) {
        return { $: "MsgInternal", a };
      };
      var $elm$core$Process$sleep = _Process_sleep;
      var $Gizra$elm_debouncer$Debouncer$Internal$Unsettled = function(a) {
        return { $: "Unsettled", a };
      };
      var $Gizra$elm_debouncer$Debouncer$Internal$cancel = function(_v0) {
        var config = _v0.a;
        var state = _v0.b;
        return A2($Gizra$elm_debouncer$Debouncer$Internal$Debouncer, config, $Gizra$elm_debouncer$Debouncer$Internal$Settled);
      };
      var $elm$core$List$partition = F2(
        function(pred, list) {
          var step = F2(
            function(x, _v0) {
              var trues = _v0.a;
              var falses = _v0.b;
              return pred(x) ? _Utils_Tuple2(
                A2($elm$core$List$cons, x, trues),
                falses
              ) : _Utils_Tuple2(
                trues,
                A2($elm$core$List$cons, x, falses)
              );
            }
          );
          return A3(
            $elm$core$List$foldr,
            step,
            _Utils_Tuple2(_List_Nil, _List_Nil),
            list
          );
        }
      );
      var $elm_community$list_extra$List$Extra$uniqueHelp = F4(
        function(f, existing, remaining, accumulator) {
          uniqueHelp:
            while (true) {
              if (!remaining.b) {
                return $elm$core$List$reverse(accumulator);
              } else {
                var first = remaining.a;
                var rest = remaining.b;
                var computedFirst = f(first);
                if (A2($elm$core$List$member, computedFirst, existing)) {
                  var $temp$f = f, $temp$existing = existing, $temp$remaining = rest, $temp$accumulator = accumulator;
                  f = $temp$f;
                  existing = $temp$existing;
                  remaining = $temp$remaining;
                  accumulator = $temp$accumulator;
                  continue uniqueHelp;
                } else {
                  var $temp$f = f, $temp$existing = A2($elm$core$List$cons, computedFirst, existing), $temp$remaining = rest, $temp$accumulator = A2($elm$core$List$cons, first, accumulator);
                  f = $temp$f;
                  existing = $temp$existing;
                  remaining = $temp$remaining;
                  accumulator = $temp$accumulator;
                  continue uniqueHelp;
                }
              }
            }
        }
      );
      var $elm_community$list_extra$List$Extra$unique = function(list) {
        return A4($elm_community$list_extra$List$Extra$uniqueHelp, $elm$core$Basics$identity, _List_Nil, list, _List_Nil);
      };
      var $Gizra$elm_debouncer$Debouncer$Internal$update = F2(
        function(msg, debouncer) {
          var wrappedConfig = debouncer.a;
          var config = wrappedConfig.a;
          var state = debouncer.b;
          switch (msg.$) {
            case "InputProvidedAt":
              var input = msg.a;
              var time = msg.b;
              var newState = function() {
                if (state.$ === "Settled") {
                  return $Gizra$elm_debouncer$Debouncer$Internal$Unsettled(
                    {
                      lastEmittedAt: $elm$core$Maybe$Nothing,
                      lastInputProvidedAt: time,
                      output: A2(config.accumulator, input, $elm$core$Maybe$Nothing),
                      unsettledAt: time
                    }
                  );
                } else {
                  var unsettled2 = state.a;
                  return $Gizra$elm_debouncer$Debouncer$Internal$Unsettled(
                    _Utils_update(
                      unsettled2,
                      {
                        lastInputProvidedAt: time,
                        output: A2(config.accumulator, input, unsettled2.output)
                      }
                    )
                  );
                }
              }();
              var newDebouncer = A2($Gizra$elm_debouncer$Debouncer$Internal$Debouncer, wrappedConfig, newState);
              var checks = function() {
                if (state.$ === "Settled") {
                  return $elm_community$list_extra$List$Extra$unique(
                    A2(
                      $elm$core$List$filterMap,
                      $elm$core$Basics$identity,
                      _List_fromArray(
                        [config.emitWhenUnsettled, config.emitWhileUnsettled, config.settleWhenQuietFor]
                      )
                    )
                  );
                } else {
                  return A2(
                    $elm$core$List$filterMap,
                    $elm$core$Basics$identity,
                    _List_fromArray(
                      [config.settleWhenQuietFor]
                    )
                  );
                }
              }();
              var _v1 = A2(
                $elm$core$Tuple$mapFirst,
                A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
                A2(
                  $elm$core$List$partition,
                  function(interval) {
                    return interval <= 0;
                  },
                  checks
                )
              );
              var checkNow = _v1.a;
              var checkLater = _v1.b;
              var _v2 = checkNow ? A2(
                $Gizra$elm_debouncer$Debouncer$Internal$update,
                $Gizra$elm_debouncer$Debouncer$Internal$Check(time),
                newDebouncer
              ) : _Utils_Tuple3(newDebouncer, _List_Nil, $elm$core$Maybe$Nothing);
              var checkedDebouncer = _v2.a;
              var checkedIntervals = _v2.b;
              var emit = _v2.c;
              return _Utils_Tuple3(
                checkedDebouncer,
                _Utils_ap(checkedIntervals, checkLater),
                emit
              );
            case "ManualCancel":
              return _Utils_Tuple3(
                $Gizra$elm_debouncer$Debouncer$Internal$cancel(debouncer),
                _List_Nil,
                $elm$core$Maybe$Nothing
              );
            case "ManualSettle":
              var emit = function() {
                if (state.$ === "Settled") {
                  return $elm$core$Maybe$Nothing;
                } else {
                  var unsettled2 = state.a;
                  return unsettled2.output;
                }
              }();
              return _Utils_Tuple3(
                $Gizra$elm_debouncer$Debouncer$Internal$cancel(debouncer),
                _List_Nil,
                emit
              );
            case "ManualEmitAt":
              var time = msg.a;
              if (state.$ === "Settled") {
                return _Utils_Tuple3(debouncer, _List_Nil, $elm$core$Maybe$Nothing);
              } else {
                var unsettled = state.a;
                var _v7 = unsettled.output;
                if (_v7.$ === "Just") {
                  var newState = $Gizra$elm_debouncer$Debouncer$Internal$Unsettled(
                    _Utils_update(
                      unsettled,
                      {
                        lastEmittedAt: $elm$core$Maybe$Just(time),
                        output: $elm$core$Maybe$Nothing
                      }
                    )
                  );
                  var intervals = function() {
                    var _v8 = config.emitWhenUnsettled;
                    if (_v8.$ === "Just") {
                      var emit2 = _v8.a;
                      return _List_fromArray(
                        [emit2]
                      );
                    } else {
                      return _List_Nil;
                    }
                  }();
                  return _Utils_Tuple3(
                    A2($Gizra$elm_debouncer$Debouncer$Internal$Debouncer, wrappedConfig, newState),
                    intervals,
                    unsettled.output
                  );
                } else {
                  return _Utils_Tuple3(debouncer, _List_Nil, $elm$core$Maybe$Nothing);
                }
              }
            default:
              var time = msg.a;
              if (state.$ === "Settled") {
                return _Utils_Tuple3(debouncer, _List_Nil, $elm$core$Maybe$Nothing);
              } else {
                var unsettled = state.a;
                var shouldSettle = A2(
                  $elm$core$Maybe$withDefault,
                  false,
                  A2(
                    $elm$core$Maybe$map,
                    function(interval) {
                      return _Utils_cmp(unsettled.lastInputProvidedAt + interval, time) < 1;
                    },
                    config.settleWhenQuietFor
                  )
                );
                var becauseEmitWhileUnsettled = function() {
                  var _v13 = config.emitWhileUnsettled;
                  if (_v13.$ === "Just") {
                    var interval = _v13.a;
                    var _v14 = unsettled.lastEmittedAt;
                    if (_v14.$ === "Just") {
                      var lastEmittedAt = _v14.a;
                      return _Utils_cmp(lastEmittedAt + interval, time) < 1;
                    } else {
                      return _Utils_cmp(unsettled.unsettledAt + interval, time) < 1;
                    }
                  } else {
                    return false;
                  }
                }();
                var becauseEmitWhenUnsettled = function() {
                  var _v11 = config.emitWhenUnsettled;
                  if (_v11.$ === "Just") {
                    var interval = _v11.a;
                    var _v12 = unsettled.lastEmittedAt;
                    if (_v12.$ === "Just") {
                      return false;
                    } else {
                      return _Utils_cmp(unsettled.unsettledAt + interval, time) < 1;
                    }
                  } else {
                    return false;
                  }
                }();
                var shouldEmit = !_Utils_eq(unsettled.output, $elm$core$Maybe$Nothing) && (shouldSettle || (becauseEmitWhenUnsettled || becauseEmitWhileUnsettled));
                var emit = shouldEmit ? unsettled.output : $elm$core$Maybe$Nothing;
                var intervals = function() {
                  if (shouldEmit && !shouldSettle) {
                    var _v10 = config.emitWhileUnsettled;
                    if (_v10.$ === "Just") {
                      var interval = _v10.a;
                      return _List_fromArray(
                        [interval]
                      );
                    } else {
                      return _List_Nil;
                    }
                  } else {
                    return _List_Nil;
                  }
                }();
                var newState = shouldSettle ? $Gizra$elm_debouncer$Debouncer$Internal$Settled : shouldEmit ? $Gizra$elm_debouncer$Debouncer$Internal$Unsettled(
                  _Utils_update(
                    unsettled,
                    {
                      lastEmittedAt: $elm$core$Maybe$Just(time),
                      output: $elm$core$Maybe$Nothing
                    }
                  )
                ) : state;
                return _Utils_Tuple3(
                  A2($Gizra$elm_debouncer$Debouncer$Internal$Debouncer, wrappedConfig, newState),
                  intervals,
                  emit
                );
              }
          }
        }
      );
      var $Gizra$elm_debouncer$Debouncer$Basic$update = F2(
        function(msg, debouncer) {
          switch (msg.$) {
            case "ProvideInput":
              var input = msg.a;
              return _Utils_Tuple3(
                debouncer,
                A2(
                  $elm$core$Task$perform,
                  A2(
                    $elm$core$Basics$composeL,
                    A2(
                      $elm$core$Basics$composeL,
                      $Gizra$elm_debouncer$Debouncer$Basic$MsgInternal,
                      $Gizra$elm_debouncer$Debouncer$Internal$InputProvidedAt(input)
                    ),
                    $elm$time$Time$posixToMillis
                  ),
                  $elm$time$Time$now
                ),
                $elm$core$Maybe$Nothing
              );
            case "EmitNow":
              return _Utils_Tuple3(
                debouncer,
                A2(
                  $elm$core$Task$perform,
                  A2(
                    $elm$core$Basics$composeL,
                    A2($elm$core$Basics$composeL, $Gizra$elm_debouncer$Debouncer$Basic$MsgInternal, $Gizra$elm_debouncer$Debouncer$Internal$ManualEmitAt),
                    $elm$time$Time$posixToMillis
                  ),
                  $elm$time$Time$now
                ),
                $elm$core$Maybe$Nothing
              );
            default:
              var subMsg = msg.a;
              var _v1 = A2($Gizra$elm_debouncer$Debouncer$Internal$update, subMsg, debouncer);
              var updatedDebouncer = _v1.a;
              var intervals = _v1.b;
              var output = _v1.c;
              var cmds = $elm$core$Platform$Cmd$batch(
                A2(
                  $elm$core$List$map,
                  function(interval) {
                    return A2(
                      $elm$core$Task$perform,
                      A2(
                        $elm$core$Basics$composeL,
                        A2($elm$core$Basics$composeL, $Gizra$elm_debouncer$Debouncer$Basic$MsgInternal, $Gizra$elm_debouncer$Debouncer$Internal$Check),
                        $elm$time$Time$posixToMillis
                      ),
                      A2(
                        $elm$core$Task$andThen,
                        $elm$core$Basics$always($elm$time$Time$now),
                        $elm$core$Process$sleep(interval)
                      )
                    );
                  },
                  intervals
                )
              );
              return _Utils_Tuple3(updatedDebouncer, cmds, output);
          }
        }
      );
      var $author$project$Brain$User$State$saveHypaethralDataSlowly = F2(
        function(debouncerMsg, model) {
          var _v0 = A2($Gizra$elm_debouncer$Debouncer$Basic$update, debouncerMsg, model.hypaethralDebouncer);
          var m = _v0.a;
          var c = _v0.b;
          var e = _v0.c;
          var bits = $Gizra$elm_all_set$EverySet$toList(
            $Gizra$elm_all_set$EverySet$fromList(
              A2($elm$core$Maybe$withDefault, _List_Nil, e)
            )
          );
          return (!$elm$core$List$isEmpty(bits) ? $Fresheyeball$elm_return$Return$andThen(
            $author$project$Brain$User$State$saveHypaethralDataBits(bits)
          ) : $elm$core$Basics$identity)(
            A2(
              $Fresheyeball$elm_return$Return$return,
              _Utils_update(
                model,
                { hypaethralDebouncer: m }
              ),
              A2(
                $elm$core$Platform$Cmd$map,
                A2($elm$core$Basics$composeR, $author$project$Brain$User$Types$SaveHypaethralDataSlowly, $author$project$Brain$Types$UserMsg),
                c
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveHypaethralDataBitWithDebounce = function(bit) {
        return $author$project$Brain$User$State$saveHypaethralDataSlowly(
          $Gizra$elm_debouncer$Debouncer$Basic$provideInput(bit)
        );
      };
      var $author$project$Brain$Ports$updateSearchIndex = _Platform_outgoingPort("updateSearchIndex", $elm$core$Basics$identity);
      var $author$project$Brain$User$State$saveTracksAndUpdateSearchIndex = F2(
        function(tracks, model) {
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            $author$project$Brain$User$State$saveHypaethralDataBitWithDebounce($author$project$User$Layer$Tracks),
            A2(
              $author$project$Return$Ext$communicate,
              $author$project$Brain$Ports$updateSearchIndex(
                A2($elm$json$Json$Encode$list, $author$project$Tracks$Encoding$encodeTrack, tracks)
              ),
              A2($author$project$Brain$User$State$hypaethralLenses.setTracks, model, tracks)
            )
          );
        }
      );
      var $author$project$Brain$Tracks$State$removeBySourceId = F2(
        function(data, model) {
          var _v0 = A2($elm$json$Json$Decode$decodeValue, $elm$json$Json$Decode$string, data);
          if (_v0.$ === "Ok") {
            var sourceId = _v0.a;
            return A2(
              $author$project$Brain$User$State$saveTracksAndUpdateSearchIndex,
              A2($author$project$Tracks$removeBySourceId, sourceId, model.hypaethralUserData.tracks).kept,
              model
            );
          } else {
            return $Fresheyeball$elm_return$Return$singleton(model);
          }
        }
      );
      var $author$project$Brain$Ports$removeTracksFromCache = _Platform_outgoingPort("removeTracksFromCache", $elm$core$Basics$identity);
      var $author$project$Brain$Tracks$State$removeFromCache = function(data) {
        return $author$project$Return$Ext$communicate(
          $author$project$Brain$Ports$removeTracksFromCache(data)
        );
      };
      var $elm_community$list_extra$List$Extra$findIndexHelp = F3(
        function(index, predicate, list) {
          findIndexHelp:
            while (true) {
              if (!list.b) {
                return $elm$core$Maybe$Nothing;
              } else {
                var x = list.a;
                var xs = list.b;
                if (predicate(x)) {
                  return $elm$core$Maybe$Just(index);
                } else {
                  var $temp$index = index + 1, $temp$predicate = predicate, $temp$list = xs;
                  index = $temp$index;
                  predicate = $temp$predicate;
                  list = $temp$list;
                  continue findIndexHelp;
                }
              }
            }
        }
      );
      var $elm_community$list_extra$List$Extra$findIndex = $elm_community$list_extra$List$Extra$findIndexHelp(0);
      var $elm_community$list_extra$List$Extra$elemIndex = function(x) {
        return $elm_community$list_extra$List$Extra$findIndex(
          $elm$core$Basics$eq(x)
        );
      };
      var $elm_community$list_extra$List$Extra$getAt = F2(
        function(idx, xs) {
          return idx < 0 ? $elm$core$Maybe$Nothing : $elm$core$List$head(
            A2($elm$core$List$drop, idx, xs)
          );
        }
      );
      var $elm_community$list_extra$List$Extra$removeAt = F2(
        function(index, l) {
          if (index < 0) {
            return l;
          } else {
            var _v0 = A2($elm$core$List$drop, index, l);
            if (!_v0.b) {
              return l;
            } else {
              var rest = _v0.b;
              return _Utils_ap(
                A2($elm$core$List$take, index, l),
                rest
              );
            }
          }
        }
      );
      var $author$project$Brain$Tracks$State$replaceTags = F2(
        function(context, model) {
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            function(m) {
              return function(data) {
                return A3($author$project$Brain$Common$State$giveUI, $author$project$Alien$ReloadTracks, data, m);
              }(
                A2($elm$json$Json$Encode$list, $author$project$Tracks$Encoding$encodeTrack, m.hypaethralUserData.tracks)
              );
            },
            function(_v2) {
              var a = _v2.a;
              return A2($author$project$Brain$User$State$saveTracksAndUpdateSearchIndex, a, model);
            }(
              A3(
                $elm$core$List$foldr,
                F2(
                  function(track, _v0) {
                    var acc = _v0.a;
                    var trackIds = _v0.b;
                    var tags = _v0.c;
                    var _v1 = A2($elm_community$list_extra$List$Extra$elemIndex, track.id, trackIds);
                    if (_v1.$ === "Just") {
                      var idx = _v1.a;
                      var newTags = A2(
                        $elm$core$Maybe$withDefault,
                        track.tags,
                        A2(
                          $elm$core$Maybe$andThen,
                          $elm$core$Basics$identity,
                          A2($elm_community$list_extra$List$Extra$getAt, idx, tags)
                        )
                      );
                      return _Utils_Tuple3(
                        A2(
                          $elm$core$List$cons,
                          _Utils_update(
                            track,
                            { tags: newTags }
                          ),
                          acc
                        ),
                        A2($elm_community$list_extra$List$Extra$removeAt, idx, trackIds),
                        A2($elm_community$list_extra$List$Extra$removeAt, idx, tags)
                      );
                    } else {
                      return _Utils_Tuple3(
                        A2($elm$core$List$cons, track, acc),
                        trackIds,
                        tags
                      );
                    }
                  }
                ),
                _Utils_Tuple3(_List_Nil, context.trackIds, context.receivedTags),
                model.hypaethralUserData.tracks
              )
            )
          );
        }
      );
      var $author$project$Brain$Ports$requestSearch = _Platform_outgoingPort("requestSearch", $elm$json$Json$Encode$string);
      var $author$project$Brain$Tracks$State$search = function(encodedSearchTerm) {
        return $author$project$Return$Ext$communicate(
          A2(
            $elm$core$Result$withDefault,
            $elm$core$Platform$Cmd$none,
            A2(
              $elm$core$Result$map,
              $author$project$Brain$Ports$requestSearch,
              A2($elm$json$Json$Decode$decodeValue, $elm$json$Json$Decode$string, encodedSearchTerm)
            )
          )
        );
      };
      var $author$project$Brain$Other$State$setCurrentTime = F2(
        function(time, model) {
          return $Fresheyeball$elm_return$Return$singleton(
            _Utils_update(
              model,
              { currentTime: time }
            )
          );
        }
      );
      var $author$project$Brain$Ports$storeTracksInCache = _Platform_outgoingPort("storeTracksInCache", $elm$core$Basics$identity);
      var $author$project$Brain$Tracks$State$storeInCache = function(data) {
        return $author$project$Return$Ext$communicate(
          $author$project$Brain$Ports$storeTracksInCache(data)
        );
      };
      var $author$project$Brain$Ports$syncTags = _Platform_outgoingPort(
        "syncTags",
        function($) {
          return $elm$json$Json$Encode$object(
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "receivedFilePaths",
                  $elm$json$Json$Encode$list($elm$json$Json$Encode$string)($.receivedFilePaths)
                ),
                _Utils_Tuple2(
                  "receivedTags",
                  $elm$json$Json$Encode$list(
                    function($2) {
                      return A3(
                        $elm$core$Maybe$destruct,
                        $elm$json$Json$Encode$null,
                        function($3) {
                          return $elm$json$Json$Encode$object(
                            _List_fromArray(
                              [
                                _Utils_Tuple2(
                                  "album",
                                  $elm$json$Json$Encode$string($3.album)
                                ),
                                _Utils_Tuple2(
                                  "artist",
                                  $elm$json$Json$Encode$string($3.artist)
                                ),
                                _Utils_Tuple2(
                                  "disc",
                                  $elm$json$Json$Encode$int($3.disc)
                                ),
                                _Utils_Tuple2(
                                  "genre",
                                  function($4) {
                                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $4);
                                  }($3.genre)
                                ),
                                _Utils_Tuple2(
                                  "nr",
                                  $elm$json$Json$Encode$int($3.nr)
                                ),
                                _Utils_Tuple2(
                                  "picture",
                                  function($4) {
                                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $4);
                                  }($3.picture)
                                ),
                                _Utils_Tuple2(
                                  "title",
                                  $elm$json$Json$Encode$string($3.title)
                                ),
                                _Utils_Tuple2(
                                  "year",
                                  function($4) {
                                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$int, $4);
                                  }($3.year)
                                )
                              ]
                            )
                          );
                        },
                        $2
                      );
                    }
                  )($.receivedTags)
                ),
                _Utils_Tuple2(
                  "trackIds",
                  $elm$json$Json$Encode$list($elm$json$Json$Encode$string)($.trackIds)
                ),
                _Utils_Tuple2(
                  "urlsForTags",
                  $elm$json$Json$Encode$list(
                    function($2) {
                      return $elm$json$Json$Encode$object(
                        _List_fromArray(
                          [
                            _Utils_Tuple2(
                              "getUrl",
                              $elm$json$Json$Encode$string($2.getUrl)
                            ),
                            _Utils_Tuple2(
                              "headUrl",
                              $elm$json$Json$Encode$string($2.headUrl)
                            )
                          ]
                        )
                      );
                    }
                  )($.urlsForTags)
                )
              ]
            )
          );
        }
      );
      var $author$project$Brain$Tracks$State$tagUrls = F3(
        function(currentTime, path, source) {
          var maker = A4($author$project$Sources$Services$makeTrackUrl, source.service, currentTime, source.id, source.data);
          return {
            getUrl: A2(maker, $author$project$Sources$Processing$Get, path),
            headUrl: A2(maker, $author$project$Sources$Processing$Head, path)
          };
        }
      );
      var $author$project$Brain$Tracks$State$syncTrackTags = F2(
        function(data, model) {
          var result = A2(
            $elm$json$Json$Decode$decodeValue,
            $elm$json$Json$Decode$list(
              A4(
                $elm$json$Json$Decode$map3,
                F3(
                  function(path, sourceId, trackId) {
                    return { path, sourceId, trackId };
                  }
                ),
                A2($elm$json$Json$Decode$field, "path", $elm$json$Json$Decode$string),
                A2($elm$json$Json$Decode$field, "sourceId", $elm$json$Json$Decode$string),
                A2($elm$json$Json$Decode$field, "trackId", $elm$json$Json$Decode$string)
              )
            ),
            data
          );
          var _v0 = A3(
            $elm$core$List$foldl,
            F2(
              function(_v1, _v2) {
                var sourceId = _v1.sourceId;
                var dict = _v2.a;
                var acc = _v2.b;
                if (A2($elm$core$List$member, sourceId, acc)) {
                  return _Utils_Tuple2(dict, acc);
                } else {
                  var _v3 = A2(
                    $elm_community$list_extra$List$Extra$find,
                    A2(
                      $elm$core$Basics$composeR,
                      function($) {
                        return $.id;
                      },
                      $elm$core$Basics$eq(sourceId)
                    ),
                    model.hypaethralUserData.sources
                  );
                  if (_v3.$ === "Just") {
                    var source = _v3.a;
                    return _Utils_Tuple2(
                      A3($elm$core$Dict$insert, sourceId, source, dict),
                      A2($elm$core$List$cons, sourceId, acc)
                    );
                  } else {
                    return _Utils_Tuple2(
                      dict,
                      A2($elm$core$List$cons, sourceId, acc)
                    );
                  }
                }
              }
            ),
            _Utils_Tuple2($elm$core$Dict$empty, _List_Nil),
            A2($elm$core$Result$withDefault, _List_Nil, result)
          );
          var sources = _v0.a;
          if (result.$ === "Ok") {
            var list = result.a;
            return A2(
              $Fresheyeball$elm_return$Return$return,
              model,
              function(_v7) {
                var accPaths = _v7.a;
                var accUrls = _v7.b;
                var accIds = _v7.c;
                return $author$project$Brain$Ports$syncTags(
                  { receivedFilePaths: accPaths, receivedTags: _List_Nil, trackIds: accIds, urlsForTags: accUrls }
                );
              }(
                A3(
                  $elm$core$List$foldr,
                  F2(
                    function(_v5, _v6) {
                      var path = _v5.path;
                      var sourceId = _v5.sourceId;
                      var trackId = _v5.trackId;
                      var accPaths = _v6.a;
                      var accUrls = _v6.b;
                      var accIds = _v6.c;
                      return A2(
                        $elm$core$Maybe$withDefault,
                        _Utils_Tuple3(accPaths, accUrls, accIds),
                        A2(
                          $elm$core$Maybe$map,
                          function(urls) {
                            return _Utils_Tuple3(
                              A2($elm$core$List$cons, path, accPaths),
                              A2($elm$core$List$cons, urls, accUrls),
                              A2($elm$core$List$cons, trackId, accIds)
                            );
                          },
                          A2(
                            $elm$core$Maybe$map,
                            A2($author$project$Brain$Tracks$State$tagUrls, model.currentTime, path),
                            A2($elm$core$Dict$get, sourceId, sources)
                          )
                        )
                      );
                    }
                  ),
                  _Utils_Tuple3(_List_Nil, _List_Nil, _List_Nil),
                  list
                )
              )
            );
          } else {
            return $Fresheyeball$elm_return$Return$singleton(model);
          }
        }
      );
      var $author$project$Alien$hostDecoder = A4(
        $elm$json$Json$Decode$map3,
        F3(
          function(tag, data, error) {
            return { data, error, tag };
          }
        ),
        A2($elm$json$Json$Decode$field, "tag", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "data", $elm$json$Json$Decode$value),
        A2(
          $elm$json$Json$Decode$field,
          "error",
          $elm$json$Json$Decode$maybe($elm$json$Json$Decode$string)
        )
      );
      var $author$project$Brain$Ports$toCache = _Platform_outgoingPort(
        "toCache",
        function($) {
          return $elm$json$Json$Encode$object(
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "data",
                  $elm$core$Basics$identity($.data)
                ),
                _Utils_Tuple2(
                  "error",
                  function($2) {
                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $2);
                  }($.error)
                ),
                _Utils_Tuple2(
                  "tag",
                  $elm$json$Json$Encode$string($.tag)
                )
              ]
            )
          );
        }
      );
      var $author$project$Brain$Other$State$toCache = function(data) {
        var _v0 = A2($elm$json$Json$Decode$decodeValue, $author$project$Alien$hostDecoder, data);
        if (_v0.$ === "Ok") {
          var alienEvent = _v0.a;
          return $author$project$Return$Ext$communicate(
            $author$project$Brain$Ports$toCache(alienEvent)
          );
        } else {
          var err = _v0.a;
          return A2(
            $author$project$Brain$Common$State$reportUI,
            $author$project$Alien$ToCache,
            $elm$json$Json$Decode$errorToString(err)
          );
        }
      };
      var $author$project$Sources$Processing$Processing = F2(
        function(a, b) {
          return { $: "Processing", a, b };
        }
      );
      var $author$project$Alien$trigger = function(tag) {
        return {
          data: $elm$json$Json$Encode$null,
          error: $elm$core$Maybe$Nothing,
          tag: $author$project$Alien$tagToString(tag)
        };
      };
      var $author$project$Brain$Common$State$nudgeUICmd = function(tag) {
        return $author$project$Brain$Ports$toUI(
          $author$project$Alien$trigger(tag)
        );
      };
      var $author$project$Brain$Common$State$nudgeUI = A2($elm$core$Basics$composeR, $author$project$Brain$Common$State$nudgeUICmd, $author$project$Return$Ext$communicate);
      var $author$project$Sources$Processing$TheBeginning = { $: "TheBeginning" };
      var $author$project$Brain$Sources$Processing$Types$PrepareStep = F2(
        function(a, b) {
          return { $: "PrepareStep", a, b };
        }
      );
      var $author$project$Brain$Sources$Processing$Types$TreeStep = F2(
        function(a, b) {
          return { $: "TreeStep", a, b };
        }
      );
      var $author$project$Sources$Services$Common$cleanPath = function(dirtyPath) {
        return function(p) {
          return $elm$core$String$isEmpty(p) ? p : p + "/";
        }(
          A2(
            $author$project$String$Ext$chopEnd,
            "/",
            A2(
              $author$project$String$Ext$chopStart,
              "/",
              $elm$core$String$trim(dirtyPath)
            )
          )
        );
      };
      var $elm$http$Http$expectStringResponse = F2(
        function(toMsg, toResult) {
          return A3(
            _Http_expect,
            "",
            $elm$core$Basics$identity,
            A2($elm$core$Basics$composeR, toResult, toMsg)
          );
        }
      );
      var $elm$http$Http$Request = function(a) {
        return { $: "Request", a };
      };
      var $elm$http$Http$State = F2(
        function(reqs, subs) {
          return { reqs, subs };
        }
      );
      var $elm$http$Http$init = $elm$core$Task$succeed(
        A2($elm$http$Http$State, $elm$core$Dict$empty, _List_Nil)
      );
      var $elm$http$Http$updateReqs = F3(
        function(router, cmds, reqs) {
          updateReqs:
            while (true) {
              if (!cmds.b) {
                return $elm$core$Task$succeed(reqs);
              } else {
                var cmd = cmds.a;
                var otherCmds = cmds.b;
                if (cmd.$ === "Cancel") {
                  var tracker = cmd.a;
                  var _v2 = A2($elm$core$Dict$get, tracker, reqs);
                  if (_v2.$ === "Nothing") {
                    var $temp$router = router, $temp$cmds = otherCmds, $temp$reqs = reqs;
                    router = $temp$router;
                    cmds = $temp$cmds;
                    reqs = $temp$reqs;
                    continue updateReqs;
                  } else {
                    var pid = _v2.a;
                    return A2(
                      $elm$core$Task$andThen,
                      function(_v3) {
                        return A3(
                          $elm$http$Http$updateReqs,
                          router,
                          otherCmds,
                          A2($elm$core$Dict$remove, tracker, reqs)
                        );
                      },
                      $elm$core$Process$kill(pid)
                    );
                  }
                } else {
                  var req = cmd.a;
                  return A2(
                    $elm$core$Task$andThen,
                    function(pid2) {
                      var _v4 = req.tracker;
                      if (_v4.$ === "Nothing") {
                        return A3($elm$http$Http$updateReqs, router, otherCmds, reqs);
                      } else {
                        var tracker2 = _v4.a;
                        return A3(
                          $elm$http$Http$updateReqs,
                          router,
                          otherCmds,
                          A3($elm$core$Dict$insert, tracker2, pid2, reqs)
                        );
                      }
                    },
                    $elm$core$Process$spawn(
                      A3(
                        _Http_toTask,
                        router,
                        $elm$core$Platform$sendToApp(router),
                        req
                      )
                    )
                  );
                }
              }
            }
        }
      );
      var $elm$http$Http$onEffects = F4(
        function(router, cmds, subs, state) {
          return A2(
            $elm$core$Task$andThen,
            function(reqs) {
              return $elm$core$Task$succeed(
                A2($elm$http$Http$State, reqs, subs)
              );
            },
            A3($elm$http$Http$updateReqs, router, cmds, state.reqs)
          );
        }
      );
      var $elm$http$Http$maybeSend = F4(
        function(router, desiredTracker, progress, _v0) {
          var actualTracker = _v0.a;
          var toMsg = _v0.b;
          return _Utils_eq(desiredTracker, actualTracker) ? $elm$core$Maybe$Just(
            A2(
              $elm$core$Platform$sendToApp,
              router,
              toMsg(progress)
            )
          ) : $elm$core$Maybe$Nothing;
        }
      );
      var $elm$http$Http$onSelfMsg = F3(
        function(router, _v0, state) {
          var tracker = _v0.a;
          var progress = _v0.b;
          return A2(
            $elm$core$Task$andThen,
            function(_v1) {
              return $elm$core$Task$succeed(state);
            },
            $elm$core$Task$sequence(
              A2(
                $elm$core$List$filterMap,
                A3($elm$http$Http$maybeSend, router, tracker, progress),
                state.subs
              )
            )
          );
        }
      );
      var $elm$http$Http$Cancel = function(a) {
        return { $: "Cancel", a };
      };
      var $elm$http$Http$cmdMap = F2(
        function(func, cmd) {
          if (cmd.$ === "Cancel") {
            var tracker = cmd.a;
            return $elm$http$Http$Cancel(tracker);
          } else {
            var r = cmd.a;
            return $elm$http$Http$Request(
              {
                allowCookiesFromOtherDomains: r.allowCookiesFromOtherDomains,
                body: r.body,
                expect: A2(_Http_mapExpect, func, r.expect),
                headers: r.headers,
                method: r.method,
                timeout: r.timeout,
                tracker: r.tracker,
                url: r.url
              }
            );
          }
        }
      );
      var $elm$http$Http$MySub = F2(
        function(a, b) {
          return { $: "MySub", a, b };
        }
      );
      var $elm$http$Http$subMap = F2(
        function(func, _v0) {
          var tracker = _v0.a;
          var toMsg = _v0.b;
          return A2(
            $elm$http$Http$MySub,
            tracker,
            A2($elm$core$Basics$composeR, toMsg, func)
          );
        }
      );
      _Platform_effectManagers["Http"] = _Platform_createManager($elm$http$Http$init, $elm$http$Http$onEffects, $elm$http$Http$onSelfMsg, $elm$http$Http$cmdMap, $elm$http$Http$subMap);
      var $elm$http$Http$command = _Platform_leaf("Http");
      var $elm$http$Http$subscription = _Platform_leaf("Http");
      var $elm$http$Http$request = function(r) {
        return $elm$http$Http$command(
          $elm$http$Http$Request(
            { allowCookiesFromOtherDomains: false, body: r.body, expect: r.expect, headers: r.headers, method: r.method, timeout: r.timeout, tracker: r.tracker, url: r.url }
          )
        );
      };
      var $elm$http$Http$get = function(r) {
        return $elm$http$Http$request(
          { body: $elm$http$Http$emptyBody, expect: r.expect, headers: _List_Nil, method: "GET", timeout: $elm$core$Maybe$Nothing, tracker: $elm$core$Maybe$Nothing, url: r.url }
        );
      };
      var $author$project$Common$translateHttpResponse = function(response) {
        switch (response.$) {
          case "BadUrl_":
            var u = response.a;
            return $elm$core$Result$Err(
              $elm$http$Http$BadUrl(u)
            );
          case "Timeout_":
            return $elm$core$Result$Err($elm$http$Http$Timeout);
          case "NetworkError_":
            return $elm$core$Result$Err($elm$http$Http$NetworkError);
          case "BadStatus_":
            var body = response.b;
            return $elm$core$Result$Err(
              $elm$http$Http$BadBody(body)
            );
          default:
            var body = response.b;
            return $elm$core$Result$Ok(body);
        }
      };
      var $author$project$Sources$Services$AmazonS3$makeTree = F4(
        function(srcData, marker, currentTime, resultMsg) {
          var initialParams = _List_fromArray(
            [
              _Utils_Tuple2("list-type", "2"),
              _Utils_Tuple2("max-keys", "500")
            ]
          );
          var directoryPath = $author$project$Sources$Services$Common$cleanPath(
            A2(
              $elm$core$Maybe$withDefault,
              "",
              A2($elm$core$Dict$get, "directoryPath", srcData)
            )
          );
          var prefix = $elm$core$String$length(directoryPath) > 0 ? _List_fromArray(
            [
              _Utils_Tuple2("prefix", directoryPath)
            ]
          ) : _List_Nil;
          var continuation = function() {
            if (marker.$ === "InProgress") {
              var s = marker.a;
              return _List_fromArray(
                [
                  _Utils_Tuple2("continuation-token", s)
                ]
              );
            } else {
              return _List_Nil;
            }
          }();
          var params = _Utils_ap(
            initialParams,
            _Utils_ap(prefix, continuation)
          );
          var url = A6($author$project$Sources$Services$AmazonS3$Presign$presignedUrl, $author$project$Sources$Processing$Get, 60 * 5, params, currentTime, srcData, "/");
          return $elm$http$Http$get(
            {
              expect: A2($elm$http$Http$expectStringResponse, resultMsg, $author$project$Common$translateHttpResponse),
              url
            }
          );
        }
      );
      var $author$project$Sources$Services$Azure$Authorization$List = { $: "List" };
      var $author$project$Sources$Services$AzureBlob$makeTree = F4(
        function(srcData, marker, currentTime, resultMsg) {
          var params = function() {
            if (marker.$ === "InProgress") {
              var s = marker.a;
              return _List_fromArray(
                [
                  _Utils_Tuple2("marker", s)
                ]
              );
            } else {
              return _List_Nil;
            }
          }();
          var directoryPath = $author$project$Sources$Services$Common$cleanPath(
            A2(
              $elm$core$Maybe$withDefault,
              "",
              A2($elm$core$Dict$get, "directoryPath", srcData)
            )
          );
          var baseParams = _List_fromArray(
            [
              _Utils_Tuple2("maxresults", "1000")
            ]
          );
          var url = A8(
            $author$project$Sources$Services$Azure$Authorization$presignedUrl,
            $author$project$Sources$Services$Azure$Authorization$Blob,
            $author$project$Sources$Services$Azure$Authorization$List,
            $author$project$Sources$Processing$Get,
            1,
            currentTime,
            srcData,
            directoryPath,
            _Utils_ap(baseParams, params)
          );
          return $elm$http$Http$get(
            {
              expect: A2($elm$http$Http$expectStringResponse, resultMsg, $author$project$Common$translateHttpResponse),
              url
            }
          );
        }
      );
      var $author$project$Sources$Services$Azure$FileMarker$separator = " \u0251 ";
      var $author$project$Sources$Services$Azure$FileMarker$Directory = function(a) {
        return { $: "Directory", a };
      };
      var $author$project$Sources$Services$Azure$FileMarker$Param = function(a) {
        return { $: "Param", a };
      };
      var $author$project$Sources$Services$Azure$FileMarker$paramSeparator = " \u0263 ";
      var $author$project$Sources$Services$Azure$FileMarker$prefixer = " \u03B2 ";
      var $author$project$Sources$Services$Azure$FileMarker$stringToItem = function(string) {
        var exploded = A2($elm$core$String$split, $author$project$Sources$Services$Azure$FileMarker$prefixer, string);
        var _v0 = $elm$core$List$head(exploded);
        _v0$2:
          while (true) {
            if (_v0.$ === "Just") {
              switch (_v0.a) {
                case "dir":
                  return $elm$core$Maybe$Just(
                    $author$project$Sources$Services$Azure$FileMarker$Directory(
                      A2(
                        $elm$core$String$join,
                        $author$project$Sources$Services$Azure$FileMarker$prefixer,
                        A2($elm$core$List$drop, 1, exploded)
                      )
                    )
                  );
                case "par":
                  return function(x) {
                    if (x.b && x.b.b && !x.b.b.b) {
                      var dir = x.a;
                      var _v2 = x.b;
                      var mar = _v2.a;
                      return $elm$core$Maybe$Just(
                        $author$project$Sources$Services$Azure$FileMarker$Param(
                          { directory: dir, marker: mar }
                        )
                      );
                    } else {
                      return $elm$core$Maybe$Nothing;
                    }
                  }(
                    A2(
                      $elm$core$String$split,
                      $author$project$Sources$Services$Azure$FileMarker$paramSeparator,
                      A2(
                        $elm$core$String$join,
                        $author$project$Sources$Services$Azure$FileMarker$prefixer,
                        A2($elm$core$List$drop, 1, exploded)
                      )
                    )
                  );
                default:
                  break _v0$2;
              }
            } else {
              break _v0$2;
            }
          }
        return $elm$core$Maybe$Nothing;
      };
      var $author$project$Sources$Services$Azure$FileMarker$takeOne = function(marker) {
        if (marker.$ === "InProgress") {
          var m = marker.a;
          return A2(
            $elm$core$Maybe$andThen,
            $author$project$Sources$Services$Azure$FileMarker$stringToItem,
            $elm$core$List$head(
              A2($elm$core$String$split, $author$project$Sources$Services$Azure$FileMarker$separator, m)
            )
          );
        } else {
          return $elm$core$Maybe$Nothing;
        }
      };
      var $author$project$Sources$Services$AzureFile$makeTree = F4(
        function(srcData, marker, currentTime, resultMsg) {
          var directoryPathFromSrcData = $author$project$Sources$Services$Common$cleanPath(
            A2(
              $elm$core$Maybe$withDefault,
              "",
              A2($elm$core$Dict$get, "directoryPath", srcData)
            )
          );
          var baseParams = _List_fromArray(
            [
              _Utils_Tuple2("maxresults", "1000")
            ]
          );
          var _v0 = function() {
            var _v1 = $author$project$Sources$Services$Azure$FileMarker$takeOne(marker);
            if (_v1.$ === "Just") {
              if (_v1.a.$ === "Directory") {
                var directory = _v1.a.a;
                return A2($elm$core$Tuple$pair, directory, _List_Nil);
              } else {
                var param = _v1.a.a;
                return A2(
                  $elm$core$Tuple$pair,
                  param.directory,
                  _List_fromArray(
                    [
                      _Utils_Tuple2("marker", param.marker)
                    ]
                  )
                );
              }
            } else {
              return A2($elm$core$Tuple$pair, directoryPathFromSrcData, _List_Nil);
            }
          }();
          var directoryPath = _v0.a;
          var params = _v0.b;
          var url = A8(
            $author$project$Sources$Services$Azure$Authorization$presignedUrl,
            $author$project$Sources$Services$Azure$Authorization$File,
            $author$project$Sources$Services$Azure$Authorization$List,
            $author$project$Sources$Processing$Get,
            1,
            currentTime,
            srcData,
            directoryPath,
            _Utils_ap(baseParams, params)
          );
          return $elm$http$Http$get(
            {
              expect: A2($elm$http$Http$expectStringResponse, resultMsg, $author$project$Common$translateHttpResponse),
              url
            }
          );
        }
      );
      var $author$project$Common$boolFromString = function(string) {
        if (string === "t") {
          return true;
        } else {
          return false;
        }
      };
      var $author$project$Common$boolToString = function(bool) {
        return bool ? "t" : "f";
      };
      var $author$project$Sources$Services$Ipfs$defaults = {
        gateway: "",
        ipns: $author$project$Common$boolToString(false),
        local: $author$project$Common$boolToString(false),
        name: "Music from IPFS"
      };
      var $author$project$Conditional$ifThenElse = F3(
        function(bool, x, y) {
          return bool ? x : y;
        }
      );
      var $author$project$Sources$Services$Ipfs$ipnsResolver = function(response) {
        switch (response.$) {
          case "BadUrl_":
            var u = response.a;
            return $elm$core$Result$Err(
              $elm$http$Http$BadUrl(u)
            );
          case "Timeout_":
            return $elm$core$Result$Err($elm$http$Http$Timeout);
          case "NetworkError_":
            return $elm$core$Result$Err($elm$http$Http$NetworkError);
          case "BadStatus_":
            var body = response.b;
            return $elm$core$Result$Err(
              $elm$http$Http$BadBody(body)
            );
          default:
            var body = response.b;
            return A2(
              $elm$core$Result$mapError,
              A2($elm$core$Basics$composeR, $elm$json$Json$Decode$errorToString, $elm$http$Http$BadBody),
              A2(
                $elm$core$Result$map,
                function(path) {
                  return {
                    ipfsPath: A2($author$project$String$Ext$chopStart, "/ipfs/", path)
                  };
                },
                A2(
                  $elm$json$Json$Decode$decodeString,
                  A2($elm$json$Json$Decode$field, "Path", $elm$json$Json$Decode$string),
                  body
                )
              )
            );
        }
      };
      var $author$project$Sources$Services$Ipfs$Marker$separator = " \u0251 ";
      var $author$project$Sources$Services$Ipfs$Marker$takeOne = function(marker) {
        if (marker.$ === "InProgress") {
          var m = marker.a;
          return $elm$core$List$head(
            A2($elm$core$String$split, $author$project$Sources$Services$Ipfs$Marker$separator, m)
          );
        } else {
          return $elm$core$Maybe$Nothing;
        }
      };
      var $author$project$Sources$Services$Ipfs$makeTree = F4(
        function(srcData, marker, _v0, resultMsg) {
          var root = $author$project$Sources$Services$Ipfs$rootHash(srcData);
          var resolveWithIpns = function() {
            if (marker.$ === "InProgress") {
              return false;
            } else {
              return $author$project$Common$boolFromString(
                A3($author$project$Dict$Ext$fetch, "ipns", $author$project$Sources$Services$Ipfs$defaults.ipns, srcData)
              );
            }
          }();
          var resolveLocally = function(b) {
            return A3($author$project$Conditional$ifThenElse, b, "true", "false");
          }(
            $author$project$Common$boolFromString(
              A3($author$project$Dict$Ext$fetch, "local", $author$project$Sources$Services$Ipfs$defaults.local, srcData)
            )
          );
          var path = function() {
            if (marker.$ === "InProgress") {
              return A2(
                $elm$core$Maybe$withDefault,
                "",
                A2(
                  $elm$core$Maybe$map,
                  function(p) {
                    return root + ("/" + p);
                  },
                  $author$project$Sources$Services$Ipfs$Marker$takeOne(marker)
                )
              );
            } else {
              return root;
            }
          }();
          var gateway = $author$project$Sources$Services$Ipfs$extractGateway(srcData);
          return A2(
            $elm$core$Task$attempt,
            resultMsg,
            A2(
              $elm$core$Task$andThen,
              function(_v1) {
                var ipfsPath = _v1.ipfsPath;
                return $elm$http$Http$task(
                  {
                    body: $elm$http$Http$emptyBody,
                    headers: _List_Nil,
                    method: "POST",
                    resolver: $elm$http$Http$stringResolver($author$project$Common$translateHttpResponse),
                    timeout: $elm$core$Maybe$Just(60 * 15 * 1e3),
                    url: gateway + ("/api/v0/ls?arg=" + ($author$project$Sources$Services$Ipfs$encodedPath(ipfsPath) + "&encoding=json"))
                  }
                );
              },
              resolveWithIpns ? $elm$http$Http$task(
                {
                  body: $elm$http$Http$emptyBody,
                  headers: _List_Nil,
                  method: "POST",
                  resolver: $elm$http$Http$stringResolver($author$project$Sources$Services$Ipfs$ipnsResolver),
                  timeout: $elm$core$Maybe$Just(60 * 15 * 1e3),
                  url: gateway + ("/api/v0/name/resolve?arg=" + ($author$project$Sources$Services$Ipfs$encodedPath(path) + ("&local=" + (resolveLocally + "&encoding=json"))))
                }
              ) : $elm$core$Task$succeed(
                { ipfsPath: path }
              )
            )
          );
        }
      );
      var $author$project$Sources$Services$Btfs$makeTree = $author$project$Sources$Services$Ipfs$makeTree;
      var $author$project$Sources$Services$Dropbox$getProperDirectoryPath = function(srcData) {
        var path = $author$project$Sources$Services$Common$cleanPath(
          A2(
            $elm$core$Maybe$withDefault,
            "",
            A2($elm$core$Dict$get, "directoryPath", srcData)
          )
        );
        return path === "" ? "" : "/" + path;
      };
      var $elm$http$Http$Header = F2(
        function(a, b) {
          return { $: "Header", a, b };
        }
      );
      var $elm$http$Http$header = $elm$http$Http$Header;
      var $author$project$Sources$Services$Dropbox$makeTree = F4(
        function(srcData, marker, _v0, resultMsg) {
          var url = function() {
            switch (marker.$) {
              case "TheBeginning":
                return "https://api.dropboxapi.com/2/files/list_folder";
              case "InProgress":
                return "https://api.dropboxapi.com/2/files/list_folder/continue";
              default:
                return "";
            }
          }();
          var body = $elm$http$Http$jsonBody(
            $elm$json$Json$Encode$object(
              function() {
                switch (marker.$) {
                  case "TheBeginning":
                    return _List_fromArray(
                      [
                        _Utils_Tuple2(
                          "limit",
                          $elm$json$Json$Encode$int(2e3)
                        ),
                        _Utils_Tuple2(
                          "path",
                          $elm$json$Json$Encode$string(
                            $author$project$Sources$Services$Dropbox$getProperDirectoryPath(srcData)
                          )
                        ),
                        _Utils_Tuple2(
                          "recursive",
                          $elm$json$Json$Encode$bool(true)
                        )
                      ]
                    );
                  case "InProgress":
                    var cursor = marker.a;
                    return _List_fromArray(
                      [
                        _Utils_Tuple2(
                          "cursor",
                          $elm$json$Json$Encode$string(cursor)
                        )
                      ]
                    );
                  default:
                    return _List_Nil;
                }
              }()
            )
          );
          var accessToken = A3($author$project$Dict$Ext$fetch, "accessToken", "", srcData);
          return $elm$http$Http$request(
            {
              body,
              expect: A2($elm$http$Http$expectStringResponse, resultMsg, $author$project$Common$translateHttpResponse),
              headers: _List_fromArray(
                [
                  A2($elm$http$Http$header, "Authorization", "Bearer " + accessToken)
                ]
              ),
              method: "POST",
              timeout: $elm$core$Maybe$Nothing,
              tracker: $elm$core$Maybe$Nothing,
              url
            }
          );
        }
      );
      var $author$project$Sources$Services$Google$Marker$itemDirectory = function(item) {
        if (item.$ === "Directory") {
          var dir = item.a;
          return dir;
        } else {
          var directory = item.a.directory;
          return directory;
        }
      };
      var $author$project$Sources$Services$Google$Marker$separator = " \u0251 ";
      var $author$project$Sources$Services$Google$Marker$Directory = function(a) {
        return { $: "Directory", a };
      };
      var $author$project$Sources$Services$Google$Marker$Param = function(a) {
        return { $: "Param", a };
      };
      var $author$project$Sources$Services$Google$Marker$paramSeparator = " \u0263 ";
      var $author$project$Sources$Services$Google$Marker$prefixer = " \u03B2 ";
      var $author$project$Sources$Services$Google$Marker$stringToItem = function(string) {
        var exploded = A2($elm$core$String$split, $author$project$Sources$Services$Google$Marker$prefixer, string);
        var _v0 = $elm$core$List$head(exploded);
        _v0$2:
          while (true) {
            if (_v0.$ === "Just") {
              switch (_v0.a) {
                case "dir":
                  return $elm$core$Maybe$Just(
                    $author$project$Sources$Services$Google$Marker$Directory(
                      A2(
                        $elm$core$String$join,
                        $author$project$Sources$Services$Google$Marker$prefixer,
                        A2($elm$core$List$drop, 1, exploded)
                      )
                    )
                  );
                case "par":
                  return function(x) {
                    if (x.b && x.b.b && !x.b.b.b) {
                      var dir = x.a;
                      var _v2 = x.b;
                      var tok = _v2.a;
                      return $elm$core$Maybe$Just(
                        $author$project$Sources$Services$Google$Marker$Param(
                          { directory: dir, token: tok }
                        )
                      );
                    } else {
                      return $elm$core$Maybe$Nothing;
                    }
                  }(
                    A2(
                      $elm$core$String$split,
                      $author$project$Sources$Services$Google$Marker$paramSeparator,
                      A2(
                        $elm$core$String$join,
                        $author$project$Sources$Services$Google$Marker$prefixer,
                        A2($elm$core$List$drop, 1, exploded)
                      )
                    )
                  );
                default:
                  break _v0$2;
              }
            } else {
              break _v0$2;
            }
          }
        return $elm$core$Maybe$Nothing;
      };
      var $author$project$Sources$Services$Google$Marker$takeOne = function(marker) {
        if (marker.$ === "InProgress") {
          var m = marker.a;
          return A2(
            $elm$core$Maybe$andThen,
            $author$project$Sources$Services$Google$Marker$stringToItem,
            $elm$core$List$head(
              A2($elm$core$String$split, $author$project$Sources$Services$Google$Marker$separator, m)
            )
          );
        } else {
          return $elm$core$Maybe$Nothing;
        }
      };
      var $author$project$Sources$Services$Google$makeTree = F4(
        function(srcData, marker, _v0, resultMsg) {
          var folderId = A3($author$project$Dict$Ext$fetch, "folderId", "", srcData);
          var parentId = $author$project$String$Path$file(
            A2(
              $elm$core$Maybe$withDefault,
              folderId,
              A2(
                $elm$core$Maybe$andThen,
                function(dir) {
                  return A3(
                    $author$project$Conditional$ifThenElse,
                    $elm$core$String$isEmpty(dir),
                    $elm$core$Maybe$Nothing,
                    $elm$core$Maybe$Just(dir)
                  );
                },
                A2(
                  $elm$core$Maybe$map,
                  $author$project$Sources$Services$Google$Marker$itemDirectory,
                  $author$project$Sources$Services$Google$Marker$takeOne(marker)
                )
              )
            )
          );
          var query = function() {
            if (parentId === "") {
              return _List_fromArray(
                ["mimeType contains 'audio/'"]
              );
            } else {
              var pid = parentId;
              return _List_fromArray(
                ["(mimeType contains 'audio/'", "or mimeType = 'application/vnd.google-apps.folder')", "and ('" + (pid + "' in parents)")]
              );
            }
          }();
          var paramsBase = _List_fromArray(
            [
              _Utils_Tuple2(
                "fields",
                A2(
                  $elm$core$String$join,
                  ", ",
                  _List_fromArray(
                    ["nextPageToken", "files/id", "files/mimeType", "files/name", "files/trashed"]
                  )
                )
              ),
              _Utils_Tuple2("includeItemsFromAllDrives", "true"),
              _Utils_Tuple2("pageSize", "1000"),
              _Utils_Tuple2(
                "q",
                $elm$core$String$concat(query)
              ),
              _Utils_Tuple2("spaces", "drive"),
              _Utils_Tuple2("supportsAllDrives", "true")
            ]
          );
          var queryString = $author$project$Common$queryString(
            A2(
              $elm$core$List$append,
              paramsBase,
              function() {
                var _v1 = $author$project$Sources$Services$Google$Marker$takeOne(marker);
                if (_v1.$ === "Just" && _v1.a.$ === "Param") {
                  var token = _v1.a.a.token;
                  return _List_fromArray(
                    [
                      _Utils_Tuple2("pageToken", token)
                    ]
                  );
                } else {
                  return _List_Nil;
                }
              }()
            )
          );
          var accessToken = A3($author$project$Dict$Ext$fetch, "accessToken", "", srcData);
          return $elm$http$Http$request(
            {
              body: $elm$http$Http$emptyBody,
              expect: A2($elm$http$Http$expectStringResponse, resultMsg, $author$project$Common$translateHttpResponse),
              headers: _List_fromArray(
                [
                  A2($elm$http$Http$header, "Authorization", "Bearer " + accessToken)
                ]
              ),
              method: "GET",
              timeout: $elm$core$Maybe$Nothing,
              tracker: $elm$core$Maybe$Nothing,
              url: "https://www.googleapis.com/drive/v3/files" + queryString
            }
          );
        }
      );
      var $author$project$Sources$Services$WebDav$Marker$takeOne = $author$project$Sources$Services$Ipfs$Marker$takeOne;
      var $author$project$Sources$Services$WebDav$makeTree = F4(
        function(srcData, marker, _v0, resultMsg) {
          var username = A3($author$project$Dict$Ext$fetch, "username", "", srcData);
          var password = A3($author$project$Dict$Ext$fetch, "password", "", srcData);
          var directory = function() {
            if (marker.$ === "InProgress") {
              return A2(
                $elm$core$Maybe$withDefault,
                "",
                $author$project$Sources$Services$WebDav$Marker$takeOne(marker)
              );
            } else {
              return A2(
                $elm$core$Maybe$withDefault,
                "",
                A2($elm$core$Dict$get, "directoryPath", srcData)
              );
            }
          }();
          var auth = "Basic " + $truqu$elm_base64$Base64$encode(username + (":" + password));
          return $elm$http$Http$request(
            {
              body: $elm$http$Http$emptyBody,
              expect: A2($elm$http$Http$expectStringResponse, resultMsg, $author$project$Common$translateHttpResponse),
              headers: _List_fromArray(
                [
                  A2($elm$http$Http$header, "Authorization", auth),
                  A2($elm$http$Http$header, "Depth", "1")
                ]
              ),
              method: "PROPFIND",
              timeout: $elm$core$Maybe$Nothing,
              tracker: $elm$core$Maybe$Nothing,
              url: A3(
                $author$project$Sources$Services$WebDav$url,
                { addAuth: false },
                srcData,
                directory
              )
            }
          );
        }
      );
      var $author$project$Sources$Services$makeTree = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return $author$project$Sources$Services$AmazonS3$makeTree;
          case "AzureBlob":
            return $author$project$Sources$Services$AzureBlob$makeTree;
          case "AzureFile":
            return $author$project$Sources$Services$AzureFile$makeTree;
          case "Btfs":
            return $author$project$Sources$Services$Btfs$makeTree;
          case "Dropbox":
            return $author$project$Sources$Services$Dropbox$makeTree;
          case "Google":
            return $author$project$Sources$Services$Google$makeTree;
          case "Ipfs":
            return $author$project$Sources$Services$Ipfs$makeTree;
          default:
            return $author$project$Sources$Services$WebDav$makeTree;
        }
      };
      var $author$project$Brain$Sources$Processing$Steps$makeTree = F2(
        function(context, currentTime) {
          return A5(
            $author$project$Sources$Services$makeTree,
            context.source.service,
            context.source.data,
            context.treeMarker,
            currentTime,
            A2(
              $elm$core$Basics$composeL,
              $author$project$Brain$Types$ProcessingMsg,
              $author$project$Brain$Sources$Processing$Types$TreeStep(context)
            )
          );
        }
      );
      var $author$project$Sources$Services$AmazonS3$prepare = F4(
        function(_v0, _v1, _v2, _v3) {
          return $elm$core$Maybe$Nothing;
        }
      );
      var $author$project$Sources$Services$AzureBlob$prepare = F4(
        function(_v0, _v1, _v2, _v3) {
          return $elm$core$Maybe$Nothing;
        }
      );
      var $author$project$Sources$Services$AzureFile$prepare = F4(
        function(_v0, _v1, _v2, _v3) {
          return $elm$core$Maybe$Nothing;
        }
      );
      var $elm$http$Http$resolve = F2(
        function(toResult, response) {
          switch (response.$) {
            case "BadUrl_":
              var url = response.a;
              return $elm$core$Result$Err(
                $elm$http$Http$BadUrl(url)
              );
            case "Timeout_":
              return $elm$core$Result$Err($elm$http$Http$Timeout);
            case "NetworkError_":
              return $elm$core$Result$Err($elm$http$Http$NetworkError);
            case "BadStatus_":
              var metadata = response.a;
              return $elm$core$Result$Err(
                $elm$http$Http$BadStatus(metadata.statusCode)
              );
            default:
              var body = response.b;
              return A2(
                $elm$core$Result$mapError,
                $elm$http$Http$BadBody,
                toResult(body)
              );
          }
        }
      );
      var $elm$http$Http$expectString = function(toMsg) {
        return A2(
          $elm$http$Http$expectStringResponse,
          toMsg,
          $elm$http$Http$resolve($elm$core$Result$Ok)
        );
      };
      var $author$project$Sources$Services$Ipfs$isDnsLink = function(srcData) {
        return A2(
          $elm$core$Maybe$withDefault,
          false,
          A2(
            $elm$core$Maybe$map,
            $author$project$Sources$Services$Ipfs$pathIsDnsLink,
            A2($elm$core$Dict$get, "directoryHash", srcData)
          )
        );
      };
      var $author$project$Sources$Services$Ipfs$prepare = F4(
        function(_v0, srcData, _v1, toMsg) {
          var domainName = A2(
            $author$project$String$Ext$chopStart,
            "_dnslink.",
            A2(
              $author$project$String$Ext$chopEnd,
              "/",
              A2(
                $author$project$String$Ext$chopStart,
                "https://",
                A2(
                  $author$project$String$Ext$chopStart,
                  "http://",
                  A2(
                    $elm$core$Maybe$withDefault,
                    "",
                    A2($elm$core$Dict$get, "directoryHash", srcData)
                  )
                )
              )
            )
          );
          return $author$project$Sources$Services$Ipfs$isDnsLink(srcData) ? A2($elm$core$Basics$composeL, $elm$core$Maybe$Just, $elm$http$Http$request)(
            {
              body: $elm$http$Http$emptyBody,
              expect: $elm$http$Http$expectString(toMsg),
              headers: _List_Nil,
              method: "POST",
              timeout: $elm$core$Maybe$Nothing,
              tracker: $elm$core$Maybe$Nothing,
              url: $author$project$Sources$Services$Ipfs$extractGateway(srcData) + ("/api/v0/dns?arg=" + domainName)
            }
          ) : $elm$core$Maybe$Nothing;
        }
      );
      var $author$project$Sources$Services$Btfs$prepare = $author$project$Sources$Services$Ipfs$prepare;
      var $author$project$Sources$Services$Dropbox$prepare = F4(
        function(_v0, _v1, _v2, _v3) {
          return $elm$core$Maybe$Nothing;
        }
      );
      var $elm$http$Http$post = function(r) {
        return $elm$http$Http$request(
          { body: r.body, expect: r.expect, headers: _List_Nil, method: "POST", timeout: $elm$core$Maybe$Nothing, tracker: $elm$core$Maybe$Nothing, url: r.url }
        );
      };
      var $author$project$Sources$Services$Google$prepare = F4(
        function(origin, srcData, _v0, resultMsg) {
          var maybeCode = A2($elm$core$Dict$get, "authCode", srcData);
          var queryParams = function() {
            if (maybeCode.$ === "Just") {
              return _List_fromArray(
                [
                  _Utils_Tuple2(
                    "client_id",
                    A3($author$project$Dict$Ext$fetch, "clientId", "", srcData)
                  ),
                  _Utils_Tuple2(
                    "client_secret",
                    A3($author$project$Dict$Ext$fetch, "clientSecret", "", srcData)
                  ),
                  _Utils_Tuple2(
                    "code",
                    A3($author$project$Dict$Ext$fetch, "authCode", "", srcData)
                  ),
                  _Utils_Tuple2("grant_type", "authorization_code"),
                  _Utils_Tuple2("redirect_uri", origin + "?path=sources/new/google")
                ]
              );
            } else {
              return _List_fromArray(
                [
                  _Utils_Tuple2(
                    "client_id",
                    A3($author$project$Dict$Ext$fetch, "clientId", "", srcData)
                  ),
                  _Utils_Tuple2(
                    "client_secret",
                    A3($author$project$Dict$Ext$fetch, "clientSecret", "", srcData)
                  ),
                  _Utils_Tuple2(
                    "refresh_token",
                    A3($author$project$Dict$Ext$fetch, "refreshToken", "", srcData)
                  ),
                  _Utils_Tuple2("grant_type", "refresh_token")
                ]
              );
            }
          }();
          var query = $author$project$Common$queryString(queryParams);
          var url = "https://www.googleapis.com/oauth2/v4/token" + query;
          return A2($elm$core$Basics$composeL, $elm$core$Maybe$Just, $elm$http$Http$post)(
            {
              body: $elm$http$Http$emptyBody,
              expect: A2($elm$http$Http$expectStringResponse, resultMsg, $author$project$Common$translateHttpResponse),
              url
            }
          );
        }
      );
      var $author$project$Sources$Services$WebDav$prepare = F4(
        function(_v0, _v1, _v2, _v3) {
          return $elm$core$Maybe$Nothing;
        }
      );
      var $author$project$Sources$Services$prepare = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return $author$project$Sources$Services$AmazonS3$prepare;
          case "AzureBlob":
            return $author$project$Sources$Services$AzureBlob$prepare;
          case "AzureFile":
            return $author$project$Sources$Services$AzureFile$prepare;
          case "Btfs":
            return $author$project$Sources$Services$Btfs$prepare;
          case "Dropbox":
            return $author$project$Sources$Services$Dropbox$prepare;
          case "Google":
            return $author$project$Sources$Services$Google$prepare;
          case "Ipfs":
            return $author$project$Sources$Services$Ipfs$prepare;
          default:
            return $author$project$Sources$Services$WebDav$prepare;
        }
      };
      var $author$project$Brain$Sources$Processing$Steps$prepare = F2(
        function(context, currentTime) {
          var maybePreparationCommand = A5(
            $author$project$Sources$Services$prepare,
            context.source.service,
            context.origin,
            context.source.data,
            context.preparationMarker,
            A2(
              $elm$core$Basics$composeL,
              $author$project$Brain$Types$ProcessingMsg,
              $author$project$Brain$Sources$Processing$Types$PrepareStep(context)
            )
          );
          if (maybePreparationCommand.$ === "Just") {
            var cmd = maybePreparationCommand.a;
            return cmd;
          } else {
            return A2($author$project$Brain$Sources$Processing$Steps$makeTree, context, currentTime);
          }
        }
      );
      var $author$project$Brain$Sources$Processing$Steps$takeFirstStep = F3(
        function(origin, currentTime, source) {
          var initialContext = { filePaths: _List_Nil, origin, preparationMarker: $author$project$Sources$Processing$TheBeginning, source, treeMarker: $author$project$Sources$Processing$TheBeginning };
          return A2($author$project$Brain$Sources$Processing$Steps$prepare, initialContext, currentTime);
        }
      );
      var $author$project$Brain$Sources$Processing$State$nextInLine = function(model) {
        var _v0 = model.processingStatus;
        if (_v0.$ === "Processing" && _v0.b.b) {
          var _v1 = _v0.a;
          var processedSource = _v1.a;
          var _v2 = _v0.b;
          var _v3 = _v2.a;
          var source = _v3.a;
          var tracks = _v3.b;
          var rest = _v2.b;
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            A2(
              $author$project$Brain$Common$State$giveUI,
              $author$project$Alien$FinishedProcessingSource,
              $elm$json$Json$Encode$string(processedSource.id)
            ),
            A2(
              $Fresheyeball$elm_return$Return$return,
              _Utils_update(
                model,
                {
                  processingStatus: A2(
                    $author$project$Sources$Processing$Processing,
                    _Utils_Tuple2(source, tracks),
                    rest
                  )
                }
              ),
              A3($author$project$Brain$Sources$Processing$Steps$takeFirstStep, model.origin, model.currentTime, source)
            )
          );
        } else {
          return A2(
            $author$project$Brain$Common$State$nudgeUI,
            $author$project$Alien$FinishedProcessingSources,
            _Utils_update(
              model,
              { processingStatus: $author$project$Sources$Processing$NotProcessing }
            )
          );
        }
      };
      var $author$project$Brain$Sources$Processing$Common$reportError = F2(
        function(source, error) {
          return A2(
            $author$project$Brain$Common$State$giveUI,
            $author$project$Alien$ReportProcessingError,
            $elm$json$Json$Encode$object(
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "sourceId",
                    $elm$json$Json$Encode$string(source.id)
                  ),
                  _Utils_Tuple2(
                    "sourceName",
                    $elm$json$Json$Encode$string(
                      A3($author$project$Dict$Ext$fetch, "name", "Unnamed", source.data)
                    )
                  ),
                  _Utils_Tuple2(
                    "error",
                    $elm$json$Json$Encode$string(error)
                  )
                ]
              )
            )
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$decodeXml = F2(
        function(_v0, _v1) {
          var decoder = _v0.a;
          var root = _v1.root;
          return decoder(root);
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$Internal$escape = function(s) {
        var reducer = function(_char) {
          switch (_char.valueOf()) {
            case "&":
              return $elm$core$String$append("&amp;");
            case "<":
              return $elm$core$String$append("&lt;");
            case ">":
              return $elm$core$String$append("&gt;");
            case '"':
              return $elm$core$String$append("&quot;");
            case "'":
              return $elm$core$String$append("&apos;");
            default:
              var c = _char;
              return $elm$core$String$cons(c);
          }
        };
        return A3($elm$core$String$foldr, reducer, "", s);
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$Internal$formatAttribute = function(attribute) {
        return $ymtszw$elm_xml_decode$Xml$Decode$Internal$escape(attribute.name) + ('="' + ($ymtszw$elm_xml_decode$Xml$Decode$Internal$escape(attribute.value) + '"'));
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$Internal$attributesToString = function(attrs) {
        if (!attrs.b) {
          return "";
        } else {
          return " " + A2(
            $elm$core$String$join,
            " ",
            A2($elm$core$List$map, $ymtszw$elm_xml_decode$Xml$Decode$Internal$formatAttribute, attrs)
          );
        }
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$Internal$formatNode = function(node) {
        if (node.$ === "Element") {
          var tagName = node.a;
          var attrs = node.b;
          var children = node.c;
          return "<" + ($ymtszw$elm_xml_decode$Xml$Decode$Internal$escape(tagName) + ($ymtszw$elm_xml_decode$Xml$Decode$Internal$attributesToString(attrs) + (">" + (A2(
            $elm$core$String$join,
            "",
            A2($elm$core$List$map, $ymtszw$elm_xml_decode$Xml$Decode$Internal$formatNode, children)
          ) + ("</" + ($ymtszw$elm_xml_decode$Xml$Decode$Internal$escape(tagName) + ">"))))));
        } else {
          var s = node.a;
          return $ymtszw$elm_xml_decode$Xml$Decode$Internal$escape(s);
        }
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$errorToRows = function(error) {
        switch (error.$) {
          case "Path":
            var path_ = error.a;
            var innerError = error.b;
            return A2(
              $elm$core$List$cons,
              "Path: /" + A2($elm$core$String$join, "/", path_),
              $ymtszw$elm_xml_decode$Xml$Decode$errorToRows(innerError)
            );
          case "OneOf":
            if (!error.a.b) {
              return _List_fromArray(
                ["No decoders available."]
              );
            } else {
              var innerErrors = error.a;
              var indentRow = F3(
                function(outerIndex, innerIndex, row) {
                  return !innerIndex ? A3(
                    $elm$core$String$padLeft,
                    2,
                    _Utils_chr(" "),
                    $elm$core$String$fromInt(outerIndex)
                  ) + (") " + row) : "    " + row;
                }
              );
              var genChildRows = function(outerIndex) {
                return A2(
                  $elm$core$Basics$composeR,
                  $ymtszw$elm_xml_decode$Xml$Decode$errorToRows,
                  $elm$core$List$indexedMap(
                    indentRow(outerIndex + 1)
                  )
                );
              };
              var innerRows = $elm$core$List$concat(
                A2($elm$core$List$indexedMap, genChildRows, innerErrors)
              );
              return A2($elm$core$List$cons, "All decoders failed:", innerRows);
            }
          default:
            var problem = error.a;
            var aNode = error.b;
            return _List_fromArray(
              [
                "Node: " + $ymtszw$elm_xml_decode$Xml$Decode$Internal$formatNode(aNode),
                problem
              ]
            );
        }
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$errorToString = function(error) {
        return A2(
          $elm$core$String$join,
          "\n",
          $ymtszw$elm_xml_decode$Xml$Decode$errorToRows(error)
        );
      };
      var $elm$parser$Parser$Advanced$bagToList = F2(
        function(bag, list) {
          bagToList:
            while (true) {
              switch (bag.$) {
                case "Empty":
                  return list;
                case "AddRight":
                  var bag1 = bag.a;
                  var x = bag.b;
                  var $temp$bag = bag1, $temp$list = A2($elm$core$List$cons, x, list);
                  bag = $temp$bag;
                  list = $temp$list;
                  continue bagToList;
                default:
                  var bag1 = bag.a;
                  var bag2 = bag.b;
                  var $temp$bag = bag1, $temp$list = A2($elm$parser$Parser$Advanced$bagToList, bag2, list);
                  bag = $temp$bag;
                  list = $temp$list;
                  continue bagToList;
              }
            }
        }
      );
      var $elm$parser$Parser$Advanced$run = F2(
        function(_v0, src) {
          var parse = _v0.a;
          var _v1 = parse(
            { col: 1, context: _List_Nil, indent: 1, offset: 0, row: 1, src }
          );
          if (_v1.$ === "Good") {
            var value = _v1.b;
            return $elm$core$Result$Ok(value);
          } else {
            var bag = _v1.b;
            return $elm$core$Result$Err(
              A2($elm$parser$Parser$Advanced$bagToList, bag, _List_Nil)
            );
          }
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$Xml = F3(
        function(processingInstructions, docType, root) {
          return { docType, processingInstructions, root };
        }
      );
      var $elm$parser$Parser$Advanced$Bad = F2(
        function(a, b) {
          return { $: "Bad", a, b };
        }
      );
      var $elm$parser$Parser$Advanced$Good = F3(
        function(a, b, c) {
          return { $: "Good", a, b, c };
        }
      );
      var $elm$parser$Parser$Advanced$Parser = function(a) {
        return { $: "Parser", a };
      };
      var $elm$parser$Parser$Advanced$findSubString = _Parser_findSubString;
      var $elm$parser$Parser$Advanced$AddRight = F2(
        function(a, b) {
          return { $: "AddRight", a, b };
        }
      );
      var $elm$parser$Parser$Advanced$DeadEnd = F4(
        function(row, col, problem, contextStack) {
          return { col, contextStack, problem, row };
        }
      );
      var $elm$parser$Parser$Advanced$Empty = { $: "Empty" };
      var $elm$parser$Parser$Advanced$fromInfo = F4(
        function(row, col, x, context) {
          return A2(
            $elm$parser$Parser$Advanced$AddRight,
            $elm$parser$Parser$Advanced$Empty,
            A4($elm$parser$Parser$Advanced$DeadEnd, row, col, x, context)
          );
        }
      );
      var $elm$parser$Parser$Advanced$chompUntil = function(_v0) {
        var str = _v0.a;
        var expecting = _v0.b;
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            var _v1 = A5($elm$parser$Parser$Advanced$findSubString, str, s.offset, s.row, s.col, s.src);
            var newOffset = _v1.a;
            var newRow = _v1.b;
            var newCol = _v1.c;
            return _Utils_eq(newOffset, -1) ? A2(
              $elm$parser$Parser$Advanced$Bad,
              false,
              A4($elm$parser$Parser$Advanced$fromInfo, newRow, newCol, expecting, s.context)
            ) : A3(
              $elm$parser$Parser$Advanced$Good,
              _Utils_cmp(s.offset, newOffset) < 0,
              _Utils_Tuple0,
              { col: newCol, context: s.context, indent: s.indent, offset: newOffset, row: newRow, src: s.src }
            );
          }
        );
      };
      var $elm$parser$Parser$Advanced$map2 = F3(
        function(func, _v0, _v1) {
          var parseA = _v0.a;
          var parseB = _v1.a;
          return $elm$parser$Parser$Advanced$Parser(
            function(s0) {
              var _v2 = parseA(s0);
              if (_v2.$ === "Bad") {
                var p = _v2.a;
                var x = _v2.b;
                return A2($elm$parser$Parser$Advanced$Bad, p, x);
              } else {
                var p1 = _v2.a;
                var a = _v2.b;
                var s1 = _v2.c;
                var _v3 = parseB(s1);
                if (_v3.$ === "Bad") {
                  var p2 = _v3.a;
                  var x = _v3.b;
                  return A2($elm$parser$Parser$Advanced$Bad, p1 || p2, x);
                } else {
                  var p2 = _v3.a;
                  var b = _v3.b;
                  var s2 = _v3.c;
                  return A3(
                    $elm$parser$Parser$Advanced$Good,
                    p1 || p2,
                    A2(func, a, b),
                    s2
                  );
                }
              }
            }
          );
        }
      );
      var $elm$parser$Parser$Advanced$ignorer = F2(
        function(keepParser, ignoreParser) {
          return A3($elm$parser$Parser$Advanced$map2, $elm$core$Basics$always, keepParser, ignoreParser);
        }
      );
      var $elm$parser$Parser$Advanced$succeed = function(a) {
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            return A3($elm$parser$Parser$Advanced$Good, false, a, s);
          }
        );
      };
      var $elm$parser$Parser$Expecting = function(a) {
        return { $: "Expecting", a };
      };
      var $elm$parser$Parser$Advanced$Token = F2(
        function(a, b) {
          return { $: "Token", a, b };
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$toToken = function(str) {
        return A2(
          $elm$parser$Parser$Advanced$Token,
          str,
          $elm$parser$Parser$Expecting(str)
        );
      };
      var $elm$parser$Parser$Advanced$fromState = F2(
        function(s, x) {
          return A2(
            $elm$parser$Parser$Advanced$AddRight,
            $elm$parser$Parser$Advanced$Empty,
            A4($elm$parser$Parser$Advanced$DeadEnd, s.row, s.col, x, s.context)
          );
        }
      );
      var $elm$parser$Parser$Advanced$isSubString = _Parser_isSubString;
      var $elm$parser$Parser$Advanced$token = function(_v0) {
        var str = _v0.a;
        var expecting = _v0.b;
        var progress = !$elm$core$String$isEmpty(str);
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            var _v1 = A5($elm$parser$Parser$Advanced$isSubString, str, s.offset, s.row, s.col, s.src);
            var newOffset = _v1.a;
            var newRow = _v1.b;
            var newCol = _v1.c;
            return _Utils_eq(newOffset, -1) ? A2(
              $elm$parser$Parser$Advanced$Bad,
              false,
              A2($elm$parser$Parser$Advanced$fromState, s, expecting)
            ) : A3(
              $elm$parser$Parser$Advanced$Good,
              progress,
              _Utils_Tuple0,
              { col: newCol, context: s.context, indent: s.indent, offset: newOffset, row: newRow, src: s.src }
            );
          }
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$comment = A2(
        $elm$parser$Parser$Advanced$ignorer,
        A2(
          $elm$parser$Parser$Advanced$ignorer,
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            $elm$parser$Parser$Advanced$succeed(_Utils_Tuple0),
            $elm$parser$Parser$Advanced$token(
              $jinjor$elm_xml_parser$XmlParser$toToken("<!--")
            )
          ),
          $elm$parser$Parser$Advanced$chompUntil(
            $jinjor$elm_xml_parser$XmlParser$toToken("-->")
          )
        ),
        $elm$parser$Parser$Advanced$token(
          $jinjor$elm_xml_parser$XmlParser$toToken("-->")
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$DocType = F2(
        function(rootElementName, definition) {
          return { definition, rootElementName };
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$Custom = function(a) {
        return { $: "Custom", a };
      };
      var $jinjor$elm_xml_parser$XmlParser$Public = F3(
        function(a, b, c) {
          return { $: "Public", a, b, c };
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$System = F2(
        function(a, b) {
          return { $: "System", a, b };
        }
      );
      var $elm$parser$Parser$Advanced$Located = F3(
        function(row, col, context) {
          return { col, context, row };
        }
      );
      var $elm$parser$Parser$Advanced$changeContext = F2(
        function(newContext, s) {
          return { col: s.col, context: newContext, indent: s.indent, offset: s.offset, row: s.row, src: s.src };
        }
      );
      var $elm$parser$Parser$Advanced$inContext = F2(
        function(context, _v0) {
          var parse = _v0.a;
          return $elm$parser$Parser$Advanced$Parser(
            function(s0) {
              var _v1 = parse(
                A2(
                  $elm$parser$Parser$Advanced$changeContext,
                  A2(
                    $elm$core$List$cons,
                    A3($elm$parser$Parser$Advanced$Located, s0.row, s0.col, context),
                    s0.context
                  ),
                  s0
                )
              );
              if (_v1.$ === "Good") {
                var p = _v1.a;
                var a = _v1.b;
                var s1 = _v1.c;
                return A3(
                  $elm$parser$Parser$Advanced$Good,
                  p,
                  a,
                  A2($elm$parser$Parser$Advanced$changeContext, s0.context, s1)
                );
              } else {
                var step = _v1;
                return step;
              }
            }
          );
        }
      );
      var $elm$parser$Parser$BadRepeat = { $: "BadRepeat" };
      var $elm$parser$Parser$Advanced$andThen = F2(
        function(callback, _v0) {
          var parseA = _v0.a;
          return $elm$parser$Parser$Advanced$Parser(
            function(s0) {
              var _v1 = parseA(s0);
              if (_v1.$ === "Bad") {
                var p = _v1.a;
                var x = _v1.b;
                return A2($elm$parser$Parser$Advanced$Bad, p, x);
              } else {
                var p1 = _v1.a;
                var a = _v1.b;
                var s1 = _v1.c;
                var _v2 = callback(a);
                var parseB = _v2.a;
                var _v3 = parseB(s1);
                if (_v3.$ === "Bad") {
                  var p2 = _v3.a;
                  var x = _v3.b;
                  return A2($elm$parser$Parser$Advanced$Bad, p1 || p2, x);
                } else {
                  var p2 = _v3.a;
                  var b = _v3.b;
                  var s2 = _v3.c;
                  return A3($elm$parser$Parser$Advanced$Good, p1 || p2, b, s2);
                }
              }
            }
          );
        }
      );
      var $elm$parser$Parser$Advanced$isSubChar = _Parser_isSubChar;
      var $elm$parser$Parser$Advanced$chompWhileHelp = F5(
        function(isGood, offset, row, col, s0) {
          chompWhileHelp:
            while (true) {
              var newOffset = A3($elm$parser$Parser$Advanced$isSubChar, isGood, offset, s0.src);
              if (_Utils_eq(newOffset, -1)) {
                return A3(
                  $elm$parser$Parser$Advanced$Good,
                  _Utils_cmp(s0.offset, offset) < 0,
                  _Utils_Tuple0,
                  { col, context: s0.context, indent: s0.indent, offset, row, src: s0.src }
                );
              } else {
                if (_Utils_eq(newOffset, -2)) {
                  var $temp$isGood = isGood, $temp$offset = offset + 1, $temp$row = row + 1, $temp$col = 1, $temp$s0 = s0;
                  isGood = $temp$isGood;
                  offset = $temp$offset;
                  row = $temp$row;
                  col = $temp$col;
                  s0 = $temp$s0;
                  continue chompWhileHelp;
                } else {
                  var $temp$isGood = isGood, $temp$offset = newOffset, $temp$row = row, $temp$col = col + 1, $temp$s0 = s0;
                  isGood = $temp$isGood;
                  offset = $temp$offset;
                  row = $temp$row;
                  col = $temp$col;
                  s0 = $temp$s0;
                  continue chompWhileHelp;
                }
              }
            }
        }
      );
      var $elm$parser$Parser$Advanced$chompWhile = function(isGood) {
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            return A5($elm$parser$Parser$Advanced$chompWhileHelp, isGood, s.offset, s.row, s.col, s);
          }
        );
      };
      var $elm$parser$Parser$Advanced$mapChompedString = F2(
        function(func, _v0) {
          var parse = _v0.a;
          return $elm$parser$Parser$Advanced$Parser(
            function(s0) {
              var _v1 = parse(s0);
              if (_v1.$ === "Bad") {
                var p = _v1.a;
                var x = _v1.b;
                return A2($elm$parser$Parser$Advanced$Bad, p, x);
              } else {
                var p = _v1.a;
                var a = _v1.b;
                var s1 = _v1.c;
                return A3(
                  $elm$parser$Parser$Advanced$Good,
                  p,
                  A2(
                    func,
                    A3($elm$core$String$slice, s0.offset, s1.offset, s0.src),
                    a
                  ),
                  s1
                );
              }
            }
          );
        }
      );
      var $elm$parser$Parser$Advanced$getChompedString = function(parser) {
        return A2($elm$parser$Parser$Advanced$mapChompedString, $elm$core$Basics$always, parser);
      };
      var $elm$parser$Parser$Advanced$problem = function(x) {
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            return A2(
              $elm$parser$Parser$Advanced$Bad,
              false,
              A2($elm$parser$Parser$Advanced$fromState, s, x)
            );
          }
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$keep = F2(
        function(count, predicate) {
          var n = count.a;
          return A2(
            $elm$parser$Parser$Advanced$andThen,
            function(str) {
              return _Utils_cmp(
                n,
                $elm$core$String$length(str)
              ) < 1 ? $elm$parser$Parser$Advanced$succeed(str) : $elm$parser$Parser$Advanced$problem($elm$parser$Parser$BadRepeat);
            },
            $elm$parser$Parser$Advanced$getChompedString(
              A2(
                $elm$parser$Parser$Advanced$ignorer,
                $elm$parser$Parser$Advanced$succeed(_Utils_Tuple0),
                $elm$parser$Parser$Advanced$chompWhile(predicate)
              )
            )
          );
        }
      );
      var $elm$parser$Parser$Advanced$keeper = F2(
        function(parseFunc, parseArg) {
          return A3($elm$parser$Parser$Advanced$map2, $elm$core$Basics$apL, parseFunc, parseArg);
        }
      );
      var $elm$parser$Parser$ExpectingSymbol = function(a) {
        return { $: "ExpectingSymbol", a };
      };
      var $elm$parser$Parser$Advanced$symbol = $elm$parser$Parser$Advanced$token;
      var $jinjor$elm_xml_parser$XmlParser$symbol = function(str) {
        return $elm$parser$Parser$Advanced$symbol(
          A2(
            $elm$parser$Parser$Advanced$Token,
            str,
            $elm$parser$Parser$ExpectingSymbol(str)
          )
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$AtLeast = function(a) {
        return { $: "AtLeast", a };
      };
      var $jinjor$elm_xml_parser$XmlParser$zeroOrMore = $jinjor$elm_xml_parser$XmlParser$AtLeast(0);
      var $jinjor$elm_xml_parser$XmlParser$docTypeExternalSubset = A2(
        $elm$parser$Parser$Advanced$inContext,
        "docTypeExternalSubset",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
            $jinjor$elm_xml_parser$XmlParser$symbol('"')
          ),
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            A2(
              $jinjor$elm_xml_parser$XmlParser$keep,
              $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
              function(c) {
                return !_Utils_eq(
                  c,
                  _Utils_chr('"')
                );
              }
            ),
            $jinjor$elm_xml_parser$XmlParser$symbol('"')
          )
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$docTypeInternalSubset = A2(
        $elm$parser$Parser$Advanced$inContext,
        "docTypeInternalSubset",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
            $jinjor$elm_xml_parser$XmlParser$symbol("[")
          ),
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            A2(
              $jinjor$elm_xml_parser$XmlParser$keep,
              $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
              function(c) {
                return !_Utils_eq(
                  c,
                  _Utils_chr("]")
                );
              }
            ),
            $jinjor$elm_xml_parser$XmlParser$symbol("]")
          )
        )
      );
      var $elm$parser$Parser$ExpectingKeyword = function(a) {
        return { $: "ExpectingKeyword", a };
      };
      var $elm$parser$Parser$Advanced$keyword = function(_v0) {
        var kwd = _v0.a;
        var expecting = _v0.b;
        var progress = !$elm$core$String$isEmpty(kwd);
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            var _v1 = A5($elm$parser$Parser$Advanced$isSubString, kwd, s.offset, s.row, s.col, s.src);
            var newOffset = _v1.a;
            var newRow = _v1.b;
            var newCol = _v1.c;
            return _Utils_eq(newOffset, -1) || 0 <= A3(
              $elm$parser$Parser$Advanced$isSubChar,
              function(c) {
                return $elm$core$Char$isAlphaNum(c) || _Utils_eq(
                  c,
                  _Utils_chr("_")
                );
              },
              newOffset,
              s.src
            ) ? A2(
              $elm$parser$Parser$Advanced$Bad,
              false,
              A2($elm$parser$Parser$Advanced$fromState, s, expecting)
            ) : A3(
              $elm$parser$Parser$Advanced$Good,
              progress,
              _Utils_Tuple0,
              { col: newCol, context: s.context, indent: s.indent, offset: newOffset, row: newRow, src: s.src }
            );
          }
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$keyword = function(kwd) {
        return $elm$parser$Parser$Advanced$keyword(
          A2(
            $elm$parser$Parser$Advanced$Token,
            kwd,
            $elm$parser$Parser$ExpectingKeyword(kwd)
          )
        );
      };
      var $elm$parser$Parser$Advanced$map = F2(
        function(func, _v0) {
          var parse = _v0.a;
          return $elm$parser$Parser$Advanced$Parser(
            function(s0) {
              var _v1 = parse(s0);
              if (_v1.$ === "Good") {
                var p = _v1.a;
                var a = _v1.b;
                var s1 = _v1.c;
                return A3(
                  $elm$parser$Parser$Advanced$Good,
                  p,
                  func(a),
                  s1
                );
              } else {
                var p = _v1.a;
                var x = _v1.b;
                return A2($elm$parser$Parser$Advanced$Bad, p, x);
              }
            }
          );
        }
      );
      var $elm$parser$Parser$Advanced$Append = F2(
        function(a, b) {
          return { $: "Append", a, b };
        }
      );
      var $elm$parser$Parser$Advanced$oneOfHelp = F3(
        function(s0, bag, parsers) {
          oneOfHelp:
            while (true) {
              if (!parsers.b) {
                return A2($elm$parser$Parser$Advanced$Bad, false, bag);
              } else {
                var parse = parsers.a.a;
                var remainingParsers = parsers.b;
                var _v1 = parse(s0);
                if (_v1.$ === "Good") {
                  var step = _v1;
                  return step;
                } else {
                  var step = _v1;
                  var p = step.a;
                  var x = step.b;
                  if (p) {
                    return step;
                  } else {
                    var $temp$s0 = s0, $temp$bag = A2($elm$parser$Parser$Advanced$Append, bag, x), $temp$parsers = remainingParsers;
                    s0 = $temp$s0;
                    bag = $temp$bag;
                    parsers = $temp$parsers;
                    continue oneOfHelp;
                  }
                }
              }
            }
        }
      );
      var $elm$parser$Parser$Advanced$oneOf = function(parsers) {
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            return A3($elm$parser$Parser$Advanced$oneOfHelp, s, $elm$parser$Parser$Advanced$Empty, parsers);
          }
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$maybe = function(parser) {
        return $elm$parser$Parser$Advanced$oneOf(
          _List_fromArray(
            [
              A2($elm$parser$Parser$Advanced$map, $elm$core$Maybe$Just, parser),
              $elm$parser$Parser$Advanced$succeed($elm$core$Maybe$Nothing)
            ]
          )
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$publicIdentifier = A2(
        $elm$parser$Parser$Advanced$inContext,
        "publicIdentifier",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
            $jinjor$elm_xml_parser$XmlParser$symbol('"')
          ),
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            A2(
              $jinjor$elm_xml_parser$XmlParser$keep,
              $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
              function(c) {
                return !_Utils_eq(
                  c,
                  _Utils_chr('"')
                );
              }
            ),
            $jinjor$elm_xml_parser$XmlParser$symbol('"')
          )
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$ignore = F2(
        function(count, predicate) {
          return A2(
            $elm$parser$Parser$Advanced$map,
            function(_v0) {
              return _Utils_Tuple0;
            },
            A2($jinjor$elm_xml_parser$XmlParser$keep, count, predicate)
          );
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$isWhitespace = function(c) {
        return _Utils_eq(
          c,
          _Utils_chr(" ")
        ) || (_Utils_eq(
          c,
          _Utils_chr("\r")
        ) || (_Utils_eq(
          c,
          _Utils_chr("\n")
        ) || _Utils_eq(
          c,
          _Utils_chr("	")
        )));
      };
      var $jinjor$elm_xml_parser$XmlParser$whiteSpace = A2($jinjor$elm_xml_parser$XmlParser$ignore, $jinjor$elm_xml_parser$XmlParser$zeroOrMore, $jinjor$elm_xml_parser$XmlParser$isWhitespace);
      var $jinjor$elm_xml_parser$XmlParser$docTypeDefinition = A2(
        $elm$parser$Parser$Advanced$inContext,
        "docTypeDefinition",
        $elm$parser$Parser$Advanced$oneOf(
          _List_fromArray(
            [
              A2(
                $elm$parser$Parser$Advanced$keeper,
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    A2(
                      $elm$parser$Parser$Advanced$ignorer,
                      A2(
                        $elm$parser$Parser$Advanced$ignorer,
                        $elm$parser$Parser$Advanced$succeed($jinjor$elm_xml_parser$XmlParser$Public),
                        $jinjor$elm_xml_parser$XmlParser$keyword("PUBLIC")
                      ),
                      $jinjor$elm_xml_parser$XmlParser$whiteSpace
                    ),
                    A2($elm$parser$Parser$Advanced$ignorer, $jinjor$elm_xml_parser$XmlParser$publicIdentifier, $jinjor$elm_xml_parser$XmlParser$whiteSpace)
                  ),
                  A2($elm$parser$Parser$Advanced$ignorer, $jinjor$elm_xml_parser$XmlParser$docTypeExternalSubset, $jinjor$elm_xml_parser$XmlParser$whiteSpace)
                ),
                $jinjor$elm_xml_parser$XmlParser$maybe($jinjor$elm_xml_parser$XmlParser$docTypeInternalSubset)
              ),
              A2(
                $elm$parser$Parser$Advanced$keeper,
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$ignorer,
                    A2(
                      $elm$parser$Parser$Advanced$ignorer,
                      $elm$parser$Parser$Advanced$succeed($jinjor$elm_xml_parser$XmlParser$System),
                      $jinjor$elm_xml_parser$XmlParser$keyword("SYSTEM")
                    ),
                    $jinjor$elm_xml_parser$XmlParser$whiteSpace
                  ),
                  A2($elm$parser$Parser$Advanced$ignorer, $jinjor$elm_xml_parser$XmlParser$docTypeExternalSubset, $jinjor$elm_xml_parser$XmlParser$whiteSpace)
                ),
                $jinjor$elm_xml_parser$XmlParser$maybe($jinjor$elm_xml_parser$XmlParser$docTypeInternalSubset)
              ),
              A2(
                $elm$parser$Parser$Advanced$keeper,
                $elm$parser$Parser$Advanced$succeed($jinjor$elm_xml_parser$XmlParser$Custom),
                $jinjor$elm_xml_parser$XmlParser$docTypeInternalSubset
              )
            ]
          )
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$oneOrMore = $jinjor$elm_xml_parser$XmlParser$AtLeast(1);
      var $jinjor$elm_xml_parser$XmlParser$tagName = A2(
        $elm$parser$Parser$Advanced$inContext,
        "tagName",
        A2(
          $jinjor$elm_xml_parser$XmlParser$keep,
          $jinjor$elm_xml_parser$XmlParser$oneOrMore,
          function(c) {
            return !$jinjor$elm_xml_parser$XmlParser$isWhitespace(c) && (!_Utils_eq(
              c,
              _Utils_chr("/")
            ) && (!_Utils_eq(
              c,
              _Utils_chr("<")
            ) && (!_Utils_eq(
              c,
              _Utils_chr(">")
            ) && (!_Utils_eq(
              c,
              _Utils_chr('"')
            ) && (!_Utils_eq(
              c,
              _Utils_chr("'")
            ) && !_Utils_eq(
              c,
              _Utils_chr("=")
            ))))));
          }
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$docType = A2(
        $elm$parser$Parser$Advanced$inContext,
        "docType",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$keeper,
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              A2(
                $elm$parser$Parser$Advanced$ignorer,
                $elm$parser$Parser$Advanced$succeed($jinjor$elm_xml_parser$XmlParser$DocType),
                $jinjor$elm_xml_parser$XmlParser$symbol("<!DOCTYPE")
              ),
              $jinjor$elm_xml_parser$XmlParser$whiteSpace
            ),
            A2($elm$parser$Parser$Advanced$ignorer, $jinjor$elm_xml_parser$XmlParser$tagName, $jinjor$elm_xml_parser$XmlParser$whiteSpace)
          ),
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            A2($elm$parser$Parser$Advanced$ignorer, $jinjor$elm_xml_parser$XmlParser$docTypeDefinition, $jinjor$elm_xml_parser$XmlParser$whiteSpace),
            $jinjor$elm_xml_parser$XmlParser$symbol(">")
          )
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$Element = F3(
        function(a, b, c) {
          return { $: "Element", a, b, c };
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$Text = function(a) {
        return { $: "Text", a };
      };
      var $jinjor$elm_xml_parser$XmlParser$Attribute = F2(
        function(name, value) {
          return { name, value };
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$attributeName = A2(
        $elm$parser$Parser$Advanced$inContext,
        "attributeName",
        A2(
          $jinjor$elm_xml_parser$XmlParser$keep,
          $jinjor$elm_xml_parser$XmlParser$oneOrMore,
          function(c) {
            return !$jinjor$elm_xml_parser$XmlParser$isWhitespace(c) && (!_Utils_eq(
              c,
              _Utils_chr("/")
            ) && (!_Utils_eq(
              c,
              _Utils_chr("<")
            ) && (!_Utils_eq(
              c,
              _Utils_chr(">")
            ) && (!_Utils_eq(
              c,
              _Utils_chr('"')
            ) && (!_Utils_eq(
              c,
              _Utils_chr("'")
            ) && !_Utils_eq(
              c,
              _Utils_chr("=")
            ))))));
          }
        )
      );
      var $elm$parser$Parser$Problem = function(a) {
        return { $: "Problem", a };
      };
      var $jinjor$elm_xml_parser$XmlParser$entities = $elm$core$Dict$fromList(
        _List_fromArray(
          [
            _Utils_Tuple2(
              "amp",
              _Utils_chr("&")
            ),
            _Utils_Tuple2(
              "lt",
              _Utils_chr("<")
            ),
            _Utils_Tuple2(
              "gt",
              _Utils_chr(">")
            ),
            _Utils_Tuple2(
              "apos",
              _Utils_chr("'")
            ),
            _Utils_Tuple2(
              "quot",
              _Utils_chr('"')
            )
          ]
        )
      );
      var $elm$core$Result$fromMaybe = F2(
        function(err, maybe) {
          if (maybe.$ === "Just") {
            var v = maybe.a;
            return $elm$core$Result$Ok(v);
          } else {
            return $elm$core$Result$Err(err);
          }
        }
      );
      var $rtfeldman$elm_hex$Hex$fromStringHelp = F3(
        function(position, chars, accumulated) {
          fromStringHelp:
            while (true) {
              if (!chars.b) {
                return $elm$core$Result$Ok(accumulated);
              } else {
                var _char = chars.a;
                var rest = chars.b;
                switch (_char.valueOf()) {
                  case "0":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated;
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "1":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "2":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 2 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "3":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 3 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "4":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 4 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "5":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 5 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "6":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 6 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "7":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 7 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "8":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 8 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "9":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 9 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "a":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 10 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "b":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 11 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "c":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 12 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "d":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 13 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "e":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 14 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  case "f":
                    var $temp$position = position - 1, $temp$chars = rest, $temp$accumulated = accumulated + 15 * A2($elm$core$Basics$pow, 16, position);
                    position = $temp$position;
                    chars = $temp$chars;
                    accumulated = $temp$accumulated;
                    continue fromStringHelp;
                  default:
                    var nonHex = _char;
                    return $elm$core$Result$Err(
                      $elm$core$String$fromChar(nonHex) + " is not a valid hexadecimal character."
                    );
                }
              }
            }
        }
      );
      var $elm$core$List$tail = function(list) {
        if (list.b) {
          var x = list.a;
          var xs = list.b;
          return $elm$core$Maybe$Just(xs);
        } else {
          return $elm$core$Maybe$Nothing;
        }
      };
      var $rtfeldman$elm_hex$Hex$fromString = function(str) {
        if ($elm$core$String$isEmpty(str)) {
          return $elm$core$Result$Err("Empty strings are not valid hexadecimal strings.");
        } else {
          var result = function() {
            if (A2($elm$core$String$startsWith, "-", str)) {
              var list = A2(
                $elm$core$Maybe$withDefault,
                _List_Nil,
                $elm$core$List$tail(
                  $elm$core$String$toList(str)
                )
              );
              return A2(
                $elm$core$Result$map,
                $elm$core$Basics$negate,
                A3(
                  $rtfeldman$elm_hex$Hex$fromStringHelp,
                  $elm$core$List$length(list) - 1,
                  list,
                  0
                )
              );
            } else {
              return A3(
                $rtfeldman$elm_hex$Hex$fromStringHelp,
                $elm$core$String$length(str) - 1,
                $elm$core$String$toList(str),
                0
              );
            }
          }();
          var formatError = function(err) {
            return A2(
              $elm$core$String$join,
              " ",
              _List_fromArray(
                ['"' + (str + '"'), "is not a valid hexadecimal string because", err]
              )
            );
          };
          return A2($elm$core$Result$mapError, formatError, result);
        }
      };
      var $jinjor$elm_xml_parser$XmlParser$decodeEscape = function(s) {
        return A2($elm$core$String$startsWith, "#x", s) ? A2(
          $elm$core$Result$mapError,
          $elm$parser$Parser$Problem,
          A2(
            $elm$core$Result$map,
            $elm$core$Char$fromCode,
            $rtfeldman$elm_hex$Hex$fromString(
              A2($elm$core$String$dropLeft, 2, s)
            )
          )
        ) : A2($elm$core$String$startsWith, "#", s) ? A2(
          $elm$core$Result$fromMaybe,
          $elm$parser$Parser$Problem("Invalid escaped charactor: " + s),
          A2(
            $elm$core$Maybe$map,
            $elm$core$Char$fromCode,
            $elm$core$String$toInt(
              A2($elm$core$String$dropLeft, 1, s)
            )
          )
        ) : A2(
          $elm$core$Result$fromMaybe,
          $elm$parser$Parser$Problem('No entity named "&' + (s + ';" found.')),
          A2($elm$core$Dict$get, s, $jinjor$elm_xml_parser$XmlParser$entities)
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$fail = function(str) {
        return $elm$parser$Parser$Advanced$problem(
          $elm$parser$Parser$Problem(str)
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$escapedChar = function(end_) {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "escapedChar",
          A2(
            $elm$parser$Parser$Advanced$andThen,
            function(s) {
              return $elm$parser$Parser$Advanced$oneOf(
                _List_fromArray(
                  [
                    A2(
                      $elm$parser$Parser$Advanced$andThen,
                      function(_v0) {
                        var _v1 = $jinjor$elm_xml_parser$XmlParser$decodeEscape(s);
                        if (_v1.$ === "Ok") {
                          var c = _v1.a;
                          return $elm$parser$Parser$Advanced$succeed(c);
                        } else {
                          var e = _v1.a;
                          return $elm$parser$Parser$Advanced$problem(e);
                        }
                      },
                      $jinjor$elm_xml_parser$XmlParser$symbol(";")
                    ),
                    $jinjor$elm_xml_parser$XmlParser$fail('Entities must end_ with ";": &' + s)
                  ]
                )
              );
            },
            A2(
              $elm$parser$Parser$Advanced$keeper,
              A2(
                $elm$parser$Parser$Advanced$ignorer,
                $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
                $jinjor$elm_xml_parser$XmlParser$symbol("&")
              ),
              A2(
                $jinjor$elm_xml_parser$XmlParser$keep,
                $jinjor$elm_xml_parser$XmlParser$oneOrMore,
                function(c) {
                  return !_Utils_eq(c, end_) && !_Utils_eq(
                    c,
                    _Utils_chr(";")
                  );
                }
              )
            )
          )
        );
      };
      var $elm$parser$Parser$Advanced$lazy = function(thunk) {
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            var _v0 = thunk(_Utils_Tuple0);
            var parse = _v0.a;
            return parse(s);
          }
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$textString = function(end_) {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "textString",
          A2(
            $elm$parser$Parser$Advanced$andThen,
            function(s) {
              return $elm$parser$Parser$Advanced$oneOf(
                _List_fromArray(
                  [
                    A2(
                      $elm$parser$Parser$Advanced$keeper,
                      A2(
                        $elm$parser$Parser$Advanced$keeper,
                        $elm$parser$Parser$Advanced$succeed($elm$core$String$cons),
                        $jinjor$elm_xml_parser$XmlParser$escapedChar(end_)
                      ),
                      $elm$parser$Parser$Advanced$lazy(
                        function(_v0) {
                          return $jinjor$elm_xml_parser$XmlParser$textString(end_);
                        }
                      )
                    ),
                    $elm$parser$Parser$Advanced$succeed(s)
                  ]
                )
              );
            },
            A2(
              $jinjor$elm_xml_parser$XmlParser$keep,
              $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
              function(c) {
                return !_Utils_eq(c, end_) && !_Utils_eq(
                  c,
                  _Utils_chr("&")
                );
              }
            )
          )
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$attributeValue = A2(
        $elm$parser$Parser$Advanced$inContext,
        "attributeValue",
        $elm$parser$Parser$Advanced$oneOf(
          _List_fromArray(
            [
              A2(
                $elm$parser$Parser$Advanced$keeper,
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
                  $jinjor$elm_xml_parser$XmlParser$symbol('"')
                ),
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  $jinjor$elm_xml_parser$XmlParser$textString(
                    _Utils_chr('"')
                  ),
                  $jinjor$elm_xml_parser$XmlParser$symbol('"')
                )
              ),
              A2(
                $elm$parser$Parser$Advanced$keeper,
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
                  $jinjor$elm_xml_parser$XmlParser$symbol("'")
                ),
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  $jinjor$elm_xml_parser$XmlParser$textString(
                    _Utils_chr("'")
                  ),
                  $jinjor$elm_xml_parser$XmlParser$symbol("'")
                )
              )
            ]
          )
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$attribute = A2(
        $elm$parser$Parser$Advanced$inContext,
        "attribute",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$keeper,
            $elm$parser$Parser$Advanced$succeed($jinjor$elm_xml_parser$XmlParser$Attribute),
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              A2(
                $elm$parser$Parser$Advanced$ignorer,
                A2($elm$parser$Parser$Advanced$ignorer, $jinjor$elm_xml_parser$XmlParser$attributeName, $jinjor$elm_xml_parser$XmlParser$whiteSpace),
                $jinjor$elm_xml_parser$XmlParser$symbol("=")
              ),
              $jinjor$elm_xml_parser$XmlParser$whiteSpace
            )
          ),
          $jinjor$elm_xml_parser$XmlParser$attributeValue
        )
      );
      var $elm$core$Set$Set_elm_builtin = function(a) {
        return { $: "Set_elm_builtin", a };
      };
      var $elm$core$Set$insert = F2(
        function(key, _v0) {
          var dict = _v0.a;
          return $elm$core$Set$Set_elm_builtin(
            A3($elm$core$Dict$insert, key, _Utils_Tuple0, dict)
          );
        }
      );
      var $elm$core$Dict$member = F2(
        function(key, dict) {
          var _v0 = A2($elm$core$Dict$get, key, dict);
          if (_v0.$ === "Just") {
            return true;
          } else {
            return false;
          }
        }
      );
      var $elm$core$Set$member = F2(
        function(key, _v0) {
          var dict = _v0.a;
          return A2($elm$core$Dict$member, key, dict);
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$attributes = function(keys) {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "attributes",
          $elm$parser$Parser$Advanced$oneOf(
            _List_fromArray(
              [
                A2(
                  $elm$parser$Parser$Advanced$andThen,
                  function(attr) {
                    return A2($elm$core$Set$member, attr.name, keys) ? $jinjor$elm_xml_parser$XmlParser$fail("attribute " + (attr.name + " is duplicated")) : A2(
                      $elm$parser$Parser$Advanced$keeper,
                      A2(
                        $elm$parser$Parser$Advanced$ignorer,
                        $elm$parser$Parser$Advanced$succeed(
                          $elm$core$List$cons(attr)
                        ),
                        $jinjor$elm_xml_parser$XmlParser$whiteSpace
                      ),
                      $jinjor$elm_xml_parser$XmlParser$attributes(
                        A2($elm$core$Set$insert, attr.name, keys)
                      )
                    );
                  },
                  $jinjor$elm_xml_parser$XmlParser$attribute
                ),
                $elm$parser$Parser$Advanced$succeed(_List_Nil)
              ]
            )
          )
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$closingTag = function(startTagName) {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "closingTag",
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              A2(
                $elm$parser$Parser$Advanced$ignorer,
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  A2(
                    $elm$parser$Parser$Advanced$ignorer,
                    $elm$parser$Parser$Advanced$succeed(_Utils_Tuple0),
                    $jinjor$elm_xml_parser$XmlParser$symbol("</")
                  ),
                  $jinjor$elm_xml_parser$XmlParser$whiteSpace
                ),
                A2(
                  $elm$parser$Parser$Advanced$andThen,
                  function(endTagName) {
                    return _Utils_eq(startTagName, endTagName) ? $elm$parser$Parser$Advanced$succeed(_Utils_Tuple0) : $jinjor$elm_xml_parser$XmlParser$fail("tag name mismatch: " + (startTagName + (" and " + endTagName)));
                  },
                  $jinjor$elm_xml_parser$XmlParser$tagName
                )
              ),
              $jinjor$elm_xml_parser$XmlParser$whiteSpace
            ),
            $jinjor$elm_xml_parser$XmlParser$symbol(">")
          )
        );
      };
      var $elm$core$Set$empty = $elm$core$Set$Set_elm_builtin($elm$core$Dict$empty);
      function $jinjor$elm_xml_parser$XmlParser$cyclic$cdataContent() {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "cdataContent",
          $elm$parser$Parser$Advanced$oneOf(
            _List_fromArray(
              [
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  $elm$parser$Parser$Advanced$succeed(""),
                  $jinjor$elm_xml_parser$XmlParser$symbol("]]>")
                ),
                A2(
                  $elm$parser$Parser$Advanced$andThen,
                  function(_v0) {
                    return A2(
                      $elm$parser$Parser$Advanced$map,
                      function(tail) {
                        return "]]" + tail;
                      },
                      $jinjor$elm_xml_parser$XmlParser$cyclic$cdataContent()
                    );
                  },
                  $jinjor$elm_xml_parser$XmlParser$symbol("]]")
                ),
                A2(
                  $elm$parser$Parser$Advanced$andThen,
                  function(_v1) {
                    return A2(
                      $elm$parser$Parser$Advanced$map,
                      function(tail) {
                        return "]" + tail;
                      },
                      $jinjor$elm_xml_parser$XmlParser$cyclic$cdataContent()
                    );
                  },
                  $jinjor$elm_xml_parser$XmlParser$symbol("]")
                ),
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    $elm$parser$Parser$Advanced$succeed($elm$core$Basics$append),
                    A2(
                      $jinjor$elm_xml_parser$XmlParser$keep,
                      $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
                      function(c) {
                        return !_Utils_eq(
                          c,
                          _Utils_chr("]")
                        );
                      }
                    )
                  ),
                  $elm$parser$Parser$Advanced$lazy(
                    function(_v2) {
                      return $jinjor$elm_xml_parser$XmlParser$cyclic$cdataContent();
                    }
                  )
                )
              ]
            )
          )
        );
      }
      try {
        var $jinjor$elm_xml_parser$XmlParser$cdataContent = $jinjor$elm_xml_parser$XmlParser$cyclic$cdataContent();
        $jinjor$elm_xml_parser$XmlParser$cyclic$cdataContent = function() {
          return $jinjor$elm_xml_parser$XmlParser$cdataContent;
        };
      } catch ($) {
        throw "Some top-level definitions from `XmlParser` are causing infinite recursion:\n\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502    cdataContent\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!";
      }
      var $jinjor$elm_xml_parser$XmlParser$cdata = A2(
        $elm$parser$Parser$Advanced$inContext,
        "cdata",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
            $jinjor$elm_xml_parser$XmlParser$symbol("<![CDATA[")
          ),
          $jinjor$elm_xml_parser$XmlParser$cdataContent
        )
      );
      function $jinjor$elm_xml_parser$XmlParser$cyclic$textNodeString() {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "textNodeString",
          $elm$parser$Parser$Advanced$oneOf(
            _List_fromArray(
              [
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    $elm$parser$Parser$Advanced$succeed(
                      F2(
                        function(s, maybeString) {
                          return $elm$core$Maybe$Just(
                            _Utils_ap(
                              s,
                              A2($elm$core$Maybe$withDefault, "", maybeString)
                            )
                          );
                        }
                      )
                    ),
                    A2(
                      $jinjor$elm_xml_parser$XmlParser$keep,
                      $jinjor$elm_xml_parser$XmlParser$oneOrMore,
                      function(c) {
                        return !_Utils_eq(
                          c,
                          _Utils_chr("<")
                        ) && !_Utils_eq(
                          c,
                          _Utils_chr("&")
                        );
                      }
                    )
                  ),
                  $elm$parser$Parser$Advanced$lazy(
                    function(_v0) {
                      return $jinjor$elm_xml_parser$XmlParser$cyclic$textNodeString();
                    }
                  )
                ),
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    $elm$parser$Parser$Advanced$succeed(
                      F2(
                        function(c, maybeString) {
                          return $elm$core$Maybe$Just(
                            A2(
                              $elm$core$String$cons,
                              c,
                              A2($elm$core$Maybe$withDefault, "", maybeString)
                            )
                          );
                        }
                      )
                    ),
                    $jinjor$elm_xml_parser$XmlParser$escapedChar(
                      _Utils_chr("<")
                    )
                  ),
                  $elm$parser$Parser$Advanced$lazy(
                    function(_v1) {
                      return $jinjor$elm_xml_parser$XmlParser$cyclic$textNodeString();
                    }
                  )
                ),
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    $elm$parser$Parser$Advanced$succeed(
                      F2(
                        function(s, maybeString) {
                          var str = _Utils_ap(
                            s,
                            A2($elm$core$Maybe$withDefault, "", maybeString)
                          );
                          return str !== "" ? $elm$core$Maybe$Just(str) : $elm$core$Maybe$Nothing;
                        }
                      )
                    ),
                    $jinjor$elm_xml_parser$XmlParser$cdata
                  ),
                  $elm$parser$Parser$Advanced$lazy(
                    function(_v2) {
                      return $jinjor$elm_xml_parser$XmlParser$cyclic$textNodeString();
                    }
                  )
                ),
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$ignorer,
                    $elm$parser$Parser$Advanced$succeed(
                      function(maybeString) {
                        var str = A2($elm$core$Maybe$withDefault, "", maybeString);
                        return str !== "" ? $elm$core$Maybe$Just(str) : $elm$core$Maybe$Nothing;
                      }
                    ),
                    $jinjor$elm_xml_parser$XmlParser$comment
                  ),
                  $elm$parser$Parser$Advanced$lazy(
                    function(_v3) {
                      return $jinjor$elm_xml_parser$XmlParser$cyclic$textNodeString();
                    }
                  )
                ),
                $elm$parser$Parser$Advanced$succeed($elm$core$Maybe$Nothing)
              ]
            )
          )
        );
      }
      try {
        var $jinjor$elm_xml_parser$XmlParser$textNodeString = $jinjor$elm_xml_parser$XmlParser$cyclic$textNodeString();
        $jinjor$elm_xml_parser$XmlParser$cyclic$textNodeString = function() {
          return $jinjor$elm_xml_parser$XmlParser$textNodeString;
        };
      } catch ($) {
        throw "Some top-level definitions from `XmlParser` are causing infinite recursion:\n\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502    textNodeString\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!";
      }
      var $jinjor$elm_xml_parser$XmlParser$children = function(startTagName) {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "children",
          $elm$parser$Parser$Advanced$oneOf(
            _List_fromArray(
              [
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  $elm$parser$Parser$Advanced$succeed(_List_Nil),
                  $jinjor$elm_xml_parser$XmlParser$closingTag(startTagName)
                ),
                A2(
                  $elm$parser$Parser$Advanced$andThen,
                  function(maybeString) {
                    if (maybeString.$ === "Just") {
                      var s = maybeString.a;
                      return A2(
                        $elm$parser$Parser$Advanced$keeper,
                        $elm$parser$Parser$Advanced$succeed(
                          function(rest) {
                            return A2(
                              $elm$core$List$cons,
                              $jinjor$elm_xml_parser$XmlParser$Text(s),
                              rest
                            );
                          }
                        ),
                        $jinjor$elm_xml_parser$XmlParser$children(startTagName)
                      );
                    } else {
                      return A2(
                        $elm$parser$Parser$Advanced$ignorer,
                        $elm$parser$Parser$Advanced$succeed(_List_Nil),
                        $jinjor$elm_xml_parser$XmlParser$closingTag(startTagName)
                      );
                    }
                  },
                  $jinjor$elm_xml_parser$XmlParser$textNodeString
                ),
                $elm$parser$Parser$Advanced$lazy(
                  function(_v2) {
                    return A2(
                      $elm$parser$Parser$Advanced$keeper,
                      A2(
                        $elm$parser$Parser$Advanced$keeper,
                        $elm$parser$Parser$Advanced$succeed($elm$core$List$cons),
                        $jinjor$elm_xml_parser$XmlParser$cyclic$element()
                      ),
                      $jinjor$elm_xml_parser$XmlParser$children(startTagName)
                    );
                  }
                )
              ]
            )
          )
        );
      };
      function $jinjor$elm_xml_parser$XmlParser$cyclic$element() {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "element",
          A2(
            $elm$parser$Parser$Advanced$keeper,
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
              $jinjor$elm_xml_parser$XmlParser$symbol("<")
            ),
            A2(
              $elm$parser$Parser$Advanced$andThen,
              function(startTagName) {
                return A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    A2(
                      $elm$parser$Parser$Advanced$ignorer,
                      $elm$parser$Parser$Advanced$succeed(
                        $jinjor$elm_xml_parser$XmlParser$Element(startTagName)
                      ),
                      $jinjor$elm_xml_parser$XmlParser$whiteSpace
                    ),
                    A2(
                      $elm$parser$Parser$Advanced$ignorer,
                      $jinjor$elm_xml_parser$XmlParser$attributes($elm$core$Set$empty),
                      $jinjor$elm_xml_parser$XmlParser$whiteSpace
                    )
                  ),
                  $elm$parser$Parser$Advanced$oneOf(
                    _List_fromArray(
                      [
                        A2(
                          $elm$parser$Parser$Advanced$ignorer,
                          $elm$parser$Parser$Advanced$succeed(_List_Nil),
                          $jinjor$elm_xml_parser$XmlParser$symbol("/>")
                        ),
                        A2(
                          $elm$parser$Parser$Advanced$keeper,
                          A2(
                            $elm$parser$Parser$Advanced$ignorer,
                            $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
                            $jinjor$elm_xml_parser$XmlParser$symbol(">")
                          ),
                          $elm$parser$Parser$Advanced$lazy(
                            function(_v0) {
                              return $jinjor$elm_xml_parser$XmlParser$children(startTagName);
                            }
                          )
                        )
                      ]
                    )
                  )
                );
              },
              $jinjor$elm_xml_parser$XmlParser$tagName
            )
          )
        );
      }
      try {
        var $jinjor$elm_xml_parser$XmlParser$element = $jinjor$elm_xml_parser$XmlParser$cyclic$element();
        $jinjor$elm_xml_parser$XmlParser$cyclic$element = function() {
          return $jinjor$elm_xml_parser$XmlParser$element;
        };
      } catch ($) {
        throw "Some top-level definitions from `XmlParser` are causing infinite recursion:\n\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502    children\n  \u2502     \u2193\n  \u2502    element\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!";
      }
      var $elm$parser$Parser$ExpectingEnd = { $: "ExpectingEnd" };
      var $elm$parser$Parser$Advanced$end = function(x) {
        return $elm$parser$Parser$Advanced$Parser(
          function(s) {
            return _Utils_eq(
              $elm$core$String$length(s.src),
              s.offset
            ) ? A3($elm$parser$Parser$Advanced$Good, false, _Utils_Tuple0, s) : A2(
              $elm$parser$Parser$Advanced$Bad,
              false,
              A2($elm$parser$Parser$Advanced$fromState, s, x)
            );
          }
        );
      };
      var $jinjor$elm_xml_parser$XmlParser$end = $elm$parser$Parser$Advanced$end($elm$parser$Parser$ExpectingEnd);
      var $jinjor$elm_xml_parser$XmlParser$ProcessingInstruction = F2(
        function(name, value) {
          return { name, value };
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$processingInstructionName = A2(
        $elm$parser$Parser$Advanced$inContext,
        "processingInstructionName",
        A2(
          $jinjor$elm_xml_parser$XmlParser$keep,
          $jinjor$elm_xml_parser$XmlParser$oneOrMore,
          function(c) {
            return !_Utils_eq(
              c,
              _Utils_chr(" ")
            );
          }
        )
      );
      function $jinjor$elm_xml_parser$XmlParser$cyclic$processingInstructionValue() {
        return A2(
          $elm$parser$Parser$Advanced$inContext,
          "processingInstructionValue",
          $elm$parser$Parser$Advanced$oneOf(
            _List_fromArray(
              [
                A2(
                  $elm$parser$Parser$Advanced$ignorer,
                  $elm$parser$Parser$Advanced$succeed(""),
                  $jinjor$elm_xml_parser$XmlParser$symbol("?>")
                ),
                A2(
                  $elm$parser$Parser$Advanced$andThen,
                  function(_v0) {
                    return A2(
                      $elm$parser$Parser$Advanced$map,
                      function(tail) {
                        return "?" + tail;
                      },
                      $jinjor$elm_xml_parser$XmlParser$cyclic$processingInstructionValue()
                    );
                  },
                  $jinjor$elm_xml_parser$XmlParser$symbol("?")
                ),
                A2(
                  $elm$parser$Parser$Advanced$keeper,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    $elm$parser$Parser$Advanced$succeed($elm$core$Basics$append),
                    A2(
                      $jinjor$elm_xml_parser$XmlParser$keep,
                      $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
                      function(c) {
                        return !_Utils_eq(
                          c,
                          _Utils_chr("?")
                        );
                      }
                    )
                  ),
                  $elm$parser$Parser$Advanced$lazy(
                    function(_v1) {
                      return $jinjor$elm_xml_parser$XmlParser$cyclic$processingInstructionValue();
                    }
                  )
                )
              ]
            )
          )
        );
      }
      try {
        var $jinjor$elm_xml_parser$XmlParser$processingInstructionValue = $jinjor$elm_xml_parser$XmlParser$cyclic$processingInstructionValue();
        $jinjor$elm_xml_parser$XmlParser$cyclic$processingInstructionValue = function() {
          return $jinjor$elm_xml_parser$XmlParser$processingInstructionValue;
        };
      } catch ($) {
        throw "Some top-level definitions from `XmlParser` are causing infinite recursion:\n\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502    processingInstructionValue\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!";
      }
      var $jinjor$elm_xml_parser$XmlParser$processingInstruction = A2(
        $elm$parser$Parser$Advanced$inContext,
        "processingInstruction",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$keeper,
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              $elm$parser$Parser$Advanced$succeed($jinjor$elm_xml_parser$XmlParser$ProcessingInstruction),
              $jinjor$elm_xml_parser$XmlParser$symbol("<?")
            ),
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              $jinjor$elm_xml_parser$XmlParser$processingInstructionName,
              $jinjor$elm_xml_parser$XmlParser$symbol(" ")
            )
          ),
          $jinjor$elm_xml_parser$XmlParser$processingInstructionValue
        )
      );
      var $elm$parser$Parser$Advanced$Done = function(a) {
        return { $: "Done", a };
      };
      var $elm$parser$Parser$Advanced$Loop = function(a) {
        return { $: "Loop", a };
      };
      var $elm$parser$Parser$Advanced$loopHelp = F4(
        function(p, state, callback, s0) {
          loopHelp:
            while (true) {
              var _v0 = callback(state);
              var parse = _v0.a;
              var _v1 = parse(s0);
              if (_v1.$ === "Good") {
                var p1 = _v1.a;
                var step = _v1.b;
                var s1 = _v1.c;
                if (step.$ === "Loop") {
                  var newState = step.a;
                  var $temp$p = p || p1, $temp$state = newState, $temp$callback = callback, $temp$s0 = s1;
                  p = $temp$p;
                  state = $temp$state;
                  callback = $temp$callback;
                  s0 = $temp$s0;
                  continue loopHelp;
                } else {
                  var result = step.a;
                  return A3($elm$parser$Parser$Advanced$Good, p || p1, result, s1);
                }
              } else {
                var p1 = _v1.a;
                var x = _v1.b;
                return A2($elm$parser$Parser$Advanced$Bad, p || p1, x);
              }
            }
        }
      );
      var $elm$parser$Parser$Advanced$loop = F2(
        function(state, callback) {
          return $elm$parser$Parser$Advanced$Parser(
            function(s) {
              return A4($elm$parser$Parser$Advanced$loopHelp, false, state, callback, s);
            }
          );
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$repeat = F2(
        function(count, parser) {
          var n = count.a;
          return A2(
            $elm$parser$Parser$Advanced$andThen,
            function(results) {
              return _Utils_cmp(
                n,
                $elm$core$List$length(results)
              ) < 1 ? $elm$parser$Parser$Advanced$succeed(results) : $elm$parser$Parser$Advanced$problem($elm$parser$Parser$BadRepeat);
            },
            A2(
              $elm$parser$Parser$Advanced$loop,
              _List_Nil,
              function(state) {
                return $elm$parser$Parser$Advanced$oneOf(
                  _List_fromArray(
                    [
                      A2(
                        $elm$parser$Parser$Advanced$map,
                        function(r) {
                          return $elm$parser$Parser$Advanced$Loop(
                            A2(
                              $elm$core$List$append,
                              state,
                              _List_fromArray(
                                [r]
                              )
                            )
                          );
                        },
                        parser
                      ),
                      A2(
                        $elm$parser$Parser$Advanced$map,
                        $elm$core$Basics$always(
                          $elm$parser$Parser$Advanced$Done(state)
                        ),
                        $elm$parser$Parser$Advanced$succeed(_Utils_Tuple0)
                      )
                    ]
                  )
                );
              }
            )
          );
        }
      );
      var $jinjor$elm_xml_parser$XmlParser$whiteSpace1 = A2($jinjor$elm_xml_parser$XmlParser$ignore, $jinjor$elm_xml_parser$XmlParser$oneOrMore, $jinjor$elm_xml_parser$XmlParser$isWhitespace);
      var $jinjor$elm_xml_parser$XmlParser$xml = A2(
        $elm$parser$Parser$Advanced$inContext,
        "xml",
        A2(
          $elm$parser$Parser$Advanced$keeper,
          A2(
            $elm$parser$Parser$Advanced$keeper,
            A2(
              $elm$parser$Parser$Advanced$keeper,
              A2(
                $elm$parser$Parser$Advanced$ignorer,
                $elm$parser$Parser$Advanced$succeed($jinjor$elm_xml_parser$XmlParser$Xml),
                $jinjor$elm_xml_parser$XmlParser$whiteSpace
              ),
              A2(
                $elm$parser$Parser$Advanced$ignorer,
                A2(
                  $jinjor$elm_xml_parser$XmlParser$repeat,
                  $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
                  A2(
                    $elm$parser$Parser$Advanced$keeper,
                    $elm$parser$Parser$Advanced$succeed($elm$core$Basics$identity),
                    A2($elm$parser$Parser$Advanced$ignorer, $jinjor$elm_xml_parser$XmlParser$processingInstruction, $jinjor$elm_xml_parser$XmlParser$whiteSpace)
                  )
                ),
                A2(
                  $jinjor$elm_xml_parser$XmlParser$repeat,
                  $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
                  $elm$parser$Parser$Advanced$oneOf(
                    _List_fromArray(
                      [$jinjor$elm_xml_parser$XmlParser$whiteSpace1, $jinjor$elm_xml_parser$XmlParser$comment]
                    )
                  )
                )
              )
            ),
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              $jinjor$elm_xml_parser$XmlParser$maybe($jinjor$elm_xml_parser$XmlParser$docType),
              A2(
                $jinjor$elm_xml_parser$XmlParser$repeat,
                $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
                $elm$parser$Parser$Advanced$oneOf(
                  _List_fromArray(
                    [$jinjor$elm_xml_parser$XmlParser$whiteSpace1, $jinjor$elm_xml_parser$XmlParser$comment]
                  )
                )
              )
            )
          ),
          A2(
            $elm$parser$Parser$Advanced$ignorer,
            A2(
              $elm$parser$Parser$Advanced$ignorer,
              $jinjor$elm_xml_parser$XmlParser$element,
              A2(
                $jinjor$elm_xml_parser$XmlParser$repeat,
                $jinjor$elm_xml_parser$XmlParser$zeroOrMore,
                $elm$parser$Parser$Advanced$oneOf(
                  _List_fromArray(
                    [$jinjor$elm_xml_parser$XmlParser$whiteSpace1, $jinjor$elm_xml_parser$XmlParser$comment]
                  )
                )
              )
            ),
            $jinjor$elm_xml_parser$XmlParser$end
          )
        )
      );
      var $jinjor$elm_xml_parser$XmlParser$parse = function(source) {
        return A2($elm$parser$Parser$Advanced$run, $jinjor$elm_xml_parser$XmlParser$xml, source);
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$parserProblemToString = function(problem) {
        switch (problem.$) {
          case "Expecting":
            var expect = problem.a;
            return "I was expecting: " + expect;
          case "ExpectingInt":
            return "I was expecting an integer";
          case "ExpectingHex":
            return "I was expecting a hexadecimal";
          case "ExpectingOctal":
            return "I was expecting an octal";
          case "ExpectingBinary":
            return "I was expecting a binary";
          case "ExpectingFloat":
            return "I was expecting a float";
          case "ExpectingNumber":
            return "I was expecting a number";
          case "ExpectingVariable":
            return "I was expecting a variable";
          case "ExpectingSymbol":
            var symbol = problem.a;
            return "I was expecting a symbol: " + symbol;
          case "ExpectingKeyword":
            var keyword = problem.a;
            return "I was expecting a keyword: " + keyword;
          case "ExpectingEnd":
            return "I was expecting the end of input";
          case "UnexpectedChar":
            return "I got an unexpected character";
          case "Problem":
            var text = problem.a;
            return text;
          default:
            return "I got a bad repetition";
        }
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$parseErrorsToString = function(deadEnds) {
        return A2(
          $elm$core$String$append,
          "Invalid XML document.\n",
          A2(
            $elm$core$String$join,
            "\n",
            A2(
              $elm$core$List$map,
              function(deadEnd) {
                return _Utils_ap(
                  "At [" + ($elm$core$String$fromInt(deadEnd.row) + ("," + ($elm$core$String$fromInt(deadEnd.col) + "], "))),
                  $ymtszw$elm_xml_decode$Xml$Decode$parserProblemToString(deadEnd.problem)
                );
              },
              deadEnds
            )
          )
        );
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$decodeString = F2(
        function(decoder, s) {
          var _v0 = $jinjor$elm_xml_parser$XmlParser$parse(s);
          if (_v0.$ === "Ok") {
            var xml = _v0.a;
            var _v1 = A2($ymtszw$elm_xml_decode$Xml$Decode$decodeXml, decoder, xml);
            if (_v1.$ === "Ok") {
              var decoded = _v1.a;
              return $elm$core$Result$Ok(decoded);
            } else {
              var dErr = _v1.a;
              return $elm$core$Result$Err(
                $ymtszw$elm_xml_decode$Xml$Decode$errorToString(dErr)
              );
            }
          } else {
            var pErr = _v0.a;
            return $elm$core$Result$Err(
              $ymtszw$elm_xml_decode$Xml$Decode$parseErrorsToString(pErr)
            );
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$Decoder = function(a) {
        return { $: "Decoder", a };
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$children = function(aNode) {
        if (aNode.$ === "Element") {
          var nodes = aNode.c;
          return nodes;
        } else {
          return _List_Nil;
        }
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$Path = F2(
        function(a, b) {
          return { $: "Path", a, b };
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$concatPath = F2(
        function(path_, error) {
          if (error.$ === "Path") {
            var innerPath = error.a;
            var innerError = error.b;
            return A2(
              $ymtszw$elm_xml_decode$Xml$Decode$Path,
              _Utils_ap(path_, innerPath),
              innerError
            );
          } else {
            var otherwise = error;
            return A2($ymtszw$elm_xml_decode$Xml$Decode$Path, path_, otherwise);
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$hasName = F2(
        function(name, aNode) {
          if (aNode.$ === "Element") {
            var nodeName = aNode.a;
            return _Utils_eq(name, nodeName);
          } else {
            return false;
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$query = F3(
        function(path_, ancestor, collected) {
          query:
            while (true) {
              if (!path_.b) {
                return _Utils_Tuple2(collected, ancestor);
              } else {
                if (!path_.b.b) {
                  var segment = path_.a;
                  return _Utils_Tuple2(
                    A2(
                      $elm$core$List$filter,
                      $ymtszw$elm_xml_decode$Xml$Decode$hasName(segment),
                      collected
                    ),
                    ancestor
                  );
                } else {
                  var segment = path_.a;
                  var ss = path_.b;
                  var _v1 = A2(
                    $elm$core$List$filter,
                    $ymtszw$elm_xml_decode$Xml$Decode$hasName(segment),
                    collected
                  );
                  if (!_v1.b) {
                    return _Utils_Tuple2(_List_Nil, ancestor);
                  } else {
                    if (!_v1.b.b) {
                      var onlyOne = _v1.a;
                      var $temp$path_ = ss, $temp$ancestor = onlyOne, $temp$collected = $ymtszw$elm_xml_decode$Xml$Decode$children(onlyOne);
                      path_ = $temp$path_;
                      ancestor = $temp$ancestor;
                      collected = $temp$collected;
                      continue query;
                    } else {
                      var many = _v1;
                      var $temp$path_ = ss, $temp$ancestor = ancestor, $temp$collected = A2($elm$core$List$concatMap, $ymtszw$elm_xml_decode$Xml$Decode$children, many);
                      path_ = $temp$path_;
                      ancestor = $temp$ancestor;
                      collected = $temp$collected;
                      continue query;
                    }
                  }
                }
              }
            }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$pathImpl = F3(
        function(path_, _v0, aNode) {
          var listDecoder = _v0.a;
          return A2(
            $elm$core$Result$mapError,
            $ymtszw$elm_xml_decode$Xml$Decode$concatPath(path_),
            listDecoder(
              A3(
                $ymtszw$elm_xml_decode$Xml$Decode$query,
                path_,
                aNode,
                $ymtszw$elm_xml_decode$Xml$Decode$children(aNode)
              )
            )
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$path = F2(
        function(path_, listDecoder) {
          return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
            A2($ymtszw$elm_xml_decode$Xml$Decode$pathImpl, path_, listDecoder)
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$ListDecoder = function(a) {
        return { $: "ListDecoder", a };
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$Failure = F2(
        function(a, b) {
          return { $: "Failure", a, b };
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$singleImpl = F2(
        function(_v0, _v1) {
          var decoder = _v0.a;
          var nodes = _v1.a;
          var ancestor = _v1.b;
          if (!nodes.b) {
            return $elm$core$Result$Err(
              A2($ymtszw$elm_xml_decode$Xml$Decode$Failure, "Node not found.", ancestor)
            );
          } else {
            if (!nodes.b.b) {
              var singleton_ = nodes.a;
              return decoder(singleton_);
            } else {
              return $elm$core$Result$Err(
                A2($ymtszw$elm_xml_decode$Xml$Decode$Failure, "Multiple nodes found.", ancestor)
              );
            }
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$single = function(decoder) {
        return $ymtszw$elm_xml_decode$Xml$Decode$ListDecoder(
          $ymtszw$elm_xml_decode$Xml$Decode$singleImpl(decoder)
        );
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$cdataImpl = F2(
        function(generator, aNode) {
          var unparsable = function(message) {
            return A2($ymtszw$elm_xml_decode$Xml$Decode$Failure, message, aNode);
          };
          var gen = A2(
            $elm$core$Basics$composeR,
            generator,
            $elm$core$Result$mapError(unparsable)
          );
          if (aNode.$ === "Text") {
            var str = aNode.a;
            return gen(str);
          } else {
            if (!aNode.c.b) {
              return gen("");
            } else {
              if (aNode.c.a.$ === "Text" && !aNode.c.b.b) {
                var _v1 = aNode.c;
                var str = _v1.a.a;
                return gen(str);
              } else {
                return $elm$core$Result$Err(
                  unparsable("The node is not a simple text node.")
                );
              }
            }
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$cdata = function(generator) {
        return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
          $ymtszw$elm_xml_decode$Xml$Decode$cdataImpl(generator)
        );
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$string = $ymtszw$elm_xml_decode$Xml$Decode$cdata($elm$core$Result$Ok);
      var $author$project$Sources$Services$AmazonS3$Parser$errorMessagesDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$path,
        _List_fromArray(
          ["Message"]
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
      );
      var $author$project$Sources$Services$AmazonS3$Parser$parseErrorResponse = function(response) {
        return $elm$core$Result$toMaybe(
          A2($ymtszw$elm_xml_decode$Xml$Decode$decodeString, $author$project$Sources$Services$AmazonS3$Parser$errorMessagesDecoder, response)
        );
      };
      var $author$project$Sources$Services$AmazonS3$parseErrorResponse = $author$project$Sources$Services$AmazonS3$Parser$parseErrorResponse;
      var $author$project$Sources$Services$Azure$BlobParser$errorMessagesDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$path,
        _List_fromArray(
          ["Message"]
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
      );
      var $author$project$Sources$Services$Azure$BlobParser$parseErrorResponse = function(response) {
        return $elm$core$Result$toMaybe(
          A2($ymtszw$elm_xml_decode$Xml$Decode$decodeString, $author$project$Sources$Services$Azure$BlobParser$errorMessagesDecoder, response)
        );
      };
      var $author$project$Sources$Services$AzureBlob$parseErrorResponse = $author$project$Sources$Services$Azure$BlobParser$parseErrorResponse;
      var $author$project$Sources$Services$Azure$FileParser$errorMessagesDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$path,
        _List_fromArray(
          ["Message"]
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
      );
      var $author$project$Sources$Services$Azure$FileParser$parseErrorResponse = function(response) {
        return $elm$core$Result$toMaybe(
          A2($ymtszw$elm_xml_decode$Xml$Decode$decodeString, $author$project$Sources$Services$Azure$FileParser$errorMessagesDecoder, response)
        );
      };
      var $author$project$Sources$Services$AzureFile$parseErrorResponse = $author$project$Sources$Services$Azure$FileParser$parseErrorResponse;
      var $author$project$Sources$Services$Ipfs$Parser$parseErrorResponse = function(response) {
        return $elm$core$Result$toMaybe(
          A2(
            $elm$json$Json$Decode$decodeString,
            A2($elm$json$Json$Decode$field, "Message", $elm$json$Json$Decode$string),
            response
          )
        );
      };
      var $author$project$Sources$Services$Ipfs$parseErrorResponse = $author$project$Sources$Services$Ipfs$Parser$parseErrorResponse;
      var $author$project$Sources$Services$Btfs$parseErrorResponse = $author$project$Sources$Services$Ipfs$parseErrorResponse;
      var $author$project$Sources$Services$Dropbox$Parser$parseErrorResponse = function(response) {
        return $elm$core$Result$toMaybe(
          A2(
            $elm$json$Json$Decode$decodeString,
            A2($elm$json$Json$Decode$field, "error_summary", $elm$json$Json$Decode$string),
            response
          )
        );
      };
      var $author$project$Sources$Services$Dropbox$parseErrorResponse = $author$project$Sources$Services$Dropbox$Parser$parseErrorResponse;
      var $author$project$Sources$Services$Google$Parser$parseErrorResponse = function(response) {
        return $elm$core$Result$toMaybe(
          A2(
            $elm$json$Json$Decode$decodeString,
            A2(
              $elm$json$Json$Decode$at,
              _List_fromArray(
                ["error", "message"]
              ),
              $elm$json$Json$Decode$string
            ),
            response
          )
        );
      };
      var $author$project$Sources$Services$Google$parseErrorResponse = $author$project$Sources$Services$Google$Parser$parseErrorResponse;
      var $author$project$Sources$Services$WebDav$Parser$parseErrorResponse = $elm$core$Maybe$Just;
      var $author$project$Sources$Services$WebDav$parseErrorResponse = $author$project$Sources$Services$WebDav$Parser$parseErrorResponse;
      var $author$project$Sources$Services$parseErrorResponse = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return $author$project$Sources$Services$AmazonS3$parseErrorResponse;
          case "AzureBlob":
            return $author$project$Sources$Services$AzureBlob$parseErrorResponse;
          case "AzureFile":
            return $author$project$Sources$Services$AzureFile$parseErrorResponse;
          case "Btfs":
            return $author$project$Sources$Services$Btfs$parseErrorResponse;
          case "Dropbox":
            return $author$project$Sources$Services$Dropbox$parseErrorResponse;
          case "Google":
            return $author$project$Sources$Services$Google$parseErrorResponse;
          case "Ipfs":
            return $author$project$Sources$Services$Ipfs$parseErrorResponse;
          default:
            return $author$project$Sources$Services$WebDav$parseErrorResponse;
        }
      };
      var $author$project$Brain$Sources$Processing$Common$translateHttpError = F2(
        function(service, err) {
          switch (err.$) {
            case "NetworkError":
              return "Cannot connect to this source";
            case "Timeout":
              return "Source did not respond (timeout)";
            case "BadUrl":
              return "Diffuse error, invalid url was used";
            case "BadStatus":
              return "Got a faulty response from this source. Use the developer console to get more info.";
            default:
              var response = err.a;
              return A2(
                $elm$core$Maybe$withDefault,
                A2(
                  $author$project$Brain$Sources$Processing$Common$translateHttpError,
                  service,
                  $elm$http$Http$BadStatus(0)
                ),
                A2($author$project$Sources$Services$parseErrorResponse, service, response)
              );
          }
        }
      );
      var $author$project$Brain$Sources$Processing$Common$reportHttpError = F2(
        function(source, err) {
          return A2(
            $author$project$Brain$Sources$Processing$Common$reportError,
            source,
            A2($author$project$Brain$Sources$Processing$Common$translateHttpError, source.service, err)
          );
        }
      );
      var $author$project$Sources$Processing$TheEnd = { $: "TheEnd" };
      var $author$project$Sources$Services$Common$noPrep = F4(
        function(_v0, _v1, srcData, _v2) {
          return { marker: $author$project$Sources$Processing$TheEnd, sourceData: srcData };
        }
      );
      var $author$project$Sources$Services$AmazonS3$parsePreparationResponse = $author$project$Sources$Services$Common$noPrep;
      var $author$project$Sources$Services$AzureBlob$parsePreparationResponse = $author$project$Sources$Services$Common$noPrep;
      var $author$project$Sources$Services$AzureFile$parsePreparationResponse = $author$project$Sources$Services$Common$noPrep;
      var $author$project$Sources$Services$Ipfs$Parser$cloudflareDnsResultDecoder = A2(
        $elm$json$Json$Decode$map,
        function(txt) {
          return A2(
            $author$project$String$Ext$chopStart,
            "dnslink=/ipfs/",
            A2(
              $author$project$String$Ext$chopStart,
              '"',
              A2($author$project$String$Ext$chopEnd, '"', txt)
            )
          );
        },
        A2(
          $elm$json$Json$Decode$at,
          _List_fromArray(
            ["Answer", "0", "data"]
          ),
          $elm$json$Json$Decode$string
        )
      );
      var $author$project$Sources$Services$Ipfs$Parser$dnsResultDecoder = $elm$json$Json$Decode$oneOf(
        _List_fromArray(
          [
            A2(
              $elm$json$Json$Decode$at,
              _List_fromArray(
                ["Path"]
              ),
              $elm$json$Json$Decode$string
            ),
            $author$project$Sources$Services$Ipfs$Parser$cloudflareDnsResultDecoder
          ]
        )
      );
      var $author$project$Sources$Services$Ipfs$Parser$parseDnsLookup = F4(
        function(response, _v0, srcData, _v1) {
          var _v2 = A2($elm$json$Json$Decode$decodeString, $author$project$Sources$Services$Ipfs$Parser$dnsResultDecoder, response);
          if (_v2.$ === "Ok") {
            var path = _v2.a;
            return function(s) {
              return { marker: $author$project$Sources$Processing$TheEnd, sourceData: s };
            }(
              A3(
                $elm$core$Dict$insert,
                "directoryHashFromDnsLink",
                A2($author$project$String$Ext$chopStart, "/ipfs/", path),
                srcData
              )
            );
          } else {
            return { marker: $author$project$Sources$Processing$TheEnd, sourceData: srcData };
          }
        }
      );
      var $author$project$Sources$Services$Ipfs$parsePreparationResponse = $author$project$Sources$Services$Ipfs$Parser$parseDnsLookup;
      var $author$project$Sources$Services$Btfs$parsePreparationResponse = $author$project$Sources$Services$Ipfs$parsePreparationResponse;
      var $author$project$Sources$Services$Dropbox$parsePreparationResponse = $author$project$Sources$Services$Common$noPrep;
      var $author$project$Sources$Services$Google$Parser$parsePreparationResponse = F4(
        function(response, currentTimePosix, srcData, _v0) {
          var newAccessToken = A2(
            $elm$core$Result$withDefault,
            "",
            A2(
              $elm$json$Json$Decode$decodeString,
              A2($elm$json$Json$Decode$field, "access_token", $elm$json$Json$Decode$string),
              response
            )
          );
          var maybeRefreshToken = $elm_community$maybe_extra$Maybe$Extra$join(
            $elm$core$Result$toMaybe(
              A2(
                $elm$json$Json$Decode$decodeString,
                $elm$json$Json$Decode$maybe(
                  A2($elm$json$Json$Decode$field, "refresh_token", $elm$json$Json$Decode$string)
                ),
                response
              )
            )
          );
          var refreshTokenUpdater = function(dict) {
            if (maybeRefreshToken.$ === "Just") {
              var refreshToken = maybeRefreshToken.a;
              return A3($elm$core$Dict$insert, "refreshToken", refreshToken, dict);
            } else {
              return dict;
            }
          };
          var currentTime = $elm$time$Time$posixToMillis(currentTimePosix);
          var expiresAt = function(s) {
            return currentTime + s * 1e3;
          }(
            A2(
              $elm$core$Result$withDefault,
              2500,
              A2(
                $elm$json$Json$Decode$decodeString,
                A2($elm$json$Json$Decode$field, "expires_in", $elm$json$Json$Decode$int),
                response
              )
            )
          );
          return function(s) {
            return { marker: $author$project$Sources$Processing$TheEnd, sourceData: s };
          }(
            A2(
              $elm$core$Dict$remove,
              "authCode",
              refreshTokenUpdater(
                A3(
                  $elm$core$Dict$insert,
                  "expiresAt",
                  $elm$core$String$fromInt(expiresAt),
                  A3($elm$core$Dict$insert, "accessToken", newAccessToken, srcData)
                )
              )
            )
          );
        }
      );
      var $author$project$Sources$Services$Google$parsePreparationResponse = $author$project$Sources$Services$Google$Parser$parsePreparationResponse;
      var $author$project$Sources$Services$WebDav$parsePreparationResponse = $author$project$Sources$Services$Common$noPrep;
      var $author$project$Sources$Services$parsePreparationResponse = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return $author$project$Sources$Services$AmazonS3$parsePreparationResponse;
          case "AzureBlob":
            return $author$project$Sources$Services$AzureBlob$parsePreparationResponse;
          case "AzureFile":
            return $author$project$Sources$Services$AzureFile$parsePreparationResponse;
          case "Btfs":
            return $author$project$Sources$Services$Btfs$parsePreparationResponse;
          case "Dropbox":
            return $author$project$Sources$Services$Dropbox$parsePreparationResponse;
          case "Google":
            return $author$project$Sources$Services$Google$parsePreparationResponse;
          case "Ipfs":
            return $author$project$Sources$Services$Ipfs$parsePreparationResponse;
          default:
            return $author$project$Sources$Services$WebDav$parsePreparationResponse;
        }
      };
      var $author$project$Brain$Sources$Processing$Steps$handlePreparationResponse = F3(
        function(response, currentTime, context) {
          var source = context.source;
          var answer = A5($author$project$Sources$Services$parsePreparationResponse, context.source.service, response, currentTime, context.source.data, context.preparationMarker);
          return _Utils_update(
            context,
            {
              preparationMarker: answer.marker,
              source: _Utils_update(
                source,
                { data: answer.sourceData }
              )
            }
          );
        }
      );
      var $author$project$Brain$Sources$Processing$Steps$intoPreparationCommands = F2(
        function(currentTime, context) {
          var _v0 = context.preparationMarker;
          switch (_v0.$) {
            case "TheBeginning":
              return $elm$core$Platform$Cmd$none;
            case "InProgress":
              return A2($author$project$Brain$Sources$Processing$Steps$prepare, context, currentTime);
            default:
              var updatedSource = context.source;
              return $elm$core$Platform$Cmd$batch(
                _List_fromArray(
                  [
                    A2($author$project$Brain$Sources$Processing$Steps$makeTree, context, currentTime),
                    $author$project$Brain$Ports$toUI(
                      A2(
                        $author$project$Alien$broadcast,
                        $author$project$Alien$UpdateSourceData,
                        $author$project$Sources$Encoding$encode(updatedSource)
                      )
                    )
                  ]
                )
              );
          }
        }
      );
      var $author$project$Brain$Sources$Processing$Steps$takePrepareStep = F3(
        function(context, response, currentTime) {
          return A2(
            $author$project$Brain$Sources$Processing$Steps$intoPreparationCommands,
            currentTime,
            A3($author$project$Brain$Sources$Processing$Steps$handlePreparationResponse, response, currentTime, context)
          );
        }
      );
      var $author$project$Brain$Sources$Processing$State$prepareStep = F3(
        function(context, result, model) {
          if (result.$ === "Ok") {
            var response = result.a;
            return A2(
              $Fresheyeball$elm_return$Return$return,
              model,
              A3($author$project$Brain$Sources$Processing$Steps$takePrepareStep, context, response, model.currentTime)
            );
          } else {
            var err = result.a;
            return A2(
              $Fresheyeball$elm_return$Return$andThen,
              A2($author$project$Brain$Sources$Processing$Common$reportHttpError, context.source, err),
              $author$project$Brain$Sources$Processing$State$nextInLine(model)
            );
          }
        }
      );
      var $author$project$Sources$Processing$Arguments = F2(
        function(origin, sources) {
          return { origin, sources };
        }
      );
      var $author$project$Sources$Processing$Encoding$argumentsDecoder = A3(
        $elm$json$Json$Decode$map2,
        $author$project$Sources$Processing$Arguments,
        A2($elm$json$Json$Decode$field, "origin", $elm$json$Json$Decode$string),
        A2(
          $elm$json$Json$Decode$field,
          "sources",
          $elm$json$Json$Decode$list($author$project$Sources$Encoding$decoder)
        )
      );
      var $author$project$Brain$Sources$Processing$Common$isProcessing = function(status) {
        if (status.$ === "Processing") {
          return true;
        } else {
          return false;
        }
      };
      var $elm_community$list_extra$List$Extra$uncons = function(list) {
        if (!list.b) {
          return $elm$core$Maybe$Nothing;
        } else {
          var first = list.a;
          var rest = list.b;
          return $elm$core$Maybe$Just(
            _Utils_Tuple2(first, rest)
          );
        }
      };
      var $author$project$Brain$Sources$Processing$State$process_ = F2(
        function(_v0, model) {
          var origin = _v0.origin;
          var sources = _v0.sources;
          var tracks = model.hypaethralUserData.tracks;
          var filter = function(s2) {
            return A2(
              $elm$core$List$filter,
              A2(
                $elm$core$Basics$composeR,
                function($) {
                  return $.sourceId;
                },
                $elm$core$Basics$eq(s2.id)
              ),
              tracks
            );
          };
          var all = A2(
            $elm$core$List$map,
            function(s2) {
              return _Utils_Tuple2(
                s2,
                filter(s2)
              );
            },
            A2(
              $elm$core$List$sortBy,
              A2(
                $elm$core$Basics$composeR,
                function($) {
                  return $.data;
                },
                A2($author$project$Dict$Ext$fetch, "name", "")
              ),
              sources
            )
          );
          var _v1 = _Utils_Tuple2(
            $author$project$Brain$Sources$Processing$Common$isProcessing(model.processingStatus) || $elm$core$List$isEmpty(sources),
            $elm_community$list_extra$List$Extra$uncons(all)
          );
          if (!_v1.a && _v1.b.$ === "Just") {
            var _v2 = _v1.b.a;
            var _v3 = _v2.a;
            var s = _v3.a;
            var t = _v3.b;
            var future = _v2.b;
            return A2(
              $Fresheyeball$elm_return$Return$return,
              _Utils_update(
                model,
                {
                  origin,
                  processingStatus: A2(
                    $author$project$Sources$Processing$Processing,
                    _Utils_Tuple2(s, t),
                    future
                  )
                }
              ),
              A3($author$project$Brain$Sources$Processing$Steps$takeFirstStep, origin, model.currentTime, s)
            );
          } else {
            return $Fresheyeball$elm_return$Return$singleton(model);
          }
        }
      );
      var $author$project$Brain$Sources$Processing$State$process = function(json) {
        var _v0 = A2($elm$json$Json$Decode$decodeValue, $author$project$Sources$Processing$Encoding$argumentsDecoder, json);
        if (_v0.$ === "Ok") {
          var _arguments = _v0.a;
          return $author$project$Brain$Sources$Processing$State$process_(_arguments);
        } else {
          var err = _v0.a;
          return A2(
            $author$project$Brain$Common$State$reportUI,
            $author$project$Alien$ProcessSources,
            $elm$json$Json$Decode$errorToString(err)
          );
        }
      };
      var $author$project$Brain$Sources$Processing$State$stopProcessing = function(model) {
        return $Fresheyeball$elm_return$Return$singleton(
          _Utils_update(
            model,
            { processingStatus: $author$project$Sources$Processing$NotProcessing }
          )
        );
      };
      var $author$project$Brain$Tracks$State$add = F2(
        function(list, model) {
          if (!list.b) {
            return $Fresheyeball$elm_return$Return$singleton(model);
          } else {
            var tracks = list;
            return A2(
              $Fresheyeball$elm_return$Return$andThen,
              A2(
                $author$project$Brain$Common$State$giveUI,
                $author$project$Alien$AddTracks,
                A2($elm$json$Json$Encode$list, $author$project$Tracks$Encoding$encodeTrack, tracks)
              ),
              A2(
                $author$project$Brain$User$State$saveTracksAndUpdateSearchIndex,
                A2($elm$core$List$append, model.hypaethralUserData.tracks, tracks),
                model
              )
            );
          }
        }
      );
      var $author$project$Brain$Ports$requestTags = _Platform_outgoingPort(
        "requestTags",
        function($) {
          return $elm$json$Json$Encode$object(
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "amount",
                  $elm$json$Json$Encode$int($.amount)
                ),
                _Utils_Tuple2(
                  "nextFilePaths",
                  $elm$json$Json$Encode$list($elm$json$Json$Encode$string)($.nextFilePaths)
                ),
                _Utils_Tuple2(
                  "receivedFilePaths",
                  $elm$json$Json$Encode$list($elm$json$Json$Encode$string)($.receivedFilePaths)
                ),
                _Utils_Tuple2(
                  "receivedTags",
                  $elm$json$Json$Encode$list(
                    function($2) {
                      return A3(
                        $elm$core$Maybe$destruct,
                        $elm$json$Json$Encode$null,
                        function($3) {
                          return $elm$json$Json$Encode$object(
                            _List_fromArray(
                              [
                                _Utils_Tuple2(
                                  "album",
                                  $elm$json$Json$Encode$string($3.album)
                                ),
                                _Utils_Tuple2(
                                  "artist",
                                  $elm$json$Json$Encode$string($3.artist)
                                ),
                                _Utils_Tuple2(
                                  "disc",
                                  $elm$json$Json$Encode$int($3.disc)
                                ),
                                _Utils_Tuple2(
                                  "genre",
                                  function($4) {
                                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $4);
                                  }($3.genre)
                                ),
                                _Utils_Tuple2(
                                  "nr",
                                  $elm$json$Json$Encode$int($3.nr)
                                ),
                                _Utils_Tuple2(
                                  "picture",
                                  function($4) {
                                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $4);
                                  }($3.picture)
                                ),
                                _Utils_Tuple2(
                                  "title",
                                  $elm$json$Json$Encode$string($3.title)
                                ),
                                _Utils_Tuple2(
                                  "year",
                                  function($4) {
                                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$int, $4);
                                  }($3.year)
                                )
                              ]
                            )
                          );
                        },
                        $2
                      );
                    }
                  )($.receivedTags)
                ),
                _Utils_Tuple2(
                  "sourceId",
                  $elm$json$Json$Encode$string($.sourceId)
                ),
                _Utils_Tuple2(
                  "urlsForTags",
                  $elm$json$Json$Encode$list(
                    function($2) {
                      return $elm$json$Json$Encode$object(
                        _List_fromArray(
                          [
                            _Utils_Tuple2(
                              "getUrl",
                              $elm$json$Json$Encode$string($2.getUrl)
                            ),
                            _Utils_Tuple2(
                              "headUrl",
                              $elm$json$Json$Encode$string($2.headUrl)
                            )
                          ]
                        )
                      );
                    }
                  )($.urlsForTags)
                )
              ]
            )
          );
        }
      );
      var $author$project$Brain$Sources$Processing$Steps$getTags = $author$project$Brain$Ports$requestTags;
      var $author$project$Brain$Sources$Processing$Steps$makeTrackUrls = F3(
        function(currentTime, source, filePaths) {
          var maker = $author$project$Sources$Services$makeTrackUrl(source.service);
          var mapFn = function(path) {
            return {
              getUrl: A5(maker, currentTime, source.id, source.data, $author$project$Sources$Processing$Get, path),
              headUrl: A5(maker, currentTime, source.id, source.data, $author$project$Sources$Processing$Head, path)
            };
          };
          return A2($elm$core$List$map, mapFn, filePaths);
        }
      );
      var $author$project$Brain$Sources$Processing$Steps$tagsBatchSize = 20;
      var $author$project$Brain$Sources$Processing$Steps$takeTagsStep = F3(
        function(currentTime, tagsCtx, source) {
          var _v0 = A2($elm_community$list_extra$List$Extra$splitAt, $author$project$Brain$Sources$Processing$Steps$tagsBatchSize, tagsCtx.nextFilePaths);
          var filesToProcess = _v0.a;
          var nextFiles = _v0.b;
          var newTagsCtx = {
            amount: tagsCtx.amount,
            nextFilePaths: nextFiles,
            receivedFilePaths: filesToProcess,
            receivedTags: _List_Nil,
            sourceId: source.id,
            urlsForTags: A3($author$project$Brain$Sources$Processing$Steps$makeTrackUrls, currentTime, source, filesToProcess)
          };
          return $elm$core$List$isEmpty(filesToProcess) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
            $author$project$Brain$Sources$Processing$Steps$getTags(newTagsCtx)
          );
        }
      );
      var $author$project$Tracks$emptyTags = { album: "Empty", artist: "Empty", disc: 1, genre: $elm$core$Maybe$Nothing, nr: 0, picture: $elm$core$Maybe$Nothing, title: "Empty", year: $elm$core$Maybe$Nothing };
      var $author$project$Tracks$makeTrack = F2(
        function(sourceId, _v0) {
          var path = _v0.a;
          var tags = _v0.b;
          return {
            id: A2(
              $author$project$String$Ext$chopEnd,
              "=",
              $truqu$elm_base64$Base64$encode(sourceId + ("//" + path))
            ),
            insertedAt: $author$project$Time$Ext$default,
            path,
            sourceId,
            tags
          };
        }
      );
      var $author$project$Brain$Sources$Processing$Common$tracksFromTagsContext = function(context) {
        return A2(
          $elm$core$List$map,
          $author$project$Tracks$makeTrack(context.sourceId),
          A2(
            $elm$core$List$map,
            $elm$core$Tuple$mapSecond(
              $elm$core$Maybe$withDefault($author$project$Tracks$emptyTags)
            ),
            A2(
              $elm$core$List$filter,
              A2($elm$core$Basics$composeR, $elm$core$Tuple$second, $elm_community$maybe_extra$Maybe$Extra$isJust),
              A2($elm_community$list_extra$List$Extra$zip, context.receivedFilePaths, context.receivedTags)
            )
          )
        );
      };
      var $author$project$Brain$Sources$Processing$State$tagsStep = F2(
        function(tagsContext, model) {
          var tracksToAdd = A2(
            $elm$core$List$map,
            function(track) {
              return _Utils_update(
                track,
                { insertedAt: model.currentTime }
              );
            },
            $author$project$Brain$Sources$Processing$Common$tracksFromTagsContext(tagsContext)
          );
          var maybeCmd = function() {
            var _v0 = model.processingStatus;
            if (_v0.$ === "Processing") {
              var _v1 = _v0.a;
              var source = _v1.a;
              return A3($author$project$Brain$Sources$Processing$Steps$takeTagsStep, model.currentTime, tagsContext, source);
            } else {
              return $elm$core$Maybe$Just($elm$core$Platform$Cmd$none);
            }
          }();
          var amountLeft = $elm$core$List$length(tagsContext.nextFilePaths);
          var progressPercentage = 0.05 + 0.95 * (1 - amountLeft / tagsContext.amount);
          var progress = _List_fromArray(
            [
              _Utils_Tuple2(
                "progress",
                $elm$json$Json$Encode$float(progressPercentage)
              ),
              _Utils_Tuple2(
                "sourceId",
                $elm$json$Json$Encode$string(tagsContext.sourceId)
              )
            ]
          );
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            A2(
              $author$project$Brain$Common$State$giveUI,
              $author$project$Alien$ReportProcessingProgress,
              $elm$json$Json$Encode$object(progress)
            ),
            A2(
              $Fresheyeball$elm_return$Return$andThen,
              $author$project$Brain$Tracks$State$add(tracksToAdd),
              A2(
                $elm$core$Maybe$withDefault,
                $author$project$Brain$Sources$Processing$State$nextInLine(model),
                A2(
                  $elm$core$Maybe$map,
                  $Fresheyeball$elm_return$Return$return(model),
                  maybeCmd
                )
              )
            )
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$listImpl = F3(
        function(_v0, acc, _v1) {
          listImpl:
            while (true) {
              var decoder = _v0.a;
              var nodes = _v1.a;
              var ancestor = _v1.b;
              if (!nodes.b) {
                return $elm$core$Result$Ok(
                  $elm$core$List$reverse(acc)
                );
              } else {
                var n = nodes.a;
                var ns = nodes.b;
                var _v3 = decoder(n);
                if (_v3.$ === "Ok") {
                  var item = _v3.a;
                  var $temp$_v0 = $ymtszw$elm_xml_decode$Xml$Decode$Decoder(decoder), $temp$acc = A2($elm$core$List$cons, item, acc), $temp$_v1 = _Utils_Tuple2(ns, ancestor);
                  _v0 = $temp$_v0;
                  acc = $temp$acc;
                  _v1 = $temp$_v1;
                  continue listImpl;
                } else {
                  var e = _v3.a;
                  return $elm$core$Result$Err(e);
                }
              }
            }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$list = function(decoder) {
        return $ymtszw$elm_xml_decode$Xml$Decode$ListDecoder(
          A2($ymtszw$elm_xml_decode$Xml$Decode$listImpl, decoder, _List_Nil)
        );
      };
      var $author$project$Sources$Services$AmazonS3$Parser$filePathsDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$path,
        _List_fromArray(
          ["Contents"]
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$list(
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              ["Key"]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        )
      );
      var $elm$core$Result$map2 = F3(
        function(func, ra, rb) {
          if (ra.$ === "Err") {
            var x = ra.a;
            return $elm$core$Result$Err(x);
          } else {
            var a = ra.a;
            if (rb.$ === "Err") {
              var x = rb.a;
              return $elm$core$Result$Err(x);
            } else {
              var b = rb.a;
              return $elm$core$Result$Ok(
                A2(func, a, b)
              );
            }
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$map2Impl = F4(
        function(valueGen, _v0, _v1, aNode) {
          var decoderA = _v0.a;
          var decoderB = _v1.a;
          return A3(
            $elm$core$Result$map2,
            valueGen,
            decoderA(aNode),
            decoderB(aNode)
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$map2 = F3(
        function(valueGen, decoderA, decoderB) {
          return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
            A3($ymtszw$elm_xml_decode$Xml$Decode$map2Impl, valueGen, decoderA, decoderB)
          );
        }
      );
      var $author$project$Sources$Processing$InProgress = function(a) {
        return { $: "InProgress", a };
      };
      var $elm$core$Maybe$map2 = F3(
        function(func, ma, mb) {
          if (ma.$ === "Nothing") {
            return $elm$core$Maybe$Nothing;
          } else {
            var a = ma.a;
            if (mb.$ === "Nothing") {
              return $elm$core$Maybe$Nothing;
            } else {
              var b = mb.a;
              return $elm$core$Maybe$Just(
                A2(func, a, b)
              );
            }
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$mapImpl = F3(
        function(valueGen, _v0, aNode) {
          var decoder = _v0.a;
          return A2(
            $elm$core$Result$map,
            valueGen,
            decoder(aNode)
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$map = F2(
        function(valueGen, decoder) {
          return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
            A2($ymtszw$elm_xml_decode$Xml$Decode$mapImpl, valueGen, decoder)
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$OneOf = function(a) {
        return { $: "OneOf", a };
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$oneOfImpl = F3(
        function(decoders, errors, aNode) {
          oneOfImpl:
            while (true) {
              if (!decoders.b) {
                return $elm$core$Result$Err(
                  $ymtszw$elm_xml_decode$Xml$Decode$OneOf(
                    $elm$core$List$reverse(errors)
                  )
                );
              } else {
                var d = decoders.a.a;
                var ds = decoders.b;
                var _v1 = d(aNode);
                if (_v1.$ === "Ok") {
                  var val = _v1.a;
                  return $elm$core$Result$Ok(val);
                } else {
                  var e = _v1.a;
                  var $temp$decoders = ds, $temp$errors = A2($elm$core$List$cons, e, errors), $temp$aNode = aNode;
                  decoders = $temp$decoders;
                  errors = $temp$errors;
                  aNode = $temp$aNode;
                  continue oneOfImpl;
                }
              }
            }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$oneOf = function(decoders) {
        return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
          A2($ymtszw$elm_xml_decode$Xml$Decode$oneOfImpl, decoders, _List_Nil)
        );
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$succeed = function(a) {
        return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
          function(_v0) {
            return $elm$core$Result$Ok(a);
          }
        );
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$maybe = function(decoder) {
        return $ymtszw$elm_xml_decode$Xml$Decode$oneOf(
          _List_fromArray(
            [
              A2($ymtszw$elm_xml_decode$Xml$Decode$map, $elm$core$Maybe$Just, decoder),
              $ymtszw$elm_xml_decode$Xml$Decode$succeed($elm$core$Maybe$Nothing)
            ]
          )
        );
      };
      var $author$project$Sources$Services$AmazonS3$Parser$markerDecoder = A3(
        $ymtszw$elm_xml_decode$Xml$Decode$map2,
        F2(
          function(a, b) {
            return A2(
              $elm$core$Maybe$withDefault,
              $author$project$Sources$Processing$TheEnd,
              A3(
                $elm$core$Maybe$map2,
                F2(
                  function(isTruncated, token) {
                    return A3(
                      $author$project$Conditional$ifThenElse,
                      isTruncated === "true",
                      $author$project$Sources$Processing$InProgress(token),
                      $author$project$Sources$Processing$TheEnd
                    );
                  }
                ),
                a,
                b
              )
            );
          }
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$maybe(
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              ["IsTruncated"]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$maybe(
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              ["NextContinuationToken"]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        )
      );
      var $author$project$Sources$Services$AmazonS3$Parser$parseTreeResponse = F2(
        function(response, _v0) {
          return A2(
            $elm$core$Result$withDefault,
            { filePaths: _List_Nil, marker: $author$project$Sources$Processing$TheEnd },
            A2(
              $ymtszw$elm_xml_decode$Xml$Decode$decodeString,
              A3(
                $ymtszw$elm_xml_decode$Xml$Decode$map2,
                F2(
                  function(f, m) {
                    return { filePaths: f, marker: m };
                  }
                ),
                $author$project$Sources$Services$AmazonS3$Parser$filePathsDecoder,
                $author$project$Sources$Services$AmazonS3$Parser$markerDecoder
              ),
              response
            )
          );
        }
      );
      var $author$project$Sources$Services$AmazonS3$parseTreeResponse = $author$project$Sources$Services$AmazonS3$Parser$parseTreeResponse;
      var $author$project$Sources$Services$Azure$BlobParser$filePathsDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$path,
        _List_fromArray(
          ["Blobs", "Blob"]
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$list(
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              ["Name"]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        )
      );
      var $author$project$Sources$Services$Azure$BlobParser$markerDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$map,
        function(maybeNextMarker) {
          if (maybeNextMarker.$ === "Just") {
            if (maybeNextMarker.a === "") {
              return $author$project$Sources$Processing$TheEnd;
            } else {
              var nextMarker = maybeNextMarker.a;
              return $author$project$Sources$Processing$InProgress(nextMarker);
            }
          } else {
            return $author$project$Sources$Processing$TheEnd;
          }
        },
        $ymtszw$elm_xml_decode$Xml$Decode$maybe(
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              ["NextMarker"]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        )
      );
      var $author$project$Sources$Services$Azure$BlobParser$parseTreeResponse = F2(
        function(response, _v0) {
          return A2(
            $elm$core$Result$withDefault,
            { filePaths: _List_Nil, marker: $author$project$Sources$Processing$TheEnd },
            A2(
              $ymtszw$elm_xml_decode$Xml$Decode$decodeString,
              A3(
                $ymtszw$elm_xml_decode$Xml$Decode$map2,
                F2(
                  function(f, m) {
                    return { filePaths: f, marker: m };
                  }
                ),
                $author$project$Sources$Services$Azure$BlobParser$filePathsDecoder,
                $author$project$Sources$Services$Azure$BlobParser$markerDecoder
              ),
              response
            )
          );
        }
      );
      var $author$project$Sources$Services$AzureBlob$parseTreeResponse = $author$project$Sources$Services$Azure$BlobParser$parseTreeResponse;
      var $ymtszw$elm_xml_decode$Xml$Decode$andThenImpl = F3(
        function(decoderBGen, _v0, aNode) {
          var decoderA = _v0.a;
          var _v1 = decoderA(aNode);
          if (_v1.$ === "Ok") {
            var valA = _v1.a;
            var _v2 = decoderBGen(valA);
            var decoderB = _v2.a;
            return decoderB(aNode);
          } else {
            var e = _v1.a;
            return $elm$core$Result$Err(e);
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$andThen = F2(
        function(decoderBGen, decoderA) {
          return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
            A2($ymtszw$elm_xml_decode$Xml$Decode$andThenImpl, decoderBGen, decoderA)
          );
        }
      );
      var $author$project$Sources$Services$Azure$FileMarker$itemToString = function(item) {
        if (item.$ === "Directory") {
          var d = item.a;
          return "dir" + ($author$project$Sources$Services$Azure$FileMarker$prefixer + d);
        } else {
          var directory = item.a.directory;
          var marker = item.a.marker;
          return "par" + ($author$project$Sources$Services$Azure$FileMarker$prefixer + (directory + ($author$project$Sources$Services$Azure$FileMarker$paramSeparator + marker)));
        }
      };
      var $author$project$Sources$Services$Azure$FileMarker$concat = F2(
        function(list, marker) {
          var listStringified = A2($elm$core$List$map, $author$project$Sources$Services$Azure$FileMarker$itemToString, list);
          var result = function() {
            if (marker.$ === "InProgress") {
              var m = marker.a;
              return A2(
                $elm$core$String$join,
                $author$project$Sources$Services$Azure$FileMarker$separator,
                $elm$core$List$concat(
                  _List_fromArray(
                    [
                      listStringified,
                      A2($elm$core$String$split, $author$project$Sources$Services$Azure$FileMarker$separator, m)
                    ]
                  )
                )
              );
            } else {
              return A2($elm$core$String$join, $author$project$Sources$Services$Azure$FileMarker$separator, listStringified);
            }
          }();
          if (result === "") {
            return $author$project$Sources$Processing$TheEnd;
          } else {
            var r = result;
            return $author$project$Sources$Processing$InProgress(r);
          }
        }
      );
      var $author$project$Sources$Services$Azure$FileParser$directoryPathsDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$path,
        _List_fromArray(
          ["Entries", "Directory"]
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$list(
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              ["Name"]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        )
      );
      var $author$project$Sources$Services$Azure$FileParser$filePathsDecoder = A2(
        $ymtszw$elm_xml_decode$Xml$Decode$path,
        _List_fromArray(
          ["Entries", "File"]
        ),
        $ymtszw$elm_xml_decode$Xml$Decode$list(
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              ["Name"]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        )
      );
      var $author$project$Sources$Services$Azure$FileParser$markerDecoder = F2(
        function(usedDirectory, markerWithDirectories) {
          return A2(
            $ymtszw$elm_xml_decode$Xml$Decode$map,
            function(maybeNextMarker) {
              if (maybeNextMarker.$ === "Just") {
                if (maybeNextMarker.a === "") {
                  return markerWithDirectories;
                } else {
                  var marker = maybeNextMarker.a;
                  return A2(
                    $author$project$Sources$Services$Azure$FileMarker$concat,
                    _List_fromArray(
                      [
                        $author$project$Sources$Services$Azure$FileMarker$Param(
                          { directory: usedDirectory, marker }
                        )
                      ]
                    ),
                    markerWithDirectories
                  );
                }
              } else {
                return markerWithDirectories;
              }
            },
            $ymtszw$elm_xml_decode$Xml$Decode$maybe(
              A2(
                $ymtszw$elm_xml_decode$Xml$Decode$path,
                _List_fromArray(
                  ["NextMarker"]
                ),
                $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
              )
            )
          );
        }
      );
      var $author$project$Sources$Services$Azure$FileMarker$removeOne = function(marker) {
        if (marker.$ === "InProgress") {
          var m = marker.a;
          var tmp = A2(
            $elm$core$String$join,
            $author$project$Sources$Services$Azure$FileMarker$separator,
            A2(
              $elm$core$List$drop,
              1,
              A2($elm$core$String$split, $author$project$Sources$Services$Azure$FileMarker$separator, m)
            )
          );
          if (tmp === "") {
            return $author$project$Sources$Processing$TheEnd;
          } else {
            var x = tmp;
            return $author$project$Sources$Processing$InProgress(x);
          }
        } else {
          return $author$project$Sources$Processing$TheEnd;
        }
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$fetchAttributeValue = F2(
        function(name_, attrs) {
          fetchAttributeValue:
            while (true) {
              if (!attrs.b) {
                return $elm$core$Maybe$Nothing;
              } else {
                var name = attrs.a.name;
                var value = attrs.a.value;
                var tl = attrs.b;
                if (_Utils_eq(name, name_)) {
                  return $elm$core$Maybe$Just(value);
                } else {
                  var $temp$name_ = name_, $temp$attrs = tl;
                  name_ = $temp$name_;
                  attrs = $temp$attrs;
                  continue fetchAttributeValue;
                }
              }
            }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$cdataAttrImpl = F3(
        function(name_, generator, aNode) {
          var notFound = A2($ymtszw$elm_xml_decode$Xml$Decode$Failure, "Attribute '" + (name_ + "' not found."), aNode);
          var gen = A2(
            $elm$core$Basics$composeR,
            generator,
            $elm$core$Result$mapError(
              function(message) {
                return A2($ymtszw$elm_xml_decode$Xml$Decode$Failure, message, aNode);
              }
            )
          );
          if (aNode.$ === "Text") {
            return $elm$core$Result$Err(notFound);
          } else {
            var attrs = aNode.b;
            return A2(
              $elm$core$Result$andThen,
              gen,
              A2(
                $elm$core$Result$fromMaybe,
                notFound,
                A2($ymtszw$elm_xml_decode$Xml$Decode$fetchAttributeValue, name_, attrs)
              )
            );
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$cdataAttr = F2(
        function(name_, generator) {
          return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
            A2($ymtszw$elm_xml_decode$Xml$Decode$cdataAttrImpl, name_, generator)
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$stringAttr = function(name_) {
        return A2($ymtszw$elm_xml_decode$Xml$Decode$cdataAttr, name_, $elm$core$Result$Ok);
      };
      var $author$project$Sources$Services$Azure$FileParser$usedDirectoryDecoder = $ymtszw$elm_xml_decode$Xml$Decode$stringAttr("DirectoryPath");
      var $author$project$Sources$Services$Azure$FileParser$treeDecoder = function(previousMarker) {
        return A2(
          $ymtszw$elm_xml_decode$Xml$Decode$andThen,
          function(_v0) {
            var usedDirectory = _v0.a;
            var filePaths = _v0.b;
            var directoryPaths = _v0.c;
            return A2(
              $ymtszw$elm_xml_decode$Xml$Decode$map,
              function(marker) {
                return { filePaths, marker };
              },
              A2(
                $author$project$Sources$Services$Azure$FileParser$markerDecoder,
                usedDirectory,
                A2(
                  $author$project$Sources$Services$Azure$FileMarker$concat,
                  A2($elm$core$List$map, $author$project$Sources$Services$Azure$FileMarker$Directory, directoryPaths),
                  $author$project$Sources$Services$Azure$FileMarker$removeOne(previousMarker)
                )
              )
            );
          },
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$andThen,
            function(usedDirectory) {
              return A3(
                $ymtszw$elm_xml_decode$Xml$Decode$map2,
                F2(
                  function(a, b) {
                    return _Utils_Tuple3(usedDirectory, a, b);
                  }
                ),
                A2(
                  $ymtszw$elm_xml_decode$Xml$Decode$map,
                  $elm$core$List$map(
                    $elm$core$String$append(usedDirectory)
                  ),
                  $author$project$Sources$Services$Azure$FileParser$filePathsDecoder
                ),
                A2(
                  $ymtszw$elm_xml_decode$Xml$Decode$map,
                  $elm$core$List$map(
                    $elm$core$String$append(usedDirectory)
                  ),
                  $author$project$Sources$Services$Azure$FileParser$directoryPathsDecoder
                )
              );
            },
            A2($ymtszw$elm_xml_decode$Xml$Decode$map, $author$project$Sources$Services$Common$cleanPath, $author$project$Sources$Services$Azure$FileParser$usedDirectoryDecoder)
          )
        );
      };
      var $author$project$Sources$Services$Azure$FileParser$parseTreeResponse = F2(
        function(response, previousMarker) {
          return A2(
            $elm$core$Result$withDefault,
            { filePaths: _List_Nil, marker: $author$project$Sources$Processing$TheEnd },
            A2(
              $ymtszw$elm_xml_decode$Xml$Decode$decodeString,
              $author$project$Sources$Services$Azure$FileParser$treeDecoder(previousMarker),
              response
            )
          );
        }
      );
      var $author$project$Sources$Services$AzureFile$parseTreeResponse = $author$project$Sources$Services$Azure$FileParser$parseTreeResponse;
      var $author$project$Sources$Services$Ipfs$Marker$concat = F2(
        function(list, marker) {
          var result = function() {
            if (marker.$ === "InProgress") {
              var m = marker.a;
              return A2(
                $elm$core$String$join,
                $author$project$Sources$Services$Ipfs$Marker$separator,
                $elm$core$List$concat(
                  _List_fromArray(
                    [
                      list,
                      A2($elm$core$String$split, $author$project$Sources$Services$Ipfs$Marker$separator, m)
                    ]
                  )
                )
              );
            } else {
              return A2($elm$core$String$join, $author$project$Sources$Services$Ipfs$Marker$separator, list);
            }
          }();
          if (result === "") {
            return $author$project$Sources$Processing$TheEnd;
          } else {
            var r = result;
            return $author$project$Sources$Processing$InProgress(r);
          }
        }
      );
      var $elm$regex$Regex$contains = _Regex_contains;
      var $author$project$Sources$Pick$musicFileRegex = A2(
        $elm$core$Maybe$withDefault,
        $elm$regex$Regex$never,
        A2(
          $elm$regex$Regex$fromStringWith,
          { caseInsensitive: true, multiline: false },
          "\\.(mp3|mp4|m4a|flac|ogg|wav|webm|opus)$"
        )
      );
      var $author$project$Sources$Pick$isMusicFile = $elm$regex$Regex$contains($author$project$Sources$Pick$musicFileRegex);
      var $elm$json$Json$Decode$index = _Json_decodeIndex;
      var $author$project$Sources$Services$Ipfs$Parser$prefixDecoder = A2(
        $elm$json$Json$Decode$field,
        "Objects",
        A2(
          $elm$json$Json$Decode$index,
          0,
          A2($elm$json$Json$Decode$field, "Hash", $elm$json$Json$Decode$string)
        )
      );
      var $author$project$Sources$Services$Ipfs$Marker$removeOne = function(marker) {
        if (marker.$ === "InProgress") {
          var m = marker.a;
          var tmp = A2(
            $elm$core$String$join,
            $author$project$Sources$Services$Ipfs$Marker$separator,
            A2(
              $elm$core$List$drop,
              1,
              A2($elm$core$String$split, $author$project$Sources$Services$Ipfs$Marker$separator, m)
            )
          );
          if (tmp === "") {
            return $author$project$Sources$Processing$TheEnd;
          } else {
            var x = tmp;
            return $author$project$Sources$Processing$InProgress(x);
          }
        } else {
          return $author$project$Sources$Processing$TheEnd;
        }
      };
      var $author$project$Sources$Services$Ipfs$Parser$Link = F3(
        function(hash, name, typ) {
          return { hash, name, typ };
        }
      );
      var $author$project$Sources$Services$Ipfs$Parser$linkDecoder = A4(
        $elm$json$Json$Decode$map3,
        $author$project$Sources$Services$Ipfs$Parser$Link,
        A2($elm$json$Json$Decode$field, "Hash", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "Name", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "Type", $elm$json$Json$Decode$int)
      );
      var $author$project$Sources$Services$Ipfs$Parser$treeDecoder = A2(
        $elm$json$Json$Decode$field,
        "Objects",
        A2(
          $elm$json$Json$Decode$index,
          0,
          A2(
            $elm$json$Json$Decode$field,
            "Links",
            $elm$json$Json$Decode$list($author$project$Sources$Services$Ipfs$Parser$linkDecoder)
          )
        )
      );
      var $author$project$Sources$Services$Ipfs$Parser$parseTreeResponse = F2(
        function(response, previousMarker) {
          var prefix = function() {
            if (previousMarker.$ === "TheBeginning") {
              return "";
            } else {
              return A2(
                $elm$core$Result$withDefault,
                "",
                A2(
                  $elm$core$Result$map,
                  function(s) {
                    return $elm$core$String$isEmpty(s) ? "" : s + "/";
                  },
                  A2(
                    $elm$core$Result$map,
                    A2(
                      $elm$core$Basics$composeR,
                      $author$project$String$Ext$chopStart("/ipfs/"),
                      A2(
                        $elm$core$Basics$composeR,
                        $elm$core$String$split("/"),
                        A2(
                          $elm$core$Basics$composeR,
                          $elm$core$List$drop(1),
                          $elm$core$String$join("/")
                        )
                      )
                    ),
                    A2($elm$json$Json$Decode$decodeString, $author$project$Sources$Services$Ipfs$Parser$prefixDecoder, response)
                  )
                )
              );
            }
          }();
          var links = function() {
            var _v0 = A2($elm$json$Json$Decode$decodeString, $author$project$Sources$Services$Ipfs$Parser$treeDecoder, response);
            if (_v0.$ === "Ok") {
              var l = _v0.a;
              return l;
            } else {
              return _List_Nil;
            }
          }();
          var files = A2(
            $elm$core$List$map,
            function(l) {
              return _Utils_ap(prefix, l.name);
            },
            A2(
              $elm$core$List$filter,
              A2(
                $elm$core$Basics$composeR,
                function($) {
                  return $.name;
                },
                $author$project$Sources$Pick$isMusicFile
              ),
              A2(
                $elm$core$List$filter,
                A2(
                  $elm$core$Basics$composeR,
                  function($) {
                    return $.typ;
                  },
                  $elm$core$Basics$eq(2)
                ),
                links
              )
            )
          );
          var dirs = A2(
            $elm$core$List$map,
            function(l) {
              return _Utils_ap(prefix, l.name);
            },
            A2(
              $elm$core$List$filter,
              A2(
                $elm$core$Basics$composeR,
                function($) {
                  return $.typ;
                },
                $elm$core$Basics$eq(1)
              ),
              links
            )
          );
          return {
            filePaths: files,
            marker: A2(
              $author$project$Sources$Services$Ipfs$Marker$concat,
              dirs,
              $author$project$Sources$Services$Ipfs$Marker$removeOne(previousMarker)
            )
          };
        }
      );
      var $author$project$Sources$Services$Ipfs$parseTreeResponse = $author$project$Sources$Services$Ipfs$Parser$parseTreeResponse;
      var $author$project$Sources$Services$Btfs$parseTreeResponse = $author$project$Sources$Services$Ipfs$parseTreeResponse;
      var $author$project$Sources$Services$Dropbox$Parser$parseTreeResponse = F2(
        function(response, _v0) {
          var paths = A2(
            $elm$json$Json$Decode$decodeString,
            A2(
              $elm$json$Json$Decode$field,
              "entries",
              $elm$json$Json$Decode$list(
                A2($elm$json$Json$Decode$field, "path_display", $elm$json$Json$Decode$string)
              )
            ),
            response
          );
          var hasMore = A2(
            $elm$json$Json$Decode$decodeString,
            A2($elm$json$Json$Decode$field, "has_more", $elm$json$Json$Decode$bool),
            response
          );
          var cursor = A2(
            $elm$json$Json$Decode$decodeString,
            A2($elm$json$Json$Decode$field, "cursor", $elm$json$Json$Decode$string),
            response
          );
          return {
            filePaths: A2($elm$core$Result$withDefault, _List_Nil, paths),
            marker: A2($elm$core$Result$withDefault, false, hasMore) ? $author$project$Sources$Processing$InProgress(
              A2($elm$core$Result$withDefault, "", cursor)
            ) : $author$project$Sources$Processing$TheEnd
          };
        }
      );
      var $author$project$Sources$Services$Dropbox$parseTreeResponse = $author$project$Sources$Services$Dropbox$Parser$parseTreeResponse;
      var $author$project$String$Path$addSuffix = function(path) {
        if (path === "") {
          return "";
        } else {
          var p = path;
          return _Utils_ap(p, $author$project$String$Path$sep);
        }
      };
      var $author$project$Sources$Services$Google$Marker$itemToString = function(item) {
        if (item.$ === "Directory") {
          var d = item.a;
          return "dir" + ($author$project$Sources$Services$Google$Marker$prefixer + d);
        } else {
          var directory = item.a.directory;
          var token = item.a.token;
          return "par" + ($author$project$Sources$Services$Google$Marker$prefixer + (directory + ($author$project$Sources$Services$Google$Marker$paramSeparator + token)));
        }
      };
      var $author$project$Sources$Services$Google$Marker$concat = F2(
        function(list, marker) {
          var listStringified = A2($elm$core$List$map, $author$project$Sources$Services$Google$Marker$itemToString, list);
          var result = function() {
            if (marker.$ === "InProgress") {
              var m = marker.a;
              return A2(
                $elm$core$String$join,
                $author$project$Sources$Services$Google$Marker$separator,
                $elm$core$List$concat(
                  _List_fromArray(
                    [
                      listStringified,
                      A2($elm$core$String$split, $author$project$Sources$Services$Google$Marker$separator, m)
                    ]
                  )
                )
              );
            } else {
              return A2($elm$core$String$join, $author$project$Sources$Services$Google$Marker$separator, listStringified);
            }
          }();
          if (result === "") {
            return $author$project$Sources$Processing$TheEnd;
          } else {
            var r = result;
            return $author$project$Sources$Processing$InProgress(r);
          }
        }
      );
      var $author$project$String$Path$dropRight = F2(
        function(_int, path) {
          return A2(
            $elm$core$String$join,
            $author$project$String$Path$sep,
            function(l) {
              return A2(
                $elm$core$List$take,
                $elm$core$List$length(l) - _int,
                l
              );
            }(
              A2($elm$core$String$split, $author$project$String$Path$sep, path)
            )
          );
        }
      );
      var $author$project$Sources$Services$Google$Parser$Directory = function(a) {
        return { $: "Directory", a };
      };
      var $author$project$Sources$Services$Google$Parser$File = function(a) {
        return { $: "File", a };
      };
      var $author$project$Sources$Services$Google$Parser$itemDecoder = A5(
        $elm$json$Json$Decode$map4,
        F4(
          function(id, name, mime, _v0) {
            if (mime === "application/vnd.google-apps.folder") {
              return $author$project$Sources$Services$Google$Parser$Directory(
                { id, name }
              );
            } else {
              return $author$project$Sources$Services$Google$Parser$File(
                { id, name }
              );
            }
          }
        ),
        A2($elm$json$Json$Decode$field, "id", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "name", $elm$json$Json$Decode$string),
        A2($elm$json$Json$Decode$field, "mimeType", $elm$json$Json$Decode$string),
        A2(
          $elm$json$Json$Decode$andThen,
          function(b) {
            return b ? $elm$json$Json$Decode$fail("Exclude deleted files") : $elm$json$Json$Decode$succeed(b);
          },
          A2($elm$json$Json$Decode$field, "trashed", $elm$json$Json$Decode$bool)
        )
      );
      var $author$project$Sources$Services$Google$Parser$itemProperties = function(item) {
        if (item.$ === "Directory") {
          var props = item.a;
          return props;
        } else {
          var props = item.a;
          return props;
        }
      };
      var $author$project$Sources$Services$Google$Marker$removeOne = function(marker) {
        if (marker.$ === "InProgress") {
          var m = marker.a;
          var tmp = A2(
            $elm$core$String$join,
            $author$project$Sources$Services$Google$Marker$separator,
            A2(
              $elm$core$List$drop,
              1,
              A2($elm$core$String$split, $author$project$Sources$Services$Google$Marker$separator, m)
            )
          );
          if (tmp === "") {
            return $author$project$Sources$Processing$TheEnd;
          } else {
            var x = tmp;
            return $author$project$Sources$Processing$InProgress(x);
          }
        } else {
          return $author$project$Sources$Processing$TheEnd;
        }
      };
      var $elm$core$List$singleton = function(value) {
        return _List_fromArray(
          [value]
        );
      };
      var $author$project$Sources$Services$Google$Parser$parseTreeResponse = F2(
        function(response, previousMarker) {
          var usedDirectory = A2(
            $elm$core$Maybe$withDefault,
            "",
            A2(
              $elm$core$Maybe$map,
              $author$project$Sources$Services$Google$Marker$itemDirectory,
              $author$project$Sources$Services$Google$Marker$takeOne(previousMarker)
            )
          );
          var usedPath = $author$project$String$Path$addSuffix(
            A2($author$project$String$Path$dropRight, 1, usedDirectory)
          );
          var nextPageToken = $elm_community$maybe_extra$Maybe$Extra$join(
            $elm$core$Result$toMaybe(
              A2(
                $elm$json$Json$Decode$decodeString,
                $elm$json$Json$Decode$maybe(
                  A2($elm$json$Json$Decode$field, "nextPageToken", $elm$json$Json$Decode$string)
                ),
                response
              )
            )
          );
          var items = A2(
            $elm$core$Result$withDefault,
            _List_Nil,
            A2(
              $elm$json$Json$Decode$decodeString,
              A2(
                $elm$json$Json$Decode$field,
                "files",
                $author$project$Json$Decode$Ext$listIgnore($author$project$Sources$Services$Google$Parser$itemDecoder)
              ),
              response
            )
          );
          var _v0 = A2(
            $elm$core$List$partition,
            function(item) {
              if (item.$ === "Directory") {
                return true;
              } else {
                return false;
              }
            },
            items
          );
          var directories = _v0.a;
          var files = _v0.b;
          return {
            filePaths: A2(
              $elm$core$List$map,
              function(_v2) {
                var id = _v2.id;
                var name = _v2.name;
                return usedPath + (id + ("?name=" + name));
              },
              A2(
                $elm$core$List$filter,
                A2(
                  $elm$core$Basics$composeR,
                  function($) {
                    return $.name;
                  },
                  $author$project$Sources$Pick$isMusicFile
                ),
                A2($elm$core$List$map, $author$project$Sources$Services$Google$Parser$itemProperties, files)
              )
            ),
            marker: function() {
              if (nextPageToken.$ === "Just") {
                var token = nextPageToken.a;
                return $author$project$Sources$Services$Google$Marker$concat(
                  $elm$core$List$singleton(
                    $author$project$Sources$Services$Google$Marker$Param(
                      { directory: usedDirectory, token }
                    )
                  )
                );
              } else {
                return $elm$core$Basics$identity;
              }
            }()(
              A2(
                $author$project$Sources$Services$Google$Marker$concat,
                A2(
                  $elm$core$List$map,
                  A2(
                    $elm$core$Basics$composeR,
                    $author$project$Sources$Services$Google$Parser$itemProperties,
                    A2(
                      $elm$core$Basics$composeR,
                      function(props) {
                        return props.name + ("/" + props.id);
                      },
                      A2(
                        $elm$core$Basics$composeR,
                        $elm$core$String$append(usedPath),
                        $author$project$Sources$Services$Google$Marker$Directory
                      )
                    )
                  ),
                  directories
                ),
                $author$project$Sources$Services$Google$Marker$removeOne(previousMarker)
              )
            )
          };
        }
      );
      var $author$project$Sources$Services$Google$parseTreeResponse = $author$project$Sources$Services$Google$Parser$parseTreeResponse;
      var $ymtszw$elm_xml_decode$Xml$Decode$accumlateOk = F2(
        function(result, acc) {
          if (result.$ === "Err") {
            return acc;
          } else {
            var a = result.a;
            return A2(
              $elm$core$Result$map,
              $elm$core$List$cons(a),
              acc
            );
          }
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$leakyList = function(_v0) {
        var decoder = _v0.a;
        return $ymtszw$elm_xml_decode$Xml$Decode$ListDecoder(
          A2(
            $elm$core$Basics$composeR,
            $elm$core$Tuple$first,
            A2(
              $elm$core$List$foldr,
              A2($elm$core$Basics$composeR, decoder, $ymtszw$elm_xml_decode$Xml$Decode$accumlateOk),
              $elm$core$Result$Ok(_List_Nil)
            )
          )
        );
      };
      var $ymtszw$elm_xml_decode$Xml$Decode$failImpl = F2(
        function(message, aNode) {
          return $elm$core$Result$Err(
            A2($ymtszw$elm_xml_decode$Xml$Decode$Failure, message, aNode)
          );
        }
      );
      var $ymtszw$elm_xml_decode$Xml$Decode$fail = function(message) {
        return $ymtszw$elm_xml_decode$Xml$Decode$Decoder(
          $ymtszw$elm_xml_decode$Xml$Decode$failImpl(message)
        );
      };
      var $author$project$Sources$Services$WebDav$Parser$mustBeAudio = function(contentType) {
        return A2($elm$core$String$startsWith, "audio/", contentType) ? $ymtszw$elm_xml_decode$Xml$Decode$succeed(contentType) : $ymtszw$elm_xml_decode$Xml$Decode$fail("Ignore this, not an audio file");
      };
      var $author$project$Sources$Services$WebDav$Parser$treeItemDecoder = function(namespace) {
        var withNamespace = $elm$core$String$append(namespace);
        return A3(
          $ymtszw$elm_xml_decode$Xml$Decode$map2,
          F2(
            function(_v0, h) {
              return h;
            }
          ),
          $ymtszw$elm_xml_decode$Xml$Decode$oneOf(
            _List_fromArray(
              [
                A2(
                  $ymtszw$elm_xml_decode$Xml$Decode$andThen,
                  $author$project$Sources$Services$WebDav$Parser$mustBeAudio,
                  A2(
                    $ymtszw$elm_xml_decode$Xml$Decode$path,
                    _List_fromArray(
                      [
                        withNamespace("propstat"),
                        withNamespace("prop"),
                        withNamespace("getcontenttype")
                      ]
                    ),
                    $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
                  )
                ),
                A2(
                  $ymtszw$elm_xml_decode$Xml$Decode$path,
                  _List_fromArray(
                    [
                      withNamespace("propstat"),
                      withNamespace("prop"),
                      withNamespace("resourcetype"),
                      withNamespace("collection")
                    ]
                  ),
                  $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
                )
              ]
            )
          ),
          A2(
            $ymtszw$elm_xml_decode$Xml$Decode$path,
            _List_fromArray(
              [
                withNamespace("href")
              ]
            ),
            $ymtszw$elm_xml_decode$Xml$Decode$single($ymtszw$elm_xml_decode$Xml$Decode$string)
          )
        );
      };
      var $author$project$Sources$Services$WebDav$Parser$treeDecoder = function(namespace) {
        return A2(
          $ymtszw$elm_xml_decode$Xml$Decode$path,
          _List_fromArray(
            [namespace + "response"]
          ),
          $ymtszw$elm_xml_decode$Xml$Decode$leakyList(
            $author$project$Sources$Services$WebDav$Parser$treeItemDecoder(namespace)
          )
        );
      };
      var $author$project$Sources$Services$WebDav$Parser$parseTreeResponse = F2(
        function(response, previousMarker) {
          var parseResult = $jinjor$elm_xml_parser$XmlParser$parse(response);
          var namespace = function(maybe) {
            if (maybe.$ === "Just") {
              var n = maybe.a;
              return n + ":";
            } else {
              return A2($elm$core$String$contains, "<d:", response) ? "d:" : "D:";
            }
          }(
            A2(
              $elm$core$Result$withDefault,
              $elm$core$Maybe$Nothing,
              A2(
                $elm$core$Result$map,
                function(xml) {
                  var _v1 = xml.root;
                  if (_v1.$ === "Element") {
                    var nodeName = _v1.a;
                    return $elm$core$List$head(
                      A2($elm$core$String$split, ":", nodeName)
                    );
                  } else {
                    return $elm$core$Maybe$Nothing;
                  }
                },
                parseResult
              )
            )
          );
          var currentDir = A2(
            $elm$core$Maybe$withDefault,
            "//",
            $author$project$Sources$Services$Ipfs$Marker$takeOne(previousMarker)
          );
          var entries = A2(
            $elm$core$List$filter,
            $elm$core$Basics$neq(currentDir),
            $elm_community$maybe_extra$Maybe$Extra$values(
              A2(
                $elm$core$List$map,
                $elm$url$Url$percentDecode,
                A2(
                  $elm$core$Result$withDefault,
                  _List_Nil,
                  A2(
                    $ymtszw$elm_xml_decode$Xml$Decode$decodeString,
                    $author$project$Sources$Services$WebDav$Parser$treeDecoder(namespace),
                    response
                  )
                )
              )
            )
          );
          var _v0 = A2(
            $elm$core$List$partition,
            $elm$core$String$endsWith("/"),
            entries
          );
          var dirs = _v0.a;
          var files = _v0.b;
          return {
            filePaths: A2(
              $elm$core$List$map,
              $author$project$String$Ext$chopStart("/"),
              files
            ),
            marker: A2(
              $author$project$Sources$Services$Ipfs$Marker$concat,
              dirs,
              $author$project$Sources$Services$Ipfs$Marker$removeOne(previousMarker)
            )
          };
        }
      );
      var $author$project$Sources$Services$WebDav$parseTreeResponse = $author$project$Sources$Services$WebDav$Parser$parseTreeResponse;
      var $author$project$Sources$Services$parseTreeResponse = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return $author$project$Sources$Services$AmazonS3$parseTreeResponse;
          case "AzureBlob":
            return $author$project$Sources$Services$AzureBlob$parseTreeResponse;
          case "AzureFile":
            return $author$project$Sources$Services$AzureFile$parseTreeResponse;
          case "Btfs":
            return $author$project$Sources$Services$Btfs$parseTreeResponse;
          case "Dropbox":
            return $author$project$Sources$Services$Dropbox$parseTreeResponse;
          case "Google":
            return $author$project$Sources$Services$Google$parseTreeResponse;
          case "Ipfs":
            return $author$project$Sources$Services$Ipfs$parseTreeResponse;
          default:
            return $author$project$Sources$Services$WebDav$parseTreeResponse;
        }
      };
      var $author$project$Brain$Sources$Processing$Steps$handleTreeResponse = F2(
        function(response, context) {
          var parsingFunc = $author$project$Sources$Services$parseTreeResponse(context.source.service);
          var parsedResponse = A2(parsingFunc, response, context.treeMarker);
          return _Utils_update(
            context,
            {
              filePaths: _Utils_ap(context.filePaths, parsedResponse.filePaths),
              treeMarker: parsedResponse.marker
            }
          );
        }
      );
      var $author$project$Brain$Sources$Processing$Types$TreeStepRemoveTracks = F2(
        function(a, b) {
          return { $: "TreeStepRemoveTracks", a, b };
        }
      );
      var $author$project$Brain$Sources$Processing$Common$contextToTagsContext = function(context) {
        return {
          amount: $elm$core$List$length(context.filePaths),
          nextFilePaths: context.filePaths,
          receivedFilePaths: _List_Nil,
          receivedTags: _List_Nil,
          sourceId: context.source.id,
          urlsForTags: _List_Nil
        };
      };
      var $author$project$Task$Extra$do = function(msg) {
        return A2(
          $elm$core$Task$perform,
          $elm$core$Basics$identity,
          $elm$core$Task$succeed(msg)
        );
      };
      var $author$project$Sources$Pick$selectMusicFiles = $elm$core$List$filter($author$project$Sources$Pick$isMusicFile);
      var $author$project$Sources$Services$AmazonS3$postProcessTree = $author$project$Sources$Pick$selectMusicFiles;
      var $author$project$Sources$Services$AzureBlob$postProcessTree = $author$project$Sources$Pick$selectMusicFiles;
      var $author$project$Sources$Services$AzureFile$postProcessTree = $author$project$Sources$Pick$selectMusicFiles;
      var $author$project$Sources$Services$Ipfs$postProcessTree = $elm$core$Basics$identity;
      var $author$project$Sources$Services$Btfs$postProcessTree = $author$project$Sources$Services$Ipfs$postProcessTree;
      var $author$project$Sources$Services$Dropbox$postProcessTree = $author$project$Sources$Pick$selectMusicFiles;
      var $author$project$Sources$Services$Google$postProcessTree = $elm$core$Basics$identity;
      var $author$project$Sources$Services$WebDav$postProcessTree = $author$project$Sources$Pick$selectMusicFiles;
      var $author$project$Sources$Services$postProcessTree = function(service) {
        switch (service.$) {
          case "AmazonS3":
            return $author$project$Sources$Services$AmazonS3$postProcessTree;
          case "AzureBlob":
            return $author$project$Sources$Services$AzureBlob$postProcessTree;
          case "AzureFile":
            return $author$project$Sources$Services$AzureFile$postProcessTree;
          case "Btfs":
            return $author$project$Sources$Services$Btfs$postProcessTree;
          case "Dropbox":
            return $author$project$Sources$Services$Dropbox$postProcessTree;
          case "Google":
            return $author$project$Sources$Services$Google$postProcessTree;
          case "Ipfs":
            return $author$project$Sources$Services$Ipfs$postProcessTree;
          default:
            return $author$project$Sources$Services$WebDav$postProcessTree;
        }
      };
      var $elm$core$Dict$diff = F2(
        function(t1, t2) {
          return A3(
            $elm$core$Dict$foldl,
            F3(
              function(k, v, t) {
                return A2($elm$core$Dict$remove, k, t);
              }
            ),
            t1,
            t2
          );
        }
      );
      var $elm$core$Set$diff = F2(
        function(_v0, _v1) {
          var dict1 = _v0.a;
          var dict2 = _v1.a;
          return $elm$core$Set$Set_elm_builtin(
            A2($elm$core$Dict$diff, dict1, dict2)
          );
        }
      );
      var $elm$core$Set$fromList = function(list) {
        return A3($elm$core$List$foldl, $elm$core$Set$insert, $elm$core$Set$empty, list);
      };
      var $author$project$Brain$Sources$Processing$Steps$separate = F2(
        function(current, srcOfTruth) {
          var setSrcOfTruth = $elm$core$Set$fromList(srcOfTruth);
          var setCurrent = $elm$core$Set$fromList(current);
          return _Utils_Tuple2(
            $elm$core$Set$toList(
              A2($elm$core$Set$diff, setSrcOfTruth, setCurrent)
            ),
            $elm$core$Set$toList(
              A2($elm$core$Set$diff, setCurrent, setSrcOfTruth)
            )
          );
        }
      );
      var $author$project$Brain$Sources$Processing$Steps$intoTreeCommand = F3(
        function(associatedTracks, currentTime, context) {
          var _v0 = context.treeMarker;
          switch (_v0.$) {
            case "TheBeginning":
              return $elm$core$Platform$Cmd$none;
            case "InProgress":
              return A2($author$project$Brain$Sources$Processing$Steps$makeTree, context, currentTime);
            default:
              var pathsCurrent = A2(
                $elm$core$List$map,
                function($) {
                  return $.path;
                },
                associatedTracks
              );
              var filteredFiles = A2($author$project$Sources$Services$postProcessTree, context.source.service, context.filePaths);
              var postContext = _Utils_update(
                context,
                { filePaths: filteredFiles }
              );
              var pathsSourceOfTruth = postContext.filePaths;
              var _v1 = A2($author$project$Brain$Sources$Processing$Steps$separate, pathsCurrent, pathsSourceOfTruth);
              var pathsAdded = _v1.a;
              var pathsRemoved = _v1.b;
              return $elm$core$Platform$Cmd$batch(
                _List_fromArray(
                  [
                    $author$project$Task$Extra$do(
                      $author$project$Brain$Types$ProcessingMsg(
                        $author$project$Brain$Sources$Processing$Types$TagsStep(
                          $author$project$Brain$Sources$Processing$Common$contextToTagsContext(
                            function(ctx) {
                              return _Utils_update(
                                ctx,
                                { filePaths: pathsAdded }
                              );
                            }(postContext)
                          )
                        )
                      )
                    ),
                    !$elm$core$List$isEmpty(pathsRemoved) ? $author$project$Task$Extra$do(
                      $author$project$Brain$Types$ProcessingMsg(
                        A2($author$project$Brain$Sources$Processing$Types$TreeStepRemoveTracks, context.source.id, pathsRemoved)
                      )
                    ) : $elm$core$Platform$Cmd$none
                  ]
                )
              );
          }
        }
      );
      var $author$project$Brain$Sources$Processing$Steps$takeTreeStep = F4(
        function(context, response, associatedTracks, currentTime) {
          return A3(
            $author$project$Brain$Sources$Processing$Steps$intoTreeCommand,
            associatedTracks,
            currentTime,
            A2($author$project$Brain$Sources$Processing$Steps$handleTreeResponse, response, context)
          );
        }
      );
      var $author$project$Brain$Sources$Processing$State$treeStep = F3(
        function(context, result, model) {
          if (result.$ === "Ok") {
            var response = result.a;
            var _v1 = model.processingStatus;
            if (_v1.$ === "Processing") {
              var _v2 = _v1.a;
              var tracks = _v2.b;
              var rest = _v1.b;
              return A2(
                $Fresheyeball$elm_return$Return$return,
                _Utils_update(
                  model,
                  {
                    processingStatus: A2(
                      $author$project$Sources$Processing$Processing,
                      _Utils_Tuple2(context.source, tracks),
                      rest
                    )
                  }
                ),
                A4($author$project$Brain$Sources$Processing$Steps$takeTreeStep, context, response, tracks, model.currentTime)
              );
            } else {
              return $Fresheyeball$elm_return$Return$singleton(model);
            }
          } else {
            var err = result.a;
            return A2(
              $Fresheyeball$elm_return$Return$andThen,
              A2($author$project$Brain$Sources$Processing$Common$reportHttpError, context.source, err),
              $author$project$Brain$Sources$Processing$State$nextInLine(model)
            );
          }
        }
      );
      var $elm_community$list_extra$List$Extra$reverseAppend = F2(
        function(list1, list2) {
          return A3($elm$core$List$foldl, $elm$core$List$cons, list2, list1);
        }
      );
      var $elm_community$list_extra$List$Extra$removeHelp = F4(
        function(list, x, xs, previousElements) {
          removeHelp:
            while (true) {
              if (!xs.b) {
                return list;
              } else {
                var y = xs.a;
                var ys = xs.b;
                if (_Utils_eq(x, y)) {
                  return A2($elm_community$list_extra$List$Extra$reverseAppend, previousElements, ys);
                } else {
                  var $temp$list = list, $temp$x = x, $temp$xs = ys, $temp$previousElements = A2($elm$core$List$cons, y, previousElements);
                  list = $temp$list;
                  x = $temp$x;
                  xs = $temp$xs;
                  previousElements = $temp$previousElements;
                  continue removeHelp;
                }
              }
            }
        }
      );
      var $elm_community$list_extra$List$Extra$remove = F2(
        function(x, xs) {
          return A4($elm_community$list_extra$List$Extra$removeHelp, xs, x, xs, _List_Nil);
        }
      );
      var $author$project$Tracks$removeByPaths = F2(
        function(_v0, tracks) {
          var sourceId = _v0.sourceId;
          var paths = _v0.paths;
          return function(_v2) {
            var k = _v2.a;
            var r = _v2.b;
            return { kept: k, removed: r };
          }(
            A3(
              $elm$core$List$foldr,
              F2(
                function(t, _v1) {
                  var kept = _v1.a;
                  var removed = _v1.b;
                  var remainingPathsToRemove = _v1.c;
                  return _Utils_eq(t.sourceId, sourceId) && A2($elm$core$List$member, t.path, remainingPathsToRemove) ? _Utils_Tuple3(
                    kept,
                    A2($elm$core$List$cons, t, removed),
                    A2($elm_community$list_extra$List$Extra$remove, t.path, remainingPathsToRemove)
                  ) : _Utils_Tuple3(
                    A2($elm$core$List$cons, t, kept),
                    removed,
                    remainingPathsToRemove
                  );
                }
              ),
              _Utils_Tuple3(_List_Nil, _List_Nil, paths),
              tracks
            )
          );
        }
      );
      var $author$project$Brain$Tracks$State$removeByPaths = F2(
        function(args, model) {
          return A2(
            $author$project$Brain$User$State$saveTracksAndUpdateSearchIndex,
            A2($author$project$Tracks$removeByPaths, args, model.hypaethralUserData.tracks).kept,
            model
          );
        }
      );
      var $author$project$Brain$Sources$Processing$State$treeStepRemoveTracks = F3(
        function(sourceId, filePaths, model) {
          var encodedData = $elm$json$Json$Encode$object(
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "filePaths",
                  A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, filePaths)
                ),
                _Utils_Tuple2(
                  "sourceId",
                  $elm$json$Json$Encode$string(sourceId)
                )
              ]
            )
          );
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            $author$project$Brain$Tracks$State$removeByPaths(
              { paths: filePaths, sourceId }
            ),
            A3($author$project$Brain$Common$State$giveUI, $author$project$Alien$RemoveTracksByPath, encodedData, model)
          );
        }
      );
      var $author$project$Brain$Sources$Processing$State$update = function(msg) {
        switch (msg.$) {
          case "Process":
            var a = msg.a;
            return $author$project$Brain$Sources$Processing$State$process(a);
          case "NextInLine":
            return $author$project$Brain$Sources$Processing$State$nextInLine;
          case "StopProcessing":
            return $author$project$Brain$Sources$Processing$State$stopProcessing;
          case "PrepareStep":
            var a = msg.a;
            var b = msg.b;
            return A2($author$project$Brain$Sources$Processing$State$prepareStep, a, b);
          case "TreeStep":
            var a = msg.a;
            var b = msg.b;
            return A2($author$project$Brain$Sources$Processing$State$treeStep, a, b);
          case "TreeStepRemoveTracks":
            var a = msg.a;
            var b = msg.b;
            return A2($author$project$Brain$Sources$Processing$State$treeStepRemoveTracks, a, b);
          default:
            var a = msg.a;
            return $author$project$Brain$Sources$Processing$State$tagsStep(a);
        }
      };
      var $author$project$Brain$User$State$sendHypaethralDataToUI = F3(
        function(encodedData, decodedData, model) {
          return A2(
            $Fresheyeball$elm_return$Return$return,
            _Utils_update(
              model,
              { hypaethralUserData: decodedData }
            ),
            $elm$core$Platform$Cmd$batch(
              _List_fromArray(
                [
                  $author$project$Brain$Ports$toUI(
                    A2($author$project$Alien$broadcast, $author$project$Alien$LoadHypaethralUserData, encodedData)
                  ),
                  $author$project$Brain$Ports$updateSearchIndex(
                    A2($elm$json$Json$Encode$list, $author$project$Tracks$Encoding$encodeTrack, decodedData.tracks)
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$User$Layer$methodToString = function(method) {
        switch (method.$) {
          case "Dropbox":
            var accessToken = method.a.accessToken;
            var expiresAt = method.a.expiresAt;
            var refreshToken = method.a.refreshToken;
            return A2(
              $elm$core$String$join,
              $author$project$User$Layer$methodSeparator,
              _List_fromArray(
                [
                  "DROPBOX",
                  accessToken,
                  $elm$core$String$fromInt(expiresAt),
                  refreshToken
                ]
              )
            );
          case "Fission":
            return "FISSION";
          case "Ipfs":
            var apiOrigin = method.a.apiOrigin;
            return A2(
              $elm$core$String$join,
              $author$project$User$Layer$methodSeparator,
              _List_fromArray(
                ["IPFS", apiOrigin]
              )
            );
          default:
            var userAddress = method.a.userAddress;
            var token = method.a.token;
            return A2(
              $elm$core$String$join,
              $author$project$User$Layer$methodSeparator,
              _List_fromArray(
                ["REMOTE_STORAGE", userAddress, token]
              )
            );
        }
      };
      var $author$project$User$Layer$encodeMethod = A2($elm$core$Basics$composeR, $author$project$User$Layer$methodToString, $elm$json$Json$Encode$string);
      var $author$project$Brain$User$Types$FinishedSyncing = { $: "FinishedSyncing" };
      var $author$project$Brain$User$Types$GotHypaethralData = function(a) {
        return { $: "GotHypaethralData", a };
      };
      var $author$project$Brain$User$Types$Sync = { $: "Sync" };
      var $author$project$Brain$User$Hypaethral$retrieveDropbox = F2(
        function(accessToken, bit) {
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A2(
              $lobanov$elm_taskport$TaskPort$call,
              {
                argsEncoder: $elm$json$Json$Encode$object,
                _function: "fromDropbox",
                valueDecoder: $elm$json$Json$Decode$maybe($elm$json$Json$Decode$value)
              },
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "fileName",
                    $author$project$Brain$User$Hypaethral$fileName(bit)
                  ),
                  _Utils_Tuple2(
                    "token",
                    $elm$json$Json$Encode$string(accessToken)
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$retrieveFission = function(bit) {
        var includePublicData = _Utils_eq(bit, $author$project$User$Layer$Playlists);
        return A2(
          $elm$core$Task$mapError,
          $author$project$TaskPort$Extra$errorToStringCustom,
          A2(
            $lobanov$elm_taskport$TaskPort$call,
            {
              argsEncoder: $elm$json$Json$Encode$object,
              _function: "fromFission",
              valueDecoder: $elm$json$Json$Decode$maybe($elm$json$Json$Decode$value)
            },
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "fileName",
                  $author$project$Brain$User$Hypaethral$fileName(bit)
                ),
                _Utils_Tuple2(
                  "includePublicData",
                  $elm$json$Json$Encode$bool(includePublicData)
                )
              ]
            )
          )
        );
      };
      var $author$project$Brain$User$Hypaethral$retrieveIpfs = F2(
        function(apiOrigin, bit) {
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A2(
              $lobanov$elm_taskport$TaskPort$call,
              {
                argsEncoder: $elm$json$Json$Encode$object,
                _function: "fromIpfs",
                valueDecoder: $elm$json$Json$Decode$maybe($elm$json$Json$Decode$value)
              },
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "fileName",
                    $author$project$Brain$User$Hypaethral$fileName(bit)
                  ),
                  _Utils_Tuple2(
                    "apiOrigin",
                    $elm$json$Json$Encode$string(apiOrigin)
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$Brain$User$Hypaethral$retrieveRemoteStorage = F2(
        function(_v0, bit) {
          var token = _v0.token;
          var userAddress = _v0.userAddress;
          return A2(
            $elm$core$Task$mapError,
            $author$project$TaskPort$Extra$errorToStringCustom,
            A2(
              $lobanov$elm_taskport$TaskPort$call,
              {
                argsEncoder: $elm$json$Json$Encode$object,
                _function: "fromRemoteStorage",
                valueDecoder: $elm$json$Json$Decode$maybe($elm$json$Json$Decode$value)
              },
              _List_fromArray(
                [
                  _Utils_Tuple2(
                    "fileName",
                    $author$project$Brain$User$Hypaethral$fileName(bit)
                  ),
                  _Utils_Tuple2(
                    "token",
                    $elm$json$Json$Encode$string(token)
                  ),
                  _Utils_Tuple2(
                    "userAddress",
                    $elm$json$Json$Encode$string(userAddress)
                  )
                ]
              )
            )
          );
        }
      );
      var $author$project$Task$Extra$fromResult = function(result) {
        if (result.$ === "Ok") {
          var v = result.a;
          return $elm$core$Task$succeed(v);
        } else {
          var e = result.a;
          return $elm$core$Task$fail(e);
        }
      };
      var $author$project$Syncing$pushLocalToRemote = F3(
        function(localConfig, remoteConfig, _v0) {
          var _return = _v0._return;
          return A2(
            $elm$core$Task$map,
            function(_v3) {
              return _return;
            },
            $elm$core$Task$sequence(
              A2(
                $elm$core$List$map,
                function(_v2) {
                  var bit = _v2.a;
                  var data = _v2.b;
                  return A2(remoteConfig.save, bit, data);
                },
                function() {
                  var _v1 = localConfig.localData.modifiedAt;
                  if (_v1.$ === "Just") {
                    var localModifiedAt = _v1.a;
                    return $elm$core$List$cons(
                      _Utils_Tuple2(
                        $author$project$User$Layer$ModifiedAt,
                        $author$project$Time$Ext$encode(localModifiedAt)
                      )
                    );
                  } else {
                    return $elm$core$Basics$identity;
                  }
                }()(
                  $author$project$User$Layer$encodedHypaethralDataList(localConfig.localData)
                )
              )
            )
          );
        }
      );
      var $author$project$User$Layer$saveHypaethralData = F2(
        function(saveFn, data) {
          return A2(
            $elm$core$Task$map,
            $elm$core$Basics$always(_Utils_Tuple0),
            $elm$core$Task$sequence(
              A2(
                $elm$core$List$map,
                function(_v0) {
                  var bit = _v0.b;
                  return A2(
                    saveFn,
                    bit,
                    A2($author$project$User$Layer$encodeHypaethralBit, bit, data)
                  );
                },
                $author$project$User$Layer$hypaethralBit.list
              )
            )
          );
        }
      );
      var $author$project$Syncing$fetchRemote = F2(
        function(localConfig, remoteConfig) {
          var _v0 = localConfig;
          var localData = _v0.localData;
          var saveLocal = _v0.saveLocal;
          var noLocalData = $elm$core$List$isEmpty(localData.sources) && ($elm$core$List$isEmpty(localData.favourites) && $elm$core$List$isEmpty(localData.playlists));
          var saveLocally = function(data) {
            return A2(
              $elm$core$Task$map,
              function(_v6) {
                return $elm$core$Maybe$Just(data);
              },
              A2($author$project$User$Layer$saveHypaethralData, saveLocal, data)
            );
          };
          var _v1 = remoteConfig;
          var retrieve = _v1.retrieve;
          return A2(
            $elm$core$Task$andThen,
            function(remoteData) {
              var _v3 = _Utils_Tuple2(remoteData.modifiedAt, localData.modifiedAt);
              if (_v3.a.$ === "Just") {
                if (_v3.b.$ === "Just") {
                  var remoteModifiedAt = _v3.a.a;
                  var localModifiedAt = _v3.b.a;
                  return _Utils_eq(
                    $elm$time$Time$posixToMillis(remoteModifiedAt),
                    $elm$time$Time$posixToMillis(localModifiedAt)
                  ) ? $elm$core$Task$succeed($elm$core$Maybe$Nothing) : _Utils_cmp(
                    $elm$time$Time$posixToMillis(remoteModifiedAt),
                    $elm$time$Time$posixToMillis(localModifiedAt)
                  ) > 0 ? saveLocally(remoteData) : A3(
                    $author$project$Syncing$pushLocalToRemote,
                    localConfig,
                    remoteConfig,
                    { _return: $elm$core$Maybe$Nothing }
                  );
                } else {
                  var _v4 = _v3.b;
                  return saveLocally(remoteData);
                }
              } else {
                if (_v3.b.$ === "Just") {
                  var _v5 = _v3.a;
                  return A3(
                    $author$project$Syncing$pushLocalToRemote,
                    localConfig,
                    remoteConfig,
                    { _return: $elm$core$Maybe$Nothing }
                  );
                } else {
                  return noLocalData ? saveLocally(remoteData) : $elm$core$Task$succeed($elm$core$Maybe$Nothing);
                }
              }
            },
            A2(
              $elm$core$Task$andThen,
              function(list) {
                return A2(
                  $elm$core$Task$mapError,
                  $elm$json$Json$Decode$errorToString,
                  $author$project$Task$Extra$fromResult(
                    $author$project$User$Layer$decodeHypaethralData(
                      $elm$json$Json$Encode$object(
                        A2(
                          $elm$core$List$map,
                          function(_v2) {
                            var a = _v2.a;
                            var b = _v2.b;
                            return _Utils_Tuple2(
                              $author$project$User$Layer$hypaethralBitKey(a),
                              A2($elm$core$Maybe$withDefault, $elm$json$Json$Encode$null, b)
                            );
                          },
                          list
                        )
                      )
                    )
                  )
                );
              },
              A2(
                $elm$core$Task$andThen,
                function(list) {
                  var remoteHasExistingData = A2(
                    $elm$core$List$any,
                    A2($elm$core$Basics$composeR, $elm$core$Tuple$second, $elm_community$maybe_extra$Maybe$Extra$isJust),
                    list
                  );
                  return remoteHasExistingData ? $elm$core$Task$succeed(list) : A3(
                    $author$project$Syncing$pushLocalToRemote,
                    localConfig,
                    remoteConfig,
                    { _return: list }
                  );
                },
                $author$project$User$Layer$retrieveHypaethralData(retrieve)
              )
            )
          );
        }
      );
      var $author$project$Syncing$task = F3(
        function(initialTask, localConfig, remoteConfig) {
          return A2(
            $elm$core$Task$andThen,
            function(maybeModifiedAt) {
              var maybeRemoteModifiedAt = A2(
                $elm$core$Maybe$andThen,
                A2(
                  $elm$core$Basics$composeR,
                  $elm$json$Json$Decode$decodeValue($author$project$Time$Ext$decoder),
                  $elm$core$Result$toMaybe
                ),
                maybeModifiedAt
              );
              var _v1 = _Utils_Tuple2(maybeRemoteModifiedAt, localConfig.localData.modifiedAt);
              if (_v1.a.$ === "Just") {
                if (_v1.b.$ === "Just") {
                  var remoteModifiedAt = _v1.a.a;
                  var localModifiedAt = _v1.b.a;
                  return _Utils_eq(
                    $elm$time$Time$posixToMillis(remoteModifiedAt),
                    $elm$time$Time$posixToMillis(localModifiedAt)
                  ) ? $elm$core$Task$succeed($elm$core$Maybe$Nothing) : _Utils_cmp(
                    $elm$time$Time$posixToMillis(remoteModifiedAt),
                    $elm$time$Time$posixToMillis(localModifiedAt)
                  ) > 0 ? A2($author$project$Syncing$fetchRemote, localConfig, remoteConfig) : A3(
                    $author$project$Syncing$pushLocalToRemote,
                    localConfig,
                    remoteConfig,
                    { _return: $elm$core$Maybe$Nothing }
                  );
                } else {
                  var _v2 = _v1.b;
                  return A2($author$project$Syncing$fetchRemote, localConfig, remoteConfig);
                }
              } else {
                var _v3 = _v1.a;
                return A2($author$project$Syncing$fetchRemote, localConfig, remoteConfig);
              }
            },
            A2(
              $elm$core$Task$andThen,
              function(_v0) {
                return remoteConfig.retrieve($author$project$User$Layer$ModifiedAt);
              },
              initialTask
            )
          );
        }
      );
      var $author$project$Brain$User$State$syncCommand = F2(
        function(initialTask, model) {
          var localData = model.hypaethralUserData;
          var attemptSync = function(args2) {
            return A2(
              $author$project$Brain$Common$State$attemptTask,
              function(maybe) {
                if (maybe.$ === "Just") {
                  var data = maybe.a;
                  return $author$project$Brain$Types$UserMsg(
                    $author$project$Brain$User$Types$GotHypaethralData(data)
                  );
                } else {
                  return $author$project$Brain$Types$UserMsg($author$project$Brain$User$Types$FinishedSyncing);
                }
              },
              A3(
                $author$project$Syncing$task,
                initialTask,
                { localData, saveLocal: $author$project$Brain$User$Hypaethral$saveLocal },
                args2
              )
            );
          };
          var _v0 = model.userSyncMethod;
          if (_v0.$ === "Just") {
            switch (_v0.a.$) {
              case "Dropbox":
                var accessToken = _v0.a.a.accessToken;
                var expiresAt = _v0.a.a.expiresAt;
                var refreshToken = _v0.a.a.refreshToken;
                return $author$project$Syncing$Services$Dropbox$Token$isExpired(
                  { currentTime: model.currentTime, expiresAt }
                ) ? A4($author$project$Brain$User$State$refreshDropboxTokens, model.currentTime, $author$project$Brain$User$Types$Sync, initialTask, refreshToken) : attemptSync(
                  {
                    retrieve: $author$project$Brain$User$Hypaethral$retrieveDropbox(accessToken),
                    save: $author$project$Brain$User$Hypaethral$saveDropbox(accessToken)
                  }
                );
              case "Fission":
                return attemptSync(
                  { retrieve: $author$project$Brain$User$Hypaethral$retrieveFission, save: $author$project$Brain$User$Hypaethral$saveFission }
                );
              case "Ipfs":
                var apiOrigin = _v0.a.a.apiOrigin;
                return attemptSync(
                  {
                    retrieve: $author$project$Brain$User$Hypaethral$retrieveIpfs(apiOrigin),
                    save: $author$project$Brain$User$Hypaethral$saveIpfs(apiOrigin)
                  }
                );
              default:
                var args = _v0.a.a;
                return attemptSync(
                  {
                    retrieve: $author$project$Brain$User$Hypaethral$retrieveRemoteStorage(args),
                    save: $author$project$Brain$User$Hypaethral$saveRemoteStorage(args)
                  }
                );
            }
          } else {
            return $elm$core$Platform$Cmd$none;
          }
        }
      );
      var $author$project$Brain$User$State$sync = F2(
        function(_v0, model) {
          var initialTask = _v0.initialTask;
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            function() {
              var _v1 = model.userSyncMethod;
              if (_v1.$ === "Just") {
                var method = _v1.a;
                return A2(
                  $author$project$Brain$Common$State$giveUI,
                  $author$project$Alien$StartedSyncing,
                  $author$project$User$Layer$encodeMethod(method)
                );
              } else {
                return $Fresheyeball$elm_return$Return$singleton;
              }
            }(),
            A2(
              $Fresheyeball$elm_return$Return$return,
              model,
              A2(
                $author$project$Brain$User$State$syncCommand,
                A2(
                  $elm$core$Maybe$withDefault,
                  $elm$core$Task$succeed(_Utils_Tuple0),
                  initialTask
                ),
                model
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$commence = F4(
        function(maybeMethod, initialUrl, _v0, model) {
          var hypaethralJson = _v0.a;
          var hypaethralData = _v0.b;
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            function() {
              var _v1 = $author$project$Url$Ext$action(initialUrl);
              if (_v1.b && _v1.a === "authenticate" && _v1.b.b && _v1.b.a === "fission" && !_v1.b.b.b) {
                var _v2 = _v1.b;
                return $author$project$Brain$Common$State$nudgeUI($author$project$Alien$CollectFissionCapabilities);
              } else {
                return $author$project$Brain$User$State$sync(
                  { initialTask: $elm$core$Maybe$Nothing }
                );
              }
            }(),
            A3(
              $author$project$Brain$User$State$sendHypaethralDataToUI,
              hypaethralJson,
              hypaethralData,
              _Utils_update(
                model,
                { userSyncMethod: maybeMethod }
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$enclosedDataRetrieved = function(json) {
        return A2($author$project$Brain$Common$State$giveUI, $author$project$Alien$LoadEnclosedUserData, json);
      };
      var $author$project$Brain$User$State$finishedSyncing = function(model) {
        var _v0 = model.userSyncMethod;
        if (_v0.$ === "Just") {
          var userSyncMethod = _v0.a;
          return A3(
            $author$project$Brain$Common$State$giveUI,
            $author$project$Alien$SyncMethod,
            $author$project$User$Layer$encodeMethod(userSyncMethod),
            model
          );
        } else {
          return $Fresheyeball$elm_return$Return$singleton(model);
        }
      };
      var $author$project$Brain$User$State$gotHypaethralData = F2(
        function(hypaethralData, model) {
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            $author$project$Brain$User$State$finishedSyncing,
            A3(
              $author$project$Brain$User$State$sendHypaethralDataToUI,
              $author$project$User$Layer$encodeHypaethralData(hypaethralData),
              hypaethralData,
              model
            )
          );
        }
      );
      var $author$project$Brain$Task$Ports$removeCache = function(tag) {
        return A2(
          $lobanov$elm_taskport$TaskPort$call,
          { argsEncoder: $elm$json$Json$Encode$string, _function: "removeCache", valueDecoder: $lobanov$elm_taskport$TaskPort$ignoreValue },
          $author$project$Alien$tagToString(tag)
        );
      };
      var $author$project$Brain$User$State$saveAllHypaethralDataTask = F2(
        function(userData, method) {
          var save = A2(
            $author$project$Brain$User$State$saveHypaethralDataBitsTask,
            A2($elm$core$List$cons, $author$project$User$Layer$ModifiedAt, $author$project$User$Layer$allHypaethralBits),
            userData
          );
          switch (method.$) {
            case "Dropbox":
              var accessToken = method.a.accessToken;
              return save(
                $author$project$Brain$User$Hypaethral$saveDropbox(accessToken)
              );
            case "Fission":
              return save($author$project$Brain$User$Hypaethral$saveFission);
            case "Ipfs":
              var apiOrigin = method.a.apiOrigin;
              return save(
                $author$project$Brain$User$Hypaethral$saveIpfs(apiOrigin)
              );
            default:
              var a = method.a;
              return save(
                $author$project$Brain$User$Hypaethral$saveRemoteStorage(a)
              );
          }
        }
      );
      var $author$project$Brain$User$State$removeEncryptionKey = function(model) {
        return A2(
          $Fresheyeball$elm_return$Return$return,
          model,
          A2(
            $author$project$Brain$Common$State$attemptTask,
            $elm$core$Basics$always($author$project$Brain$Types$Bypass),
            A2(
              $elm$core$Task$andThen,
              function(currentTime) {
                var _v1 = model.userSyncMethod;
                if (_v1.$ === "Just") {
                  var method = _v1.a;
                  var data = model.hypaethralUserData;
                  return A2(
                    $author$project$Brain$User$State$saveAllHypaethralDataTask,
                    _Utils_update(
                      data,
                      {
                        modifiedAt: $elm$core$Maybe$Just(currentTime)
                      }
                    ),
                    method
                  );
                } else {
                  return $elm$core$Task$succeed(_Utils_Tuple0);
                }
              },
              A2(
                $elm$core$Task$andThen,
                function(_v0) {
                  return $elm$time$Time$now;
                },
                A2(
                  $elm$core$Task$mapError,
                  $author$project$TaskPort$Extra$errorToStringCustom,
                  $author$project$Brain$Task$Ports$removeCache($author$project$Alien$SecretKey)
                )
              )
            )
          )
        );
      };
      var $author$project$Brain$Ports$requestCache = _Platform_outgoingPort(
        "requestCache",
        function($) {
          return $elm$json$Json$Encode$object(
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "data",
                  $elm$core$Basics$identity($.data)
                ),
                _Utils_Tuple2(
                  "error",
                  function($2) {
                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $2);
                  }($.error)
                ),
                _Utils_Tuple2(
                  "tag",
                  $elm$json$Json$Encode$string($.tag)
                )
              ]
            )
          );
        }
      );
      var $author$project$Brain$User$State$retrieveEnclosedData = $author$project$Return$Ext$communicate(
        $author$project$Brain$Ports$requestCache(
          $author$project$Alien$trigger($author$project$Alien$EnclosedData)
        )
      );
      var $author$project$Brain$User$State$saveEnclosedData = function(json) {
        return $author$project$Return$Ext$communicate(
          $author$project$Brain$Ports$toCache(
            A2($author$project$Alien$broadcast, $author$project$Alien$EnclosedData, json)
          )
        );
      };
      var $author$project$Brain$User$State$saveFavourites = F2(
        function(value, model) {
          return A2(
            $author$project$Brain$User$State$saveHypaethralDataBitWithDebounce,
            $author$project$User$Layer$Favourites,
            A2(
              $author$project$Brain$User$State$hypaethralLenses.setFavourites,
              model,
              A2(
                $elm$core$Result$withDefault,
                model.hypaethralUserData.favourites,
                A2(
                  $elm$json$Json$Decode$decodeValue,
                  $elm$json$Json$Decode$list($author$project$Tracks$Encoding$favouriteDecoder),
                  value
                )
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveMethod = F2(
        function(method, model) {
          return A2(
            $Fresheyeball$elm_return$Return$return,
            _Utils_update(
              model,
              {
                userSyncMethod: $elm$core$Maybe$Just(method)
              }
            ),
            $author$project$Brain$Ports$toCache(
              A2(
                $author$project$Alien$broadcast,
                $author$project$Alien$SyncMethod,
                $author$project$User$Layer$encodeMethod(method)
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$savePlaylists = F2(
        function(value, model) {
          return A2(
            $author$project$Brain$User$State$saveHypaethralDataBitWithDebounce,
            $author$project$User$Layer$Playlists,
            A2(
              $author$project$Brain$User$State$hypaethralLenses.setPlaylists,
              model,
              A2(
                $elm$core$Result$withDefault,
                model.hypaethralUserData.playlists,
                A2(
                  $elm$json$Json$Decode$decodeValue,
                  $elm$json$Json$Decode$list($author$project$Playlists$Encoding$decoder),
                  value
                )
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveProgress = F2(
        function(value, model) {
          return A2(
            $author$project$Brain$User$State$saveHypaethralDataBitWithDebounce,
            $author$project$User$Layer$Progress,
            A2(
              $author$project$Brain$User$State$hypaethralLenses.setProgress,
              model,
              A2(
                $elm$core$Result$withDefault,
                model.hypaethralUserData.progress,
                A2(
                  $elm$json$Json$Decode$decodeValue,
                  $elm$json$Json$Decode$dict($elm$json$Json$Decode$float),
                  value
                )
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveSettings = F2(
        function(value, model) {
          return A2(
            $author$project$Brain$User$State$saveHypaethralDataBitWithDebounce,
            $author$project$User$Layer$Settings,
            A2(
              $author$project$Brain$User$State$hypaethralLenses.setSettings,
              model,
              A2(
                $elm$core$Result$withDefault,
                model.hypaethralUserData.settings,
                A2(
                  $elm$json$Json$Decode$decodeValue,
                  A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $author$project$Settings$decoder),
                  value
                )
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveSources = F2(
        function(value, model) {
          return A2(
            $author$project$Brain$User$State$saveHypaethralDataBitWithDebounce,
            $author$project$User$Layer$Sources,
            A2(
              $author$project$Brain$User$State$hypaethralLenses.setSources,
              model,
              A2(
                $elm$core$Result$withDefault,
                model.hypaethralUserData.sources,
                A2(
                  $elm$json$Json$Decode$decodeValue,
                  $elm$json$Json$Decode$list($author$project$Sources$Encoding$decoder),
                  value
                )
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$saveTracks = F2(
        function(value, model) {
          return A2(
            $author$project$Brain$User$State$saveTracksAndUpdateSearchIndex,
            A2(
              $elm$core$Result$withDefault,
              model.hypaethralUserData.tracks,
              A2(
                $elm$json$Json$Decode$decodeValue,
                $elm$json$Json$Decode$list($author$project$Tracks$Encoding$trackDecoder),
                value
              )
            ),
            model
          );
        }
      );
      var $author$project$Brain$Task$Ports$fabricateSecretKey = $lobanov$elm_taskport$TaskPort$call(
        {
          argsEncoder: $elm$json$Json$Encode$string,
          _function: "fabricateSecretKey",
          valueDecoder: $elm$json$Json$Decode$succeed(_Utils_Tuple0)
        }
      );
      var $author$project$Brain$User$State$setSyncMethod = F2(
        function(json, model) {
          var decoder = A3(
            $elm$json$Json$Decode$map2,
            F2(
              function(a, b) {
                return _Utils_Tuple2(a, b);
              }
            ),
            A2(
              $elm$json$Json$Decode$field,
              "method",
              A2($elm$json$Json$Decode$map, $author$project$User$Layer$methodFromString, $elm$json$Json$Decode$string)
            ),
            A2(
              $elm$json$Json$Decode$field,
              "passphrase",
              $elm$json$Json$Decode$maybe($elm$json$Json$Decode$string)
            )
          );
          var _v0 = A2($elm$json$Json$Decode$decodeValue, decoder, json);
          if (_v0.$ === "Ok") {
            if (_v0.a.a.$ === "Just") {
              if (_v0.a.b.$ === "Just") {
                var _v1 = _v0.a;
                var method = _v1.a.a;
                var passphrase = _v1.b.a;
                var initialTask = A2(
                  $elm$core$Task$mapError,
                  $author$project$TaskPort$Extra$errorToStringCustom,
                  $author$project$Brain$Task$Ports$fabricateSecretKey(passphrase)
                );
                return A2(
                  $Fresheyeball$elm_return$Return$andThen,
                  $author$project$Brain$User$State$saveMethod(method),
                  A2(
                    $author$project$Brain$User$State$sync,
                    {
                      initialTask: $elm$core$Maybe$Just(initialTask)
                    },
                    _Utils_update(
                      model,
                      {
                        userSyncMethod: $elm$core$Maybe$Just(method)
                      }
                    )
                  )
                );
              } else {
                var _v2 = _v0.a;
                var method = _v2.a.a;
                var _v3 = _v2.b;
                return A2(
                  $Fresheyeball$elm_return$Return$andThen,
                  $author$project$Brain$User$State$saveMethod(method),
                  A2(
                    $author$project$Brain$User$State$sync,
                    { initialTask: $elm$core$Maybe$Nothing },
                    _Utils_update(
                      model,
                      {
                        userSyncMethod: $elm$core$Maybe$Just(method)
                      }
                    )
                  )
                );
              }
            } else {
              var _v4 = _v0.a;
              var _v5 = _v4.a;
              return $Fresheyeball$elm_return$Return$singleton(
                _Utils_update(
                  model,
                  { userSyncMethod: $elm$core$Maybe$Nothing }
                )
              );
            }
          } else {
            return $Fresheyeball$elm_return$Return$singleton(model);
          }
        }
      );
      var $author$project$Brain$Ports$deconstructFission = _Platform_outgoingPort(
        "deconstructFission",
        function($) {
          return $elm$json$Json$Encode$null;
        }
      );
      var $author$project$Brain$Ports$deconstructRemoteStorage = _Platform_outgoingPort(
        "deconstructRemoteStorage",
        function($) {
          return $elm$json$Json$Encode$null;
        }
      );
      var $author$project$Brain$Ports$removeCache = _Platform_outgoingPort(
        "removeCache",
        function($) {
          return $elm$json$Json$Encode$object(
            _List_fromArray(
              [
                _Utils_Tuple2(
                  "data",
                  $elm$core$Basics$identity($.data)
                ),
                _Utils_Tuple2(
                  "error",
                  function($2) {
                    return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $2);
                  }($.error)
                ),
                _Utils_Tuple2(
                  "tag",
                  $elm$json$Json$Encode$string($.tag)
                )
              ]
            )
          );
        }
      );
      var $author$project$Brain$User$State$unsetSyncMethod = function(model) {
        return A2(
          $Fresheyeball$elm_return$Return$return,
          _Utils_update(
            model,
            { userSyncMethod: $elm$core$Maybe$Nothing }
          ),
          $elm$core$Platform$Cmd$batch(
            _List_fromArray(
              [
                $author$project$Brain$Ports$removeCache(
                  $author$project$Alien$trigger($author$project$Alien$SyncMethod)
                ),
                $author$project$Brain$Ports$removeCache(
                  $author$project$Alien$trigger($author$project$Alien$SecretKey)
                ),
                function() {
                  var _v0 = model.userSyncMethod;
                  if (_v0.$ === "Just") {
                    switch (_v0.a.$) {
                      case "Dropbox":
                        return $elm$core$Platform$Cmd$none;
                      case "Fission":
                        return $author$project$Brain$Ports$deconstructFission(_Utils_Tuple0);
                      case "Ipfs":
                        return $elm$core$Platform$Cmd$none;
                      default:
                        return $author$project$Brain$Ports$deconstructRemoteStorage(_Utils_Tuple0);
                    }
                  } else {
                    return $elm$core$Platform$Cmd$none;
                  }
                }()
              ]
            )
          )
        );
      };
      var $author$project$Brain$User$State$updateEncryptionKey = F2(
        function(json, model) {
          var _v0 = A2($elm$json$Json$Decode$decodeValue, $elm$json$Json$Decode$string, json);
          if (_v0.$ === "Ok") {
            var passphrase = _v0.a;
            return A2(
              $Fresheyeball$elm_return$Return$return,
              model,
              A2(
                $author$project$Brain$Common$State$attemptTask,
                $elm$core$Basics$always($author$project$Brain$Types$Bypass),
                A2(
                  $elm$core$Task$andThen,
                  function(currentTime) {
                    var _v2 = model.userSyncMethod;
                    if (_v2.$ === "Just") {
                      var method = _v2.a;
                      var data = model.hypaethralUserData;
                      return A2(
                        $author$project$Brain$User$State$saveAllHypaethralDataTask,
                        _Utils_update(
                          data,
                          {
                            modifiedAt: $elm$core$Maybe$Just(currentTime)
                          }
                        ),
                        method
                      );
                    } else {
                      return $elm$core$Task$succeed(_Utils_Tuple0);
                    }
                  },
                  A2(
                    $elm$core$Task$andThen,
                    function(_v1) {
                      return $elm$time$Time$now;
                    },
                    A2(
                      $elm$core$Task$mapError,
                      $author$project$TaskPort$Extra$errorToStringCustom,
                      $author$project$Brain$Task$Ports$fabricateSecretKey(passphrase)
                    )
                  )
                )
              )
            );
          } else {
            return $Fresheyeball$elm_return$Return$singleton(model);
          }
        }
      );
      var $author$project$Brain$User$State$refreshedDropboxTokens = F4(
        function(_v1, tokens, msg, model) {
          var currentTime = _v1.currentTime;
          var refreshToken = _v1.refreshToken;
          return A2(
            $Fresheyeball$elm_return$Return$andThen,
            $author$project$Brain$User$State$update(msg),
            function(m) {
              return A2($author$project$Brain$User$State$saveMethod, m, model);
            }(
              $author$project$User$Layer$Dropbox(
                { accessToken: tokens.accessToken, expiresAt: currentTime + tokens.expiresIn, refreshToken }
              )
            )
          );
        }
      );
      var $author$project$Brain$User$State$update = function(msg) {
        switch (msg.$) {
          case "Commence":
            var a = msg.a;
            var b = msg.b;
            var c = msg.c;
            return A3($author$project$Brain$User$State$commence, a, b, c);
          case "SetSyncMethod":
            var a = msg.a;
            return $author$project$Brain$User$State$setSyncMethod(a);
          case "Sync":
            return $author$project$Brain$User$State$sync(
              { initialTask: $elm$core$Maybe$Nothing }
            );
          case "UnsetSyncMethod":
            return $author$project$Brain$User$State$unsetSyncMethod;
          case "RetrieveEnclosedData":
            return $author$project$Brain$User$State$retrieveEnclosedData;
          case "EnclosedDataRetrieved":
            var a = msg.a;
            return $author$project$Brain$User$State$enclosedDataRetrieved(a);
          case "SaveEnclosedData":
            var a = msg.a;
            return $author$project$Brain$User$State$saveEnclosedData(a);
          case "SaveFavourites":
            var a = msg.a;
            return $author$project$Brain$User$State$saveFavourites(a);
          case "SavePlaylists":
            var a = msg.a;
            return $author$project$Brain$User$State$savePlaylists(a);
          case "SaveProgress":
            var a = msg.a;
            return $author$project$Brain$User$State$saveProgress(a);
          case "SaveSettings":
            var a = msg.a;
            return $author$project$Brain$User$State$saveSettings(a);
          case "SaveSources":
            var a = msg.a;
            return $author$project$Brain$User$State$saveSources(a);
          case "SaveTracks":
            var a = msg.a;
            return $author$project$Brain$User$State$saveTracks(a);
          case "FinishedSyncing":
            return $author$project$Brain$User$State$finishedSyncing;
          case "GotHypaethralData":
            var a = msg.a;
            return $author$project$Brain$User$State$gotHypaethralData(a);
          case "SaveHypaethralDataBits":
            var a = msg.a;
            return $author$project$Brain$User$State$saveHypaethralDataBits(a);
          case "SaveHypaethralDataSlowly":
            var a = msg.a;
            return $author$project$Brain$User$State$saveHypaethralDataSlowly(a);
          case "RemoveEncryptionKey":
            return $author$project$Brain$User$State$removeEncryptionKey;
          case "UpdateEncryptionKey":
            var a = msg.a;
            return $author$project$Brain$User$State$updateEncryptionKey(a);
          default:
            var a = msg.a;
            var b = msg.b;
            var c = msg.c;
            return A3($author$project$Brain$User$State$refreshedDropboxTokens, a, b, c);
        }
      };
      var $author$project$Brain$Tracks$State$updateSearchIndex = function(data) {
        return $author$project$Return$Ext$communicate(
          $author$project$Brain$Ports$updateSearchIndex(data)
        );
      };
      var $author$project$Brain$update = function(msg) {
        switch (msg.$) {
          case "Bypass":
            return $Fresheyeball$elm_return$Return$singleton;
          case "Cmd":
            var a = msg.a;
            return $author$project$Return$Ext$communicate(a);
          case "DownloadTracks":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$download(a);
          case "GotSearchResults":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$gotSearchResults(a);
          case "MakeArtworkTrackUrls":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$makeArtworkTrackUrls(a);
          case "RemoveTracksBySourceId":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$removeBySourceId(a);
          case "RemoveTracksFromCache":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$removeFromCache(a);
          case "ReplaceTrackTags":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$replaceTags(a);
          case "Search":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$search(a);
          case "StoreTracksInCache":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$storeInCache(a);
          case "SyncTrackTags":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$syncTrackTags(a);
          case "UpdateSearchIndex":
            var a = msg.a;
            return $author$project$Brain$Tracks$State$updateSearchIndex(a);
          case "ProcessingMsg":
            var a = msg.a;
            return $author$project$Brain$Sources$Processing$State$update(a);
          case "UserMsg":
            var a = msg.a;
            return $author$project$Brain$User$State$update(a);
          case "RefreshedAccessToken":
            var a = msg.a;
            return $author$project$Brain$Other$State$refreshedAccessToken(a);
          case "SetCurrentTime":
            var a = msg.a;
            return $author$project$Brain$Other$State$setCurrentTime(a);
          default:
            var a = msg.a;
            return $author$project$Brain$Other$State$toCache(a);
        }
      };
      var $elm$core$Platform$worker = _Platform_worker;
      var $author$project$Brain$main = $elm$core$Platform$worker(
        { init: $author$project$Brain$init, subscriptions: $author$project$Brain$subscriptions, update: $author$project$Brain$update }
      );
      _Platform_export({ "Brain": { "init": $author$project$Brain$main(
        A2(
          $elm$json$Json$Decode$andThen,
          function(initialUrl) {
            return $elm$json$Json$Decode$succeed(
              { initialUrl }
            );
          },
          A2($elm$json$Json$Decode$field, "initialUrl", $elm$json$Json$Decode$string)
        )
      )(0) } });
    })(exports2);
  }
});

// src/Javascript/Brain/index.ts
init_node_shims();

// node_modules/elm-taskport/js/taskport.js
init_node_shims();

// node_modules/elm-taskport/js/url.js
init_node_shims();
var URL_PREFIX = "elmtaskport://";
function parseUrl(url) {
  const m = url.match(/^elmtaskport:\/\/([\w-]+\/[\w-]+)?\/([\w]+)\?v=(\d\.\d\.\d)(?:&nsv=([\w.-]+))?$/);
  if (!m) {
    return;
  }
  const [_, namespaceName, functionName, apiVersion, namespaceVersion] = m;
  if (namespaceName !== void 0 && namespaceVersion === void 0) {
    return;
  }
  return { namespaceName, namespaceVersion, apiVersion, functionName };
}

// node_modules/elm-taskport/js/namespace.js
init_node_shims();
function Namespace(version) {
  if (typeof version !== "string" || !version.match(/^[\w-.]+$/)) {
    throw new Error("Invalid namespace version: " + version);
  }
  this.version = version;
  this.functions = {};
  this.register = function(name, fn) {
    if (!name.match(/^\w+$/)) {
      throw new Error("Invalid function name: " + name);
    }
    if (name in this.functions) {
      throw new Error(name + " is already used");
    }
    this.functions[name] = fn;
  };
  this.names = function() {
    return Object.keys(this.functions);
  };
  this.find = function(name) {
    if (name in this.functions) {
      return this.functions[name];
    }
  };
}

// node_modules/elm-taskport/js/taskport.js
var MODULE_VERSION = "2.0.1";
var DEFAULT_SETTINGS = {
  /** Whether TaskPort should log errors thrown by JavaScript functions to the console */
  logCallErrors: false,
  /** Whether TaskPort should log errors occuring in the interop mechanism to the console */
  logInteropErrors: true
};
var globalSettings = DEFAULT_SETTINGS;
var defaultNamespace = new Namespace("unversioned");
var namespaces = {};
function callAndReturnPromise(fn, args) {
  try {
    return Promise.resolve(fn(args));
  } catch (e) {
    return Promise.reject(e);
  }
}
function describeError(error) {
  if (error instanceof Error) {
    const { name, message, cause, stack } = error;
    const stackLines = stack === void 0 ? [] : stack.split(/\n/).slice(1);
    return { name, message, cause: describeError(cause), stackLines };
  } else if (error === void 0) {
    return null;
  } else {
    return error;
  }
}
function install(settings, xhrProto) {
  if (typeof settings === "object") {
    globalSettings = { ...DEFAULT_SETTINGS, ...settings };
  }
  if (xhrProto === void 0) {
    xhrProto = XMLHttpRequest.prototype;
  }
  xhrProto.__elm_taskport_open = xhrProto.open;
  xhrProto.open = function(method, url, async, user, password) {
    if (url.indexOf(URL_PREFIX) === 0) {
      this.__elm_taskport_url = url;
      this.__elm_taskport_function_call = true;
      Object.defineProperty(this, "responseType", { writable: true });
      Object.defineProperty(this, "response", { writable: true });
      Object.defineProperty(this, "status", { writable: true });
      const parsedUrl = parseUrl(url);
      if (parsedUrl === void 0) {
        this.__elm_taskport_error = [400, `Cannot decode TaskPort url ${url}. Did you update TaskPort package to a new version, but forgot to update the JavaScript code it requires?`];
      } else {
        const { namespaceName, functionName, apiVersion, namespaceVersion } = parsedUrl;
        if (apiVersion !== MODULE_VERSION) {
          this.__elm_taskport_error = [400, `TaskPort version conflict. Elm-side is ${apiVersion}, but JavaScript-side is ${MODULE_VERSION}. Did you update TaskPort package to a new version, but forgot to update the JavaScript code it requires?`];
        } else if (namespaceName === void 0) {
          this.__elm_taskport_function_name = functionName;
          const fn = defaultNamespace.find(functionName);
          if (fn !== void 0) {
            this.__elm_taskport_function = fn;
          } else {
            this.__elm_taskport_error = [404, `Cannot find function '${functionName}' in the default namespace. The default namespace has the following functons registered:
` + defaultNamespace.names().join("\n")];
          }
        } else {
          this.__elm_taskport_function_name = namespaceName + "/" + functionName;
          if (namespaceName in namespaces) {
            const ns = namespaces[namespaceName];
            if (ns.version === namespaceVersion) {
              const fn = ns.find(functionName);
              if (fn !== void 0) {
                this.__elm_taskport_function = fn;
              } else {
                this.__elm_taskport_error = [404, `Cannot find function '${functionName}' in namespace ${namespaceName}. This namespace has only the following functons registered with it:
` + ns.names().join("\n")];
              }
            } else {
              this.__elm_taskport_error = [400, `The interop call expected namespace '${namespaceName}' to have version '${namespaceVersion}', but it is registered with version '${ns.version}'. Did you update the Elm package to a new version, but forgot to update the JavaScript code it requires?`];
            }
          } else {
            const knownNamespaces = Object.keys(namespaces);
            this.__elm_taskport_error = [404, `Namespace '${namespaceName}' is not registered with TaskPort. Did you follow the instructions to install required JavaScript code for the package? ` + (knownNamespaces.length == 0) ? `There are no namespaces registered with TaskPort.` : `Only the following namespaces are known to TaskPort:
` + knownNamespaces.join("\n")];
          }
        }
      }
    }
    return this.__elm_taskport_open(method, url, async, user, password);
  };
  if (typeof ProgressEvent === "function") {
    xhrProto.__elm_taskport_dispatch_event = function(eventName) {
      this.dispatchEvent(new ProgressEvent(eventName));
    };
  } else {
    xhrProto.__elm_taskport_dispatch_event = xhrProto.dispatchEvent;
  }
  xhrProto.__elm_taskport_send = xhrProto.send;
  xhrProto.send = function(body) {
    if (!this.__elm_taskport_function_call) {
      return this.__elm_taskport_send(body);
    }
    if (this.__elm_taskport_function !== void 0) {
      const parsedBody = JSON.parse(body);
      const promise = callAndReturnPromise(this.__elm_taskport_function, parsedBody);
      promise.then((res) => {
        this.responseType = "json";
        this.response = res === void 0 ? "null" : JSON.stringify(res);
        this.status = 200;
        this.__elm_taskport_dispatch_event("load");
      }).catch((err) => {
        if (globalSettings.logCallErrors) {
          console.error("JavaScript function " + this.__elm_taskport_function_name + " thrown an error or returned a rejected Promise:", err);
        }
        this.status = 500;
        this.responseType = "json";
        this.response = JSON.stringify(describeError(err));
        this.__elm_taskport_dispatch_event("load");
      });
    } else {
      if (this.__elm_taskport_error === void 0) {
        this.__elm_taskport_error == [400, "TaskPort call failed without an error message. This could indicate a bug in TaskPort itself."];
      }
      const [status, message] = this.__elm_taskport_error;
      if (globalSettings.logInteropErrors) {
        console.error("Unable to execute the interop call. " + message);
      }
      this.status = status;
      this.responseType = "text";
      this.response = this.__elm_taskport_function_name;
      this.__elm_taskport_dispatch_event("load");
    }
  };
}
function register(name, fn) {
  defaultNamespace.register(name, fn);
}

// src/Javascript/Brain/artwork.ts
init_node_shims();

// src/Javascript/urls.ts
init_node_shims();
var EXPIRED_ACCESS_TOKENS = {
  GOOGLE: {}
};
async function transformUrl(url, app2) {
  const parts = url.split("://");
  switch (parts[0]) {
    case "dropbox": {
      const dropboxBits = parts[1].split("@");
      const accessToken = dropboxBits[0];
      const filePath = dropboxBits[1];
      return fetch(
        "https://api.dropboxapi.com/2/files/get_temporary_link",
        {
          method: "POST",
          body: JSON.stringify({ path: filePath }),
          headers: new Headers({
            "Authorization": "Bearer " + accessToken,
            "Content-Type": "application/json"
          })
        }
      ).then(
        (response) => response.json()
      ).then(
        (response) => response.link
      );
    }
    case "google": {
      let finalAccessToken;
      const googleBits = parts[1].split("@");
      const [accessToken, expiresAtString, refreshToken, clientId, clientSecret, srcId] = googleBits[0].split(":");
      const fileId = googleBits[1];
      const inXminutes = Date.now() + 5 * 60 * 1e3;
      const expiresAt = parseInt(expiresAtString, 10);
      const isAlmostExpired = expiresAt <= inXminutes;
      if (EXPIRED_ACCESS_TOKENS.GOOGLE[accessToken]) {
        const replacement = EXPIRED_ACCESS_TOKENS.GOOGLE[accessToken];
        if (replacement.newExpiresAt <= inXminutes) {
          finalAccessToken = await refreshGoogleAccessToken({
            app: app2,
            clientId,
            clientSecret,
            refreshToken,
            srcId,
            oldToken: accessToken
          });
        } else {
          finalAccessToken = replacement.newToken;
        }
      } else if (isAlmostExpired) {
        finalAccessToken = await refreshGoogleAccessToken({
          app: app2,
          clientId,
          clientSecret,
          refreshToken,
          srcId,
          oldToken: accessToken
        });
      } else {
        finalAccessToken = accessToken;
      }
      return Promise.resolve(
        `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(fileId)}?alt=media&bearer_token=${encodeURIComponent(finalAccessToken)}`
      );
    }
    default:
      return Promise.resolve(url);
  }
}
async function refreshGoogleAccessToken({ app: app2, clientId, clientSecret, oldToken, refreshToken, srcId }) {
  console.log("\u{1F510} Refreshing Google Drive access token");
  const url = new URL("https://www.googleapis.com/oauth2/v4/token");
  url.searchParams.set("client_id", clientId);
  url.searchParams.set("client_secret", clientSecret);
  url.searchParams.set("refresh_token", refreshToken);
  url.searchParams.set("grant_type", "refresh_token");
  const serverResponse = await fetch(url, { method: "POST" }).then((r) => r.json());
  const newToken = serverResponse.access_token;
  const newExpiresAt = Date.now() + serverResponse.expires_in * 1e3;
  EXPIRED_ACCESS_TOKENS.GOOGLE[oldToken] = {
    oldToken,
    newToken,
    newExpiresAt,
    refreshToken
  };
  app2.ports.refreshedAccessToken.send({
    service: "Google",
    sourceId: srcId,
    accessToken: newToken,
    expiresAt: newExpiresAt
  });
  return serverResponse.access_token;
}

// src/Javascript/processing.ts
init_node_shims();
var musicMetadata = __toESM(require_lib4());
var import_http = __toESM(require_lib6());

// src/Javascript/common.ts
init_node_shims();
var localforage = __toESM(require_localforage());
var APP_INFO = {
  creator: "icidasset",
  name: "Diffuse"
};
var ODD_CONFIG = {
  namespace: APP_INFO,
  permissions: {
    app: APP_INFO,
    fs: { public: [{ directory: ["Apps", APP_INFO.creator, APP_INFO.name] }] }
  },
  debug: true
};
function db(storeName = "main") {
  return localforage.createInstance({
    name: "diffuse",
    storeName
  });
}
function mimeType(fileExt) {
  switch (fileExt) {
    case "mp3":
      return "audio/mpeg";
    case "mp4":
      return "audio/mp4";
    case "m4a":
      return "audio/mp4";
    case "flac":
      return "audio/flac";
    case "ogg":
      return "audio/ogg";
    case "wav":
      return "audio/wave";
    case "webm":
      return "audio/webm";
    case "opus":
      return "audio/opus";
  }
}

// src/Javascript/processing.ts
function processContext(context, app2) {
  const initialPromise = Promise.resolve([]);
  return context.urlsForTags.reduce((accumulator, urls, idx) => {
    return accumulator.then((col) => {
      const filename = context.receivedFilePaths[idx].split("/").reverse()[0];
      return Promise.all([
        transformUrl(urls.headUrl, app2),
        transformUrl(urls.getUrl, app2)
      ]).then(([headUrl, getUrl]) => {
        return getTags(headUrl, getUrl, filename, { skipCovers: true });
      }).then((r) => {
        return col.concat(r);
      }).catch((e) => {
        console.warn(e);
        return col.concat(null);
      });
    });
  }, initialPromise).then((col) => {
    context.receivedTags = col;
    return context;
  });
}
var parserConfiguration = Object.assign(
  {},
  { duration: false, skipPostHeaders: true }
);
function getTags(headUrl, getUrl, filename, options) {
  const fileExtMatch = filename.match(/\.(\w+)$/);
  const fileExt = fileExtMatch && fileExtMatch[1];
  const overrideContentType = getUrl.includes("googleapis.com") || getUrl.includes("googleusercontent.com");
  return (0, import_http.makeTokenizer)(headUrl).then((tokenizer) => {
    const fileMime = overrideContentType ? mimeType(fileExt) : tokenizer.fileInfo.mimeType;
    tokenizer.fileInfo.mimeType = fileMime;
    tokenizer.fileInfo.url = getUrl;
    if (tokenizer.rangeRequestClient) {
      tokenizer.rangeRequestClient.url = getUrl;
      tokenizer.rangeRequestClient.resolvedUrl = void 0;
    }
    return musicMetadata.parseFromTokenizer(
      tokenizer,
      Object.assign({}, parserConfiguration, options || {})
    );
  }).then((result) => {
    return pickTags(filename, result);
  }).catch((err) => {
    console.error(err);
    return fallbackTags(filename);
  });
}
function pickTags(filename, result) {
  const tags = result && result.common;
  if (!tags)
    return null;
  const artist = tags.artist && tags.artist.length ? tags.artist : null;
  const title = tags.title && tags.title.length ? tags.title : null;
  return {
    disc: tags.disk.no || 1,
    nr: tags.track.no || 1,
    album: tags.album && tags.album.length ? tags.album : "Unknown",
    artist: artist || "Unknown",
    title: title ? title : artist ? "Unknown" : filename.replace(/\.\w+$/, ""),
    genre: tags.genre && tags.genre[0] || null,
    year: tags.year || null,
    picture: tags.picture ? tags.picture[0] : null
  };
}
function fallbackTags(filename) {
  const filenameWithoutExt = filename.replace(/\.\w+$/, "");
  return {
    disc: 1,
    nr: 1,
    album: "Unknown",
    artist: "Unknown",
    title: filenameWithoutExt,
    genre: null,
    year: null,
    picture: null
  };
}

// src/Javascript/Brain/artwork.ts
var REJECT = () => Promise.reject("No artwork found");
function find(prep, app2) {
  return findUsingTags(prep, app2).then((a) => a ? a : findUsingMusicBrainz(prep)).then((a) => a ? a : findUsingLastFm(prep)).then((a) => a ? a : REJECT()).then((a) => a.type.startsWith("image/") ? a : REJECT());
}
function decodeCacheKey(cacheKey) {
  return decodeURIComponent(escape(atob(cacheKey)));
}
function findUsingTags(prep, app2) {
  return Promise.all(
    [
      transformUrl(prep.trackHeadUrl, app2),
      transformUrl(prep.trackGetUrl, app2)
    ]
  ).then(([headUrl, getUrl]) => getTags(
    headUrl,
    getUrl,
    prep.trackFilename,
    { skipCovers: false }
  )).then((tags) => {
    return tags?.picture ? new Blob([tags.picture.data], { type: tags.picture.format }) : null;
  });
}
function findUsingMusicBrainz(prep) {
  const parts = decodeCacheKey(prep.cacheKey).split(" --- ");
  const artist = parts[0];
  const album = parts[1] || parts[0];
  const query = `release:"${album}"` + (prep.variousArtists === "t" ? `` : ` AND artist:"${artist}"`);
  const encodedQuery = encodeURIComponent(query);
  return fetch(`https://musicbrainz.org/ws/2/release/?query=${encodedQuery}&fmt=json`).then((r) => r.json()).then((r) => musicBrainzCover(r.releases));
}
function musicBrainzCover(remainingReleases) {
  const release = remainingReleases[0];
  if (!release)
    return null;
  return fetch(
    `https://coverartarchive.org/release/${release.id}/front-500`
  ).then(
    (r) => r.blob()
  ).then(
    (r) => r && r.type.startsWith("image/") ? r : musicBrainzCover(remainingReleases.slice(1))
  ).catch(
    () => musicBrainzCover(remainingReleases.slice(1))
  );
}
function findUsingLastFm(prep) {
  const query = decodeCacheKey(prep.cacheKey).replace(" --- ", " ");
  return fetch(`https://ws.audioscrobbler.com/2.0/?method=album.search&album=${query}&api_key=4f0fe85b67baef8bb7d008a8754a95e5&format=json`).then((r) => r.json()).then((r) => lastFmCover(r.results.albummatches.album));
}
function lastFmCover(remainingMatches) {
  const album = remainingMatches[0];
  const url = album ? album.image[album.image.length - 1]["#text"] : null;
  return url && url !== "" ? fetch(url).then((r) => r.blob()).catch((_) => lastFmCover(remainingMatches.slice(1))) : album && lastFmCover(remainingMatches.slice(1));
}

// src/Javascript/Brain/user.ts
init_node_shims();

// src/Javascript/crypto.ts
init_node_shims();

// node_modules/uint8arrays/dist/src/index.js
init_node_shims();

// node_modules/uint8arrays/dist/src/xor.js
init_node_shims();

// src/Javascript/crypto.ts
var extractable = false;
function keyFromPassphrase(passphrase) {
  return crypto.subtle.importKey(
    "raw",
    fromString(passphrase, "utf8"),
    {
      name: "PBKDF2"
    },
    false,
    ["deriveKey"]
  ).then((baseKey) => crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: fromString("diffuse", "utf8"),
      iterations: 1e4,
      hash: "SHA-512"
    },
    baseKey,
    {
      name: "AES-GCM",
      length: 256
    },
    extractable,
    ["encrypt", "decrypt"]
  ));
}
function encrypt(key, string) {
  let iv = crypto.getRandomValues(new Uint8Array(12));
  return crypto.subtle.encrypt(
    {
      name: "AES-GCM",
      iv,
      tagLength: 128
    },
    key,
    fromString(string, "base64pad")
  ).then((buf) => {
    const iv_b64 = toString(iv, "base64pad");
    const buf_b64 = toString(new Uint8Array(buf), "base64pad");
    return iv_b64 + buf_b64;
  });
}
function decrypt(key, string) {
  const iv_b64 = string.substring(0, 16);
  const buf_b64 = string.substring(16);
  const iv = fromString(iv_b64, "base64pad");
  const buf = fromString(buf_b64, "base64pad");
  return crypto.subtle.decrypt(
    {
      name: "AES-GCM",
      iv,
      tagLength: 128
    },
    key,
    buf
  ).then(
    (buffer) => toString(
      new Uint8Array(buffer),
      "utf8"
    )
  );
}

// src/Javascript/Brain/common.ts
init_node_shims();
var SECRET_KEY_LOCATION = "SECRET_KEY";
function parseJsonIfNeeded(a) {
  if (typeof a === "string")
    return JSON.parse(a);
  return a;
}
function reportError(app2, event) {
  return (e) => {
    const err = e ? e.message || e : null;
    if (err) {
      console.error(err, e.stack);
      app2.ports.fromAlien.send({ tag: event.tag, data: null, error: err });
    }
  };
}
function sendData(app2, event, opts = {}) {
  return (data) => {
    app2.ports.fromAlien.send({
      tag: event.tag,
      data: opts && opts.parseJSON && typeof data === "string" ? JSON.parse(data) : data || null,
      error: null
    });
  };
}
function removeCache(key) {
  return db().removeItem(key);
}
function fromCache(key) {
  return db().getItem(key);
}
function toCache(key, data) {
  return db().setItem(key, data);
}
function decryptIfNeeded(data) {
  if (typeof data !== "string") {
    return Promise.resolve(data);
  } else if (data.startsWith("{") || data.startsWith("[")) {
    return Promise.resolve(data);
  } else if (data.length < 15 && Number.isInteger(parseInt(data, 10))) {
    return Promise.resolve(data);
  } else {
    return data ? getSecretKey().then((secretKey) => {
      if (!secretKey)
        throw new Error("There seems to be existing data that's encrypted, I will need the passphrase (ie. encryption key) to continue.");
      return decrypt(secretKey, data);
    }) : Promise.resolve(null);
  }
}
async function encryptIfPossible(unencryptedData) {
  return unencryptedData ? getSecretKey().then((secretKey) => encrypt(secretKey, unencryptedData)).catch((_) => unencryptedData) : unencryptedData;
}
function getSecretKey() {
  return db().getItem(SECRET_KEY_LOCATION);
}

// src/Javascript/Brain/user.ts
var ports = {};
var taskPorts = {};
taskPorts.fabricateSecretKey = async (passphrase) => {
  const data = await keyFromPassphrase(passphrase);
  return toCache(SECRET_KEY_LOCATION, data);
};
taskPorts.fromDropbox = ({ fileName, token }) => {
  return fetch("https://content.dropboxapi.com/2/files/download", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + token,
      "Dropbox-API-Arg": JSON.stringify({ path: "/" + fileName })
    }
  }).then((r) => r.ok ? r.text() : r.json()).then((r) => r.error ? null : r).then(decryptIfNeeded).then(parseJsonIfNeeded);
};
taskPorts.toDropbox = async ({ fileName, data, token }) => {
  const json = JSON.stringify(data);
  const params = {
    path: "/" + fileName,
    mode: "overwrite",
    mute: true
  };
  return fetch("https://content.dropboxapi.com/2/files/upload", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + token,
      "Content-Type": "application/octet-stream",
      "Dropbox-API-Arg": JSON.stringify(params)
    },
    body: await encryptIfPossible(json)
  });
};
var odd;
var session;
taskPorts.fromFission = async ({ fileName, includePublicData }) => {
  await constructFission();
  const privatePath = odd.path.appData(APP_INFO, odd.path.file(fileName));
  const privateData = await session.fs.exists(privatePath) ? session.fs.read(privatePath).then((bytes) => new TextDecoder().decode(bytes)).then(parseJsonIfNeeded) : null;
  if (includePublicData && Array.isArray(privateData)) {
    const publicPath = {
      file: privatePath.file.map((a, idx) => {
        return idx === 0 ? "public" : a;
      })
    };
    const publicData = await session.fs.exists(publicPath) ? session.fs.read(publicPath).then((bytes) => new TextDecoder().decode(bytes)).then(parseJsonIfNeeded) : null;
    return publicData ? [...privateData, ...publicData] : privateData;
  } else {
    return privateData;
  }
};
taskPorts.toFission = async ({ data, fileName, savePublicData }) => {
  await constructFission();
  const privatePath = odd.path.appData(APP_INFO, odd.path.file(fileName));
  const isDataObject = typeof data === "object" && !!data.data;
  if (!isDataObject) {
    await session.fs.write(
      privatePath,
      new TextEncoder().encode(JSON.stringify(data))
    );
    await session.fs.publish();
    return;
  }
  const [privateData, publicData] = Array.isArray(data.data) && savePublicData ? data.data.reduce(
    ([priv, pub], item) => {
      return item.public ? [priv, [...pub, item]] : [[...priv, item], pub];
    },
    [[], []]
  ) : [data.data, null];
  await session.fs.write(
    privatePath,
    new TextEncoder().encode(JSON.stringify({ ...data, data: privateData }))
  );
  if (publicData) {
    const publicPath = {
      file: privatePath.file.map((a, idx) => {
        return idx === 0 ? "public" : a;
      })
    };
    await session.fs.write(
      publicPath,
      new TextEncoder().encode(JSON.stringify({ ...data, data: publicData }))
    );
  }
  await session.fs.publish();
};
async function constructFission() {
  if (odd)
    return Promise.resolve();
  odd = await import("./lib-APSA3CZM.js");
  const program = await odd.program({
    ...ODD_CONFIG,
    fileSystem: { loadImmediately: false }
  });
  session = program.session;
  if (!session) {
    await removeCache("SYNC_METHOD");
    window.location.reload();
    throw new Error("Failed to load ODD SDK session");
  }
  session.fs = await program.fileSystem.load(session.username);
  if (!session.fs)
    throw new Error("Did not load ODD SDK file system");
}
ports.deconstructFission = (_app) => (_) => {
  if (!session)
    return;
  session.destroy();
  session = void 0;
  odd = void 0;
};
var IPFS_ROOT = "/Applications/Diffuse/";
taskPorts.fromIpfs = ({ apiOrigin, fileName }) => {
  const path = IPFS_ROOT + fileName;
  return fetch(apiOrigin + "/api/v0/files/read?arg=" + encodeURIComponent(path), { method: "POST" }).then((r) => r.ok ? r.text() : r.json()).then((r) => r.Code === 0 ? null : r).then(decryptIfNeeded).then(parseJsonIfNeeded);
};
taskPorts.toIpfs = ({ apiOrigin, fileName, data }) => {
  const json = JSON.stringify(data);
  const params = new URLSearchParams({
    arg: IPFS_ROOT + fileName,
    create: "true",
    offset: "0",
    parents: "true",
    truncate: "true"
  }).toString();
  return encryptIfPossible(json).then((possiblyEncryptedData) => {
    const formData = new FormData();
    formData.append("data", possiblyEncryptedData);
    return fetch(
      apiOrigin + "/api/v0/files/write?" + params,
      { method: "POST", body: formData }
    );
  });
};
var rs;
var rsClient;
async function remoteStorage(userAddress, token) {
  if (!rs) {
    const { default: RemoteStorage } = await import("./remotestorage-BVONVTVQ.js");
    rs = new RemoteStorage({ cache: false });
    rs.access.claim("diffuse", "rw");
    rsClient = rs.scope("/diffuse/");
    return new Promise((resolve2) => {
      rs.on("connected", resolve2);
      rs.connect(userAddress, token);
    });
  } else {
    return Promise.resolve();
  }
}
ports.deconstructRemoteStorage = (_app) => (_) => {
  rs = null;
  rsClient = null;
};
taskPorts.fromRemoteStorage = ({ fileName, userAddress, token }) => {
  return remoteStorage(userAddress, token).then((_) => rsClient.getFile(fileName)).then((r) => r.data).then(decryptIfNeeded).then(parseJsonIfNeeded);
};
taskPorts.toRemoteStorage = ({ data, fileName, userAddress, token }) => {
  const json = JSON.stringify(data);
  return remoteStorage(userAddress, token).then((_) => encryptIfPossible(json)).then((data2) => rsClient.storeFile("application/json", fileName, data2));
};
function setupPorts(app2) {
  Object.keys(ports).forEach((name) => {
    const fn = ports[name](app2);
    app2.ports[name].subscribe(fn);
  });
}
function setupTaskPorts() {
  Object.keys(taskPorts).forEach((name) => {
    const fn = taskPorts[name];
    register(name, fn);
  });
}

// src/Javascript/Brain/index.ts
var import_brain_elm = __toESM(require_brain_elm());
var app;
var wire = {};
install();
register("fromCache", fromCache);
register("removeCache", removeCache);
register("toCache", ({ key, value }) => toCache(key, value));
setupTaskPorts();
wire.ui = () => {
  app.ports.toUI.subscribe((event) => {
    self.postMessage(event);
  });
};
self.onmessage = (event) => {
  if (event.data.action)
    return handleAction(event.data.action, event.data.data);
  if (event.data.tag)
    return app.ports.fromAlien.send(event.data);
};
function handleAction(action, data) {
  switch (action) {
    case "DOWNLOAD_ARTWORK":
      return downloadArtwork(data);
  }
}
wire.caching = () => {
  app.ports.removeCache.subscribe((event) => {
    removeCache(event.tag).catch(reportError(app, event));
  });
  app.ports.requestCache.subscribe((event) => {
    const key = event.data && event.data.file ? event.tag + "_" + event.data.file : event.tag;
    fromCache(key).then(sendData(app, event)).catch(reportError(app, event));
  });
  app.ports.toCache.subscribe((event) => {
    const key = event.data && event.data.file ? event.tag + "_" + event.data.file : event.tag;
    toCache(key, event.data.data || event.data).catch(reportError(app, event));
  });
};
var artworkQueue = [];
wire.artworkCaching = () => {
  app.ports.provideArtworkTrackUrls.subscribe(provideArtworkTrackUrls);
};
function downloadArtwork(list) {
  const exe = !artworkQueue[0];
  artworkQueue = artworkQueue.concat(list);
  if (exe)
    shiftArtworkQueue();
}
function shiftArtworkQueue() {
  const next = artworkQueue.shift();
  if (next) {
    app.ports.makeArtworkTrackUrls.send(next);
  } else {
    self.postMessage({
      action: "FINISHED_DOWNLOADING_ARTWORK",
      data: null
    });
  }
}
function provideArtworkTrackUrls(prep) {
  find(prep, app).then((blob) => {
    const url = URL.createObjectURL(blob);
    self.postMessage({
      tag: "GOT_CACHED_COVER",
      data: { key: prep.cacheKey, url },
      error: null
    });
    return toCache(`coverCache.${prep.cacheKey}`, blob);
  }).catch((err) => {
    if (err === "No artwork found") {
      return toCache(`coverCache.${prep.cacheKey}`, "TRIED");
    } else {
      reportError(app, { tag: "REPORT_ERROR" })(err);
    }
  }).catch(() => {
    console.warn("Failed to download artwork for ", prep);
  }).finally(shiftArtworkQueue);
}
wire.tracksCaching = () => {
  app.ports.removeTracksFromCache.subscribe(removeTracksFromCache);
  app.ports.storeTracksInCache.subscribe(storeTracksInCache);
};
function removeTracksFromCache(trackIds) {
  trackIds.reduce(
    (acc, id) => acc.then((_) => db("tracks").removeItem(id)),
    Promise.resolve()
  ).catch(
    (_) => reportError(app, { tag: "REMOVE_TRACKS_FROM_CACHE" })("Failed to remove tracks from cache")
  );
}
function storeTracksInCache(list) {
  list.reduce(
    (acc, item) => {
      return acc.then((_) => transformUrl(item.url, app)).then(fetch).then((r) => r.blob()).then((b) => db("tracks").setItem(item.trackId, b));
    },
    Promise.resolve()
  ).then(
    (_) => self.postMessage({
      tag: "STORE_TRACKS_IN_CACHE",
      data: list.map((l) => l.trackId),
      error: null
    })
  ).catch(
    (err) => {
      console.error(err);
      self.postMessage({
        tag: "STORE_TRACKS_IN_CACHE",
        data: list.map((l) => l.trackId),
        error: err.message || err
      });
    }
  );
}
wire.downloading = () => {
  app.ports.downloadTracks.subscribe((group) => {
    self.postMessage({
      action: "DOWNLOAD_TRACKS",
      data: group
    });
  });
};
var search = new Worker(
  "../../search.js",
  { type: "module" }
);
wire.search = () => {
  app.ports.requestSearch.subscribe(requestSearch);
  app.ports.updateSearchIndex.subscribe(updateSearchIndex);
};
function requestSearch(searchTerm) {
  search.postMessage({
    action: "PERFORM_SEARCH",
    data: searchTerm
  });
}
function updateSearchIndex(tracksJson) {
  search.postMessage({
    action: "UPDATE_SEARCH_INDEX",
    data: tracksJson
  });
}
search.onmessage = (event) => {
  switch (event.data.action) {
    case "PERFORM_SEARCH":
      app.ports.receiveSearchResults.send(event.data.data);
      break;
  }
};
wire.tags = () => {
  app.ports.requestTags.subscribe((context) => {
    processContext(context, app).then((newContext) => {
      app.ports.receiveTags.send(newContext);
    });
  });
  app.ports.syncTags.subscribe((context) => {
    processContext(context, app).then((newContext) => {
      app.ports.replaceTags.send(newContext);
    });
  });
};
var flags = location.hash.substr(1).split("&").reduce((acc, flag) => {
  const [k, v] = flag.split("=");
  return { ...acc, [k]: v };
}, {});
forwardCompatibility().then(initialise);
function initialise() {
  app = import_brain_elm.Elm.Brain.init({
    flags: {
      initialUrl: decodeURIComponent(flags.appHref) || ""
    }
  });
  setupPorts(app);
  wire.ui();
  wire.caching();
  wire.artworkCaching();
  wire.tracksCaching();
  wire.downloading();
  wire.search();
  wire.tags();
  self.postMessage({ action: "READY" });
}
async function forwardCompatibility() {
  if (await fromCache("MIGRATED"))
    return;
  await moveOldDbValue({ oldName: "AUTH_SECRET_KEY", newName: "SECRET_KEY" });
  await moveOldDbValue({ oldName: "AUTH_ENCLOSED_DATA", newName: "ENCLOSED_DATA" });
  const method = await fromCache("AUTH_METHOD");
  if (method === "LOCAL") {
    await moveOldDbValue({ oldName: "AUTH_ANONYMOUS_favourites.json", newName: "SYNC_LOCAL_favourites.json", parseJSON: true });
    await moveOldDbValue({ oldName: "AUTH_ANONYMOUS_playlists.json", newName: "SYNC_LOCAL_playlists.json", parseJSON: true });
    await moveOldDbValue({ oldName: "AUTH_ANONYMOUS_progress.json", newName: "SYNC_LOCAL_progress.json", parseJSON: true });
    await moveOldDbValue({ oldName: "AUTH_ANONYMOUS_settings.json", newName: "SYNC_LOCAL_settings.json", parseJSON: true });
    await moveOldDbValue({ oldName: "AUTH_ANONYMOUS_sources.json", newName: "SYNC_LOCAL_sources.json", parseJSON: true });
    await moveOldDbValue({ oldName: "AUTH_ANONYMOUS_tracks.json", newName: "SYNC_LOCAL_tracks.json", parseJSON: true });
    await removeCache("AUTH_METHOD");
  } else if (method) {
    await toCache("SYNC_METHOD", method);
    await removeCache("AUTH_METHOD");
  }
  await toCache("MIGRATED", "3.3.0");
}
async function moveOldDbValue({ oldName, newName, parseJSON }) {
  const value = await fromCache(oldName);
  if (value && typeof value === "string") {
    await toCache(newName, parseJSON ? JSON.parse(value) : value);
    await removeCache(oldName);
  }
}
/*! Bundled license information:

content-type/index.js:
  (*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

media-typer/index.js:
  (*!
   * media-typer
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
